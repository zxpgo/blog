<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.png?v=5.1.4" color="#222">





  <meta name="keywords" content="云存储安全 大数据安全 C++ Python" />





  <link rel="alternate" href="/atom.xml" title="平步青云win" type="application/atom+xml" />






<meta name="description" content="云存储和人工智能数据安全 Python C++">
<meta name="keywords" content="云存储和人工智能数据安全 Python C++">
<meta property="og:type" content="website">
<meta property="og:title" content="平步青云win">
<meta property="og:url" content="https://zxpgo.github.io/index.html">
<meta property="og:site_name" content="平步青云win">
<meta property="og:description" content="云存储和人工智能数据安全 Python C++">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="平步青云win">
<meta name="twitter:description" content="云存储和人工智能数据安全 Python C++">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":10,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'PAO8LM7QB1',
      apiKey: '',
      indexName: 'Blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zxpgo.github.io/"/>





  <title>平步青云win</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7a4517a3ce6d7c50203655d056f01ac3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">平步青云win</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-随笔">
          <a href="/sui" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            随笔
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2100/03/27/公告/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2100/03/27/公告/" itemprop="url">公告</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2100-03-27T20:18:14+08:00">
                2100-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2100/03/27/公告/" class="leancloud_visitors" data-flag-title="公告">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <center><strong>由于博客中的所有图片托管在imgur，由于最近国内无法访问该网站，所以博文中的图片无法访问，需要连上VPN才可浏览。后面的图片已经托管在七牛云上。</strong></center>

<center><a href="https://www.zxpblog.cn/2018/08/13/VPN%E8%B5%84%E6%BA%90md/" target="_blank" rel="noopener">VPN资源</a></center>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/06/22/LeetCode算法题目C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/LeetCode算法题目C++/" itemprop="url">LeetCode算法题目C++</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T22:28:50+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/22/LeetCode算法题目C++/" class="leancloud_visitors" data-flag-title="LeetCode算法题目C++">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<pre><code>输入: 123
输出: 321
</code></pre><p> 示例 2:</p>
<pre><code>输入: -123
输出: -321
</code></pre><p>示例 3:</p>
<pre><code>输入: 120
输出: 21
</code></pre><p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0</p>
<p><strong>思路：</strong>每次取整数的最后一位，将整数除以10，一直循环得到整数为0。其中需要注意，整数翻转的时候可能超出了整数的表示范围（-2^32,2^32-1），所以乘以10之前需要判断乘以10之前会不会超过表示范围。</p>
<p>代码：</p>
<pre><code>int reverse(int x) {
        int ans = 0;
        while(x)
        {
            if (ans &gt; INT_MAX/10 || ans &lt; INT_MIN/10)
                return 0;
            ans = (x % 10) + ans * 10;
            x = x /10;
        }
        return ans;
    }
</code></pre><h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:</p>
<pre><code>输入: 121
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入: -121
输出: false
</code></pre><p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:</p>
<pre><code>输入: 10
输出: false
</code></pre><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>进阶:</p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<p><strong>思路：</strong>首先判断整数是否为正数，如果负数则直接返回false，如果x等于0直接返回true。然后就是将将x一位一位放入容器vector中。最后两个指针一个从头开始一个从尾开始，如果两个相等，则同时加加，如果不相等直接返回false。</p>
<p>代码：</p>
<pre><code>bool isPalindrome(int x) {
        vector&lt;int&gt; vi;
        if (x &lt; 0 )
            return false;
        else if (x == 0)
            return true;
        else
        {

            while (x)
            {
                vi.push_back(x%10);
                x = x /10;
            }
        }
        auto ite_begin = vi.begin();
        auto ite_end = vi.end()-1;
        while (ite_begin &lt; ite_end)
        {
            if (*ite_begin == *ite_end)
            {
                ite_begin++;
                ite_end--;
            }
            else
            {
                return false;
            }
        }
        return true;       
    }
</code></pre><h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</code></pre><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;III&quot;
输出: 3
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;IV&quot;
输出: 4
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;IX&quot;
输出: 9
</code></pre><p>示例 4:</p>
<pre><code>输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.
</code></pre><p>示例 5:</p>
<pre><code>输入: &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre><p><strong>思路：</strong>这个题目写得有些复杂，其实挺简单的。题目意思是：小数在大数左侧，则小数变成相应的负数。即<code>IXLDI</code>，结果可以表示为<code>-1-10-50+500+1</code>。</p>
<p>代码：</p>
<pre><code>int romanToInt(string s) {
        map&lt;char, int&gt; cim;
        cim[&apos;I&apos;] = 1;
        cim[&apos;V&apos;] = 5;
        cim[&apos;X&apos;] = 10;
        cim[&apos;L&apos;] = 50;
        cim[&apos;C&apos;] = 100;
        cim[&apos;D&apos;] = 500;
        cim[&apos;M&apos;] = 1000;
        int ans = 0;
        for (int i = 0; i &lt; s.size(); i++)
        {
            if (i &lt; s.size()-1 &amp;&amp; cim[s[i]] &lt; cim[s[i+1]])
                ans -= cim[s[i]];
            else
                ans += cim[s[i]];
        }
        return ans;
    }
</code></pre><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
</code></pre><p>示例 2:</p>
<pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre><p>说明:</p>
<p>所有输入只包含小写字母 a-z</p>
<p><strong>思路：</strong>首先确定所有字符串中最短字符串的长度，所有字符串比较的次数就是最短字符串的长度。然后就是针对第一个字符，每次字符串都比较一次，依次比较，如果相等，将当前字符添加到str（用来存储最终的结果），遇到一个不相等，直接break当前循环，返回str。</p>
<p>注意，在C++中string，不能用str[i]往里面填加字符，而应该采用追加的形式，即<code>str += &#39;s&#39;</code>。</p>
<p>代码：</p>
<pre><code>string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        int len = INT_MAX;
        string str = &quot;&quot;;
        if (strs.size() &lt; 1)
            return &quot;&quot;;
        for (int i = 0; i &lt; strs.size(); i++)
        {
            len = min(len, (int)strs[i].size());
        }
        int j = 0;
        while (j &lt; len)
        {
            int i = 0;
            while ((i &lt; strs.size()-1) &amp;&amp; (strs[i][j] == strs[i+1][j]) )
                i++;   
            if (i == strs.size()-1)
               str += strs[0][j];
            else
                break;
            j++;
        }
        return str;
    }
</code></pre><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;()&quot;
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;()[]{}&quot;
输出: true
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;(]&quot;
输出: false
</code></pre><p>示例 4:</p>
<pre><code>输入: &quot;([)]&quot;
输出: false
</code></pre><p>示例 5:</p>
<pre><code>输入: &quot;{[]}&quot;
输出: true
</code></pre><p>思路： 如果遇到([{，就放入栈中，如果遇到)]}，首先判断栈是否为空，如果不为空，然后从栈中弹出元素，看是否能够组成一对，如果没法组成一对，直接返回false。</p>
<p>还有另一种方法，就如遇到(，就将)入栈；如果遇到[，就将]入栈；果遇到{就将}入栈。然后遇到([{就从栈中弹出元素，判断跟当前元素是否相等。</p>
<p>代码：</p>
<pre><code>bool isValid(string s) {
    stack&lt;char&gt; sc;
    if (s.size() == 1)
        return false;
    if (s.size() == 0)
        return true;
    int i = 0;
    while (s[i] != &apos;\0&apos;)
    {
        if (s[i] == &apos;(&apos; || s[i] == &apos;{&apos; || s[i] == &apos;[&apos;)
        {
            sc.push(s[i]);
            i++;
        }
        else if (!sc.empty() &amp;&amp; ((sc.top() == &apos;(&apos; &amp;&amp; s[i] == &apos;)&apos;) || (sc.top() == &apos;[&apos; &amp;&amp; s[i] == &apos;]&apos;) || (sc.top() == &apos;{&apos; &amp;&amp; s[i] == &apos;}&apos;) ))
        {
            sc.pop();
            i++;
        }
        else
        {
            return false;
        }
    }
    if (sc.empty())
        return true;
    return false;
}
</code></pre><h3 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a>28. 实现strStr()</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
</code></pre><p>示例 2:</p>
<pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
</code></pre><p>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<p><strong>思路：</strong></p>
<p>第一种解法：暴力解法。设父字符串为P，子串为L。对L中的字符一个一个在P中对比，如果遇到不想当的，P中的标记向前走一步，L中的标记回到0。直到其他一个字符串到达末尾结束。</p>
<p>第二种解法：KMP，比较复杂，在此不论述，，可以百度一下。</p>
<p>还有就是可以直接调用string的库函数。</p>
<p>代码：</p>
<pre><code>int strStr(string haystack, string needle) {
  /*直接调用string库
  int temp = haystack.find(needle);
    return temp;*/
  int len_hay = haystack.size();
  int len_nee = needle.size();
  if (len_nee == 0)
      return 0;
  if (len_hay == 0)
      return -1;
  int i = 0;
  int j = 0;
  int temp = 1;
  while (needle[j] != &apos;\0&apos; &amp;&amp; haystack[i] != &apos;\0&apos;)
  {
      if(haystack[i++] != needle[j++])
      {
          j = 0;
          i = temp;
          temp += 1;
      }
  }
  if (needle[j] == &apos;\0&apos;)
      return i-needle.size();
  else 
      return -1;
}
</code></pre><h3 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a>38. 报数</h3><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre><ul>
<li>1 被读作  “one 1”  (“一个一”) , 即 11。</li>
<li>11 被读作 “two 1s” (“两个一”）, 即 21。</li>
<li>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>
</ul>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p>示例 1:</p>
<pre><code>输入: 1
输出: &quot;1&quot;
</code></pre><p>示例 2:</p>
<pre><code>输入: 4     
输出: &quot;1211&quot;
</code></pre><p>思路： 对于每次都判断一下当前字符跟下一个字符是否相等，如果相等则，计数器count加1，否则直接将count转换为字符串加上当前字符一起加到答案字符串的结尾，直到字符串到达结尾结束。</p>
<p>代码：</p>
<pre><code>string countAndSay(int n) {
        string s;
        string str(&quot;1&quot;);
        if (n == 1)
            return  str;
        for (int i = 2; i &lt;= n; i++)
        {
            int j = 0;
            int count = 1;
            string s;
            while(str[j] != &apos;\0&apos;)
            {
                if (str[j] == str[j+1])
                    count++;
                else
                {
                    s +=to_string(count)+str[j]; 
                    count = 1;
                }
                j++;
            }
            str = s;
        }
        return str;
    }
</code></pre><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre><p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p><strong>思路：</strong> 这是一道动态规划的问题。边界条件是数组遍历结束，最有子结构是如果前面的序列小于零，则对于最大和不会起到作用，所以直接加0，如果前面的序列最大和大于0，则表示前面的序列对最大和会起作用，将前面序列的最大和加到当前序列的最大和。</p>
<p>代码：</p>
<pre><code>int maxSubArray(vector&lt;int&gt;&amp; nums) {
       int n = nums.size();
       int * dp = new int[n];
       dp[0] = nums[0];
       int m = nums[0];
       for (int i = 1; i &lt; n; i++)
       {
           dp[i] = nums[i] + (dp[i-1] &gt; 0 ?  dp[i-1] : 0);
           m = max(m, dp[i]);
       }
       return m;
   }
</code></pre><h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h3><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p>示例:</p>
<pre><code>输入: &quot;Hello World&quot;
输出: 5
</code></pre><p><strong>思路：</strong>如果字符串的末尾有空格，则将字符串的长度减去空格的数量。然后但遇到最后一个字符串前面的空格就结束，并记录该空格的位置。最后，将字符串长度减去空格的位置移动，就得到最后一个单词的长度。</p>
<p>代码：</p>
<pre><code>int lengthOfLastWord(string s) {
    int len = s.size();
    if (len == 0 || (len == 1 &amp;&amp; s[0] == &apos; &apos;))
        return 0;
    int i;
    while (s[len-1] == &apos; &apos; )
    {
        len--;
    }
    for (i = len - 1;  i &gt;= 0 ; i--)
    {

        if (s[i] == &apos; &apos;)
        {
            break;
        }
    }
    return len-i-1;
}
</code></pre><h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h3><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
</code></pre><p>示例 2:</p>
<pre><code>输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
</code></pre><p><strong>思路：</strong> 将最后一个数字加1，并除以10，如果等于0，表示不需要进位，如果等于1，表示需要进位。如果到达数组中的第一个数字，并且有进位，则需要在数组之前添加一个1。</p>
<p>其实这样做有些复杂，可以直接判断数组中的元素是否为9，如果为9表示需要进位，如果不为9则不需要进位。在第一位时，并且该元素为9，则需要在数组之前添加一个1。</p>
<p>代码：</p>
<pre><code>vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
    int i = digits.size()-1;
    int temp = 1;
    while (i &gt;= 0)
    {
        temp = (digits[i]+temp) / 10;
        if (temp == 0)
        {
            digits[i] = (digits[i]+1) % 10;
            break;
        }
        else
        {
            digits[i] = (digits[i]+temp) % 10;
            if (i == 0 &amp;&amp; temp == 1 )
                digits.insert(digits.begin(), 1);
        }
        i--;
    }
    return digits;
}
</code></pre><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 1 和 0。</p>
<p>示例 1:</p>
<pre><code>输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;
</code></pre><p>示例 2:</p>
<pre><code>输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;
</code></pre><p><strong>思路：</strong> 首先，判断两个字符串的长度，将最大的字符串放入a。然后执行最大字符串长度次数的循环，如果两个元素加起来等于2，则需要进位，如果不等式2，则不需要进位。</p>
<p>注意，字符串需要转换为整数，即减去48。</p>
<p>代码：</p>
<pre><code>string addBinary(string a, string b) {
    string temp;
    if (a.size() &lt; b.size())
    {
        temp = a;
        a = b;
        b = temp;
    }
    int i = a.size()-1;
    int j = b.size() - 1;
    bool t = 0;
    char k;
    while (i &gt;= 0)
    {
        if (j &gt;=  0)
        {
            k = a[i];
            a[i] = ((a[i] - 48 + b[j]  -48+ t) % 2) + 48;
            t = (k - 48 + b[j] - 48 + t) / 2;
            j--;
        }
        else
        {
            k= a[i];
            a[i] = (a[i] - 48 + t) % 2 + 48;
            t = (k -48+ t) / 2;
        }
        if (i == 0 &amp;&amp; t == 1)
        {
            a.insert(a.begin(), &apos;1&apos;);
        }
        i--;
    }
    return a;
}
</code></pre><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:</p>
<pre><code>输入: 4
输出: 2
</code></pre><p>示例 2:</p>
<pre><code>输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
</code></pre><p><strong>直观的方法：</strong></p>
<p>思路：从1开始一个一个尝试，看是否满足平方根的条件。需要注意的是，不能用乘法，只能用除法，乘法会超过int的表示范围。这样做速度太慢。</p>
<p>代码：</p>
<pre><code>int mySqrt(int x) {
        if (x &lt;= 0)
            return x;
        int i = 1;
        while (i &lt;= x)
        {
            if (i &lt;= x/i &amp;&amp; x/(i+1) &lt; (i+1))
                break;
            i++;
        }
        return i;

    }
</code></pre><p><strong>牛顿迭代法：</strong></p>
<p>思路： 找到一个数r，使得<code>r^2-n=0</code>。即求解该方程。然后利用牛顿迭代法求解该方程。迭代公式：</p>
<pre><code>x=(x+n/x)/2;
</code></pre><p>牛顿迭代的具体公式：</p>
<p><img src="https://i.imgur.com/9nP8tQc.png" alt=""></p>
<p>图曲线图：</p>
<p><img src="https://i.imgur.com/ZNaZYaP.png" alt=""></p>
<p>一直逼近点x*。</p>
<p>代码：</p>
<pre><code>int mySqrt(int x) {
        if (x &lt;= 0)
            return x;
        long r = x;
        while (r &gt; x / r)
            r = (r + x/r) / 2;
        return r;
    }
</code></pre><p>###</p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<pre><code>输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
</code></pre><p>示例 2：</p>
<pre><code>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</code></pre><p><strong>思路：</strong>这是一个动态规划问题(DP)，边界条件是，只有1阶时，dp[1] = 1; 只有2阶时，dp[2] = 2。最优子结构：向前走一步和或向前走两步，然后将两种情况的相加。</p>
<pre><code>dp[i] = dp[i-1] + dp[i-2];
</code></pre><p>可以使用递归的形式实现。</p>
<p>代码：<br>      int climbStairs(int n) {<br>            if (n == 1)<br>                return 1;</p>
<pre><code>    /*if (n == 1)
        return 1;
    if (n == 2)
        return 2;
    int a = climbStairs(n-1) + climbStairs(n-2);
    return a;*/
    if (n == 1)
        return 1;
    int * dp = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i &lt;= n; i++)
    {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
</code></pre><h3 id="83-删除排序列表中的重复元素"><a href="#83-删除排序列表中的重复元素" class="headerlink" title="83. 删除排序列表中的重复元素"></a>83. 删除排序列表中的重复元素</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<pre><code>输入: 1-&gt;1-&gt;2
输出: 1-&gt;2
</code></pre><p>示例 2:</p>
<pre><code>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3
</code></pre><p><strong>思路：</strong>直接前后两个元素比较，如果相等，则删除第二元素。</p>
<p>代码：</p>
<pre><code>ListNode* deleteDuplicates(ListNode* head) {
    map&lt;int, int&gt; map_i_i;
    ListNode * temp = head;
    ListNode * p = NULL;
    if (temp != NULL &amp;&amp; temp-&gt;next != NULL)
        p = temp-&gt;next;
    while (temp != NULL &amp;&amp;  p != NULL)
    {

        if (temp-&gt;val == p-&gt;val)
        {
            temp-&gt;next = p-&gt;next;
            ListNode * q = p;
            p =  p-&gt;next;
            delete q;
        }
        else
        {
            temp = p;
            p = p-&gt;next;
        }
    }
    return head;
}
</code></pre><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p>
<p>输入:<br>    nums1 = [1,2,3,0,0,0], m = 3<br>    nums2 = [2,5,6],       n = 3</p>
<pre><code>输出: [1,2,2,3,5,6]
</code></pre><p><strong>思路：</strong>新创建一个数组，然后另一个数组之间元素相比，小的元素放入新数组。</p>
<p>代码：</p>
<pre><code>void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
    int i = 0, j = 0, k = 0;
    vector&lt;int&gt; temp(n+m, 0);
    while (i &lt; m || j &lt; n)
    {
        if (i &gt;= m)
            temp[k++] = nums2[j++];
        else if (j &gt;= n)
            temp[k++] = nums1[i++];
        else if (nums1[i] &gt;= nums2[j])
            temp[k++] = nums2[j++];
        else
            temp[k++] = nums1[i++];
    }
    i = 0;
    k = 0;
    while(i &lt; m+n)
        nums1[i++] = temp[k++];
}
</code></pre><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre><p><strong>思路：</strong> 创建一个字典，将所有元素当作key，其对应的下标当作value，添加的字典map中。然后用target减去每一个元素，判断得到的差在不在map中，如果在map，这返回该值的下标和map中对应差的value。</p>
<p>代码：</p>
<pre><code>vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
    map&lt;int, int&gt; map_i_i;
    for (int i = 0; i &lt; nums.size(); i++)
        map_i_i[nums[i]] = i;
    for (int i = 0; i &lt; nums.size(); i++)
    {
        if (map_i_i.find(target-nums[i]) != map_i_i.end() &amp;&amp; i != map_i_i[target-nums[i]])
            return {i, map_i_i[target-nums[i]]};
    }
    return {};
}
</code></pre><h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<pre><code>给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p>示例 2:</p>
<pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><p>思路: 定义一个指针从0开始，i从1开始，然后两个元素相等，res不变，i向前走一个；如果两个元素相等，则将nums[i]赋给nums[res++]，相同将i和res向前走一个。</p>
<p>代码：</p>
<pre><code>int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int res = 0;
        if (nums.size() == 0)
            return 0;
        for (int i = 1; i &lt; nums.size(); i++)
        {
            if (nums[res] != nums[i])
            {
                nums[++res] = nums[i];
            }


        }
        return res+1;
    }
</code></pre><h3 id="27-移除重复元素"><a href="#27-移除重复元素" class="headerlink" title="27. 移除重复元素"></a>27. 移除重复元素</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<pre><code>给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p>示例 2:</p>
<pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
</code></pre><p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><p>思路：定义一个res指针，指向需要被替换的元素。如果i指向的元素相等val，则res不变，i向下移动一个；如果i指向元素不等于val，则将i指向的元素赋给res位置。</p>
<p>代码：</p>
<pre><code>int removeElement(vector&lt;int&gt;&amp; nums, int val) {
    int i;
    if (nums.size() == 0)
        return 0;
    int res = 0;
    for(i = 0; i &lt; nums.size(); i++)
    {
        if (nums[i] != val)
            nums[res++] = nums[i];
    }
    return res;
}
</code></pre><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<pre><code>输入: [1,3,5,6], 5
输出: 2
</code></pre><p>示例 2:</p>
<pre><code>输入: [1,3,5,6], 2
输出: 1
</code></pre><p>示例 3:</p>
<pre><code>输入: [1,3,5,6], 7
输出: 4
</code></pre><p>示例 4:</p>
<pre><code>输入: [1,3,5,6], 0
输出: 0
</code></pre><p>思路：如果目标元素小于等于数组中的元素，则该元素对应的下标就是i所在值或所需插入的位置。如果目标值比数组中最大元素还有大，则返回数组的长度。</p>
<p>代码：</p>
<pre><code>int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
       int i;
       for (i = 0; i &lt; nums.size(); i++)
           if (nums[i] &gt;= target)
               return i;
       return i;
   }
</code></pre><h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt=""></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<pre><code>输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre><p>思路: 略</p>
<p>代码：</p>
<pre><code>vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt;  ans(numRows);
        for (int i = 0; i &lt; numRows; i++)
        {
            ans[i] = vector&lt;int&gt;(i+1);
            ans[i][0] = ans[i][i] = 1;
            for (int j = 1; j &lt; i; j++)
            {
                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];
            }

        }
        return ans;
    }
</code></pre><h3 id="119-杨辉三角Ⅱ"><a href="#119-杨辉三角Ⅱ" class="headerlink" title="119. 杨辉三角Ⅱ"></a>119. 杨辉三角Ⅱ</h3><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt=""></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<pre><code>输入: 3
输出: [1,3,3,1]
进阶：
</code></pre><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p>
<p>最简单的做法，但是空间复杂度比较高，无法满足o(k)。</p>
<p>思路：略</p>
<p>代码：</p>
<pre><code>vector&lt;int&gt; getRow(int rowIndex) {
        vector&lt;vector&lt;int&gt;&gt;  ans(rowIndex+1);
            for (int i = 0; i &lt;= rowIndex; i++)
            {
                ans[i] = vector&lt;int&gt;(i+1);
                ans[i][0] = ans[i][i] = 1;
                for (int j = 1; j &lt; i; j++)
                {
                    ans[i][j] = ans[i-1][j-1] + ans[i-1][j];
                }

            }
            return ans[rowIndex];
    }
</code></pre><p>考虑复杂度</p>
<p>思路：利用杨辉三角的推导公式。每一项等于该项所在的行号减1的阶乘除以列号减1的阶乘和行号减列号的阶乘之积。</p>
<p>但是由于阶乘得到的数非常大，甚至超过了long long类型。在求每项的元素，无法每次求出阶乘。可以通过下面的迭代公式求得：</p>
<p>直接使用组合公式C(n,i) = n!/(i!*(n-i)!), 则第(i+1)项是第i项的倍数=(n-i+1)/i;</p>
<p>注意行号n从0开始，列号i从0开始。</p>
<p>代码：</p>
<pre><code>vector&lt;int&gt; getRow(int rowIndex) {
       vector&lt;int&gt;  ans(rowIndex+1);
       ans[0] = ans[rowIndex] = 1;
       long temp = 1;
       for (int i = 1; i &lt;= (rowIndex+1)/2; i++)
       {
          temp = temp * (rowIndex-i+1) / i;
          ans[i] = ans[rowIndex-i] = temp;
       }
       return ans;
   }
</code></pre><h3 id="121-买卖股票的最佳时机-Ⅰ"><a href="#121-买卖股票的最佳时机-Ⅰ" class="headerlink" title="121. 买卖股票的最佳时机 Ⅰ"></a>121. 买卖股票的最佳时机 Ⅰ</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre><p>示例 2:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><p>思路： 这一个求山的峰谷的问题，即求出最低谷到最高峰的差值。首先，将最大利润设置为0，最低谷设置为第一个元素的值。然后每次循环，判断当前元素是否为低谷，最后，将每个元素都与低谷做差，并取最大的差值。</p>
<pre><code>int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.size() &lt;= 1)
            return 0;
        int minprices = prices[0];  
        int maxprofit = 0;
        for (int i = 1; i &lt; prices.size(); i++)
        {

            minprices = min(minprices, prices[i]);
            int profit =  prices[i] - minprices;
            maxprofit = max(profit, maxprofit);
        }
        return maxprofit;
    }
</code></pre><h3 id="122-买卖股票的最佳时机Ⅱ"><a href="#122-买卖股票的最佳时机Ⅱ" class="headerlink" title="122. 买卖股票的最佳时机Ⅱ"></a>122. 买卖股票的最佳时机Ⅱ</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre><p>示例 2:</p>
<pre><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre><p>示例 3:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><p>思路：这也是一个山的峰谷的问题，不过这是求出所有的低谷到山峰差值的和。而上一个题目是求最大的山谷。每过了一个山峰，就将最大利润和最低谷重置，计算下一个峰。</p>
<p><img src="https://pic.leetcode-cn.com/d447f96d20d1cfded20a5d08993b3658ed08e295ecc9aea300ad5e3f4466e0fe-file_1555699515174" alt=""></p>
<p>代码：</p>
<pre><code>int maxProfit(vector&lt;int&gt;&amp; prices) {
    if (prices.size() &lt;= 1)
        return 0;
    int maxprofit = 0;
    int sum = 0;
    int minprice = prices[0];
    for (int i = 1; i &lt; prices.size(); i++)
    {
        minprice = min(minprice, prices[i]);
        maxprofit = max(prices[i] - minprice, maxprofit);
        if (i &lt; prices.size()-1 &amp;&amp; prices[i+1] &lt; prices[i])
        {
            sum += maxprofit;
            maxprofit = 0;
            minprice = prices[i+1];
        }
    }
    sum += maxprofit;
    return sum;
}
</code></pre><h3 id="167-两数之和Ⅱ-输入有序数组"><a href="#167-两数之和Ⅱ-输入有序数组" class="headerlink" title="167. 两数之和Ⅱ-输入有序数组"></a>167. 两数之和Ⅱ-输入有序数组</h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p>示例:</p>
<pre><code>输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
</code></pre><p>思路： 两个指针法。一个指针指i向最开头的元素，另一个指针j指向最末尾的元素。如果两个元素的和等于target，这将这两个值的下标放入数组中。如果最末尾的元素大于target或者两个两个元素的值加起来大于target，则j向前移动；如果两个元素的值加起来小于target，则指针i先后移动。</p>
<p>代码：</p>
<pre><code>vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
    if (numbers.size() &lt;= 1)
        return {};
    vector&lt;int&gt; res;
    //双指针
    int i = 0; 
    int j = numbers.size()-1;
    while(i &lt; j)
    {
        if (numbers[i] + numbers[j] == target)
        {
            res.push_back(i+1);
            res.push_back(j+1);
            break;
        }
        if(numbers[j] &gt; target || numbers[i] + numbers[j] &gt; target)
            j--;
        if (numbers[i] + numbers[j] &lt; target)
            i++;
    }
    return res;
}
</code></pre><p>暴力解法：</p>
<pre><code>vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
    if (numbers.size() &lt;= 1)
        return {};
    vector&lt;int&gt; res;
    //暴力解法
    for (int i = 0; i &lt; numbers.size()-1 &amp;&amp; numbers[i] &lt;= target; i++)
    {
        auto t = find(numbers.begin()+i+1, numbers.end(), target - numbers[i]);
        if ( t != numbers.end())
        {
            res.push_back(i+1);
            res.push_back(distance(numbers.begin(), t)+1);
            break;
        }
    }
    return res;
}
</code></pre><h3 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169. 求众数"></a>169. 求众数</h3><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p>示例 1:</p>
<pre><code>输入: [3,2,3]
输出: 3
</code></pre><p>示例 2:</p>
<pre><code>输入: [2,2,1,1,1,2,2]
输出: 2
</code></pre><p>方法一：字典计数法</p>
<p>思路：使用一个字典来记录每个元素出现的次数，key为对应的元素，value为key出现的次数。然后找出value最大所对应的key。</p>
<p>代码：</p>
<pre><code>int majorityElement(vector&lt;int&gt;&amp; nums) {
    map&lt;int, int&gt; map_i_i;
    for (int i = 0; i &lt; nums.size(); i++)
    {
        if (map_i_i.find(nums[i]) != map_i_i.end())
            map_i_i[nums[i]]++;
        else
            map_i_i[nums[i]] = 1;
    }
    int m = 0;
    int temp = 0;
    for (auto ite = map_i_i.begin(); ite != map_i_i.end(); ite++)
    {
        if (ite-&gt;second &gt;= m)
        {
            temp = ite-&gt;first;
            m = ite-&gt;second;
        }

    }
    return temp;
</code></pre><p>方法二：</p>
<p>用一个计数器进行计数。从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个</p>
<pre><code>int majorityElement(vector&lt;int&gt;&amp; nums) {
        int count = 1;
        int temp = nums[0];
        for (int i = 1; i &lt; nums.size(); i++)
        {
            if (nums[i] == temp)
                count++;
            else
            {
                count--;
                if (count == 0)
                    temp = nums[i+1];
            }
        }
        return temp;
    }
</code></pre><p>方法三：</p>
<p>先对数组排序，然后取数组的中间元素。</p>
<pre><code>int majorityElement(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size()/2];
    }
</code></pre><p>方法二的效率最高。</p>
<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
</code></pre><p>示例 2:</p>
<pre><code>输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
</code></pre><p>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的原地算法。</p>
<p>思路：将数组旋转三次就可以得到想要的结果。首先，对整体数组旋转一次，其次，对前k个元素旋转一次，最后，对后n-k个元素旋转一次。</p>
<p>代码：</p>
<pre><code>void rotate(vector&lt;int&gt;&amp; nums, int k) {
        if (nums.size() == 1)
            return;
        k = k % nums.size();
        reverse(nums, 0, nums.size()-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.size()-1);
    }


    void reverse(vector&lt;int&gt; &amp; nums, int a, int b)
    {
        int t = 1;
        while (a &lt; b)
        {
            int temp = nums[a];
            nums[a] = nums[b];
            nums[b] = temp;
            a++;
            b--;
        }
    }
</code></pre><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3,1]
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入: [1,2,3,4]
输出: false
</code></pre><p>示例 3:</p>
<pre><code>输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
</code></pre><p>思路：首先对数组进行排序，然后判断是否存在前后两个元素相等的情况。</p>
<p>代码：</p>
<pre><code>bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
       if (nums.size() == 0)
           return false;
       sort(nums.begin(), nums.end());
       for (int i = 1; i &lt; nums.size(); i++)
       {
           if (nums[i] == nums[i-1])
               return true;
       }
       return false;
   }
</code></pre><p>方法二：利用set的特性，不允许重复的key，判断set和vector的大小即可。</p>
<p>代码：</p>
<pre><code>bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        if (nums.size() == 0)
            return false;
        set&lt;int&gt; set_i(nums.begin(), nums.end());
        return nums.size() &gt; set_i.size();   
    }
</code></pre><h3 id="219-存在重复元素Ⅱ"><a href="#219-存在重复元素Ⅱ" class="headerlink" title="219. 存在重复元素Ⅱ"></a>219. 存在重复元素Ⅱ</h3><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [1,2,3,1], k = 3
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [1,0,1,1], k = 1
输出: true
</code></pre><p>示例 3:</p>
<pre><code>输入: nums = [1,2,3,1,2,3], k = 2
输出: false
</code></pre><p>思路：创建一个map存储相同值的数量，如果map中存储对应元素，则判断个数是否已经大于k，如果不大于k，则将map的value加1；如果map中没有对应元素，则插入一个pair。</p>
<p>代码：</p>
<pre><code>bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k)     {
    if (nums.size() &lt;= 1)
        return false;
    map&lt;int, int&gt; map_i_i;
    for (int i = 0; i &lt; nums.size(); i++)
    {
        if (map_i_i.count(nums[i]))
        {
            if (i - map_i_i[nums[i]] &lt;= k)
                return true;
            else
                map_i_i[nums[i]] = i;
        }
        else
            map_i_i.insert(pair&lt;int, int&gt;(nums[i], i));
    }
    return false;
}
</code></pre><h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h3><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<p>示例 1:</p>
<pre><code>输入: [3,0,1]
输出: 2
</code></pre><p>示例 2:</p>
<pre><code>输入: [9,6,4,2,3,5,7,0,1]
输出: 8
</code></pre><p>说明:</p>
<p>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<p>思路： 求和法： 将1到元素个数+1中间所有元素的和减去数组中所有元素，得到的结果就是缺失的元素。</p>
<p>代码：</p>
<pre><code> int missingNumber(vector&lt;int&gt;&amp; nums) {
       int len = nums.size();
    int sum = len * (len + 1) / 2;
    for (int i = 0; i &lt; len; i++)
        sum -= nums[i];
    int sum = 0;
    for (int i = 0; i &lt; nums.size(); i++ )
        sum = sum^(i+1)^(nums[i]);
    return sum;
}
</code></pre><p>异或法：间每个元素和1~n异或，最后得到的结果就是确实的元素</p>
<pre><code>int missingNumber(vector&lt;int&gt;&amp; nums) {
       int len = nums.size();
    int sum = 0;
    for (int i = 0; i &lt; nums.size(); i++ )
        sum = sum^(i+1)^(nums[i]);
    return sum;
}
</code></pre><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<pre><code>输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
</code></pre><p>说明:</p>
<ul>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ul>
<p>思路： 双指针法：定义一个指针记录需要覆盖的元素，最后将末尾的元素全部赋值为0。</p>
<p>可以先把所有非0的元素移到前面，然后将后面的位置补0。 使用指针i，指向需要插入的下标，使用指针j指向遍历的下标。遍历一遍，如果j指向的位置为0，则i不变，j++后移；如果j指向的位置不为0，则将j位置的元素值赋值到i位置，然后i++。</p>
<p>代码：</p>
<pre><code>void moveZeroes(vector&lt;int&gt;&amp; nums) {
    int res = 0;
    for (int i = 0; i &lt; nums.size(); i++)
    {
        if (nums[i] != 0)
        {
            nums[res] = nums[i];
            res++;
        }
    }
    for (int j = res; j &lt; nums.size(); j++)
        nums[j] = 0;
}
</code></pre><h3 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a>414. 第三大的数</h3><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<p>示例 1:</p>
<pre><code>输入: [3, 2, 1]

输出: 1

解释: 第三大的数是 1.
</code></pre><p>示例 2:</p>
<pre><code>输入: [1, 2]

输出: 2

解释: 第三大的数不存在, 所以返回最大的数 2 .
</code></pre><p>示例 3:</p>
<pre><code>输入: [2, 2, 3, 1]

输出: 1

解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。
存在两个值为2的数，它们都排第二。
</code></pre><p>思路：首先对元素进行排序（从小到大），设置一个count，遇到两个不相等的，就减1，当count等于0时，返回当前元素。如果没有就返回最大元素。</p>
<p>代码：</p>
<pre><code>int thirdMax(vector&lt;int&gt;&amp; nums) {
    sort(nums.begin(), nums.end());
    int count = 2;
    for (int  i = nums.size()-1; i &gt;= 1; i--)
    {
        if (nums[i] != nums[i-1])
        {
            count--;
        }
        if (count == 0)
        {
            return nums[i-1];
        }
    }
    return nums[nums.size()-1];
}
</code></pre><p>思路： 利用set去重，而且set是自动排序的，从小到大排序，然后集合大小小于3，直接返回最大的元素，否则往后退两个元素。</p>
<p>代码：</p>
<pre><code>int thirdMax(vector&lt;int&gt;&amp; nums) {
    //采用set去重
    set&lt;int&gt; set_i;
    for(int i = 0; i &lt; nums.size(); i++)
        set_i.insert(nums[i]);
    set&lt;int&gt;::iterator ite = set_i.end();
    if  (set_i.size() &lt; 3)  
    {
        ite--;
        return *ite;
    }
    else
    {
        ite--;
        ite--;
        ite--;
        return *ite;
    }

}
</code></pre><h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h3><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<pre><code>输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
</code></pre><p>思路：原理是遍历数组中所有元素，将元素值 - 1对应下标处的值取对应的负数作为标记，最后数组中依然大于0的即为未出现的元素</p>
<p>代码：</p>
<pre><code>vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; res;
    for (int i = 0; i &lt; nums.size(); i++)
        nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]);
    for (int i = 0; i &lt; nums.size(); i++)
        if (nums[i] &gt; 0)
            res.push_back(i+1);
    return res;
}
</code></pre><h3 id="485-最大连续的个数"><a href="#485-最大连续的个数" class="headerlink" title="485. 最大连续的个数"></a>485. 最大连续的个数</h3><p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<p>示例 1:</p>
<pre><code>输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
</code></pre><p>注意：</p>
<ul>
<li>输入的数组只包含 0 和1。</li>
<li>输入数组的长度是正整数，且不超过 10,000。</li>
</ul>
<p>思路： count记录连续1的个数，如果遇到0，就将count重置为0，每次取最大的count。</p>
<p>代码：</p>
<pre><code>int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
    int count = 0;
    int m = 0;
    for (int i = 0; i &lt; nums.size(); i++)
    {
        if (nums[i] == 1)
            count++;
        else
            count = 0;
        m = max(m, count);
    }
    return m;
}
</code></pre><h3 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a>532. 数组中的K-diff数对</h3><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p>
<p>示例 1:</p>
<pre><code>输入: [3, 1, 4, 1, 5], k = 2
输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
</code></pre><p>示例 2:</p>
<pre><code>输入:[1, 2, 3, 4, 5], k = 1
输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
</code></pre><p>示例 3:</p>
<pre><code>输入: [1, 3, 1, 5, 4], k = 0
输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。
</code></pre><p>注意:</p>
<ul>
<li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li>
<li>数组的长度不超过10,000。</li>
<li>所有输入的整数的范围在 [-1e7, 1e7]。</li>
</ul>
<p>思路：首先对于k=0的情况单独分析，直接找相同的元素。对于其他情况，将元素放入一个集合中进行去重，然后判断每个元素+k是否在集合中。</p>
<p>代码：</p>
<pre><code>int findPairs(vector&lt;int&gt;&amp; nums, int k) {
    map&lt;int, int&gt; map_i_i;
    int count = 0;
    if (k &lt; 0)
        return 0;
    if (k == 0)
    {
        for (int i = 0; i &lt; nums.size(); i++)
        {
            if (map_i_i.find(nums[i]) != map_i_i.end())
                map_i_i[nums[i]]++;
            else
                map_i_i[nums[i]] = 1;
            if (map_i_i[nums[i]] == 2)
                count++;
        }
        return count;
    }
    set&lt;int&gt; set_i(nums.begin(), nums.end());
    auto ite = set_i.begin();
    while (ite != set_i.end())
    {
        if (set_i.find(*ite+k) != set_i.end())
            count ++;
        ite++;
    }
    return count;
}
</code></pre><h3 id="561-数组拆分Ⅰ"><a href="#561-数组拆分Ⅰ" class="headerlink" title="561. 数组拆分Ⅰ"></a>561. 数组拆分Ⅰ</h3><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:</p>
<pre><code>输入: [1,4,3,2]

输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
</code></pre><p>提示:</p>
<ul>
<li>n 是正整数,范围在 [1, 10000].</li>
<li>数组中的元素范围在 [-10000, 10000].</li>
</ul>
<p>思路：首先对数组进行排序，然后取一个元素，隔一个元素再去下一个元素。</p>
<p>代码：</p>
<pre><code>int arrayPairSum(vector&lt;int&gt;&amp; nums) {
    sort(nums.begin(), nums.end());
    int sum = 0;
    for (int i = 0; i &lt; nums.size(); i+=2)
    {
        sum += nums[i];
    }
    return sum;
}
</code></pre><h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a>566. 重塑矩阵</h3><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p>
<p>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</p>
<p>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p>示例 1:</p>
<pre><code>输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
</code></pre><p>示例 2:</p>
<pre><code>输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
</code></pre><p>注意：</p>
<ul>
<li>给定矩阵的宽和高范围在 [1, 100]。</li>
<li>给定的 r 和 c 都是正数。</li>
</ul>
<p>思路：首先判断重塑矩阵的大小是否能够容纳原始矩阵的所有元素。然后，将原始矩阵的所有元素看成是一个1×n的矩阵，并将元素依次放入重塑矩阵中。</p>
<p>这里重点掌握二维矩阵的创建和使用。</p>
<pre><code>vector&lt;vector&lt;int&gt;&gt; ans(r);
for (auto i : r)
    ans[i] = vector&lt;int&gt;(c);
</code></pre><p>代码：</p>
<pre><code>vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) {
    int row = nums.size();
    int column = nums[0].size();
    if (r * c &gt;  row * column)
        return nums;
    int i = 0;
    vector&lt;vector&lt;int&gt; &gt; ans(row*column/c); 
    while (i &lt; row * column)
    {
        if (i%c == 0)
            ans[i/c] = vector&lt;int&gt;(c);
        ans[i/c][i%c] = nums[i/column][i%column];
        i++;
    }
    return ans;
}
</code></pre><h3 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h3><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是最短的，请输出它的长度。</p>
<p>示例 1:</p>
<pre><code>输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
</code></pre><p>说明 :</p>
<ul>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li>
</ul>
<p>思路：首先对元素进行排序，然后两个指针分别从最开头和最末尾开始，判断是否等于排序好的元素，如果不相等就停止，最后，如果两个指针相等，则答案是0，否则答案就是两个指针之查减一。</p>
<p>代码：</p>
<pre><code>int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {
    int i = 0;
    int j = nums.size()-1;
    vector&lt;int&gt;  temp(nums.begin(), nums.end());
    sort(temp.begin(), temp.end());
    while(i &lt; j)
    {
        if (temp[i] != nums[i])
            break;
        i++;
    }
    while (j &gt; i)
    {
        if (temp[j] != nums[j])
            break;
        j--;
    }
    return i == j ? 0 : j - i + 1;
}
</code></pre><h3 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h3><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<p>示例 1:</p>
<pre><code>输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
</code></pre><p>示例 2:</p>
<pre><code>输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
</code></pre><p>注意:</p>
<ul>
<li>数组内已种好的花不会违反种植规则。</li>
<li>输入的数组长度范围为 [1, 20000]。</li>
<li>n 是非负整数，且不会超过输入数组的大小。</li>
</ul>
<p>方法一：</p>
<p>思路：记录0的个数，len个连续0可以放入(len-1)/2个1，最后还需要考虑末尾的时候，两个零就可以放入一个1。</p>
<p>代码：</p>
<pre><code>bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {
    int len = 1, ans = 0;
    for(auto i : flowerbed)
    {
        if (i)
        {
            ans += (len-1)/2;
            len = 0;
        }
        else
            len++;
    }
    ans += len/2;
    return ans &gt;= n;
}
</code></pre><p>方法二：</p>
<p>思路：判断当前位置是否为0，以及前一个位置是否为0或者当前处于第一个元素，并且后一个位置为0或者当前处于最后一个元素，如果当前可以放入一个1，则直接向后跳两步，否则跳一步。</p>
<p>代码：</p>
<pre><code>bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {
    int i = 0;
    int len = flowerbed.size();
    while(i &lt; len &amp;&amp; n != 0)
    {
        if (flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i-1] == 0) &amp;&amp; (i == len-1 || flowerbed[i+1] == 0))
        {
            n--;
            i+=2;
        }
        else
            i++;
    }
    return n == 0;
}
</code></pre><h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a>628. 三个数的最大乘积</h3><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3]
输出: 6
</code></pre><p>示例 2:</p>
<pre><code>输入: [1,2,3,4]
输出: 24
</code></pre><p>注意:</p>
<ul>
<li>给定的整型数组长度范围是[3,10^4]，数组中所有的元素范围是[-1000, 1000]。</li>
<li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li>
</ul>
<p>思路：首先对数组进行排序，末尾的元素一定是需要三个数之一；然后判断是取前面两个元素还是后面两个元素：如果倒数第二元素小于零，则一定是取前面两个元素；如果第一个和第二元素小于零，并且两者的乘积大于倒数第二和第三两个元素之积，则一定是取前面两个元素。否则取倒数第二和第三个元素。</p>
<p>代码：</p>
<pre><code>int maximumProduct(vector&lt;int&gt;&amp; nums) {
    if (nums.size() &lt;= 2)
        return 0;
    sort(nums.begin(), nums.end());
    int ans = 1;
    ans *= nums[nums.size()-1];
    if (nums[nums.size()-2] &lt; 0 || (nums[0] &lt; 0 &amp;&amp; nums[1] &lt; 0 &amp;&amp; abs(nums[0])*abs(nums[1]) &gt; nums[nums.size()-2]*nums[nums.size()-3]) )
        ans *= nums[0]*nums[1];
    else
        ans *= nums[nums.size()-2]*nums[nums.size()-3];
    return ans;
}
</code></pre><h3 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643 子数组最大平均数 I"></a>643 子数组最大平均数 I</h3><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p>
<p>示例 1:</p>
<pre><code>输入: [1,12,-5,-6,50,3], k = 4
输出: 12.75
解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
</code></pre><p>注意:</p>
<ul>
<li>1 &lt;= k &lt;= n &lt;= 30,000。</li>
<li>所给数据范围 [-10,000，10,000]。</li>
</ul>
<p>思路： 窗口平滑。首先计算k元素的和，然后从每次减去开头第i个元素的值，加上第k+i个元素的值，每次取最大和。</p>
<p>代码：</p>
<pre><code>double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) {
    int max = 0;
    for (int i = 0; i &lt; k; i++)
        max += nums[i];
    int max1 = max;
    int max2 = 0;
    for (int i = 1; i &lt; nums.size() - k + 1; i++)
    {
        max2 = max1 - nums[i-1] + nums[k+i-1];
        max = max &gt; max2 ? max : max2;
        max1 = max2;
    }
    return (double)(max)/k;
}
</code></pre><h3 id="661-图片平滑器"><a href="#661-图片平滑器" class="headerlink" title="661. 图片平滑器"></a>661. 图片平滑器</h3><p>包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</p>
<p>示例 1:</p>
<pre><code>输入:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
</code></pre><p>注意:</p>
<ul>
<li>给定矩阵中的整数范围为 [0, 255]。</li>
<li>矩阵的长和宽的范围均为 [1, 150]。</li>
</ul>
<p>思路: 考虑所有情况。如果位置为第一行，则只需要考虑数组所在的行和下一行；如果位置为最后一行，则只需要考虑数字所在的行和前一行。如果位置位于第一列，则只需要考虑数字所在的列和后一列；如果位置位于最后一列，则只需要考虑数字所在的列和前一列。</p>
<p>代码：</p>
<p>   vector&lt;vector<int>&gt; imageSmoother(vector&lt;vector<int>&gt;&amp; M) {<br>        vector&lt;vector<int> &gt;  ans(M.size());<br>        int sum = 0;<br>        int count = 0;<br>        for(int i = 0; i &lt; M.size(); i++)<br>        {<br>            ans[i] = vector<int>(M[0].size());<br>            for (int j = 0; j &lt; M[0].size(); j++)<br>            {<br>                sum = 0;<br>                count = 0;<br>                //计算左侧一列<br>                if (j &gt; 0)<br>                {<br>                    sum += M[i][j-1];<br>                    count++;<br>                    if (i &gt; 0)<br>                    {<br>                        sum += M[i-1][j-1];<br>                        count++;<br>                    }<br>                    if (i &lt; M.size()-1)<br>                    {<br>                        sum += M[i+1][j-1];<br>                        count++;<br>                    }<br>                }<br>                //计算中间一列<br>                sum += M[i][j];<br>                count++;<br>                if (i &gt; 0)<br>                {<br>                    sum += M[i-1][j];<br>                    count++;<br>                }<br>                if (i &lt; M.size()-1)<br>                {<br>                    sum += M[i+1][j];<br>                    count++;<br>                }<br>                //计算右侧一列<br>                if (j &lt; M[0].size() - 1)<br>                {<br>                    sum += M[i][j+1];<br>                    count++;<br>                    if (i &gt; 0)<br>                    {<br>                        sum += M[i-1][j+1];<br>                        count++;<br>                    }<br>                    if (i &lt; M.size() - 1)<br>                    {<br>                        sum += M[i+1][j+1];<br>                        count++;<br>                    }<br>                }<br>                ans[i][j] = sum / count;<br>            }<br>        }<br>        return ans;</int></int></int></int></p>
<pre><code>}
</code></pre><h3 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a>665. 非递减数列</h3><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p>
<p>示例 1:</p>
<pre><code>输入: [4,2,3]
输出: True
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
</code></pre><p>示例 2:</p>
<pre><code>输入: [4,2,1]
输出: False
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
</code></pre><p>说明:  n 的范围为 [1, 10,000]。</p>
<p>思路：    </p>
<pre><code>如果出现 a[i] &gt; a[i+1]   改变一个数 就面临两种选择
1. 把a[i]变大
2. 把a[i+1] 变小
这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值
eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大
改变完之后，记录改变次数，再检测是否升序
如果次数大于1，至少改了两次 返回false

先让前两个有序
因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小
</code></pre><p>代码：</p>
<pre><code>bool checkPossibility(vector&lt;int&gt;&amp; nums) {
    // 数组个数小于2个 一定可以
    if (nums.size() &lt; 3)
        return true;
    int count = 0;
    if (nums[0] &gt; nums[1])
    {
        count++;
        nums[0] = nums[1];
    }
    for (int i = 1; i &lt; nums.size()-1;  i++)
    {
        int right = nums[i+1];
        if (nums[i] &gt; right)
        {
            count++;
            if (count &gt; 1)
                return false;
            int left = nums[i-1];
            if (left &gt; right)
                nums[i+1] = nums[i];
            else
                nums[i] = left;
        }
    }
    return true;
}
</code></pre><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1:</p>
<pre><code>输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
</code></pre><p> 示例 2:</p>
<pre><code>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
</code></pre><p>注意：</p>
<ul>
<li>cost 的长度将会在 [2, 1000]。</li>
<li>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</li>
</ul>
<p>思路：动态规划。最小子问题，每一步i的最小从花费等于前一步开销加上当前i阶梯开销和前两步的开销加上当前i阶梯的开销中的最小值。对于，最后一步，如果是前两步的开销必须加上最后一步的开销，而对于前一步的开销就不需要加上最后一步的开销。</p>
<p>代码：</p>
<pre><code>int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
    if (cost.size() == 0)
        return 0;
    if (cost.size() == 1)
        return cost[0];
    if (cost.size() == 2)
        return min(cost[0], cost[1]);
    vector&lt;int&gt; dp(cost.size());
    dp[0] = cost[0];
    dp[1] = cost[1];
    int i;
    for (i = 2; i &lt; cost.size()-1; i++)
    {
        dp[i] = min(dp[i-1]+cost[i], dp[i-2]+cost[i]);
    }
    dp[i] = min(dp[i-1], dp[i-2]+cost[i]);
    return dp[i];
}
</code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="5-最大子序和"><a href="#5-最大子序和" class="headerlink" title="5. 最大子序和"></a>5. 最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre><p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>思路： 子问题是每次判断前面所有的和是否大于0，如果小于零，则对于求最大和没有作用，所以直接省略前面的和。</p>
<p>代码：</p>
<pre><code>int maxSubArray(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    int * dp = new int[n];
    dp[0] = nums[0];
    int m = nums[0];
    for (int i = 1; i &lt; n; i++)
    {
        dp[i] = nums[i] + (dp[i-1] &gt; 0 ?  dp[i-1] : 0);
        m = max(m, dp[i]);
    }
    return m;
}
</code></pre><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<pre><code>输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
</code></pre><p>示例 2：</p>
<pre><code>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</code></pre><p>思路：初始问题，一个台阶只有一种爬法；两个台阶有两种爬法。而对于i个台阶，其爬法为：i-1个台阶爬法和i-2个台阶的爬法之和。</p>
<p>代码：</p>
<pre><code>int climbStairs(int n) {
    if (n == 1)
        return 1;
    int * dp = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i &lt;= n; i++)
    {
        dp[i] =dp[i-1] + dp[i-2]; 
    }
    return dp[n];
    /*if (n == 1) //递归实现
        return 1;
    if (n == 2)
        return 2;
    int a = climbStairs(n-1) + climbStairs(n-2);
    return a;*/
}
</code></pre><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre><p>示例 2:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><p>思路： 每次第i个元素和前面i个元素中最小值，并将i个元素减去最小值，然后取差中的最大值。</p>
<p>其实这是一个求最低谷到最高峰的问题。</p>
<p>代码：</p>
<pre><code>int maxProfit(vector&lt;int&gt;&amp; prices) {
    if (prices.size() &lt;= 1)
        return 0;
    int minprices = prices[0];  
    int maxprofit = 0;
    for (int i = 1; i &lt; prices.size(); i++)
    {

        minprices = min(minprices, prices[i]);
        int profit =  prices[i] - minprices;
        maxprofit = max(profit, maxprofit);
    }
    return maxprofit;
}
</code></pre><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre><p>示例 2:</p>
<pre><code>输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</code></pre><p>思路： 动态规划。初始问题，只有一个房屋是，小偷收益就是该房间的。如果两个房屋，小偷收益就是两个房屋中的最大值。而对于第i个房屋，小偷的最大收益为当前房屋i的金额加上偷第i-2个房屋的收益和偷第i-1个房屋的收益的最大值。</p>
<p>代码：</p>
<pre><code>int rob(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0)
        return 0;
    if (nums.size() == 1)
        return nums[0];
    vector&lt;int&gt; dp(nums.size());
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    for (int i = 2; i &lt; nums.size(); i++)
    {
        dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
    }
    return dp[nums.size()-1];
}
</code></pre><h3 id="213-打家劫舍-Ⅱ（中等）"><a href="#213-打家劫舍-Ⅱ（中等）" class="headerlink" title="213 打家劫舍 Ⅱ（中等）"></a>213 打家劫舍 Ⅱ（中等）</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<pre><code>输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
</code></pre><p>示例 2:</p>
<pre><code>输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre><p>思路：分两种情况，分别计算两种情况下的最大收益，即两次动态规划。第一种情况，即偷第一间房屋，这样就不能偷最后一间房屋；第二种情况，不偷第一间放我，这样就可以偷最后一间房屋。</p>
<p>代码：</p>
<pre><code>int rob(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; dp1(nums.size());
    vector&lt;int&gt; dp2(nums.size());
    if (nums.size()  == 0)
        return 0;
    if (nums.size() == 1)
        return nums[0];
    dp1[0] = nums[0];
    dp1[1] = max(nums[0], nums[1]);
    for (int i = 2; i &lt; nums.size()-1; i++)
    {
        dp1[i] = max(dp1[i-1], nums[i]+dp1[i-2]);
    }
    dp2[0] = 0;
    dp2[1] = nums[1];
    for (int i = 2; i &lt; nums.size(); i++)
    {
        dp2[i] = max(dp2[i-1], nums[i] + dp2[i-2]);
    }
    return max(dp1[nums.size()-2], dp2[nums.size()-1]);
}
</code></pre><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303  区域和检索 - 数组不可变"></a>303  区域和检索 - 数组不可变</h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>示例：</p>
<pre><code>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3
</code></pre><p>说明:</p>
<ul>
<li>你可以假设数组不可变。</li>
<li>会多次调用 sumRange 方法。</li>
</ul>
<p>思路：创建一个共享数组。构造函数往共享数组中写数据，该数组中元素是构造函数参数数组中前i个元素的和，而sumRange()函数返回结果。</p>
<p>代码：</p>
<pre><code>class NumArray {
public:
    //创建一个数字记录前面计算过的值，避免重复计算
    vector&lt;int&gt; num;
    NumArray(vector&lt;int&gt;&amp; nums) {
        num.push_back(0);
        int sum = 0;
        for (int i = 0; i &lt; nums.size(); i++)
        {
            sum += nums[i];
            num.push_back(sum);
        }
    }

    int sumRange(int i, int j) {
        return num[j+1] - num[i];
    }
};
</code></pre><h3 id="746-使用最小花费爬楼梯-1"><a href="#746-使用最小花费爬楼梯-1" class="headerlink" title="746 使用最小花费爬楼梯"></a>746 使用最小花费爬楼梯</h3><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost [i] (索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1:</p>
<pre><code>输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
</code></pre><p>示例 2:</p>
<pre><code>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
</code></pre><p>注意：</p>
<ul>
<li>cost 的长度将会在 [2, 1000]。</li>
<li>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</li>
</ul>
<p>思路：动态规划问题。最小问题就是对于第i个台阶，所需的总开销就是当前台阶的开销加上前一个台阶和前两个台阶最小开销之和。</p>
<p>需要注意的是，最后一步，如果从第i-1步直接走上去，就不需要加上第i个台阶的开销。而对于从第i-2步走得话，就需要加上第i个台阶得开销。</p>
<p>代码：</p>
<pre><code>int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
    if (cost.size() == 0)
        return 0;
    if (cost.size() == 1)
        return cost[0];
    if (cost.size() == 2)
        return min(cost[0], cost[1]);
    vector&lt;int&gt; dp(cost.size());
    dp[0] = cost[0];
    dp[1] = cost[1];
    int i;
    for (i = 2; i &lt; cost.size()-1; i++)
    {
        dp[i] = min(dp[i-1]+cost[i], dp[i-2]+cost[i]);
    }
    //最后一步需要单独考虑，可能最后一个台阶可以直接跳过
    dp[i] = min(dp[i-1], dp[i-2]+cost[i]);
    return dp[i];
}
</code></pre><h4 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a>1025. 除数博弈</h4><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p>
<ul>
<li>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。</li>
<li>用 N - x 替换黑板上的数字 N 。</li>
</ul>
<p>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p>
<p>示例 1：</p>
<pre><code>输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：

输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
</code></pre><p>提示：</p>
<pre><code>1 &lt;= N &lt;= 1000
</code></pre><p>方法一： 归纳法</p>
<p>思路： 首先需要明确的是，对于一个确定的数N，只可能赢或者输，不可能存在不确定的情况，也就是只要对于N能存在赢的情况就是赢，那么该问题演变为，如果Alice拿到N是输的话，那么她拿到N+1一定为赢，因为拿到N+1时，她可以只取1，那么Bob就会拿到N，Bob就会输，所以这时候奇数偶数，一个为赢另一个为输的问题，我们只需要确定奇数赢还是偶数赢就可以了，依据示例可以看出偶数是赢的</p>
<p>代码：</p>
<pre><code>bool divisorGame(int N) {
    return N % 2 == 0;
}
</code></pre><p>方法二：暴力解法</p>
<p>代码：</p>
<pre><code>bool divisorGame(int N) {
    int count = 0;
    while (N &gt; 1)
    {
        for (int i = 1; i &lt; sqrt(N); i++)
        {
            if (N % i == 0)
            {
                N = N - i;
                count++;
                break;
            }
        }
    }
    return (count % 2) != 0;

}
</code></pre><p>方法三：动态规划DP</p>
<p>代码：</p>
<pre><code>bool divisorGame(int N) {
    if (N &lt; 2)
        return false;
    vector&lt;bool&gt; dp(N+1);
    dp[0] = false;
    dp[1] = false;
    for (int i = 2; i &lt;= N; i++)
        for (int j = 1; j &lt; i; j++)
        {
            if (!dp[i-j] &amp;&amp; i % j == 0)
            {
                dp[i] = true;
                break;
            }
        }
    return dp[N];
}
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415 字符串相加"></a>415 字符串相加</h3><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：</p>
<ul>
<li>num1 和num2 的长度都小于 5100.</li>
<li>num1 和num2 都只包含数字 0-9.</li>
<li>num1 和num2 都不包含任何前导零。</li>
<li>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</li>
</ul>
<p>思路：首先将两个字符串进行转序，创建一个num3字符串记录结构。然后从i=0开始，每次将字符串中的字符转换为整型，然后计算两者的和，如果和大于9，则将和取余转换成字符串加入num3，并将flag设置为1，表示需要进位；否则直接结果放入num3中。最后，判断flag是否为1，如果为1，在num3的末尾添加一个字符1。最后，将num3进行转序得到结果。</p>
<p>代码：</p>
<pre><code>string addStrings(string num1, string num2) {
    reverse(num1.begin(), num1.end());
    reverse(num2.begin(), num2.end());
    string num3;
    int flag = 0;
    int i;
    for (i = 0; i &lt; num1.size() || i &lt; num2.size(); i++)
    {
        int ans = 0, n1 = 0, n2 = 0;
        if (i &lt; num1.size())
            n1 = num1[i] - &apos;0&apos;;
        if (i &lt; num2.size())
            n2 = num2[i] - &apos;0&apos;;
        ans = n1 + n2 + flag;
        if (ans &gt; 9)
        {
            num3.insert(i,1, ans%10 + &apos;0&apos;);
            flag = 1;
        }
        else 
        {
            num3.insert(i,1, ans+&apos;0&apos;);
            flag = 0;
        }
    }
    if (flag == 1)
        num3.append(&quot;1&quot;);
    reverse(num3.begin(), num3.end());
    return num3;
}
</code></pre><h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434 字符串中的单词数"></a>434 字符串中的单词数</h3><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<p>示例:</p>
<pre><code>输入: &quot;Hello, my name is John&quot;
输出: 5
</code></pre><p>思路：但前一个字符不为空格，而当前字符串为空格或者为\0时，表示前面出现一个单词。</p>
<p>代码：</p>
<pre><code>int countSegments(string s) {
    int count = 0;
    for (int i = 1; i &lt;= s.size(); i++)
    {
        if (s[i-1] != &apos; &apos; &amp;&amp; (s[i] == &apos; &apos; || s[i] == &apos;\0&apos; ))
            count++;
    }
    return count;
}
</code></pre><h3 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443 压缩字符串"></a>443 压缩字符串</h3><p>题目：</p>
<p>给定一组字符，使用原地算法将其压缩。</p>
<p>压缩后的长度必须始终小于或等于原数组长度。</p>
<p>数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。</p>
<p>在完成原地修改输入数组后，返回数组的新长度。</p>
<p>进阶：<br>你能否仅使用O(1) 空间解决问题？</p>
<p>示例 1：</p>
<pre><code>输入：
[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]

输出：
返回6，输入数组的前6个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]

说明：
&quot;aa&quot;被&quot;a2&quot;替代。&quot;bb&quot;被&quot;b2&quot;替代。&quot;ccc&quot;被&quot;c3&quot;替代。
</code></pre><p>示例 2：</p>
<pre><code>输入：
[&quot;a&quot;]

输出：
返回1，输入数组的前1个字符应该是：[&quot;a&quot;]

说明：
没有任何字符串被替代。
</code></pre><p>示例 3：</p>
<pre><code>输入：
[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]

输出：
返回4，输入数组的前4个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。

说明：
由于字符&quot;a&quot;不重复，所以不会被压缩。&quot;bbbbbbbbbbbb&quot;被“b12”替代。
注意每个数字在数组中都有它自己的位置。
</code></pre><p>注意：</p>
<ul>
<li>所有字符都有一个ASCII值在[35, 126]区间内。</li>
<li>1 &lt;= len(chars) &lt;= 1000。</li>
</ul>
<p>思路：双指针法。一个指针记录需要存放字母出现次数的位置。当另一个指针指向的字符和后一个字符相等，则计数器count加加，否则如果两个字符不相等，分两种情况，如果count=1，则不需要将count加入到字符串中；否则，得将count放入字符串中，利用<code>to_string()</code>函数将整型转换成字符串，然后一个一个字符添加到字符串中。</p>
<p>代码：</p>
<pre><code>int compress(vector&lt;char&gt;&amp; chars) {
    int r = 0;
    int count = 1;
    for (int i = 0; i &lt; chars.size()-1; i++)
    {
        if (chars[i] == chars[i+1])
            count++;
        else if (chars[i] != chars[i+1] &amp;&amp; count == 1)
        {
            chars[++r] = chars[i+1];
        }
        else
        {
            string temp = to_string(count);
            for (auto c : temp)
                chars[++r] = c;
            chars[++r] = chars[i+1];
            count = 1;
        }
    }
    if (count != 1)
    {
        string temp = to_string(count);
        for (auto c : temp)
            chars[++r] = c;
    }
    return r+1;
}
</code></pre><h3 id="459-重复得子字符串"><a href="#459-重复得子字符串" class="headerlink" title="459 重复得子字符串"></a>459 重复得子字符串</h3><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;abab&quot;

输出: True

解释: 可由子字符串 &quot;ab&quot; 重复两次构成。
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;aba&quot;

输出: False
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;abcabcabcabc&quot;

输出: True

解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)
</code></pre><p>思路：创建一个字符数组，其大小是原字符串大小的2倍减1，然后将字符串除第一个字符之外的所有字符放入数组中，以及将除字符最后一个字符之外的所有字符放入数组中。最后，判断新创建的字符串是否包含原字符串。</p>
<p>注意： strncat(dest, src, n)，将src中的前n个字符追加到str的末尾；strstr(str1, str2)判断str2是否是str1的子串。memset(str, 0, sizeof(str))将str中所有字符初始化为0。</p>
<p>代码：</p>
<pre><code>bool repeatedSubstringPattern(string s) {
    int len = s.size();
    char str1[len+1];
    int i;
    for (i = 0; i &lt; len; i++)
        str1[i] = s[i];
    str1[i] = &apos;\0&apos;;
    char str[2 * len - 1];
    memset(str, 0, sizeof(str));
    strncat(str, str1 + 1, len - 1);
    strncat(str, str1, len - 1);

    return strstr(str, str1);
}
</code></pre><h3 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a>520. 检测大写字母</h3><p>给定一个单词，你需要判断单词的大写使用是否正确。</p>
<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>
<ul>
<li>全部字母都是大写，比如”USA”。</li>
<li>单词中所有字母都不是大写，比如”leetcode”。</li>
<li>如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。</li>
</ul>
<p>否则，我们定义这个单词没有正确使用大写字母。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;USA&quot;
输出: True
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;FlaG&quot;
输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。
</code></pre><p>思路： 首先判断首字母是否为大写，用flag=true标记，如果剩余字符中出现大写字母，则将flag设为false，并结束循环；最后判断flag是否为true，为true则返回true。</p>
<p>以上是第一种情况，现在分析第二种和第三种情况，初始化两个计数器，分别记录大写字母的数量和小写字母的数量，通过islower和isupper函数来判断一个字符是否为小写字母和大写字母。最后判断两者的大小是否等于字符串的大小，如果某一个等于字符串大小，则返回true，否则返回false。</p>
<p>代码：</p>
<pre><code>bool detectCapitalUse(string word) {
    int flag = false;
    if (isupper(word[0]))
        flag = true;
    for (int i = 1; i &lt; word.size(); i++)
    {
        if (isupper(word[i]))
        {                    
            flag = false;
            break;
        }    
    }
    if (flag == true)
        return true;
    int up_count = 0;
    int low_count = 0;
    for (int i = 0; i &lt; word.size(); i++)
        if (islower(word[i]))
            low_count++;
        else 
            up_count++;
    if (low_count == word.size() || up_count == word.size())
        return true;
    return false;     
}
</code></pre><p>第二种解法：记录大写字母的数量，如果出现大写字母的数量小于当前字符的下标，则返回false，说明前面出现非连续的大写字母。</p>
<p>代码：</p>
<pre><code>bool detectCapitalUse(string word) {
    int uc = 0;
    for (int i = 0; i &lt; word.size(); i++)
    {
        if (isupper(word[i]) &amp;&amp; uc++ &lt; i)
            return false;
    }
    return uc == word.size() || uc &lt;= 1;
}
</code></pre><h3 id="521-最长特殊序列-Ⅰ"><a href="#521-最长特殊序列-Ⅰ" class="headerlink" title="521 最长特殊序列 Ⅰ"></a>521 最长特殊序列 Ⅰ</h3><p>给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<p>示例 :</p>
<pre><code>输入: &quot;aba&quot;, &quot;cdc&quot;
输出: 3
解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)
</code></pre><p>说明:</p>
<ul>
<li>两个字符串长度均小于100。</li>
<li>字符串中的字符仅含有 ‘a’~’z’。</li>
</ul>
<p>思路：</p>
<ul>
<li>s1 = ‘ab’,s2 = ‘a’,因为ab是s1独有，所以最长子序列为ab，</li>
<li>s1 = ‘ab’, s2 = ‘ab’, 因为ab是两个串都有，ab排除，a也是两个串都有，排除，b也是两个串都有，排除。所以最长特殊序列不存在，返回-1</li>
<li>通过以上分析，我们可以得出结论，如果：两个串相等（不仅长度相等，内容也相等），那么他们的最长特殊序列不存在。返回-1</li>
<li>如果两个串长度不一样，那么长的串 永远也不可能是 短串的子序列，即len(s1) &gt; len(s2),则最长特殊序列为s1,返回长度大的数</li>
</ul>
<p>注意：</p>
<p>string转换成字符数组转的函数： c_str()</p>
<pre><code>string x = &quot;ab&quot;;
char * y = x.c_str();
</code></pre><p>字符数组转成成string的函数： 直接赋值</p>
<pre><code>const char * x = &quot;abc&quot;;
string y = x;
</code></pre><p>整型转string: to_string()</p>
<pre><code>int a = 10;
string x = a.to_string();
</code></pre><p>strcmp(str1, str2)，比较两个字符串的是否相等（长度和内容相等），str1和str2为字符数组。若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。</p>
<p>代码：</p>
<pre><code>  int findLUSlength(string a, string b) {
    return (strcmp(a.c_str(), b.c_str()) ? (a.size()&gt; b.size() ? a.size() : b.size() ): -1);
}
</code></pre><h3 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541 反转字符串 II"></a>541 反转字符串 II</h3><p>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</p>
<p>示例:</p>
<pre><code>输入: s = &quot;abcdefg&quot;, k = 2
输出: &quot;bacdfeg&quot;
</code></pre><p>要求:</p>
<ul>
<li>该字符串只包含小写的英文字母。</li>
<li>给定字符串的长度和 k 在[1, 10000]范围内。</li>
</ul>
<p>思路:对字符串进行分隔，然后创建一个临时字符串来存储每个部分的字符串，并利用reverse进行逆转，逆转后将该字符串加入存放结果的字符串中。最后，两种特殊情况进行讨论，即大小k个字符时，以及大于等于k个字符和小于2k。</p>
<p>代码：</p>
<pre><code>string reverseStr(string s, int k) {
    int n = s.size()%(2*k);
    int m = s.size()/(2*k);
    string str;
    for (int i = 0; i &lt; m; i++)
    {
        string temp = string(s.begin()+2*k*i, s.begin()+2*k*(i+1));
        reverse(temp.begin(), temp.end()-k);
        str += temp;
        temp = &quot;&quot;;
    }
    string temp = string(s.begin()+2*k*m, s.end());
    if (n &lt; k)
        reverse(temp.begin(), temp.end());
    if (n &gt;= k &amp;&amp; n &lt; 2*k)
        reverse(temp.begin(), temp.begin()+k);
    str += temp;
    return str;
}
</code></pre><h3 id="551-学生出勤记录"><a href="#551-学生出勤记录" class="headerlink" title="551 学生出勤记录"></a>551 学生出勤记录</h3><p>给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：</p>
<pre><code>&apos;A&apos; : Absent，缺勤
&apos;L&apos; : Late，迟到
&apos;P&apos; : Present，到场
</code></pre><p>如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。</p>
<p>你需要根据这个学生的出勤记录判断他是否会被奖赏。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;PPALLP&quot;
输出: True
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;PPALLL&quot;
输出: False
</code></pre><p>思路: 不被奖赏的同学包括：大于等于2个A，或者存在连续3个L。所以，我们只要统计A的个数，以及是否存在连续的3个L，两个条件满足一个就返回false。如果字符串长度小于等于1，则一定会被奖赏，返回true。</p>
<p>代码:</p>
<pre><code>bool checkRecord(string s) {
    if (s.size() &lt;= 1)
        return true;
    int flag1 = 0, flag2 = 0;
    for (int i = 0; i &lt; s.size()-2; i++)
    {
        if (s[i] == &apos;A&apos;)
            flag1 += 1;
        if (s[i] == s[i+1] &amp;&amp; s[i+1] == s[i+2] &amp;&amp; (s[i] == &apos;L&apos;))
            flag2 = 1;
    }
    if ( s[s.size()-1] == &apos;A&apos;)
        flag1  += 1;
    if (s[s.size()-2] == &apos;A&apos;)
        flag1++;
    if (flag1 &gt;= 2 || flag2 == 1)
        return false;
    else
        return true;
}
</code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<pre><code>输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
</code></pre><p>示例 3:</p>
<pre><code>输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
</code></pre><p>思路： 递归。最小问题时，但两颗树同时指向空，则返回true，如果其中一个为空，另一个不为空，或者两个都不为空，但是不相等，则返回false。</p>
<p>代码：</p>
<pre><code>bool isSameTree(TreeNode* p, TreeNode* q) {
    if (p == NULL &amp;&amp; q == NULL)
        return true;
    if ( (p != NULL &amp;&amp;  q == NULL) || (p == NULL &amp;&amp;  q != NULL) || ((p != NULL &amp;&amp; q != NULL) &amp;&amp; (p-&gt;val != q-&gt;val)) )
        return false;
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);

}
</code></pre><p>简单版：</p>
<pre><code>bool isSameTree(TreeNode* p, TreeNode* q) {
    if (p == NULL &amp;&amp; q == NULL)
        return true;
    if ((p != NULL &amp;&amp; q != NULL) &amp;&amp; (p-&gt;val == q-&gt;val)) 
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    else
        return false;
}
</code></pre><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3
</code></pre><p>说明:</p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<p>思路：递归的子问题是：判断两个子树中，一个子树的左子树是否等于另一个子树的右子树，一个子树的右子树是否等于另一个子树的左子树。</p>
<p>代码：</p>
<pre><code> bool isSymmetric(TreeNode* root) {
if (root == NULL)
        return true;
    return isSameTree(root-&gt;left, root-&gt;right);
}

bool isSameTree(TreeNode * p, TreeNode * q)
{
    if (p == NULL &amp;&amp; q == NULL)
        return true;
    if (p != NULL &amp;&amp; q != NULL &amp;&amp; p-&gt;val == q-&gt;val)
        return isSameTree(p-&gt;left, q-&gt;right) &amp;&amp; isSameTree(p-&gt;right, q-&gt;left);
    else
        return false;
}
</code></pre><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>返回它的最大深度 3 。</p>
<p>思路：递归</p>
<p>代码：</p>
<pre><code>int maxDepth(TreeNode* root) {
    if (root == NULL)
        return 0;
    return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1;
}
</code></pre><h3 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a>107. 二叉树的层次遍历 II</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>返回其自底向上的层次遍历为：</p>
<pre><code>[
  [15,7],
  [9,20],
  [3]
]
</code></pre><p>思路：通过队列实现。首先将根节点放入队列中。求出队列的长度，将队列中的元素放入一个数组中，当作一层的输出，并将队列中结点的子节点放入队列中，将上一层的节点在队列中删除。每一层的节点组成的数组放入一个新的数组中。</p>
<p>代码：</p>
<pre><code>vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
    vector&lt;vector&lt;int&gt;&gt; res;
    if (root == NULL)
        return res;
    queue&lt;TreeNode*&gt; q;
    q.push(root); //将头节点放入队列中
    while (!q.empty())
    {
        int len = q.size(); //获取队列的长度
        vector&lt;int&gt; temp; 
        for (int i = 0; i &lt; len; i++) //将当前队列中的节点的值取出放入数组，并将节点的子树放入依次放入队列中
        {
            temp.push_back(q.front()-&gt;val); 
            if (q.front()-&gt;left != NULL)
                q.push(q.front()-&gt;left);
            if (q.front()-&gt;right != NULL)
                q.push(q.front()-&gt;right);
            q.pop();
        }
        res.insert(res.begin(), temp); //将一层节点的值放入结果数组中
    }
    return res;
}
</code></pre><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>     0
    / \
  -3   9
  /   /
-10  5
</code></pre><p>思路： 递归的思想。每次将数组的中间元素作为根结点，左侧的元素位于左子树，右侧的元素位于右子树。</p>
<p>代码：</p>
<pre><code>TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
    return sortedArrayToBST(nums, 0, nums.size()-1);
}
TreeNode * sortedArrayToBST(vector&lt;int&gt; &amp; nums, int i, int j)
{
    if (i &gt; j)
        return NULL;
    int mid = (j-i)/2+i;
    TreeNode * root = new TreeNode(nums[mid]);
    root-&gt;left = sortedArrayToBST(nums, i, mid-1);
    root-&gt;right = sortedArrayToBST(nums, mid+1, j);
    return root;
}
</code></pre><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>      1
     / \
    2   2
   / \
  3   3
 / \
4   4
</code></pre><p>返回 false 。</p>
<p>思路： 首先判断树是否为空，或者树是否有子树，如果数为空，或者根节点没有子树，就返回true。否则，计算两棵子树的高度差，如果高度差小于1，则递归计算左右两棵子树是否满足平衡二叉树，否则直接返回false。</p>
<p>树的深度计算也是通过递归实现。</p>
<p>代码：</p>
<pre><code>bool isBalanced(TreeNode* root) {
    if (root == NULL || root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
        return true;
    int t = abs(deepOfTree(root-&gt;left) - deepOfTree(root-&gt;right));
    if (t &lt;= 1)
        return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);
    else
        return false;

}
int deepOfTree(TreeNode * root)
{
    if (root == NULL)
        return 0;
    return max(deepOfTree(root-&gt;left), deepOfTree(root-&gt;right)) + 1;
}
</code></pre><p>上一种方法比较慢，使用了两次递归。下面的方法每次计算递归计算树的高度。</p>
<p>   bool isBalanced(TreeNode* root) {<br>        int h;<br>        return isBalanced(root, h);<br>    }</p>
<pre><code>bool isBalanced(TreeNode* root, int&amp; height) {
    if (root == nullptr)
    {
        height = 0;
        return true;
    }
    int h1, h2;
    bool flag = isBalanced(root-&gt;left, h1) &amp;&amp;
        isBalanced(root-&gt;right, h2);
    height = max(h1, h2) + 1;
    return flag &amp;&amp; abs(h1 - h2) &lt;= 1;
}
</code></pre><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>返回它的最小深度  2.</p>
<p>思路：递归实现。每次取两颗子树的最小深度加1，终止条件根节点为NULL。</p>
<p>注意两种情况：一种根节点没有左子树，另一种是根节点没有右子树。即下面两种情况。</p>
<p><img src="https://i.imgur.com/C3QPVWZ.png" alt=""></p>
<p>上面两种情况，最小深度为3。需要单独考虑，如果不单独考虑，这两种情况的最小深度都为1。</p>
<p>代码：</p>
<pre><code>int minDepth(TreeNode* root) {
    if (root == NULL)
        return 0;
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right != NULL)
        return minDepth(root-&gt;right)+1;
    if (root-&gt;left != NULL &amp;&amp; root-&gt;right == NULL)
        return minDepth(root-&gt;left)+1;
    return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;
}
</code></pre><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>思路：递归思路。每次递归都减去当前节点的值，然后取两个子树递归结果的或。如果该节点为叶子节点并且sum=0，则返回true。如果当前节点为空节点返回false。</p>
<p>代码：</p>
<pre><code>bool hasPathSum(TreeNode* root, int sum) {
    if (root == NULL)
        return false;
    sum -= root-&gt;val;
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
        return (sum == 0);
    return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);
}
</code></pre><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><p>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
<p>思路：先序遍历实现。</p>
<p>代码：</p>
<pre><code>TreeNode* invertTree(TreeNode* root) {
    if (root == NULL)
        return nullptr;
    TreeNode * temp = root-&gt;right;
    root-&gt;right = invertTree(root-&gt;left);
    root-&gt;left = invertTree(temp);
    return root;
}
</code></pre><p>其他方法：中序遍历和后序遍历实现跟先序遍历相似。还有一种就是层次遍历，利用队列实现。</p>
<p>代码：</p>
<pre><code>TreeNode* invertTree(TreeNode* root) {   
 //层次遍历实现
    if (root == NULL)
        return nullptr;
    queue&lt;TreeNode *&gt; q;
    q.push(root);
    while (!q.empty())
    {
        TreeNode * node = q.front();
        q.pop();
        TreeNode * temp = node-&gt;left;
        node-&gt;left = node-&gt;right;
        node-&gt;right = temp;
        if (node-&gt;left != NULL)
            q.push(node-&gt;left);
        if (node-&gt;right != NULL)
           q.push(node-&gt;right) ;
    }
    return root;
}
</code></pre><p>中序遍历和后序遍历理解有点困难：</p>
<pre><code>利用中序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
            invertTree(root.left); // 递归找到左节点
            TreeNode rightNode= root.right; // 保存右节点
            root.right = root.left;
            root.left = rightNode;
            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left
            invertTree(root.left); 
    }
}

利用后序遍历
 class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 后序遍历-- 从下向上交换
            if (root == null) return null;
            TreeNode leftNode = invertTree(root.left);
            TreeNode rightNode = invertTree(root.right);
            root.right = leftNode;
            root.left = rightNode;
            return root;
        }
    }
</code></pre><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235 二叉搜索树的最近公共祖先"></a>235 二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p>
<p>示例 1:</p>
<pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
</code></pre><p>示例 2:</p>
<pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
</code></pre><p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路： 利用二叉搜索树的特性，左子树的值小于根节点的值，右子树的值大于根节点的值。两个节点的最近祖先，满足该节点的值大于一个子节点的值，而小于另一个子节点的值。如果同时大于两个子节点，则表示两个子节点在节点的左子树上；如果同时小于两个子节点，则表示两个子节点在节点的右子树上。</p>
<p>代码：</p>
<pre><code>TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == NULL)
        return NULL;
    while (true)
    {
        if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)
            root = root-&gt;left;
        else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)
            root = root-&gt;right;
        else
            return root;
    }
}
</code></pre><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>输入:</p>
<pre><code>   1
 /   \
2     3
 \
  5
</code></pre><p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</p>
<p>思路：递归方法，每次递归中都将结果利用引用的形式存放在参数中，而且将一个路径上的字符串也放在参数中，如果到达叶子节点则将字符串放入结果中。</p>
<p>代码：</p>
<pre><code>vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
    vector&lt;string&gt; res;
    if (root == NULL)
        return res;
    string temp = &quot;&quot;;
    binaryTreePaths(root, temp, res);
    return res;

}
void binaryTreePaths(TreeNode * root, string temp, vector&lt;string&gt; &amp;res)
{
    if (root == NULL)
        return;
    temp += to_string(root-&gt;val);
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
        res.push_back(temp);
    binaryTreePaths(root-&gt;left, temp + &quot;-&gt;&quot;, res);
    binaryTreePaths(root-&gt;right, temp + &quot;-&gt;&quot;, res);
}
</code></pre><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h3><p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>思路：递归实现，递归函数中保护所要计算的结果和一个标记，标记用来标记一个节点是否为左节点。如果一个节点的左子树和右子树为空，并且标记为true(即为左子树)，则将该节点的值加入到结果中。</p>
<p>代码：</p>
<pre><code>int sumOfLeftLeaves(TreeNode* root) {
    if (root == NULL)
        return 0;
    int sum = 0;
    sumOfLeftLeaves(root, false, sum);
    return sum;
}
void sumOfLeftLeaves(TreeNode* root, bool flag, int &amp;sum) {
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; flag == true)
    {
        sum += root-&gt;val;
        return;
    }
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; flag == false)
        return;
    if (root-&gt;left != NULL)
        sumOfLeftLeaves(root-&gt;left, true, sum);
    if (root-&gt;right != NULL)
        sumOfLeftLeaves(root-&gt;right, false, sum);
}
</code></pre><p>另一种解法：</p>
<pre><code>int sumOfLeftLeaves(TreeNode* root) {
    int res = 0;
    if (root == nullptr)
        return res;
    if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)
        return res;
    if (root-&gt;left != nullptr &amp;&amp; root-&gt;left-&gt;left == nullptr &amp;&amp; root-&gt;left-&gt;right == nullptr)
        res += root-&gt;left-&gt;val;
    else if (root-&gt;left)
        res += sumOfLeftLeaves(root-&gt;left);
    if (root-&gt;right)
        res += sumOfLeftLeaves(root-&gt;right);
    return res;
}
</code></pre><h3 id="437-路径总和-Ⅲ"><a href="#437-路径总和-Ⅲ" class="headerlink" title="437 路径总和 Ⅲ"></a>437 路径总和 Ⅲ</h3><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p>示例：</p>
<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<pre><code>      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
</code></pre><p>返回 3。和等于 8 的路径有:</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<p>思路：递归。利用数组来记录走过的路径。并判断当前路径是否等于sum。</p>
<p>代码：</p>
<pre><code>int pathSum(TreeNode* root, int sum) {
    if(root == nullptr) return 0;
    vector&lt;int&gt; buf;
    int res =0;
    pathSum_core(root,sum,buf,res);
    return res;
}

void pathSum_core(TreeNode *root,int sum,vector&lt;int&gt; &amp;buf, int &amp;res){
    if(root == nullptr) return;
    buf.push_back(root-&gt;val);
    int ans = 0;
    for(int i = buf.size()-1;i&gt;=0;i--){  
        ans += buf[i];
        if(ans == sum) res++;
    }
    pathSum_core(root-&gt;left,sum,buf,res);
    pathSum_core(root-&gt;right,sum,buf,res);
    buf.pop_back();
}
</code></pre><p>另一种方法比较笨，直接计算所有可能的路径，判断是否等于sum。效率比较低。</p>
<pre><code>int pathSum(TreeNode* root, int sum) {
    if (root == nullptr)
        return 0;
    return pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum) + dfs(root, sum);
}
int dfs(TreeNode * root, int sum)
{
    if (root == nullptr)
        return 0;
    int count = 0;
    if (root-&gt;val == sum)
        count += 1;

    return count + dfs(root-&gt;left, sum - root-&gt;val) + dfs(root-&gt;right, sum - root-&gt;val);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/06/17/C++并发与多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/C++并发与多线程/" itemprop="url">C++11并发与多线程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T20:18:14+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/17/C++并发与多线程/" class="leancloud_visitors" data-flag-title="C++11并发与多线程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          <p><a href="https://www.bilibili.com/video/av39171692?from=search&amp;seid=7663928812674265445" target="_blank" rel="noopener">C++多线程编程视频课程学习</a>笔记，适用于具有C++11基础的学者，开发环境VS2017。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/06/17/C++并发与多线程/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/06/15/HTTP和HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/HTTP和HTTPS/" itemprop="url">HTTP和HTTPS</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T13:44:14+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/15/HTTP和HTTPS/" class="leancloud_visitors" data-flag-title="HTTP和HTTPS">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP的缺点：</p>
<ul>
<li>通信使用明文，内容可能被窃取；</li>
<li>不验证通信方的身份，可能遭遇伪装；</li>
<li>无法验证报文的完整性，可能遭遇篡改攻击。</li>
</ul>
<h3 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h3><p>HTTPS并非是应用层一种新的协议，只是HTTP通信接口部分用SSL(安全套接字security scoket layer)和TSL(传输层安全 transport layer security)协议而已。</p>
<p>HTTP协议直接跟TCP通信。当使用SSL时，则演变成HTTP向和SSL协议通信，再由SSL和TCP通信。简而言之，HTTPS就是被SSL封装了一层的HTTP。</p>
<h3 id="HTTPS的作用"><a href="#HTTPS的作用" class="headerlink" title="HTTPS的作用"></a>HTTPS的作用</h3><ul>
<li>内容加密</li>
<li>身份认证</li>
<li>数据完整性验证</li>
</ul>
<p>现在的HTTPS基本都是用TLS了，因为更加安全。</p>
<h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><ul>
<li><p>对称加密： 内容的加密使用对称加密算法，对称加密算法中，公钥和私钥相同或者公私钥可以相互推导出来。客户端和服务端必须提前知道密钥，而在发送密钥的过程中可能被第三方监听。</p>
</li>
<li><p>非对称加密： 为了保证对称加密中密钥的安全，使用非对称加密算法。非对称加密算法中，由一个公私钥对，私钥用户保存，公钥发给其他用户。任何人无法从公钥推导出私钥来。</p>
</li>
</ul>
<p>为什么不直接使用非对称加密算法加密？</p>
<p>因为非对称加密算法更为复杂，通信中使用非对称加密算法，效率比较低。</p>
<ul>
<li>确保客户端收到的服务端的公钥是正确的（公钥在传输过程中，可能被攻击者替换），需要对证书中的公钥进行加密（HTTPS的服务端都必须去专门的证书机构注册一个证书），使用证书机构（CA）私钥进行加密，让步客户端利用CA的公钥进行解密。CA的公钥是内嵌在操作系统中，所以是安全的，CA的机构数据不多，所以维护起来方便。</li>
</ul>
<p>总结：</p>
<p>HTTPS通过非对称加密（通常是RSA算法）加密对称加密的密钥，然后使用证书机构的私钥加密非对称加密的公钥，而证书机构的公钥会内置在操作系统中，从而保证即使第三方监听，也可以保证安全。</p>
<h3 id="SSL和TLS"><a href="#SSL和TLS" class="headerlink" title="SSL和TLS"></a>SSL和TLS</h3><p>SSL可确保数据在传输过程中不会被截取。</p>
<p>TSL用于两个应用程序之间提供保密性和数据完整性。</p>
<p>SSL/TSL协议的作用：</p>
<ul>
<li>认证用户和服务器：确保数据发送到正确的客户端和服务器；</li>
<li>加密数据防止数据中途被窃取；</li>
<li>维护数据的完整性：确保数据在传输过程中不被篡改。</li>
</ul>
<p>TSL比SSL的优势：</p>
<ul>
<li>对于消息认证使用密钥散列法：TSL十三亿“消息认证代码的密钥散列法（HMAC）”，确保数据的完整性，HMAC比SSL使用的MAC更安全。</li>
<li>增强伪随机功能： PRF生成密钥数据。</li>
<li>改进的已完成消息验证</li>
<li>一致证书处理</li>
<li>特定报警消息</li>
</ul>
<h3 id="SSL和TSL的握手过程"><a href="#SSL和TSL的握手过程" class="headerlink" title="SSL和TSL的握手过程"></a>SSL和TSL的握手过程</h3><p>SSL与TSL握手整个过程如下图所示：</p>
<p><img src="https://images.morethink.cn/ea844ad80d80956a30095d5e4f39fd7b.png" alt=""></p>
<p>客户端首次发出请求：</p>
<p>请求包含的内容：</p>
<ul>
<li>支持的协议版本</li>
<li>支持的加密算法和压缩算法</li>
<li>一个随机数(N1，后面用于生成会话密钥)</li>
<li>hello</li>
</ul>
<p>服务端首次回应：</p>
<p>回应内容：</p>
<ul>
<li>确认使用的加密通信协议版本，比如TSL1.0版本</li>
<li>确认使用的加密方法，比如RSA加密</li>
<li>一个随机数(N2)</li>
<li>服务端自己的证书</li>
</ul>
<p>客户端再次回应：</p>
<p>客户端首先验证服务端证书，如果验证通过，则继续下面的操作，</p>
<ul>
<li>客户端再次生成一个随机数（N3），然后使用服务器证书中的公钥加密</li>
<li>一个编码改变的消息（即随后发送的消息都将用双发协商的加密算法和密钥进行加密）</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束，这一项通知也是前面发送的所有内容的hash值，用来提供服务器校验。</li>
</ul>
<p>在上面整个握手过程中，客户端和服务器同时有了三个随机数，接着双方就用实现商定的加密算法，各自生成本次会话所用的同一把“会话密钥”。</p>
<p>趋势面试：</p>
<ul>
<li>项目</li>
<li>用两三种方法实现斐不拉契数列，并分析时间和空间复杂度（当时就直接给的一个数列，没有是斐不拉契数列，需要自己看出来）</li>
<li>线程和进程的区别</li>
<li>用C++怎么实现多线程</li>
<li>socket编程怎么实现TCP和UDP,scoket怎么体现的TCP和UDP</li>
<li>如果ping一个域名不通，怎么判断是哪里出错了，比如是南京移动中心过去不，还是北京中心过不去，找出在哪里失败了</li>
<li>讲一个你写过的多态例子，分析其中的原理</li>
<li>SQL实现计算一个学生成绩表中每门成绩的平均成绩</li>
<li>HTTPS中怎么实现数据完整性的</li>
</ul>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/morethink/p/8127276.html" target="_blank" rel="noopener">https://www.cnblogs.com/morethink/p/8127276.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/06/14/面试常考题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/面试常考题/" itemprop="url">面试常考问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T13:44:14+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/14/面试常考题/" class="leancloud_visitors" data-flag-title="面试常考问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ul>
<li>进程是运行中的程序，线程是进程的内部的一个执行序列</li>
<li>进程是资源分配的单元，线程是执行单元</li>
<li>进程间切换代价大，线程间切换代价小</li>
<li>进程拥有资源多，线程拥有资源少</li>
<li>多个线程共享进程的资源</li>
</ul>
<h3 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h3><ul>
<li>全局变量</li>
<li>消息机制：windows程序设计</li>
</ul>
<h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><ul>
<li>临界区</li>
<li>互斥量</li>
<li>信号量</li>
<li>事件</li>
</ul>
<h3 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h3><ul>
<li>管道<ul>
<li>有名管道：任意进程之间，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>无名进程：父子进程之间，管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</li>
</ul>
</li>
<li>信号量： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>套接字：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>FCFS:先来先服务</li>
<li>SJF:短作业优先</li>
<li>按时间片论调</li>
<li>优先级： 分前台任务和后台任务，前台任务重视响应时间，后台任务重视周转时间</li>
</ul>
<h3 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h3><ul>
<li>堆：由程序员申请释放，如果没有释放，则有系统自动释放，类似于数据结构中的链表</li>
<li>栈：由程序自身自动释放，在调用参数时，主要用来存储形参和局部非静态变量，以及返回值，类似于数据结构中的堆</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="链表有无环以及找入点"><a href="#链表有无环以及找入点" class="headerlink" title="链表有无环以及找入点"></a>链表有无环以及找入点</h3><h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><ul>
<li>虚函数可以有函数体，如果子类没有重载虚函数，则调用父类的虚函数</li>
<li><p>纯虚函数没有函数体，必须在派生类中重载函数</p>
</li>
<li><p>虚函数主要实现多态机制，避免二义性</p>
</li>
<li>纯虚函数是抽象类机制，提供接口，派生类提供实现，</li>
</ul>
<p>最大的区别，有纯虚函数的抽象类不能定义对象，纯虚函数必须被重载，因此在被用来做基类的抽象类中肯定有一个或多个纯虚<br>函数。 而虚函数可以在继承中被重载，也可以不。</p>
<p>二者都实现了多态性。</p>
<h3 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h3><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul>
<li>引用是别名，而指针是地址。</li>
<li>声明时，必须给引用指定值，而指针可以为空。</li>
<li>引用没有const，而指针有。</li>
<li>引用不能为空，而指针可以为空。</li>
<li>指针在运行期间可以改变值，而引用一旦和某个等值线绑定后就不能改变。</li>
<li>程序为指针分配内存空间，而引用没有分配。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/06/11/Linux内核阅读问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/Linux内核阅读问题/" itemprop="url">Linux内核分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T13:44:14+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/11/Linux内核阅读问题/" class="leancloud_visitors" data-flag-title="Linux内核分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h2><h3 id="无libc库或无标准头文件"><a href="#无libc库或无标准头文件" class="headerlink" title="无libc库或无标准头文件"></a>无libc库或无标准头文件</h3><p>Linux内核无法使用C语言的库函数，但是Linux内核实现了这些库函数，实现的文件(即.c文件)包含在lib目录下，头文件(即.h文件)在include\linux目录下。</p>
<p>基本的头文件位于include\linux目录下；体系结构相关的头文件位于内核源代码数的arch/<architecture>/include/asm目录下。比如如果编译的是x86体系结构，则体系结构相关的头文件就是arch/x86/include/asm</architecture></p>
<p>使用的时候包含如下头文件：</p>
<pre><code>//包含基本头文件
#include &lt;linux/string.h&gt;
//包含体系结构相关的头文件
#include &lt;asm/ioctl.h&gt;
</code></pre><p>内核肯定无法调用printf，但是其提供了printk函数，几乎与printf()相同。printk()函数负责把格式化好的字符串拷贝到内核日志缓冲区上，这样syslog程序就可以通过读取该缓冲区来获取内核信息。printk()用法：</p>
<pre><code>printk(&quot;Hello world! A string: &apos;%s&apos; and an integer: &apos;%d&apos;\n&quot;, str ,i);
</code></pre><p>printk()与printf()的一个区别在于，printk()允许你通过一个标志来设置优先级。syslog会根据这个优先级标志来决定在什么地方显示这条系统信息。下面是一个车使用这种优先级标志的例子：</p>
<pre><code>printk(KERN_ERR &quot;This is an error!\n&quot;);
</code></pre><p>注意:KERN_ERR和要打印的消息之间没有逗号。优先级标志是预处理程序定义的一个描述性字符串，在编译时优先级标志与要打印的信息绑定在一起处理。</p>
<h3 id="GNU-C"><a href="#GNU-C" class="headerlink" title="GNU C"></a>GNU C</h3><p>Linux使用的是GNU C。</p>
<p>C语言扩展：</p>
<ul>
<li>inline函数：函数会在他所调用的位置上展开，这样会消除函数调用和返回所带来的开销。代价是代码会变长，占用更多的内存空间。所以经常把对时间要求比较高，而本身长度比较短的函数定义为内敛函数。</li>
</ul>
<p>定义内敛函数时，需要使用static作为关键字，并且用inline限定他。比如：</p>
<pre><code>static inline void wolf(unsigned long tail_size)
{ ...}
</code></pre><p>使用static限制，编译时不会为内联函数单独建立一个函数体。</p>
<p>为了安全险，优先使用内联函数，而不是复杂的宏</p>
<ul>
<li>内联汇编</li>
</ul>
<p>C函数中可以嵌入汇编指令。</p>
<p>通常使用asm()指令来嵌入汇编代码。</p>
<p>在偏近体系结构的底层或对执行时间要求严格的地方，一般使用汇编语言；而内核的其他部分使用C语言。</p>
<ul>
<li>分支声明</li>
</ul>
<p>对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核把这条指令封装成了宏，比如likely()和unlikely()，这样使用起来比较方便。</p>
<p>例如，普通的分支声明：</p>
<pre><code>if (error) {...}
</code></pre><p>如果想要把这个选择标记成绝少发生的分支：</p>
<pre><code>if(unlikely(error)) {...}
</code></pre><p>相反，如果我们想把一个分支标记成通常为真的选择：</p>
<pre><code>if(likely(error)) {...}
</code></pre><h3 id="内有内存保护机制"><a href="#内有内存保护机制" class="headerlink" title="内有内存保护机制"></a>内有内存保护机制</h3><p>如果一个用户程序视图进行一次非法的内存访问，内核就会出现错误，发送SIGSEGV信号，并结束进程。</p>
<p>如果是内核自己非法访问了内存，那后果加很难控制了。内核中发生的内存错误会导致oops，这是内存中出现的最常见的一类错误。在内核中，不应该取访问非法的内存地址，引用控制住，否则会死掉，却根本不告诉你。</p>
<p>内核中的内存都不分页。即，你用掉一个字节，物理内存就减少一个字节。</p>
<h3 id="不要轻易在内核中使用浮点数"><a href="#不要轻易在内核中使用浮点数" class="headerlink" title="不要轻易在内核中使用浮点数"></a>不要轻易在内核中使用浮点数</h3><p>用户空间的进程内进行浮点数操作的时候，内核会完成从整数操作到浮点数操作的模式转换。</p>
<p>而内核空间并不能完美地支持浮点操作，因为它本身不能陷入。在内核中使用浮点数，除了要人工保存和恢复浮点寄存器，还有其他一些琐碎的事情要做。</p>
<p>总之，在内核，不要进行浮点数操作。</p>
<h3 id="容积小而固定的栈"><a href="#容积小而固定的栈" class="headerlink" title="容积小而固定的栈"></a>容积小而固定的栈</h3><p>用户空间的成协商可以从栈上分配大量的空间来存放变量，甚至巨大的结构体和数组等。这是因为用户空间的栈本身很大，而且还可以动态增长。</p>
<p>而内核栈的准确大小随体系结构而变。内核栈的大小是两页，即32位机内核栈是8KB，而64位机是16KB，这是固定不变的。每个处理器都有自己的栈。</p>
<h3 id="同步和并发"><a href="#同步和并发" class="headerlink" title="同步和并发"></a>同步和并发</h3><p>内核很容器产生竞争条件。和单线程的用户空间程序不同，内核的特性要求能够并发地访问共享数据，这就要求同步机制以保证不出现竞争条件。</p>
<h3 id="可移植性的重要性"><a href="#可移植性的重要性" class="headerlink" title="可移植性的重要性"></a>可移植性的重要性</h3><p>用户空间的成协商不太注意移植问题，然而Linux却是一个可移植的操作系统，并且一直保持这种特点。即，大部分C代码应该与体系结构无关。</p>
<h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2 进程管理"></a>2 进程管理</h2><h3 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1 进程"></a>2.1 进程</h3><p>进程是出于执行期的程序以及相关的资源的总称。存在多个进程执行的是同一个程序，并且多个并存的进程还可以共享地址空间等资源。</p>
<p>线程是在进程中活动的对象。在Linux而言，线程只不过是一种特殊的进程罢了。</p>
<p>在现代操作系统中，进程提供了两种虚拟机制：虚拟处理器和虚拟内存。即多个进程在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器。</p>
<p>Linux中，通常是调用fork()通过复制一个现有的进程来创建一个全新的进程。调用fork()的进程称为父进程，新产生的进程称为子进程。在调用结束时，在返回点这个相同位置上，父进程恢复执行，子进程开始执行。</p>
<p>exec()这组函数可以创建新的地址空间，并把新的程序载入其中。</p>
<p>在linux内核中，fork()实际上是由clone()系统调用实现的。</p>
<p>exit()系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。</p>
<p>父进程可以通过wait4()系统调用查询子进程是否终结。</p>
<h3 id="2-2-进程描述符及任务结构"><a href="#2-2-进程描述符及任务结构" class="headerlink" title="2.2 进程描述符及任务结构"></a>2.2 进程描述符及任务结构</h3><p>内核把进程的列表存放在叫做任务队列的双向循环列表中。链表中的每一项都是类型为task_struct，称为进程描述符的结构，该结构定义在&lt;linux/sched.h&gt;文件中。进程描述符中包含一个具体进程的所有信息。</p>
<p>task_sturct相对比较大。这是由于该结构内包含了内核管理一个进程所需的所有信息。进程描述符中包含的数据能完整地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态等等。</p>
<p>Linux通过slab分配器分配<code>task_struct</code>结构，这样能达到对象复用和缓存着色的目的。由于现在用slab分配器动态生成<code>task_struct</code>，所以只需在栈底或栈顶创建一个新的结构<code>struct thread_info</code>。<code>thread_info</code>头文件在arch\x86\include\asm目录下。</p>
<p>内核通过一个唯一的进程标识值或PID来标识每个进程。PID是一个数，标识为<code>pid_t</code>隐含类型，实际上就是一个int类型。PID的最大值默认设置为32768（short int的最大值），尽管这个值可以增加到到达400万（在&lt;linux/threads.h&gt;中所定义的PID最大值的限制）。内核把每个进程的PID存放在它们各自的进程描述符中。</p>
<p>进程描述符中的state描述了进程的当前状态：</p>
<ul>
<li>运行（TASK_RUNNING）</li>
<li>可中断（TASK_INTERRUPTIBLE）：进程正在睡眠（即它被阻塞）</li>
<li>不可中断（TASK_UNINTERRUPTIBLE）</li>
<li><code>__TASK_TRACED</code>：被其他进程跟踪的进程</li>
<li>停止（<code>__TAS_STOPPED</code>）</li>
</ul>
<p>设置当前进程状态：</p>
<p><code>set_task_state(task, state)</code>函数将制定的进程设置为指定的状态。</p>
<p><code>set_current_state(state)</code>和<code>set_task_state(current, state)</code>含义是等同的。</p>
<p>所有进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。</p>
<p>系统中的每一个进程必有一个父进程，每个进程也可以拥有零个或多个子进程。</p>
<p>每个task_struct都包含一个指向其父进程<code>tast_sturct</code>，叫做parent的指针，还包含一个称为children的子进程链表。</p>
<h3 id="2-3-进程的创建"><a href="#2-3-进程的创建" class="headerlink" title="2.3 进程的创建"></a>2.3 进程的创建</h3><p>首先，fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID和资源的统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。这两个函数组合在一起使用的效果跟其他操作系统使用的单一函数一样。</p>
<p>写时拷贝</p>
<p>传统的fork()系统调用直接把所有的资源复制到新创建的进程。这种实现过于简单并且效率低下。Linux的fork()使用写时拷贝页实现。写时拷贝是一个可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p>
<p>Linux通过clone()系统调用使用fork()。然后又clone()调用do_fork()。<code>do_fork()</code>再调用<code>_do_fork()</code>。</p>
<p><code>_do_fork()</code>完成了创建中的大部分工作，它的定义在kernel/forK.c文件中。该函数调用<code>copy_process()</code>函数，然后让进程开始运行。</p>
<p><code>copy_process()</code>函数完成的工作：</p>
<ul>
<li>调用<code>dup_task_struct()</code>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>，这些值与当前进程的值相同。</li>
<li>检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超过它分配的资源限制。</li>
<li>子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清0或设为初始值。</li>
<li>子进程的状态被设置为TASK_UNITERRUPTIBLE，以保证它不会投入运行。</li>
<li>调用<code>copy_flags()</code>以更新<code>task_sturct</code>的flags成员，表明进程是否拥有超级用户权限的<code>PF_SUPERPRIV</code>标志被清0，表明进程还没被调用exce()函数的<code>PF_FORKNOEXEC</code>标志被设置。</li>
<li>调用<code>alloc_pid()</code>为新进程分配一个有效的PID。</li>
<li>根据创建给clone()的参数标志，<code>copy_process()</code>拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间。</li>
<li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针。</li>
</ul>
<p>除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。由于fork()有了写时拷贝页表现，那么vfork()就彻底没用了。</p>
<h3 id="2-4-线程再Linux中的实现"><a href="#2-4-线程再Linux中的实现" class="headerlink" title="2.4 线程再Linux中的实现"></a>2.4 线程再Linux中的实现</h3><p>线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。</p>
<p>Linux实现线程的机制非常独特。从内核的角度来看，它并没有线程这个概念。Linux把所有的线程当作进程来实现。线程仅仅被视为一个与其他进程共享某些资源的进程，每一个线程都拥有唯一隶属于自己的<code>task_struct</code>，所以在内核中，它看起来就是一个普通的进程。</p>
<p>上述的线程机制与Windoes等系统的实现差异非常大。这些系统在内核提供了专门支持线程的机制。这些系统常常把线程称作轻量级进程。</p>
<p>在其他的系统中，相较于重量级的进程，线程被抽象成为一种耗费较少资源，运行迅速的执行单元。而对于Linux，它只是一种进程间共享资源的手段（Linux的进程本身就够轻量级了）。</p>
<p>创建线程：</p>
<p>线程的创建和普通进程的创建类似，只不过调用clone()的时候需要传递一些参数标志了指向需要共享的资源。</p>
<p>内核线程：</p>
<p>内核线程只能由其他内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在&lt;linux/kthread.h&gt;中申明有接口。于是，从现有内核线程中创建一个新的内核线程的方法如下：</p>
<pre><code>struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),
                       void *data,
                       int node,
                       const char namefmt[], ...);
</code></pre><p>内核线程被创建后，如果不通过调用<code>wake_up_process()</code>明确唤醒它，它不会主动运行。创建一个并让他运行起来，可以通过调用<code>thread_run()</code>来到达，这个函数以宏实现，只是简单的调用<code>kthread_create()</code>和<code>wake_up_process()</code>。</p>
<h3 id="2-5-进程终结"><a href="#2-5-进程终结" class="headerlink" title="2.5 进程终结"></a>2.5 进程终结</h3><p>当进程终结时，内核必须释放它所占有的资源并把这一不幸告知父进程。</p>
<p>进程的终结，该任务大部分要靠<code>do_exit()</code>来完成（定义在kernel/exit.c）。</p>
<p>调用<code>do_exit()</code>之后，线程已经僵死不能再运行，但是系统还保留了它的进程描述符。这样可以让系统有办法在子进程终结后仍能获得它的信息。</p>
<p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父进程，否则这些成为孤儿的进程辉在退出时永远处于僵死状态，白白地消耗内存。</p>
<p>解决办法是给子进程在当前线程组内找一个线程作为父进程，如果不行，就让init做它们的父进程。寻找父进程的的函数<code>find_new_reaper()</code>。</p>
<h2 id="13-虚拟文件系统"><a href="#13-虚拟文件系统" class="headerlink" title="13 虚拟文件系统"></a>13 虚拟文件系统</h2><p>虚拟文件系统，简称VFS，作为内核自系统，为用户空间程序提供了文件和文件系统相关的接口。系统中所有文件系统不但依赖VFS共存，而且依靠VFS系统协同工作。通过虚拟文件系统，程序可以利用标准的Unix系统调用对不同的文件系统，甚至不同介质上的文件系统进行读写操作。</p>
<p>VFS使得用户可以直接使用open(),read()和write()这样的系统调用而无需考虑具体文件系统和实际物理介质。</p>
<p>之所以可以使用这种通用接口对所有类型的文件系统进行操作，是因为内核在它的底层文件系统接口上建立一个抽象层。该抽象层使Linux能够支持各种文件系统，即便是他们在功能和行为上存在很大差别。为了支持多文件系统，VFS提供了一个通用文件系统模型，该模型囊括了人任何文件系统的常用功能集和行为。</p>
<p>VFS抽象层之所能衔接各种各样的文件系统，是因为它定义了所有文件系统都支持的、基本的、概念上的接口和数据结构。</p>
<p>在内核中，除了文件系统本身外，其他部分并不需要了解文件系统的内部细节。比如一个简单的用户空间程序执行如下操作：</p>
<pre><code>ret = write(fd, buf, len);
</code></pre><p>该系统调用将buf指针指向的长度为len字节的数据写入文件描述符fd对应的文件的当前位置。</p>
<p>这个系统调用首先被一个通用系统调用<code>sys_write()</code>处理，<code>sys_write()</code>函数要找到fd所在的文件系统实际给出的是哪个操作，然后再执行该操作。</p>
<p>Unix文件系统：</p>
<p>Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装点（mount point）。</p>
<p>目录属于普通文件，它记录再其目录下的所有文件。</p>
<p>文件相关信息，包括访问控制权限、大小、拥有者、创建事件等信息，有时被称为文件的元数据，被存储再一个单独的数据结构中，该结构被称为索引节点（inode），其实是index node的缩写。</p>
<p>超级快是一种包含文件系统信息的数据结构，包含文件系统的控制信息。</p>
<p>FAT或NTFS这样的非Unix风格的文件系统，需要经过封装，提供一个符合这些概念的界面，才可以在Linux上工作。比如，即使一个文件系统不支持索引节点，它也必须在内存中装配索引节点结构体。</p>
<h3 id="VFS对象及其数据结构"><a href="#VFS对象及其数据结构" class="headerlink" title="VFS对象及其数据结构"></a>VFS对象及其数据结构</h3><p>VFS其实采用的是面向对象的设计思路，使用一组数据结构来代表通用文件对象。这些数据结构类似于对象，因为内核纯粹使用C代码实现，没有直接利用面向对象的语言，所以内核中的数据结构都是用C语言的结构体实现，而这些结构体包含数据的同时也包含操作这些数据的函数指针，其中的操作函数由具体的文件系统实现。</p>
<p>VFS中由4个主要的对象类型：</p>
<ul>
<li>超级快对象：它代表一个具体的已安装文件系统；</li>
<li>索引节点对象：它代表一个具体文件；</li>
<li>目录项对象：它代表一个车目录项，是路径的一个组成部分；</li>
<li>文件对象：它代表有进程打开的文件。</li>
</ul>
<p>因为VFS将目录作为一个文件来处理，所以不存在目录对象。目录项代表的是一个路径中的一部分，它可能包括一个普通文件。目录项不同于目录，但目录却是另一种形式的文件。</p>
<p>每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法：</p>
<ul>
<li><code>super_operations</code>对象，其中包含内核针对特定文件系统所能调用的方法，比如<code>write_inode()</code>和<code>sync_fs()</code>等方法。</li>
<li><code>inode_operations</code>对象，其中包含书内核针对特定文件所能调用的方法，比如create()方法和link()等方法。</li>
<li><code>dentry_operations</code>对象，其中包含内核针对特定目录所能调用的方法，比如<code>d_compare()</code>和<code>d_delete()</code>等方法。</li>
<li><code>file_operations</code>对象，其中包括进程针对已打开文件所能调用的方法，比如read()和write()等方法。</li>
</ul>
<p>操作对象作为一个结构体实现指针来实现，此结构体中包含指向操作其父对象的函数指针。对于其中许多方法来说，可以继承使用VFS提供的通用函数，如果通用函数提供的基本功能无法满足需要，那么就必须使用实际文件系统的独有方法填充这些函数指针，使其指向文件系统实例。</p>
<p>VFS使用了大量的结构体对象，远不止上面四种主要的对象。比如，每个注册的文件系统都由<code>file_system_type</code>结构体来表示，它描述了文件系统及其性能；另外，每一个安装点也都用vfsmount结构体表示，它包含的是安装点的相关信息，比如位置和安装标志等。</p>
<p><code>fs_struct</code>结构体和file结构体分别描述了文件系统以及和进程相关的文件。</p>
<p>超级块对象由<code>super_block</code>结构体表示，在文件&lt;linux/fs.h&gt;中，创建、管理和撤销超级块对象的代码文娱文件fs/super.c中。超级块对象通过调用<code>alloc_super()</code>函数创建并初始化。在文件系统安装时，文件系统会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中。</p>
<p>超级块对象中最重要的一个域是<code>s_op</code>，它指向超级块的操作函数表。超级块函数表由<code>super_operations</code>结构体表示，定义在&lt;linux/fs.h&gt;中。该结构体中的每一项都是一个指向超级块操作函数的指针，超级块操作函数执行文件系统和索引节点的底层操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/05/20/STL学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/STL学习/" itemprop="url">标准模板库STL</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T22:28:50+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/05/20/STL学习/" class="leancloud_visitors" data-flag-title="标准模板库STL">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h2 id="STL概论"><a href="#STL概论" class="headerlink" title="STL概论"></a>STL概论</h2><p>C++ Standard Library (C++标准库)：可以看到所有的源代码</p>
<p>Standard Template Libraay(STL 标准模板库)</p>
<p>标准库包含标准模板库，标准模板库包含六大部件。</p>
<p>STL是为了建立数据结构和算法的一套标准，并且降低其间的耦合关系以及提升各自的独立性、弹性、交互操作性而诞生的。</p>
<p>STL是依据泛型思维架设起来的一个概念结构。</p>
<p>STL六大组件功能与运用：</p>
<ul>
<li>容器(containers)：各种数据结构：vector、list、map、deque、set</li>
<li>算法(algorithms)：各种常用算法：sort、search、copy、erase</li>
<li>迭代器(iterators)：扮演容器和算法之间的桥梁</li>
<li>仿函式(functors)：行为类似函数，可做算法的某种策略</li>
<li>配接器(adapters)：一种用来修饰容器或仿函式或迭代器接口的东西</li>
<li>配置器(allocators)：负责空间配置和管理</li>
</ul>
<p><img src="https://i.imgur.com/8n0rfmV.png" alt=""></p>
<p>STL是一种模板编程。跟面对对象思想有些不同，STL将数据放在类中，而将函数独立出来。</p>
<p>分配器支持容器，容器是一个模板类，有些操作再容器中完成，有些独立出来成为一个个函数，组成了算法。迭代器就一种泛化的指针。仿函数作用类似于函数，类对象的相加相减都是通过仿函数实现。适配器转换一些东西。比如将容器进行转换，对仿函数进行转换，对迭代器进行转换。</p>
<p>六大组件使用实例：</p>
<pre><code>#include &lt;vector&gt;
...
int ia[6] = {11,22,33,44,53,61};
vector&lt;int, allocator&lt;int&gt; &gt; vi(ia, ia+6);
cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40)));//条件小于40的元素个数
</code></pre><p>vector是容器，allocator<int>是分配器，存在默认值。注意容器类型和分配器的类型必须相配。</int></p>
<p>count_if是一个函数（算法），计算符合给定条件的元素个数；算法操作的元素范围由迭代器指定，vi.begin()和vi.end()是迭代器。每个元素跟40比较，less是一个仿函数，即小于；bind2nd是一个适配器，绑定第二参数，即将less的第二个参数绑定为40；not1表示否定的意思，即大于等于40。 not1(bind2nd(less<int>(), 40))表示判断大于等于40的条件式。</int></p>
<p><img src="https://i.imgur.com/o5j1FJO.png" alt=""></p>
<p>算法已经固定，没有可选的。而容器不同，可以根据实际情况，数据情况和分布，来选择适合的容器。说到容器和算法就要提到复杂度（complexity, Big-oh）。</p>
<ul>
<li>常数时间o(1)或o(c)</li>
<li>线性时间o(n)</li>
<li>指数时间o(2^n)<br>等等。</li>
</ul>
<h3 id="STL版本："><a href="#STL版本：" class="headerlink" title="STL版本："></a>STL版本：</h3><p>GNU（GNU is not Unix）宣言来反对封锁源码。GNU以GPL(广泛开放授权)来保护其成员：使用者可以自由阅读和修改GPL软件的源码，但如果使用者要传布借助GPL软件而完成的软件，他们必须也同意GPL规范。</p>
<ul>
<li>HP版本的STL:允许任何人免费使用、拷贝、修改、传布、贩卖这份软件及其说明文件，并不属于GNU GPL范畴。</li>
<li>PJ版本的STL，继承自HP版本，不属于open source范畴，更不属于GNU GPL。因为HP的版本声明并发GPL，并没有强迫其衍生产品必须开放源码。PJ版本被Visual采用，所以可以在visualc++的“include”子目录下找到所有STL头文件，但是不能公开或修改它。</li>
<li>RW(Rouge Wave)版本的STL(RW STL)同样继承了HP版本，也不属于open source范畴，更不是GNU GPL。RW STL被C++ Builder采用，所以在C++Builder的“include”子目录下找到所有的STL头文件。</li>
<li>STLport</li>
<li>SGI STL继承了HP版本，SGI版本被GCC采用，可以在GCC的“include”子目录下找到所有的STL头文件，并且获准自由公开它或修改它甚至贩卖它。<strong>与前面所有版本相比，这个版本的可读性非常高。</strong></li>
</ul>
<h3 id="GNU-c-headers文件分布："><a href="#GNU-c-headers文件分布：" class="headerlink" title="GNU c++headers文件分布："></a>GNU c++headers文件分布：</h3><ul>
<li>C++标准规范下的C头文件（无扩展名），例如cstdio, cstirng</li>
<li>C++标准链接库中不属于STL范畴者，例如，string,stream等</li>
<li>STL标准头文件（无扩展名），例如vector,deque,list,map,algorithm,functional</li>
<li>C++ standard定案前，HP所规范的STL头文件，例如vector.h,deque.h,list.h,map.h,function.h</li>
<li>SGI STL内部文件（STL起作用的部分），例如stl_vector, stl _deque.h,stl _list.h,stl _map.h等</li>
</ul>
<p>SGI STL准备了一个环境组态文件&lt;stl_config.h&gt;，其中定义许多常数，表示某些状态的成立与否。所有STL头文件都会直接或间接含入这个组态文件，并以条件式写法，让前处理器根据各个常数决定取舍哪一段程序码。</p>
<p>所有新式的headers内的组件被封装到namespace std。C中旧式头文件（带.h）不被封装到namespace std。</p>
<h3 id="令人困惑的C-语法"><a href="#令人困惑的C-语法" class="headerlink" title="令人困惑的C++语法"></a>令人困惑的C++语法</h3><p>暂时（临时）对象，就是一种无名的对象。例如，int(8)，其意义相当于使用响应的构造函数生成对象且不指定对象的名称。</p>
<p>静态常数整数成员在class内部直接初始化</p>
<pre><code>class testClass
{
public:
    static cosnt int  _datai = 5;
    static const long _datal = 3L;
    static const char _datac = &apos;c&apos;;
};
</code></pre><p>静态类成员，需要在类外部初始化：</p>
<pre><code>class testClass
{
    static int _datai;
};

testClass::_datai = 3;
</code></pre><p>而且对于静态类成员，所有对象都共享一种静态类成员。</p>
<h4 id="前闭后开区间表示法"><a href="#前闭后开区间表示法" class="headerlink" title="前闭后开区间表示法[)"></a>前闭后开区间表示法[)</h4><p>任何一个STL算法，都需要获得一对迭代器所标示的区间，用以表示操作范围。这一对迭代器所表示的是个所谓的前闭后开区间，以[begin, end)表示，即，整个实际范围从begin开始，直到end-1。迭代器end所指的是最后一个元素的下一个位置。</p>
<p>注意，容器不一定是连续空间，比如链表，树等。</p>
<p><img src="https://i.imgur.com/djeYwXH.png" alt=""></p>
<p>定义迭代器：vector<int>::iterator ite = c.being();所有指针的操作，都可以使用到迭代器上，比如++，–, *，-&gt;等。</int></p>
<p>c++11中基于范围的for循环：</p>
<pre><code>for (int i: {2,3,4,5,6,7})
    std::cout &lt;&lt; i &lt;&lt; std::endl;

std::vector&lt;double&gt; vec;
...
for(auto elem: vec)
    std::cout &lt;&lt; elem &lt;&lt; std::endl;
for (auto&amp; elem : vec) //如果不使用引用，值将不会变
    elem *= 3;
</code></pre><p>auto:</p>
<pre><code>list&lt;string&gt; c;
    ....
lsit&lt;string&gt;::iterator ite;
ite = ::find(c.begin(), c.end(), target);

//使用auto
list&lt;string&gt; c;
    ...
auto ite = ::find(c.begin, c.end, targe);
</code></pre><h4 id="function-call运算子"><a href="#function-call运算子" class="headerlink" title="function call运算子"></a>function call运算子</h4><p>函数呼叫动作也可以被多载化。许多STL算法提供两个版本，一个用于一般请情况，例如排序时以递增方式排列；一个用于特殊状况，例如排序时有使用者指定以何种特殊关系进行排序。</p>
<p>像这种情况，需要使用者指定某个条件或某个策略，而条件或策略的背后由一整组动作构成，便需要某种特殊的东西来代表这一整组动作。代表这一整组动作的当然是函数。过去，C语言时代，欲将函数当作参数传递，唯有通过函数指针才能达成。但是函数指针优缺点，最重要的是它无法持有自己的状态（所谓区域状态），无法再将某些修饰条件加诸于其上而改变其状态。</p>
<p>为此，STL算法的特殊版本所接收的所谓条件或策略或一整组动作，都以仿函数形式呈现。所谓仿函数（functor）就是使用起来像函数一样的东西。如果你针对某个类进行operator()多载化，它就成为了一个仿函数。</p>
<h2 id="空间配置器allocator"><a href="#空间配置器allocator" class="headerlink" title="空间配置器allocator"></a>空间配置器allocator</h2><p>整个STL的操作对象都存放在容器之内，而容器一定需要配置空间以置放数据。</p>
<p>alocator是空间配置器而不是内存配置器。因为，空间不一定是内存，空间也可以是磁盘或其他辅助存储媒体。例如，可以写一个allocatro直接向磁盘取空间。</p>
<h3 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h3><h3 id="具备次配置力-sub-allocation-的SGI空间配置器"><a href="#具备次配置力-sub-allocation-的SGI空间配置器" class="headerlink" title="具备次配置力(sub-allocation)的SGI空间配置器"></a>具备次配置力(sub-allocation)的SGI空间配置器</h3><p>SGI STL的配置器与众不同，也与标准规范不同，其名称为alloc而非allocator。</p>
<p>不能采用标准的写法：</p>
<pre><code>vector&lt;int, std::allocator&lt;int&gt;&gt; iv; //in VC or CB
</code></pre><p>必须这么写：</p>
<pre><code>vector&lt;int, std::alloc&gt; iv; //in GCC
</code></pre><p>但是SGI STL的每一个容器都已经指定其预设的空间配置器alloc。例如下面的vector声明：</p>
<pre><code>template&lt;class T, classAlloc = alloc&gt; //预设使用alloc为配置器
class vector {...};
</code></pre><h4 id="SGI标准的空间配置器std-allocator"><a href="#SGI标准的空间配置器std-allocator" class="headerlink" title="SGI标准的空间配置器std::allocator"></a>SGI标准的空间配置器std::allocator</h4><p>虽然SGI也定义有一个符合部分标准、名为allocator的配置器，但SGI自己从未使用过它，也不建议使用。主要原因是效率太差，只把C++的::operator new和::operator delete做一层薄薄的包装而已。。</p>
<h4 id="SGI特殊的空间配置器std-alloc"><a href="#SGI特殊的空间配置器std-alloc" class="headerlink" title="SGI特殊的空间配置器std::alloc"></a>SGI特殊的空间配置器std::alloc</h4><p>前面所讲的allocator只是基层内存配置/释放行为（也就是说::operator new和::operator delete）的一层薄薄包装，并没有考虑任何效率上的强化。</p>
<p>一般而言，C++内存配置和释放动作是这样：</p>
<pre><code>class Foo{...};
Foo * pf = new Foo;
delete pf;
</code></pre><p>这其中的new算式内含两阶段动作：调用::operator new配置内存； 调用Foo::Foo()构建对象内容。delete算式也内含两阶段动作：调用Foo::~FOO()将对象析构；调用::operator delete释放内存。</p>
<p>为了精密分工，STL allocator决定将这两阶段动作区分开来。内存配置动作由alloc::alllocate()负责，内存释放动作由alloc::deallocate()负责；对象构造动作由::construct()负责，对象析构动作由::destroy()负责。</p>
<p>STL标准规格告诉我们，配置器定义于<memory>之中，SGI<memeory>内含一下两个文件：</memeory></memory></p>
<pre><code>#include&lt;stl_alloc.h&gt; //负责内存空间的配置和释放
#include&lt;stl_construct.h&gt; //负责对象内容的构造和析构
</code></pre><p> <img src="https://i.imgur.com/mT8eu7w.png" alt=""></p>
<h2 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h2><p>STL的中心思想在于，将数据容器和算法分开，彼此独立设计，最后再以一帖胶着剂将他们撮合在一起。容器和算法的泛型并不困难，C++的类模板和函数模板课分别达成目标。设计两者之间的胶着剂才是难题。</p>
<h3 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h3><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见的也最重要的就是解除引用(dereference)和成员提取（member access）。因此迭代器最重要的编程工作就是对operator *和operator-&gt;进行重载。</p>
<h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><ul>
<li>序列式容器： 固定数组Array, 可变数组Vector, 双队列Deque， 双向链表List， 单向链表Forward-List。 </li>
</ul>
<p>分配器负责vector的自动扩充。</p>
<ul>
<li>关联式容器： Set:红黑树, Map  ;适用于需要大量查找的数据结构</li>
</ul>
<p>红黑树一种特殊的二叉树，高度平横的二叉树，左右差不多，自动完成。并没有要求使用哪个</p>
<ul>
<li>不定序容器：就是一种关联式容器 </li>
</ul>
<p>lsit使用示例：</p>
<pre><code>namespace STL_List{
    woid test_list(long value)
    {
        list&lt;string&gt; c;
        char buf[10];
        for (long i = 0; i &lt; value; i++)
        {
            try{
                snprintf(buf, 10, &quot;%d&quot;, rand());
                c.push_back(string(buf));
            }
            catch(exception &amp;p)
            {
                cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p.what() &lt;&lt; endl;
                abort();
             }
        }
        cout &lt;&lt; &quot;list.size()=&quot; &lt;&lt; c.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;list.max_size()&quot; &lt;&lt; c.max_size() &lt;&lt; endl;
        cout &lt;&lt; &quot;list.front()&quot;  &lt;&lt; c.front() &lt;&lt; endl;
        cout &lt;&lt; &quot;list.back()&quot; &lt;&lt; c.back() &lt;&lt; endl;

        string target = c[value/2];
        auto pItem = find(c.begin(), c.end(), target); //查找
        if (pItem != c.end())
            cout &lt;&lt; &quot;found, &quot; &lt;&lt; *pItem &lt;&lt; endl;;
        else
            cout &lt;&lt; &quot;not found&quot; &lt;&lt; endl; 

        c.sort();  //list自带sort，所以使用自带的sort，而不使用全局sort

    }

}
</code></pre><p>froward_list使用示例：</p>
<pre><code>namespace STL_forward_list{
    void test_forward_list(long value)
    {
        forward_list&lt;string&gt; c;
        char buf[10];
        for (long i = 0; i &lt; value; i++)
        try{
                snprintf(buf, 10, &quot;%d&quot;, rand());
                c.push_front(string(buf));  //注意单向链表没有push_back
            }
            catch(exception &amp;p)
            {
                cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p.what() &lt;&lt; endl;
                abort();
             }

        //cout &lt;&lt; &quot;forward_list.size()=&quot; &lt;&lt; c.size() &lt;&lt; endl;  //不提供
        cout &lt;&lt; &quot;forward_list.max_size()&quot; &lt;&lt; c.max_size() &lt;&lt; endl; 
        //cout &lt;&lt; &quot;forward_list.front()&quot;  &lt;&lt; c.front() &lt;&lt; endl;  
        cout &lt;&lt; &quot;forward_list.back()&quot; &lt;&lt; c.back() &lt;&lt; endl;  //不提供back()

        string target = c[value/2];
        auto pItem = find(c.begin(), c.end(), target); //查找
        if (pItem != c.end())
            cout &lt;&lt; &quot;found, &quot; &lt;&lt; *pItem &lt;&lt; endl;;
        else
            cout &lt;&lt; &quot;not found&quot; &lt;&lt; endl; 

        c.sort();  //排序

    }
}
</code></pre><p>slist使用示例：</p>
<p>slist是GNU g++自带的，是一种非标准的。</p>
<p>用法跟forward_list相同。</p>
<p><img src="https://i.imgur.com/5aYs6Lj.png" alt=""></p>
<p>deque使用示例：</p>
<p>deque是分段连续的，但是对用户来说是完全连续的。如果空间不足，deque在两端都可以扩充一个buffer，这样就实现了双向队列。</p>
<p><img src="https://i.imgur.com/u82baSj.png" alt=""></p>
<pre><code>namespace STL_deque
{
    void test_deque(long value)
    {
        deque&lt;string&gt; c;
        char buf[10];
        for (long i = 0; i &lt; value; i++)
            {
                try{
                    snprintf(buf, 10, &quot;%d&quot;, rand());
                    c.push_back(string(buf));
                }
                catch(exception &amp;p)
                {
                    cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p.what() &lt;&lt; endl;
                    abort();
                 }
            }

        cout &lt;&lt; &quot;deque.size()=&quot; &lt;&lt; c.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;deque.max_size()&quot; &lt;&lt; c.max_size() &lt;&lt; endl;
        cout &lt;&lt; &quot;deque.front()&quot;  &lt;&lt; c.front() &lt;&lt; endl;
        cout &lt;&lt; &quot;deque.back()&quot; &lt;&lt; c.back() &lt;&lt; endl;

        string target = c[value/2];
        auto pItem = find(c.begin(), c.end(), target); //查找
        if (pItem != c.end())
            cout &lt;&lt; &quot;found, &quot; &lt;&lt; *pItem &lt;&lt; endl;;
        else
            cout &lt;&lt; &quot;not found&quot; &lt;&lt; endl; 

        sort(c.begin(), c.end());  //deque不自带排序函数，所以需要调用全局的sort
    }
}
</code></pre><p>stack使用示例:</p>
<p><img src="https://i.imgur.com/7u4ols8.png" alt=""></p>
<p>一个deque涵盖了stack的功能，stack内部使用deque实现。</p>
<pre><code>namespace STL_stack
{
    void test_stack(long value)
    {
        stack&lt;string&gt; c;
        char buf[10];
        for (long i = 0; i &lt; value; i++)
            {
                try{
                    snprintf(buf, 10, &quot;%d&quot;, rand());
                    c.push(string(buf));
                }
                catch(exception &amp;p)
                {
                    cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p.what() &lt;&lt; endl;
                    abort();
                 }
            }

        cout &lt;&lt; &quot;stack.size()=&quot; &lt;&lt; c.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;stack.top()&quot; &lt;&lt; c.top() &lt;&lt; endl;
        c.pop();
        cout &lt;&lt; &quot;stack.size()&quot;  &lt;&lt;  &lt;&lt; endl;
        cout &lt;&lt; &quot;stack.top()&quot; &lt;&lt; c.top() &lt;&lt; endl;
    }
}
</code></pre><p>queue使用示例：</p>
<p><img src="https://i.imgur.com/yi0GvGY.png" alt=""></p>
<p>一个deque涵盖了queue的功能，queue内部使用deque实现。</p>
<pre><code>namespace STL_queue
{
    void test_queue(long value)
    {
        queue&lt;string&gt; c;
        char buf[10];
        for (long i = 0; i &lt; value; i++)
            {
                try{
                    snprintf(buf, 10, &quot;%d&quot;, rand());
                    c.push(string(buf));
                }
                catch(exception &amp;p)
                {
                    cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p.what() &lt;&lt; endl;
                    abort();
                 }
            }

        cout &lt;&lt; &quot;queue.size()=&quot; &lt;&lt; c.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;queue.front()&quot; &lt;&lt; c.front() &lt;&lt; endl;
        cout &lt;&lt; &quot;queue.back()&quot; &lt;&lt; c.back() &lt;&lt; endl;
        c.pop();
        cout &lt;&lt; &quot;queue.size()&quot;  &lt;&lt;  &lt;&lt; endl;
        cout &lt;&lt; &quot;queue.front()&quot; &lt;&lt; c.front() &lt;&lt; endl;
        cout &lt;&lt; &quot;queue.back()&quot; &lt;&lt; c.back() &lt;&lt; endl;

    }
}
</code></pre><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>这里仅仅适用于GNU C编译器。</p>
<p><img src="https://i.imgur.com/dcMvf1W.png" alt=""></p>
<p>默认都是使用std::allocator分配器。</p>
<p>其他分配器使用方法（仅适用于GNU C）：</p>
<p><img src="https://i.imgur.com/ZeUNAi7.png" alt=""></p>
<p>以上都是在在容器上使用分配器来分配内存。也可以单独使用分配器，但是没有必要。</p>
<pre><code>int *p;
allocator&lt;int&gt; alloc1;
p = alloc1.allocate(1); //1表示分配一个int元素
alloc1.deallocate(p,1); //释放内存，1表示释放内存的大小

__gnu_cxx::malloc_allocator&lt;int&gt; alloc2;
p = alloc2.allocate(1);
alloc2.deallocate(p,1);
</code></pre><p>一般使用new，delete或malloc或free。new和delete最终也是调用malloc和free。</p>
<p>malloc分配内存，使用free释放内存时，不需要告诉free需要释放的内存大小。而分配器释放内存时，需要告知其需要释放的内存大小，这样太麻烦。</p>
<h2 id="体系结构与内核分析"><a href="#体系结构与内核分析" class="headerlink" title="体系结构与内核分析"></a>体系结构与内核分析</h2><p>源码之前，了无秘密</p>
<p>GNU C 2.9</p>
<p>标准库主要使泛型编程（Generic Programming, GP）实现的。</p>
<p>OOP概念：将datas和methods关联在一起</p>
<pre><code>template &lt;class T, class Alloc = alloc&gt;
class list{
    ...
    void sort();
};
</code></pre><p>list内部定义了一个sort函数，而不是用全局的sort函数。</p>
<p><img src="https://i.imgur.com/ZNzJ5BI.png" alt=""></p>
<p>list所具备的迭代器，只能逐个访问，而不能向vector等其他容器一样直接进行跳转。全局sort需要的迭代器要满足一定的条件：迭代器是可以连续访问的，而list无法满足，list是双向链表，在内存中存储是不连续的。所以需要定义私有的sort函数。</p>
<p>GP概念：将datas和methods分开来</p>
<p>数据结构（容器）:</p>
<pre><code>template&lt;class T, class Alloc = alloc&gt;
class vector{
...
};
</code></pre><p>中间通过迭代器将容器和算法连起来。</p>
<pre><code>sort(c.being(),c.end());
</code></pre><p>算法：</p>
<pre><code>template&lt;typename _RandomAccessIterator&gt;
inline void
sort(_RandomAccessIterator __first,
        _RandomAccessIterator __last)
{
    ...
}
</code></pre><p>min和max的源代码：</p>
<pre><code>template&lt;class T&gt;
inline const T &amp; min(const T &amp; a, const T &amp;  b){
    return b &lt; a ? b:a;
}

template&lt;class T&gt;
inline const T &amp; max(cosnt T &amp; a, const T &amp; b){
    return a &lt; b ? b:a;
}
</code></pre><p>所有算法，其实最终涉及元素本身的操作，无非就是比大小。</p>
<pre><code>bool strLonger(const string &amp; s1, const string &amp; s2)
{ return s1.size() &gt; s2.size(); }

cout &lt;&lt; &quot;max of zoo and hello: &quot; &lt;&lt; max(string(&quot;zoo&quot;), string(&quot;hello&quot;)) &lt;&lt; endl; //zoo
cout &lt;&lt; &quot;max of zoo and hello: &quot; &lt;&lt; max(string(&quot;zoo&quot;), string(&quot;hello&quot;), strLonger) &lt;&lt; endl; //hello

template&lt;class T&gt;
inline const T &amp; max(const T &amp; a, const T &amp; b)
{ return a &gt; b ? a : b; }

template&lt;class T, class Compare&gt;
inline const T &amp; max(const T &amp; a, const T &amp; b, Compare comp)
{ return comp(a, b) ? a : b; }
</code></pre><p>模板：</p>
<ul>
<li>类模板</li>
<li>函数模板</li>
<li>成员模板：比较复杂</li>
</ul>
<p>泛化与特化：</p>
<p>对于一类问题，提供一种泛化的做法，但是对于某些特定的问题，有更优的做法，所以特定为其再定义一种做法。</p>
<p><img src="https://i.imgur.com/HfCnlFQ.png" alt=""></p>
<p>template&lt;&gt;的出现，就表示特化。</p>
<p><img src="https://i.imgur.com/blTyLj2.png" alt=""></p>
<p>特化（全特化），偏特化（局部特化）</p>
<p><img src="https://i.imgur.com/GUDOeEX.png" alt=""></p>
<p>其中类型具体化位bool，但是分配器还是模板参数。</p>
<p>左侧是个数的偏特化。</p>
<p>右侧是范围的偏特化，第一种偏特化是指向一个任意类型的指针，第二种偏特化是指向一个常量指针。</p>
<h3 id="分配器allocators"><a href="#分配器allocators" class="headerlink" title="分配器allocators"></a>分配器allocators</h3><p>operator new()和malloc()</p>
<p><img src="https://i.imgur.com/4wvYbhI.png" alt=""></p>
<p>operator new()会调用malloc()，malloc所申请的内存比你提供的size大，需要附加一些内容（开销）。小块内存，开销比例大，大块内存，开销比例小。</p>
<ul>
<li>VC版本：</li>
</ul>
<p><img src="https://i.imgur.com/8AjRbsM.png" alt=""></p>
<p>申请512的内存：</p>
<pre><code>int *p = allocator&lt;int&gt;().allocate(512, (int*)0); //allocator&lt;int&gt;() 创建一个临时对象，没有名称
allocator&lt;int&gt;().deallocate(p, 512); //释放内存
</code></pre><p>分配器最终调用malloc和free申请和释放内存。</p>
<ul>
<li>BC5版本</li>
</ul>
<p><img src="https://i.imgur.com/Vmta3PO.png" alt=""></p>
<p>申请512内存：</p>
<pre><code>int *p = allocator&lt;int&gt;().allocate(512);
allocator&lt;int&gt;().deallocate(p,512);
</code></pre><ul>
<li>GNU C2.9版本</li>
</ul>
<p><img src="https://i.imgur.com/rZDymea.png" alt=""></p>
<p>三者都是一样，使用malloc和free来申请和释放内存，这样会带来很大的开销，因为每申请一个内存需要附带一些内容，而申请的内存都比较小，会导致附带的开销比例大，不能接收。</p>
<p>GNU C上述标准分配器没有被使用到任何容器中。而是使用别的分配器alloc。</p>
<p><img src="https://i.imgur.com/Zduzw3S.png" alt=""></p>
<p>具体形式如下：</p>
<p><img src="https://i.imgur.com/rUBbzqR.png" alt=""></p>
<p>alloc尽量减少调用malloc的次数，这样可以降低额外开销。malloc每次申请时，需要在内存中记录申请的内存块大小。容器中的元素大小是一样的，所以没必要每次申请都记录内存块大小，不要cookies。</p>
<p>alloc设计了16条链表，每条链表负责某一种特定大小的内存块，用链表串起来。</p>
<p>0号链表负责8字节的大小，7号链表负责64个字节的大小，15号链表负责128个字节的内存大小。</p>
<p>所有的容器当它需要内存的时候，容器元素的大小会调整到8的倍数，如50调整到56，然后在链表中查找。找到对应编号的链表。如果链表中挂有内存，则直接使用。如果没有，再跟操作系统malloc要一大块来做切割，然后用链表串起来。其中每一块不用记录内存块大小，即不要带cookies。注意，每次用malloc去申请一大块内存时，还是需要cookies，只是每一个小块不需要。</p>
<p>比如，如果容器申请100 0000个元素，则可以省掉800 0000个字节，这只是一个概念上的估计，实际上大块内存需要附带记录信息cookies。</p>
<ul>
<li>GNU C4.9版本</li>
</ul>
<p>4.9版不再使用分配器alloc，而是使用allocator。</p>
<p><img src="https://i.imgur.com/A2V4kSc.png" alt=""></p>
<p>这种没有特殊设计，没有使用优化的alloc。但是alloc还在，只是更改了名字<code>__pool_alloc</code>。</p>
<p><img src="https://i.imgur.com/7wIs9CV.png" alt=""></p>
<p>使用方法： </p>
<pre><code>vector&lt;string, __gnu_cxx::__pool_alloc&lt;string&gt; &gt; vec; 
</code></pre><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><img src="https://i.imgur.com/WyLgOgE.png" alt=""></p>
<p>容器之间没有继承关系。</p>
<p>heap是一个特殊的容器，heap里面有一个vector做底部支撑。</p>
<p>rb_tree是红黑树。set里面有一个红黑树做底部的支撑。</p>
<p>sizeof()表示控制一个容器的所需的大小。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><img src="https://i.imgur.com/ytXA96s.png" alt=""></p>
<p>list_node是一个节点，node就是一个指向节点的指针。list _node中的指针指向void，后面需要进行转型，2.9版就是如此，但是4.9中进行了改善。放入1000个元素，所耗费的内存，不仅仅是1000个元素的大小，因为每个元素还要包括两个指针的大小。</p>
<p>除了vector和array外，所有的容器有一个iterator类。list中，iterator类：对应<code>__list_iterator</code></p>
<p>iterator类里面有大量的操作符重载，iterator模拟指针，实现指针的各种操作。</p>
<p><img src="https://i.imgur.com/kJpqeJx.png" alt=""></p>
<p>所有的迭代器开始有一堆的typedef(至少5个)，然后一堆function实现操作符重载。</p>
<p>list中迭代器的++实现：iterator中有两个++，一个带参数一个不带参数。</p>
<p>为了区分前++和后++，前++没有参数，后++带参数，但是参数没有意义，只是形式上的。</p>
<p>前++的实现：</p>
<pre><code>node = (link_type)((*node).next);
return *this;
</code></pre><p>后++的实现：</p>
<p>后++需要把原来的内容记录下来，然后再++。比如： a = i++，首先将原值记录，进行前++操作，然后将原值返回给a。</p>
<pre><code>self tmp = *this;  //记录原值
++*this;           //进行操作
returm tmp;        //原值返回
</code></pre><p><img src="https://i.imgur.com/LIrHFZG.png" alt=""></p>
<p>$\ast$this不会调用<code>operator*()</code>，在<code>*</code>之前有一个等于号，表示调用拷贝构造函数，所以<code>*this</code>变成了拷贝构造函数的参数。</p>
<p>还需要注意，前++和后++重载函数的返回值。前++的返回值是self &amp;，而后++的返回值为self。</p>
<pre><code>int i(6);
+++++i; -&gt; (++)++i;  //这是允许的
i+++++; -&gt; (i++)++; //这是不允许的，不准后加加两次
</code></pre><p>所以后++的返回值是self，没有引用，这样就不允许后++两次。而前++允许两次，所以前++的返回值为self &amp;。</p>
<p>解引用，即提取值。包括两种操作：*和-&gt;</p>
<p><img src="https://i.imgur.com/9G6tbBw.png" alt=""></p>
<p>list容器的迭代器使用实例：</p>
<pre><code>list&lt;Foo&gt;::iterator ite;
*ite; //获得一个Foo对象
ite-&gt;method();
</code></pre><p>2.9版和4.9版对比：</p>
<p><img src="https://i.imgur.com/5Jw7QaT.png" alt=""></p>
<p>4.9版本对2.9版本进行了改进，迭代器类中模板传递的类型有3个变成了1个，原来是T，T&amp;和T*，4.9版本变成了一个T，然后在迭代器类中实现了T&amp;，T$\ast$。</p>
<p>还有一个点在2.9中，节点的设计开始是void类型的指针，而在4.9版本中，节点中的指针的类型是节点本身。</p>
<p>4.9版本中，list继承了<code>_List_base</code>父类，父类内含<code>_List_impl</code>类，….</p>
<p>而在2.9版本中，只有一个类list。</p>
<p>2.9版中只有一个指针，而4.9版本中有两个指针。</p>
<p><img src="https://i.imgur.com/vRizhOP.png" alt=""></p>
<p>Iterator需要遵循的原则：</p>
<p>rotate函数调用<code>__rotate</code>函数。</p>
<p>iterator_category:表示迭代器的移动性质，有些迭代器只能向前移动，有些迭代器可以先后移动，有些迭代器只能移动一步，有些迭代器可以跳着走，一次条多步。</p>
<p>iterator的value_type: iterator所指的元素类型</p>
<p>iteartor的difference_type:两个iterator之间的距离，用什么类型表示，比如unsigned int的距离不超过2^32，如果一个迭代器的范围不超过2^32，就可以用unsinged int来表示两iterator之间的距离。</p>
<p><img src="https://i.imgur.com/K1p13tR.png" alt=""></p>
<p>算法提出问题，迭代器能够回答问题。图中提出了3个问题。一共有5种问题。其中还有reference和pointer，但是在所有算法中从来没有使用过。</p>
<p>Iterator一定需要写出来的5个assocated types:</p>
<p><img src="https://i.imgur.com/JZTRbwL.png" alt=""></p>
<p>算法中提问的方式：</p>
<pre><code>I::iterator_category;
I::pointer;
...
</code></pre><p>iterator中必须声明出5个associated types。对于difference_type，Iterator直接使用的某个文件中的<code>ptrdiff_t</code>。<code>bidirectional_iterator_tag</code>表示双向。</p>
<p>如果iterator并不是class类？只有class可以做typedef。可以使用指针，指针是一个中退化的iterator。在调用算法是可能传入的是一个指针，而不是迭代器iterator。这个时候算法提问，获取某些属性，就无法成功。</p>
<p>这个时候需要Traits。</p>
<p>Traits能够区分class形式的iterator和普通指针。</p>
<p><img src="https://i.imgur.com/pUULLlS.png" alt=""></p>
<p>trats的具体做法：</p>
<p><img src="https://i.imgur.com/bDel2pd.png" alt=""></p>
<p>算法想要直到I的5种相关类型，算法向<code>iterator_traits</code>提问，<code>iterator_traits</code>转问I。设置一个中间层<code>iterator_traits</code>，如果传入的是指针，调用分出的两种偏特化。如果是class iterator，则会进入<code>iterator_traits</code>。</p>
<p>不是采用直接的问法，而是间接的：</p>
<pre><code>typename iterator_traits&lt;I&gt;::value_type v1;
</code></pre><p>完整的iterator_traits：</p>
<p><img src="https://i.imgur.com/e3NhvJi.png" alt=""></p>
<p>各式各样的Traits:</p>
<ul>
<li>type traits</li>
<li>iterator traits</li>
<li>char traits</li>
<li>allocator traits</li>
<li>pointer traits</li>
<li>array traits</li>
</ul>
<h3 id="容器vector"><a href="#容器vector" class="headerlink" title="容器vector"></a>容器vector</h3><p>vector中有3个指针：start指向开头，finish表示存储元素的结尾，<code>end_of_storage</code>表示容器的结尾。</p>
<p><img src="https://i.imgur.com/5FVTJ6L.png" alt=""></p>
<p>如果存储的元素个数超过capacity，vector需要在内存中找一个块两倍的空间。</p>
<p>GNU C 2.9版本中，vector使用默认的分配器alloc。vector的大小实际是3个指针的大小(12字节)：start,finish,<code>end_of_storage</code>。</p>
<p>vector提供begin()和end()两个函数，以及size()函数，capacity()函数，empty()函数，operator[]重载，front()函数和back()函数。</p>
<p>提供连续空间的容器，都会提供operator[]重载。</p>
<p>二倍增长的过程：</p>
<p><img src="https://i.imgur.com/6w1P7tN.png" alt=""></p>
<p><code>push_back()</code>向容器末尾添加元素。首先，通过finish和<code>end_of_storage</code>判断是否有足够的空间存放元素，如果有直接添加即可。如果没有，调用<code>insert_aus</code>辅助函数。<code>insert_aus</code>再做一次检查，主要原因是其他函数也调用它，所以需要做检查。</p>
<p>如果没有空间存储元素，则执行下面的代码：</p>
<p><img src="https://i.imgur.com/cLnpSRz.png" alt=""></p>
<p>首先判断原来的vector大小，如果开始是0，就分配一个元素大小的空间。如果不等于是，则直接是原来的两倍。然后是绿色allocate()分配内存。分配足够空间后，在try模块中，将原来的vector内容拷贝到新vector中，为新的元素设置初值（即将新来的元素插入），然后安插点后的内容拷贝过来（这是由于insert也需要调用该函数，insert可以在中间插入，这样需要将插入点之后的元素通用拷贝到新的vector）。  最后，释放原来的vecotr。</p>
<p>vector的iterator</p>
<p>list的迭代器是一个类，而vector的迭代器是一个指针。</p>
<p><img src="https://i.imgur.com/56qkS1u.png" alt=""></p>
<p>使用vector的迭代器：</p>
<pre><code>vector&lt;int&gt; vec;
vector&lt;int&gt;::iterator ite = vec.begin();

iterator_traits&lt;ite&gt;::iterator_category; //ite给iterator_traits，由于ite是一个指针，则会调用偏特化的iterator_traits&lt;T *&gt;，对于指针，指针指向T，所以value_type是T，ponter是T *，reference是T &amp;。
</code></pre><p>G4.9版本中，vector变得非常复杂。存在类的继承关系：</p>
<p><img src="https://i.imgur.com/DfDex3b.png" alt=""></p>
<p>vector继承<code>_Vector_base</code>父类，父类包含<code>_Vector_impl</code>，而<code>Vector_impl</code>包含三个指针，<code>_Vector_impl</code>继承<code>std::allocator</code>父类。<code>_Vector_base</code>中有一个数据成员，该数据成员包含三个指针，所以vector的大小为12。</p>
<p>4.9版本中，迭代器采用类实现，变得非常复杂，但是最终目的跟2.9相同。</p>
<p><img src="https://i.imgur.com/fJVDezc.png" alt=""></p>
<p>抽象后，变成：</p>
<p><img src="https://i.imgur.com/t7DCZxm.png" alt=""></p>
<h3 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器array</h3><p>array比vector更简单。array在C++本来就存在，将其封装成容器，以便于可以使用算法和仿函数等。</p>
<p>TR1（技术报告1）是介于C++1.0和C+++2.0之间一个过度版本。C++1.0是1998版本，C++2.0是2011版本。由于TR1技术比较容器读。</p>
<p><img src="https://i.imgur.com/ZL75d18.png" alt=""></p>
<p>struct和class地位等同，不过有些一些小差别。</p>
<pre><code>_M_instance[_Nm, ? _Nm : 1]; //声明一个数组，如果_Nm为0，则表示申请一个元素。
</code></pre><p>array没有析构函数和构造函数。</p>
<p>array的迭代器是一个指针，G2.9版中的vector也是如此。此时调用<code>iterator_traits</code>偏特化类。</p>
<p>array使用：</p>
<pre><code>array&lt;int, 10&gt; myArray; //必须指定大小
auto ite = myArray.begin();
</code></pre><p>G4.9版本中的array:</p>
<p><img src="https://i.imgur.com/GZdWQCa.png" alt=""></p>
<p>声明数组的方法：</p>
<pre><code>int c[100];   //OK
typedef int T[100];
T c;           //OK
</code></pre><p>这样变得复杂，但是作用跟G2.9一样。</p>
<h3 id="容器forward-list"><a href="#容器forward-list" class="headerlink" title="容器forward_list"></a>容器forward_list</h3><p><img src="https://i.imgur.com/qilVlQV.png" alt=""></p>
<p>跟list相似，只不过list是双向的，forward_list是单向的。</p>
<h3 id="容器deque"><a href="#容器deque" class="headerlink" title="容器deque"></a>容器deque</h3><p>deque采用分段的形式，</p>
<p><img src="https://i.imgur.com/d35IkhG.png" alt=""></p>
<p>迭代器包含4个元素：cur,first,last,node。</p>
<p><img src="https://i.imgur.com/LDqwLqy.png" alt=""></p>
<p>map指向的内容是控制中心，控制中心按二倍成长。如果当前map指向的控制中心内存已经使用完，则map在内存中申请二倍的内存，并将当前的内容复制到新内存中。</p>
<p>对于一个缓冲区，其默认</p>
<p>map的类型是指向指针的指针。deque的大小为40字节。包含两个迭代器，一个指针和一个sizetype(4个字节)。</p>
<p>deque的迭代器包含4个指针，大小为16个字节。</p>
<p><img src="https://i.imgur.com/HonJ1I4.png" alt=""></p>
<p>deque的insert()</p>
<p>有两个参数：迭代器，新元素值</p>
<p>如果插在偏前面的位置，则将元素往前面推；反之往后面推。</p>
<p><img src="https://i.imgur.com/SXotVqV.png" alt=""></p>
<p>如果在前端，调用<code>push_front()</code>函数，如果在尾端，调用<code>push_back()</code>函数。如果都不是，则调用<code>insert_aux()</code>函数。</p>
<p><img src="https://i.imgur.com/ohKVzGF.png" alt=""></p>
<p><code>insert_aux()</code>首先判断插入的位置跟中点的位置关系，如果位于中点左侧，将前面的元素往前推动一个位置；如果位于右侧，执行，将后面的庸俗往后推动一个位置。</p>
<p>deque如何模拟连续空间的？</p>
<p><img src="https://i.imgur.com/xpmIWTE.png" alt=""></p>
<p>start指向最头的元素，finish指向最后一个元素的下一个位置。front()返回start，back()返回finish后退一个位置的元素。</p>
<p><img src="https://i.imgur.com/xVq9yHr.png" alt=""></p>
<p>实现连续空间都是迭代器的功能，通过迭代器操作符重载实现的。</p>
<p>++和–运算符重载：</p>
<p><img src="https://i.imgur.com/10GFtHl.png" alt=""></p>
<p>cur++后，看是否到达一个缓冲区的边界，如果到达边界，则跳到下一个缓冲区（<code>set_node(node+1)</code>），并指向最开头的元素。</p>
<p>cur–后，看是否到达一个缓冲区的开头边界，如果到达开头，则调跳到前一个缓冲区(<code>set_node(node-1)</code>)，并指向最后一个元素。</p>
<p>+=和+运算符重载：</p>
<p><img src="https://i.imgur.com/0IN7A0X.png" alt=""></p>
<p>对于-=和+运算符重载，直接利用+=和+来表现。</p>
<p><img src="https://i.imgur.com/7QMJXfs.png" alt=""></p>
<p>G4.9版本</p>
<p><img src="https://i.imgur.com/YeWcXEQ.png" alt=""></p>
<h3 id="容器queue"><a href="#容器queue" class="headerlink" title="容器queue"></a>容器queue</h3><p>queue底层实现是deque，只是将deque的某些功能关闭，就得到了queue。</p>
<p><img src="https://i.imgur.com/BBAWOlE.png" alt=""></p>
<h3 id="容器stack"><a href="#容器stack" class="headerlink" title="容器stack"></a>容器stack</h3><p>跟queue一样，stack内含一个deque，全部功能都是转调用。</p>
<p><img src="https://i.imgur.com/f1DHLxT.png" alt=""></p>
<p>stack和queue都不允许遍历，也不提供iterator。</p>
<p>stack和queue都可选择list或deque做为底部结构。但是deque做底部结构速度更快。</p>
<p><img src="https://i.imgur.com/7p04AGw.png" alt=""></p>
<p>queue不可选择vector做为底层结构，但是stack可以选择vector做为底部结构。</p>
<p><img src="https://i.imgur.com/Epmcpqo.png" alt=""></p>
<p>stack和queue都不可选择set或map做为底部结构。</p>
<p><img src="https://i.imgur.com/7CisDIQ.png" alt=""></p>
<h3 id="容器-rb-tree"><a href="#容器-rb-tree" class="headerlink" title="容器 rb_tree"></a>容器 rb_tree</h3><p>Red-Black tree(红黑树)是平衡二叉搜索树中常被使用的一种。平衡二叉搜索树的特性：排列规则有利于search和insert，并保持高度平衡——无任何节点特深。</p>
<p>红黑树提供遍历操作及iterators，按照正常规则（++ite）遍历，便能获得排序的序列。</p>
<p>我们<strong>不应该</strong>使用红黑树的iterators改变元素值（因为元素有其严谨的排列规则）。编程层面并未阻止此事。如此设计是正确的，因为红黑树将为set和map服务（做为其底部数据结构），而map允许元素的data被修改，只有元素的key才是不可被修改的。</p>
<p>红黑树提供两种插入操作：<code>insert_unique()</code>和<code>insert_equal()</code>。前者表示节点的key一定在整个tree中独一无二，否则安插失败；后者表示节点的key可重复。</p>
<p><img src="https://i.imgur.com/B1cokni.png" alt=""></p>
<p>红黑树实现：</p>
<p><img src="https://i.imgur.com/bG7DYOd.png" alt=""></p>
<p>第一个模板参数是Key的类型，第二个模板参数是（key，value）整体的类型，第三个模板参数告诉怎么从（key,value）整体中取出key，第四个参数是告诉两个Key如何比较大小。第五个参数是分配器。</p>
<p>黑红树有三个数据成员，node_count表示节点数量（4个字节），header指向红黑树的头节点（4个字节）。<code>key_compare</code>是一个类（这个类没有数据成员，所以默认是1个字节）。9个接字，按照内存对齐规则，必须是最大数据成员的整数倍，即12。</p>
<p>红黑树中，为了实现的方便，在头节点之上添加了一个空节点，然后header指向该节点，这样实现上方便很多。在，双向链表中也有同样的设计。</p>
<p>红黑树使用：</p>
<pre><code>rb_tree&lt;int, //Key的类型
        int, //表示只有Key，没有data
        identity&lt;int&gt;, //采用标准库的identity类，传入一个参数，返回该参数 
        less&lt;int&gt;,  //key怎么比较大小，使用标准库提供的仿函数less 
        alloc&gt; myTree;
</code></pre><p><img src="https://i.imgur.com/yJdMP6r.png" alt=""></p>
<p>红黑树用例 ：</p>
<p><img src="https://i.imgur.com/kaM9dyg.png" alt=""></p>
<p>G4.9版本中红黑树的用例：</p>
<p><img src="https://i.imgur.com/dbvDQsW.png" alt=""></p>
<p><img src="https://i.imgur.com/hu3rVwL.png" alt=""></p>
<p><code>_Rb_tree</code>类中内含一个<code>_Rb_tree_impl</code>，<code>_Rb_tree_impl</code>继承<code>_Node_allocator</code>，并内含<code>_Rb_tree_node_base</code>。</p>
<p>采用这种做法，为了遵循handle和body规则（OO思想中的概念）。<code>_Rb_tree</code>中有一个指针（<code>_M_impl</code>,即handle）来表示它的实现手法。</p>
<h3 id="容器set和mulitset"><a href="#容器set和mulitset" class="headerlink" title="容器set和mulitset"></a>容器set和mulitset</h3><p>set/mulitset以红黑树为底层结构，因此有元素自动排序的特性。排序的依据是key，而set/multiset元素的value和key相同，value就是key。</p>
<p>set/multiset提供遍历的操作，及iterators。按正常规则（++ite）遍历，便能获得排序后的状态。</p>
<p>我们无法使用set和multiset的迭代器改变元素的值。set/multiset的iterator是其底部的红黑树的const-iterator，就是为了禁止用户对元素赋值。</p>
<p>set元素的key必须独一无二，因此其insert()用的是红黑树的insert_unique()。</p>
<p>multiset元素的key可以重复，因此其insert()用的是红黑树的insert_equal()。</p>
<p>set的源代码：</p>
<p><img src="https://i.imgur.com/uBqyuzZ.png" alt=""></p>
<p>set包含3个模板参数，第一个参数是Key的类型，第二参数告诉怎么比较key的大小。在使用的时候，只需要指定一个key的类型，后面两个参数都要默认值：</p>
<pre><code>set&lt;int&gt; iset;
</code></pre><p>set中内含一个红黑树。set的迭代器实际上是红黑树的迭代器：<code>const_iterator</code>，而这个迭代器是一个常量迭代器，无法修改对应的值。</p>
<p>set的所有操作，都是转调用底层红黑树t的操作。set可以当作一个容器的适配器，其不做任何操作，全部都是转调用红黑树的操作。跟stack和queue一样，这两个都是转调用deque的操作。</p>
<p>GNU下有identity函数，但是在VC下没有，所以VC6在内部定义了一个类实现相同的功能，该类重载operator()，所以可以当作函数使用。</p>
<p><img src="https://i.imgur.com/CMKbIHy.png" alt=""></p>
<h3 id="容器map和multimap"><a href="#容器map和multimap" class="headerlink" title="容器map和multimap"></a>容器map和multimap</h3><p>map/multimap也是以红黑树为底部数据结构，因此有元素自动排序特性，排序的依据是key。</p>
<p>map/multimap提供遍历的操作及iterator。按正常规则（++ite）遍历，便能获得排序状态的序列。</p>
<p>我们无法使用map/multimap的iterators改变元素的key，但可以十三亿它来改变元素的data。因此map/multimap内部自动将用户指定的key类型为const，如果便能禁止用户对元素的key赋值。</p>
<p>map元素的key必须独一无二，因此insert()用的是红黑树的insert_unique()。</p>
<p>multimap元素的key可以重复，因此其insert()用的是红黑树的insert_equal()。</p>
<p><img src="https://i.imgur.com/s0dD3I5.png" alt=""></p>
<p>map包含4个模板参数，后两个有默认值。前两个是指定key和data的类型。map的迭代器就是红黑树的迭代器，并没有规定key不能赋值，而是在包装成pair时，指定key的类型为const，即<code>pair&lt;const Key, T&gt;</code>。</p>
<p>select1st取出map元素的第一个值，即key。select1st是GNU C特有的，所以对于其他版本，它们必须自己定义一个功能相同的函数。在map类中，定义了内部类，并给类重载()运算符操作，这样类可以当作函数使用。</p>
<p><img src="https://i.imgur.com/oa73mmd.png" alt=""></p>
<p>pair是标准库的结构，pair&lt;fisrtType, secondType&gt; p; p.first即p中的第一个元素，p.seconde即第二个元素。</p>
<p>map独有的operator[]:</p>
<pre><code>map&lt;int, string&gt; m;
m[1] = &quot;abc&quot;;
</code></pre><p>[]返回key对应的value，如果key不存在，就会创建一个元素&lt;key, value&gt;放入map中。</p>
<p><img src="https://i.imgur.com/QkE4qoi.png" alt=""></p>
<p><code>_k</code>表示key，<code>lower_bound</code>标准库中的一个算法，该算法的作用是：从排序好中序列中查找对应的key，如果找到，返回迭代器指向其中的第一个车元素。如果没有找到，就会传会最适合插入查找的key的位置。如果即没有找到，就调用insert函数。</p>
<p>使用[]和insert两个进行元素插入，insert的效率更高，因为[]还需要调用<code>lower_bound</code>函数进行判断。</p>
<h3 id="容器hashtable"><a href="#容器hashtable" class="headerlink" title="容器hashtable"></a>容器hashtable</h3><p>散列表或者哈希表。</p>
<p>unsigned int有2^32种变化，如果每个情况都申请内存，由于内存大小有限，内存是无法存储所有情况。</p>
<p><img src="https://i.imgur.com/9cb0AP0.png" alt=""></p>
<p>但内存不足时，将编号除以空间的大小，得到余数。将元素放到余数对应的位置。</p>
<p>比如内存大小为100，5存放在5的位置，8存放在8的位置，105存放在5的位置。这样就存在碰撞。</p>
<p>防止碰撞的方法有多种：一次函数和二次函数分开。</p>
<p>还有就是拉链法（sepearate chaining）:</p>
<p><img src="https://i.imgur.com/WlFgFZm.png" alt=""></p>
<p>一般篮子的数量都是素数。如果篮子数量小于元素数量，找到篮子数量离翻倍后最近的素数，将其当作更新的篮子数量，重新打散所有元素重新分配到篮子中。</p>
<p>GNU C中将篮子的数量提前分配好，存放在一个数组。</p>
<p>GNU C中hashtable内部实现:</p>
<p><img src="https://i.imgur.com/ADifuYu.png" alt=""></p>
<p>6个模板参数：Value和Key分别表示两者的类型，HashFcn是一个函数：将元素映射到一个编号，ExtractKey是提取key的函数，EqualKey是判断两个key相等的函数，最后是一个分配器。</p>
<p>一个hashtable包含5个数据成员，前三个是函数对象（每一个函数对象实际上的大小是0，但是实际上无法做到0，而是做成1个字节），第四个是一个vector容器（即篮子）（一个vector里面有3个指针，所以是12字节），最后一个是元素的数量（4个字节）。大小为19，由于对齐规则，所以调整为20个字节。</p>
<p>一个hashtable迭代器包含两个指针，cur指向链表中的某个元素，而ht指向某个篮子。</p>
<p>hashtable的使用：</p>
<p><img src="https://i.imgur.com/fAhxVsU.png" alt=""></p>
<p>hash-function传回的值就是hash-code。</p>
<p><img src="https://i.imgur.com/uGwXOX4.png" alt=""></p>
<p><img src="https://i.imgur.com/EmwGr8v.png" alt=""></p>
<p>hashtable中许多函数最后会归结到<code>hash(key)%n</code>：</p>
<p><img src="https://i.imgur.com/UZXpXCZ.png" alt=""></p>
<h3 id="unordered"><a href="#unordered" class="headerlink" title="unordered"></a>unordered</h3><p><img src="https://i.imgur.com/RZjy5kb.png" alt=""></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>容器、迭代器、仿函数、适配器和分配器都是类模板（class template)；</p>
<p>算法是函数模板（function template）。</p>
<p>算法的形式：</p>
<pre><code>template&lt;typename Iterator&gt;
Algorithm(Iteraotor ite1, Iterator ite2)
{...}

template&lt;typename Iterator, typename Cmp&gt;
Algorithm(Iterator itr1, Iterator itr2, Cmp comp)
{...}
</code></pre><p>算法看不见容器，对容器一无所知，算法只能看到迭代器，算法所需的一切信息都必须从Iterators取得，而迭代器必须能够回答算法的所有提问，才能搭配该算法的所有操作。</p>
<h3 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h3><p>5种迭代器分类：</p>
<pre><code>struct input_iterator_tag{};
struct output_iterator_tag{};
struct farward_iterator_tag : public input_iterator_tag{};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag{};
</code></pre><p><img src="https://i.imgur.com/qV7XdQs.png" alt=""></p>
<p>Array、Vector、Deque：在用户层面都是连续的，可以随机跳(<code>random_access_iterator_tag</code>)</p>
<p>list：双向(<code>random_access_iterator_tag</code>)</p>
<p>Forward=list：单向(<code>farword_iterator_tag</code>)</p>
<p>红黑树：双向（<code>bidirectional_iterator_tag</code>）</p>
<p>Hashtable: 单向或者双向（取决于底部链表是双向还是单向）</p>
<p>打印各种容器的迭代器：</p>
<p><img src="https://i.imgur.com/zDvQ7MH.png" alt=""></p>
<p>typename()这样生成一个临时对象，比如<code>int()</code>。</p>
<p><code>istream_iterator</code>和<code>ostream_iterator</code>分别是<code>input_iterator</code>和<code>output_isterator</code>。</p>
<p><img src="https://i.imgur.com/Ujzp3RV.png" alt=""></p>
<p>typeid(itr).name()：itr是一个类型，返回类型的名字。</p>
<p>istream_iterator的iterator类型</p>
<p><img src="https://i.imgur.com/q6lDN4Z.png" alt=""></p>
<p>所有版本接口都一样，虽然模板参数不同，但是不同的部分都给出了默认的值。所有版本都是规定<code>istream_iterator</code>的类型为<code>input_iterator</code>。</p>
<p>ostream_iterator的iterator类型</p>
<p><img src="https://i.imgur.com/eXd5ABX.png" alt=""></p>
<p>其与istream_iterator类似。</p>
<h4 id="迭代器分类对算法的影响"><a href="#迭代器分类对算法的影响" class="headerlink" title="迭代器分类对算法的影响"></a>迭代器分类对算法的影响</h4><p><strong>distance</strong>有两个版本：一个对于连续空间，直接用尾指针减去头指针（效率高）；另一个对于非连续空间，通过将指针往后移动，并进行计数（效率低）。</p>
<p>distance的返回类型：两个指针的距离类型，通过<code>iterator_traits</code>获取迭代器的difference_type。</p>
<p><img src="https://i.imgur.com/M9daKWJ.png" alt=""></p>
<p>首先将迭代器给<code>iterator_traits</code>得到迭代器的类型，然后利用迭代器类型名建立临时对象，放入<code>_distance</code>，根据临时对象调用不同的版本。</p>
<p>很多算法都会有一个主函数，然后根据迭代器类型，调用不同的次函数，类似于distance。</p>
<p><strong>advance</strong>有三个版本：一个是前进，另一个是后退，最后一个是可前进也可以后退（双向迭代器）。</p>
<p>前进和移动可以是一步一步移动（效率低），也可以直接跳转（效率高）。</p>
<p><img src="https://i.imgur.com/xneK9aO.png" alt=""></p>
<p><code>iterator_category(i)</code>根据迭代器i获取迭代器的类型（分类），并以此类型创建一个临时对象返回。</p>
<p>迭代器有5种类型，但是为什么这里只考虑了两种情况或三种情况呢？</p>
<p>如果类型是<code>farward_iterator_tag</code>，distance会调用<code>input_iterator_tag</code>版本，因为<code>farward_iterator_tag</code>是一个种<code>input_iterator_tag</code>类型，这是根据类的继承是一个种is-a的关系。</p>
<p><strong>copy</strong>：复制一个容器中的所有元素到一个新容器中。</p>
<p><img src="https://i.imgur.com/pQma4mi.png" alt=""></p>
<p>copy不断的做迭代器类型判断，对不同的迭代器采用不同的做法。</p>
<p>首先，如果迭代器类型是<code>const char *</code>和<code>const wchar_t*</code>，则调用mememove()(是一个底层的系统函数)；如果是迭代器类型不是上述两种类型，调用一个泛化版本<code>_copy_dispatch()</code>函数。然后，<code>_copy_dispatch()</code>在进行迭代器类型判断，如果是指针，则调用<code>_copy_t()</code>函数，如果不是指针，则调用泛化版本<code>__copy()</code>。最后，<code>__copy()</code>判断迭代器类型，如果<code>input_iterator</code>类型调用for-loop，这样从头指针开始一个一个复制；如果是<code>random_access_iterator</code>，调用<code>_copy_d()</code>函数，直接last-first得到循环的次数，这样速度更快。</p>
<p>注意，<code>__copy_t()</code>函数会使用type traits来判断执行一个动作重不重要（比如拷贝赋值重不重要，对于一个含有指针的类是重要的），如果它是不重要的（trivial），就会调用<code>memmove()</code>函数，如果它重要，就会调用<code>__copy_d()</code>一个一个进行赋值，就会调用拷贝赋值函数。比如，如果一个对象里面没有指针，调用复制构造函数和拷贝赋值函数是不重要的。</p>
<p>type traits不属于STL，但属于标准库。</p>
<p><strong>destroy</strong>：调用析构函数</p>
<p><img src="https://i.imgur.com/5cxT7al.png" alt=""></p>
<p>其也要调用type traits，如果摧毁的元素的析构函数不重要，就不需要调用析构函数；如果析构函数重要，就调用析构函数destroy函数。</p>
<p>destroy的详细实现：</p>
<p><img src="https://i.imgur.com/TEucOpM.png" alt=""></p>
<p><strong>算法的效率主要看算法能不能判断迭代器的分类。</strong></p>
<p><code>unique_copy()</code>只复制不重复的元素</p>
<p><img src="https://i.imgur.com/k8l0J5i.png" alt=""></p>
<p>如果目的端是一个outputiterator，不能读取其中的值(<code>*result</code>)，所以不能采用forwarditerator。</p>
<p>算法的接口不会规定只接受某种迭代器，而是会接收所有迭代器。因为使用的是模板函数，所以对迭代器类型没有规定。但是如果传入的迭代器类型不符合算法要求的类型，到迭代器跳转的时候会失败。</p>
<p><img src="https://i.imgur.com/whWRE1K.png" alt=""></p>
<p>distance接收的迭代器类型是input iterator，所以除了output iterator，其他迭代器都可以正确放入distance函数。</p>
<p>比如，sort中的模板类型名称是randomAccessIterator，告诉我们迭代器类型是<code>randmo_access_iterator</code>，如果是其他类型，执行到迭代器跳转的地方会失败。</p>
<h4 id="具体算法分析"><a href="#具体算法分析" class="headerlink" title="具体算法分析"></a>具体算法分析</h4><p>C函数：</p>
<ul>
<li>qsort(c.data, ASIZE, sizeof(long), compareLongs)</li>
<li>bsearch(&amp;target, c.data(), ASIZE, sizeof(long), compareLongs)</li>
</ul>
<p>标准库提供的算法：</p>
<ul>
<li>count_if(vi.begin(), vi.end(), not1(bind2nd(less<int>(),40)))</int></li>
<li>find(c.begin(), c.end(), target)</li>
<li>sort(c.begin(), c.end())</li>
</ul>
<p>标准库的算法需要符合：</p>
<pre><code>template &lt;typename Iterator&gt;
std::Algorithm(Iterator itr1, Iterator itr2 ..)
{}
</code></pre><ul>
<li>算法accumulate:</li>
</ul>
<p>有两个版本：第一个版本接收头尾两个指针和一个初值；另一个版本接收头尾两个指针，一个初值和一个函数（操作）。</p>
<p><img src="https://i.imgur.com/nrX44WF.png" alt=""></p>
<p>第一个版本，执行累加操作。而第二个版本，要根据给定的函数才能知道执行了什么操作。</p>
<p>右侧示例中，在accumulate中给出不同的函数，得到了不同的结果。不同的函数是可被调用的对象包括：函数和函数对象。</p>
<ul>
<li>算法for_each</li>
</ul>
<p>对每个元素执行相同的操作。</p>
<p>接收头尾两个迭代器，和一个函数对象。</p>
<p><img src="https://i.imgur.com/cfgsCxs.png" alt=""></p>
<p>基于范围的for循环：</p>
<pre><code>for(decl : coll)
    statement;

for (int i : {1,3,4,6,5,7})
    cout &lt;&lt; i &lt;&lt; endl;
</code></pre><ul>
<li>算法replace, replace_ if, replace_copy</li>
</ul>
<p><img src="https://i.imgur.com/TMwqGJh.png" alt=""></p>
<p>replace：如果元素跟旧值(<code>old_value</code>)相同，就替换为新值(<code>new_value</code>)。</p>
<p>replace_if：满足某条件（pred）的元素，替换为新值。</p>
<p>replace_copy: 如果元素跟旧值相同，不是取代，而是复制到内的地方并替换为新值。</p>
<ul>
<li>算法count，count_if</li>
</ul>
<p><img src="https://i.imgur.com/EQUojmx.png" alt=""></p>
<p>count：对所有元素进行计数</p>
<p>count_if: 对满足某个条件的元素，进行计数</p>
<p>带成员函数count()的容器：set/mulitset，map/multimap…。这些容器调用count()时，调用其成员函数速度将更快。这8个容器中有key，有其更快速的做法，所以这8个容器每个都定义了一个count成员函数。</p>
<p>但是对于容器不带成员函数count()，那么只能调用标准库中的算法count()。</p>
<ul>
<li>算法find，find_if</li>
</ul>
<p><img src="https://i.imgur.com/9Np9TVU.png" alt=""></p>
<p>跟count类似。</p>
<ul>
<li>算法sort</li>
</ul>
<p><img src="https://i.imgur.com/zkkUMzU.png" alt=""></p>
<pre><code>bool myfunc(int i, int j) { return (i &lt; j);}
struct myclass{
    bool operator()(int i, int j) {return (i &lt; j);}
} myobj;

int myints[] = {32, 17, 12, 45, 26, 80, 53, 33};
vector&lt;int&gt; myvec(myints, myints+8);

sort(myvec.begin(), myvec.begin()+4);

sort(myvec.begin()+4, myvec.end(), myfunc);

sort(myvec.begin(), myvec.end(), myobj); 

sort(myvec.rbegin(), myvec.rend());  //rbegin()=end(), rend()=begin()  得到的排序跟前面相反
</code></pre><p>8种关联式容器中所有元素已经排序好，所有不再需要使用sort进行排序，所以其没有定义成员函数sort。</p>
<p>list和forward_list无法调用sort，因为这两者的迭代器无法跳转，所以其自身带有sort成员函数。</p>
<p>rbegin()和rend()</p>
<p><img src="https://i.imgur.com/VRQMFTt.png" alt=""></p>
<p>reverset_iterator是一个适配器，将end()的取值方式反过来。</p>
<ul>
<li>算法binary_search</li>
</ul>
<p>二分查找：前提条件是，容器已经排序好</p>
<p><img src="https://i.imgur.com/B1ry9gk.png" alt=""></p>
<p><code>lower_bound</code>返回能够插入某个元素的最低点，<code>upper_bound</code>返回能够插入某个元素的最高点。前提条件是元素已经排序好。</p>
<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p>仿函数，又称函数对象</p>
<p>仿函数根据用户的要求进行设计，然后使用到算法中。</p>
<p><img src="https://i.imgur.com/nKgp29E.png" alt=""></p>
<p>仿函数三大类：</p>
<ul>
<li>算术类</li>
</ul>
<p>计算两个数的加减乘除等。</p>
<pre><code>template &lt;class T&gt;    
struct plus : public binary_function&lt;T,T,T&gt;
{ T operator()(const T&amp;x, const T&amp; y) const
    {return x + y; }
};

template&lt;class T&gt;
struct minus : public binary_function&lt;T,T,T&gt;
{ T operator()(const T&amp;x, const T&amp; y) const
    {return x - y; }
};
</code></pre><ul>
<li>逻辑运算类</li>
</ul>
<p>计算两个元素的或、与。</p>
<pre><code>template&lt;class T&gt;
struct logical_and : public binary_function&lt;T,T,bool&gt;{
    bool operator()(const T&amp; x, const T&amp; y) const
    { return x &amp;&amp; y;}
};
</code></pre><ul>
<li>相对关系类</li>
</ul>
<p>比较两个元素的大小关系</p>
<pre><code>template&lt;class T&gt;
struct equal_to : pulbic binary_function&lt;T, T, bool&gt;
{    
    bool operator()(const T&amp; x, const T&amp; y)const    
    {    return x == y; }
};
</code></pre><p>GNU C++独有的仿函数，非标准的</p>
<pre><code>template &lt;class T&gt;
struct identity : public unary_function&lt;T,T&gt;
{
    const T&amp; operator()(const T&amp; x) const 
    { return x;}
}

template&lt;class Pair&gt;
struct select1st: public unary_fucntion&lt;Pair, typenmae Pair::first_type&gt;{
    const typename Pair::first_type &amp; operator()(const Pair &amp; x) const
    { return x.first; }
}

...
</code></pre><p>sort中仿函数的使用：</p>
<p><img src="https://i.imgur.com/sGaXjR7.png" alt=""></p>
<p>标准库提供的仿函数继承自<code>binary_function</code>或<code>unary_function</code>。而我们写的继承关系，可以运行，但是这样就没有容器STL中，在执行某些动作时可能会失败。</p>
<p>仿函数可适配的条件是：仿函数需要继承<code>binary_function</code>或<code>unary_function</code>。这是因为适配器可能需要访问仿函数的一些参数（即问问题），如果不继承自这两个函数，将无法进行回答。</p>
<p><img src="https://i.imgur.com/JtGlxi0.png" alt=""></p>
<p><code>unary_function</code>针对于运算符!(not)等,只有一个操作数。<code>binary_function</code>针对两个操作数的运算符。</p>
<p>这两个类都没有数据成员和成员函数，大小理论值为0，实际上大小为1。如果有子类继承自它，那它的大小是0。所以less的大小，理论上为0，实际上为1。</p>
<h2 id="适配器adapter"><a href="#适配器adapter" class="headerlink" title="适配器adapter"></a>适配器adapter</h2><p>多种适配器： </p>
<ul>
<li>容器适配器</li>
<li>迭代器适配器</li>
<li>仿函数适配器</li>
</ul>
<p><img src="https://i.imgur.com/bWw6TUP.png" alt=""></p>
<p>A改造了B，就可以用A代替B，用户是使用A，但幕后还是B在起作用。</p>
<p>适配器都是内含的方式，而不是继承。</p>
<p>容器适配器就是内含一个容器，迭代器适配器就是内含一个迭代器，仿函数适配器内含一个适配器。</p>
<p>算法不知道容器，只能看到迭代器，而迭代器有容器提供。迭代器必须拥有5个typedef。</p>
<p>仿函数主要是跟算法合作，比如算法比较大小的准则等都是由仿函数提供，可以把仿函数包成一个适配器，然后给算法使用。算法可能需要直到某些信息，或者适配器需要直到仿函数的性质，通过3个或2个typedef实现。</p>
<h3 id="容器适配器-stack-queue"><a href="#容器适配器-stack-queue" class="headerlink" title="容器适配器 stack, queue"></a>容器适配器 stack, queue</h3><p><img src="https://i.imgur.com/XSM9tgN.png" alt=""></p>
<p>Stack内含一个容器deque，对其进行了改造，其开放了deque的某些函数。</p>
<p>queue内含一个容器deque，对其进行了改造，函数的实现都是转调用deque的函数。</p>
<h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><p>binder2nd：将仿函数绑定第二参数。</p>
<pre><code>count_if(vi.begin(), vi.end, 
            not1(bind2nd(less&lt;int&gt;(), 40)));
</code></pre><p><img src="https://i.imgur.com/JsCMx7x.png" alt=""></p>
<p>bind2nd只是一个接口，内部实现交给binder2nd。bind2nd会根据仿函数，得到仿函数的类型，然后当作binder2nd的模板参数。比如，less<int>放入的时候，编译器会启动推导出类型。</int></p>
<p>binder2nd类中有两个数据成员op和value，一个表示函数，另一个表示需要绑定的参数。</p>
<p>binder2nd重载了()运算符，所以binder2nd是一个函数对象，可以像函数一样使用它。</p>
<p><code>operation::second_argument_type</code>得到less的第二个参数的类型，然后在调用binder2nd时进行强制类型转换(<code>arg2_type(x)</code>)。</p>
<p>在binder2nd中，<code>operation::second_argument_type</code>得到less的第二个参数的类型，第二个参数的类型应该是该类型；<code>operation::result_type</code>得到less的返回类型，bind2nd的返回类型应该也是该类型。</p>
<p>在<code>count_if</code>中，放入的参数是第一实参，第二个参数已经绑定为40。</p>
<p>typename的作用：在编译时，Operation的类型无法知道，也无法知道Operation能否回答这个问题，这是编译器可能无法通过编译；使用typenam就可以让编译器通过编译。</p>
<p>binder2nd再一次继承了<code>unary_function</code>，使其变成可适配的，可以被其他适配器改造。</p>
<p><strong>适配器就是将参数的类型记录下来，以便后面使用。</strong></p>
<p>not1: 取否定，<code>bind2nd(less&lt;int&gt;(), 40)</code>表示大于40的条件，加上not1修饰，表示小于40的条件。</p>
<p><img src="https://i.imgur.com/cv6PyrY.png" alt=""></p>
<p>not1同样有一个主函数和一个次函数，主函数相当于一个接口，主要的内容有次函数完成。主函数完成实参推导，即得到pred的类型Predicate。然后，利用该类型创建临时对象<code>unary_negate</code>，调用构造函数。</p>
<p>在<code>count_if</code>中，利用创建的临时对象<code>unary_negate</code>，调用重载的()运算符。</p>
<h3 id="新型适配器-bind"><a href="#新型适配器-bind" class="headerlink" title="新型适配器 bind"></a>新型适配器 bind</h3><p><img src="https://i.imgur.com/UzzPyDH.png" alt=""></p>
<p>表明binder1st,bind1st,binder2st,bind2st等都是过时的，已经替换成bind。</p>
<p><img src="https://i.imgur.com/QDbh0Z9.png" alt=""></p>
<p>bind可以绑定：</p>
<ul>
<li>函数</li>
<li>函数对象</li>
<li>成员函数</li>
<li>数据成员 </li>
</ul>
<p>绑定成员函数和数据成员时，<code>_1</code>必须是某个对象地址。</p>
<p>绑定函数：</p>
<p><code>_1</code>表示占位符，即空着这个位。必须添加命名空间：<code>using namespace std::placeholders;</code></p>
<pre><code>auto fn_invert = bind(my_divide,_2,_1);
cout &lt;&lt; fn_invert(10,2) &lt;&lt; endl; // 输出0.2
</code></pre><p>其中<code>_1</code>绑定fn_invert(10,2)的第一个实参10，<code>_2</code>绑定第二实参2。</p>
<p>bind可以指定一个模板参数，绑定的是函数的返回类型。</p>
<pre><code>auto fn_rounding = bind&lt;int&gt;(my_divide, _1,_2);
cout &lt;&lt; fn_rounding(10, 3) &lt;&lt; endl; //输出3
</code></pre><p>由于指定返回类型为3，会将原来的返回类型double覆盖，所以返回值是3。</p>
<p>绑定函数对象：</p>
<p>跟绑定函数一样，只是将函数声明换出了函数对象：</p>
<pre><code>先定义divides对象，并重载operator()
std::divides&lt;double&gt; my_divide;
</code></pre><p>绑定成员函数：</p>
<pre><code>MyPair ten_two {10,2}; //创建对象，并给数据成员给初值

auto bound_memfn = bind(&amp;MyPair::multiply, _1); //_1表示对象的this指针 
cout &lt;&lt; bound_memfn(ten_two);   
</code></pre><p>绑定数据成员：</p>
<pre><code>auto bound_memdata = bind(&amp;MyPair::a, ten_two);
cout &lt;&lt; bound_memdata() &lt;&lt; endl;

auto bound_memdata2 = bind(&amp;MyPair::b, _1);
cout &lt;&lt; bound_memedata2(ten_two) &lt;&lt; endl;
</code></pre><p>bind的使用：</p>
<pre><code>vector&lt;int&gt; v {15,23,56,34,67,24, 14};
int n = count_if(v.cbegin(), v.cend(), not1(bind2nd(less&lt;int&gt;(), 30)));
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;

auto fn_ = bind(less&lt;int&gt;(), _10, 30);
cout &lt;&lt; count_if(v.cbegin(), v.cend(), fn_) &lt;&lt; endl;
cout &lt;&lt; count_if(v.begin(), v.end(), bind(less&lt;int&gt;(), _1, 30)) &lt;&lt; endl;
</code></pre><p>cbegin()和cend()表示迭代器是const类型，无法修改它。</p>
<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p>对迭代器进行改造。</p>
<p>reverse_iterator:</p>
<p>排序的默认情况，从小到大。如果传给其的迭代器是两个逆向迭代器（rbegin()和rend()），得到的是从大到小。</p>
<p><img src="https://i.imgur.com/4M3nfs8.png" alt=""></p>
<p><code>reverse_iterator</code>逆向迭代器也需要5个typedef，跟正向迭代器一致。</p>
<p>关键的取值动作，逆向迭代器是反向取值，逆向迭代器取值，就是对正向迭代器退一位取值。逆向的++就是正向的–，所有操作都是逆向的。</p>
<p>迭代器适配器inserter</p>
<p><img src="https://i.imgur.com/r2vwbc4.png" alt=""></p>
<p>复制：</p>
<pre><code>int myints[] = {}10,20,30,40,50,60,70};
vector&lt;int&gt; myvec(7); //如果给出vector的大小不足，复制的时候，如果构造这个范围，vector不会自动增长
copy(myints, myints+7, myvec.begin());
</code></pre><p>正常的迭代器，copy会进行赋值动作，会见后面的内容覆盖。</p>
<p>而如果想在中间插入多个元素，而不覆盖后面的元素，可以使用inserter实现。</p>
<p>inserter每插入一个元素，会在迭代器后向安排一个新的空间以便元素插入。</p>
<p>但是copy已经写死，无法修改，就考虑对赋值=进行重载。就是对copy中的第三参数进行=操作符重载。</p>
<p>执行<code>*restult=*first;</code>，会进入<code>insert_iterator</code>中的重载operator=函数中，执行插入操作。</p>
<p>inserter</p>
<pre><code>list&lt;int&gt; foo, bar;
for (int i = 1; i &lt;= 5; i++)
{
    foo.push_back(i);
    bar.push_back(i*10);
}

list&lt;int&gt;::iterator it = foo.begin();
advance(it, 3);
copy(bar.begin(), bar.end(), inserter(foo, it));
</code></pre><h3 id="X适配器：-ostream-iterator"><a href="#X适配器：-ostream-iterator" class="headerlink" title="X适配器： ostream_iterator"></a>X适配器： ostream_iterator</h3><p><img src="https://i.imgur.com/oGTFvBG.png" alt=""></p>
<p>ostream_iterator使用：</p>
<pre><code>std::ostream_iterator&lt;int&gt; out_it(std::cout, &quot;,&quot;);
std::copy(myvector.begin(), myvector.end(), out_it);
</code></pre><p><code>out_it(std::cout,&quot;,&quot;)</code>调用<code>ostrem_iterator</code>的构造函数，在copy函数中执行<code>*result=*first;</code>是调用<code>ostream_iterator</code>重载的=运算符。</p>
<h3 id="x适配器：istream-iterator"><a href="#x适配器：istream-iterator" class="headerlink" title="x适配器：istream_iterator"></a>x适配器：istream_iterator</h3><p><img src="https://i.imgur.com/nfx5Fql.png" alt=""></p>
<p>如果<code>istream_iterator</code>不带参数，就是一个<code>end-of-stream</code>迭代器，代表一个标兵。</p>
<p><code>istream_iterator</code>重载++操作符，可以读取值到value，然后通过重载*运算符来返回value值。对<code>istream_iterator</code>进行++，就是进行读取值操作。</p>
<p><img src="https://i.imgur.com/ryOpEZT.png" alt=""></p>
<p>先创造两个<code>istream_iterator</code>迭代器，然后将这两个迭代器当作copy的来源端，inserter()将复制操作变成插入操作。</p>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>勿在浮沙筑高台</p>
<h3 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h3><p>为自己的hashtable写一个hash function，来设置每个元素的位置。</p>
<p>写一个hash function的形式：</p>
<p>如果将Cunstomer放入hashtable，需要为其设置一个hash function（Customerhash）。</p>
<p><img src="https://i.imgur.com/dL9mDGz.png" alt=""></p>
<p>有两种定义hash function的形式：</p>
<ul>
<li>函数对象</li>
<li>普通函数</li>
</ul>
<p>两种形式使用的方式不同：</p>
<pre><code>unordered_set&lt;Customer, CustomerHash&gt; custset;
unordered_set&lt;Customer, size_t(*)(const Customer&amp;)&gt; custset(20, customer_hash_func);
                     //指明函数返回类型和参数类型                   //实际的函数地址
</code></pre><p><img src="https://i.imgur.com/lE9sm91.jpg" alt=""></p>
<p>对于直接用类的所有成员的哈希值相加当作函数函数，这样太天真。实际上可以运行，但是出现碰撞的几率高，导致查找速度慢。</p>
<p>TR1给出了hash function实现，比直接相加好。</p>
<p>直接调用<code>hash_val</code>函数，将类的所有成员当作参数。第一个版本的<code>hash_val</code>，template可以接收任意个数的模板参数；第二版本的<code>hash_val</code>，第一个参数是<code>size_t</code>，模板参数个数是任意多个；第三个版本的<code>hash_val</code>，只有两个模板参数。</p>
<p>首先调用的第一个版本<code>hash_val</code>，然后第一个版本<code>hash_val</code>调用第二个版本的<code>hash_val</code>，第二个版本里面有递归，直到递归到最后一个时(只有两个参数)，调用第三个版本的<code>hash_val</code>。</p>
<p>除了前面两种形式,还有另一种形式,写一个偏特化的hash版本.</p>
<p><img src="https://i.imgur.com/Rr0Su8s.png" alt=""></p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple在TR1开始加入的.</p>
<p>在声明的时候,允许放入的任意的元素类型和个数.</p>
<p>使用示例:</p>
<pre><code>cout &lt;&lt; &quot;string sizeof=&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
cout &lt;&lt; &quot;double sizeof=&quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
cout &lt;&lt; &quot;float sizeof=&quot; &lt;&lt; sizefo(float) &lt;&lt; endl;
cout &lt;&lt; &quot;int sizeof=&quot; &lt;&lt; sizeof(int) &lt;&lt; enld;
cout &lt;&lt; &quot;complex&lt;double&gt; sizeof=&quot; &lt;&lt; sizeof(complex&lt;double&gt;) &lt;&lt; endl;

tuple&lt;string, int, int, complex&lt;double&gt; &gt; t;
cout &lt;&lt; &quot;sizeof=&quot; &lt;&lt; sizeof(t) &lt;&lt; endl;   //32

tuple&lt;int, float, string&gt; t1(41, 6.3, &quot;nico&quot;);
cout &lt;&lt; &quot;tuple&lt;int, float, string&gt; sizeof=&quot; &lt;&lt; sizeof(t1) &lt;&lt; endl; //12

cout &lt;&lt; &quot;t1: &quot; &lt;&lt; get&lt;0&gt;(t1) &lt;&lt; &quot; &quot; &lt;&lt; get&lt;1&gt;(t1) &lt;&lt; &quot; &quot; &lt;&lt; get&lt;2&gt;(t1) &lt;&lt; endl;

auto t2 = make_tuple(22, 444, &quot;stacy&quot;);
get&lt;1&gt;(t1) = get&lt;1&gt;(t2);

if (t1 &lt; t2)
    cout &lt;&lt; &quot;t1 &lt; t2&quot; &lt;&lt; endl;
else
    cout &lt;&lt; &quot;t1 &gt;= t2&quot; &lt;&lt; endl;
t1 = t2;
cout &lt;&lt; &quot;t1: &quot; &lt;&lt; t1 &lt;&lt; endl;

tuple&lt;int, float, string&gt; t3(77, 1.1, &quot;more light&quot;);
int i1;
float f1;
string s1;
tie(s1, f1, s1) = t3;  //分配值给值给i1,f1,s1


typedef tuple&lt;int, float, string&gt; TuepleType;
cout &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; endl;
tuple_element&lt;1, TupleType&gt;::type fl = 1.0;
typedef tuple_element&lt;1, TupleType&gt;::type T;
</code></pre><p>tuple实现:</p>
<p><img src="https://i.imgur.com/Q4eIMBy.png" alt=""></p>
<p>如果tuple包含n个元素,则它会继承一个n-1个元素的tuple。 第一个元素成为类中的一个变量。如果到达0个元素时，调用偏特化偏特化版本（即一个空的模板类）。</p>
<p>tuple有两个函数head()和tail()。head()传回第一个值，tail()获得父类的成员起点。</p>
<h3 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h3><p><img src="https://i.imgur.com/VZ6ouo0.png" alt=""></p>
<p>默认情况下，默认构造函数、拷贝构造函数，拷贝赋值函数，析构函数是重要的，那就需要在实现这些函数时，需要将对象一个一个赋值。</p>
<p>对于基本类型，这些函数都是不重要的。也对可以对自己定义的类，设置特化版本。</p>
<pre><code>template&lt;&gt; struct __tyep_traits&lt;Foo&gt;{
    teypdef __true_type has_trivial_default_constructor; //这些值可以设定
    ....
};
</code></pre><p>如果不给自己定义的类设置特化版本，将会使用默认的版本。普通的类都没有必要设置特化版本，除非类中使用了指针，文件等，这样使用特化版本来设置是有必要的。</p>
<p>POD是C中的struct，只有数据成员，没有函数成员。</p>
<p>c++11里面的type_traits:</p>
<p><img src="https://i.imgur.com/UPvk6hh.png" alt=""></p>
<p><img src="https://i.imgur.com/x78fuvh.png" alt=""></p>
<p>type_traits使用方式：</p>
<pre><code>template&lt;typename T&gt;
void type_traits_output(const T&amp; x)    
{
    cout &lt;&lt; is_void&lt;T&gt;::value &lt;&lt; endl;
    cout &lt;&lt; is_integrial&lt;T&gt;::value &lt;&lt; endl;
....
}
</code></pre><p>类中指针时，需要析构函数。类当成是父类时，才有必要将析构函数写成虚函数。</p>
<p><img src="https://i.imgur.com/wH0tPav.png" alt=""></p>
<p>string不能被当作父类，所以它的析构函数不是虚函数。</p>
<p>对于自己定义的类，分析type_traits:</p>
<p><img src="https://i.imgur.com/n7nd4I1.png" alt=""></p>
<p>自己定义的类Zoo:</p>
<p><img src="https://i.imgur.com/IbdF21a.png" alt=""></p>
<pre><code>Zoo(const Zoo &amp;)=delete; //表示不要拷贝构造函数，编译器不要生成默认的拷贝构造函数
Zoo(Zoo &amp;&amp;) = default; //移动构造函数，使用编译器给的默认版本
</code></pre><p>complex复数：没有指针，没有构造函数函数和析构函数，但是编译器会给出默认的模板。</p>
<p><img src="https://i.imgur.com/zD09TGE.png" alt=""></p>
<p>c++11 type_traits实现：</p>
<p>is_void实现：</p>
<p><img src="https://i.imgur.com/6LfmiHD.png" alt=""></p>
<p><code>is_void</code>首先调用<code>remove_cv</code>去掉变量的const和volatile，然后调用<code>__is_void_helper</code>来得到是否为void。这里，每一个步骤都是通过声明泛化和偏特化来实现功能。</p>
<p>is_integral实现：</p>
<p>integral包括：int,long,long long, char，bool,signed char, unsigned char, unsigned int, signed int, …</p>
<p><img src="https://i.imgur.com/U537C8c.png" alt=""></p>
<p>首先去掉const和voliate，然后给<code>__is_ingegral_helper</code>去实现，实现也是采用泛化和偏特化实现的。</p>
<p><code>is_class</code>,<code>is_union</code>,<code>is_enum</code>,<code>is_pod</code>的实现：</p>
<p><img src="https://i.imgur.com/vziWV98.png" alt=""></p>
<p>这些实现都找不到具体的原始实现，认为是交给编译器实现的，所以看不到源码。</p>
<p><code>is_move_assignable</code>:同样找不到源代码</p>
<h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout是标准库的一部分，cout是一个对象，而不是类，类不能被直接使用。</p>
<p><img src="https://i.imgur.com/PsU6tUq.png" alt=""></p>
<p>extern表示cout可以被其他文件使用。</p>
<p><img src="https://i.imgur.com/kfjp9d9.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/05/05/最大公约数和最小公倍数求法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/最大公约数和最小公倍数求法/" itemprop="url">最大公约数和最小公倍数求法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T13:44:14+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/05/05/最大公约数和最小公倍数求法/" class="leancloud_visitors" data-flag-title="最大公约数和最小公倍数求法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          <p>最大公约数可以通过辗转相除法求出，而最小公倍数可以通过最大公约数求出。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/05/最大公约数和最小公倍数求法/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/04/21/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/操作系统/" itemprop="url">操作系统</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T13:44:14+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/21/操作系统/" class="leancloud_visitors" data-flag-title="操作系统">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          <p>多进程视图和文件视图，包括进程管理、内存管理、IO设备和磁盘管理。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/04/21/操作系统/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxpgo.github.io/2019/03/31/C语言实现发送邮件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zxp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平步青云win">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/31/C语言实现发送邮件/" itemprop="url">C语言实现发送邮件</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-31T11:44:14+08:00">
                2019-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/31/C语言实现发送邮件/" class="leancloud_visitors" data-flag-title="C语言实现发送邮件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          <p>telent模拟发送邮件，并利用C语言进行实现。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/03/31/C语言实现发送邮件/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="zxp" />
            
              <p class="site-author-name" itemprop="name">zxp</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">133</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_25774883" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zxpgo/zxpgo" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/feed/" target="_blank" title="LinkedIn">
                      
                        <i class="fa fa-fw fa-globe"></i>LinkedIn</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1165772354@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com" title="Next主题" target="_blank">Next主题</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.rexking6.top" title="青爷博客" target="_blank">青爷博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://me.csdn.net/download/qq_25774883" title="CSDN下载" target="_blank">CSDN下载</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.livere.com/" title="来必力" target="_blank">来必力</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://tongji.baidu.com/web/welcome/login" title="百度统计" target="_blank">百度统计</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://leancloud.cn/" title="LeanCloud" target="_blank">LeanCloud</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ibruce.info/2015/04/04/busuanzi/" title="不蒜子" target="_blank">不蒜子</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://leetcode-cn.com/" title="LeetCode" target="_blank">LeetCode</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div>
<script async src="https//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    访问人数 <span id="busuanzi_value_site_uv"></span>
</span>
</div>


<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; 2018-8 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-"></i> Power by 
  </span>
  <span class="author" itemprop="copyrightHolder">zxp</span>
  
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  




  
  <div id="lv-container" data-uid="MTAyMC8zODgxNC8xNTM0Mg==">
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
	</div>
  











  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2AyV3DKioBSdoryrFLRohzjB-gzGzoHsz", "XynedcHyJCVCrTfbD4yYnodo");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "default";
      
          pbOptions.boxForm = "vertical";
      
          pbOptions.position = "top";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


  
  
  	 <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("2AyV3DKioBSdoryrFLRohzjB-gzGzoHsz", "XynedcHyJCVCrTfbD4yYnodo");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = $(document.getElementById(url)).text() + ' 0';
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = $(document.getElementById(url)).text() + ' ' + object.get('time');
					$(document.getElementById(url)).text(content);
				}
			}
		});

	});
}

</script>
  
</body>
</html>
