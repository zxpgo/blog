<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>移动通信技术</title>
      <link href="/2019/09/06/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/09/06/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>介绍第二代至第四代移动通信技术，以及正在研发的第五代移动通信技术<a id="more"></a></p><table><thead><tr><th>第几代</th><th>移动</th><th>电信</th><th>联通</th></tr></thead><tbody><tr><td>2G</td><td>GSM</td><td>CDMA</td><td>GSM</td></tr><tr><td>3G</td><td>TD-SCDMA</td><td>CDMA2000</td><td>WCDMA</td></tr><tr><td>4G</td><td>TD-LTE</td><td>FDD-LTE和TD-LTE</td><td>FDD-LTE和TD-LTE</td></tr></tbody></table><p>第五代移动通信系统，采用高频段，传输距离缩短，所以需要部署比较密集的基站。</p><h2 id="5G关键技术"><a href="#5G关键技术" class="headerlink" title="5G关键技术"></a>5G关键技术</h2><ul><li>高频传输技术：目前全球使用的3G和4G使用的频段是2GHz左右，频段越低则覆盖率越高，但是低频段谱往往是有限的。为了传输速度更快，高频段需要更宽的带宽与之匹配。</li><li>大规模天线传输技术（MIMO）</li><li>密集网络技术</li></ul><h2 id="5G三大场景"><a href="#5G三大场景" class="headerlink" title="5G三大场景"></a>5G三大场景</h2><ul><li>eMBB:3D/超高清视频等大流量移动宽带业务</li><li>mMMT：大规模物联网业务</li><li>URLLC：如无人驾驶、工业自动化等需要低延时、高可靠连接的业务</li></ul><h2 id="5G三种标准-信道编码"><a href="#5G三种标准-信道编码" class="headerlink" title="5G三种标准(信道编码)"></a>5G三种标准(信道编码)</h2><ul><li>LDPC方案：高通牵头</li><li>Polar方案：华为牵头</li><li>Turbo方案：LG牵头</li></ul>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python2.x和Python3.x的版本区别</title>
      <link href="/2019/08/22/python2.x%E5%92%8Cpython3.x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/22/python2.x%E5%92%8Cpython3.x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>Python 3.0在设计的时候没有考虑向下相容。许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。<a id="more"></a></p><p><a href="https://www.zxpblog.cn/2019/08/22/python2.x和python3.x版本区别/" target="_blank" rel="noopener">pyython3.x和python2.x的版本区别</a></p><p>为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。</p><p>目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。</p><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>python 3.0 中使用print()函数来输出，而不再使用print语句。</p><pre><code>print(&quot;zxp&quot;) #python3.0print &quot;zxp&quot; #python3.0不再支持</code></pre><p>在python2.6和python2.7中，三种形式等价：</p><pre><code>print(&quot;zxp&quot;)# print不能带任何参数print (&quot;zxp&quot;) #print后有空格print &quot;zxp&quot;</code></pre><p>python2.6实际已经支持print()语法：</p><pre><code>seq = &apos;hello&apos;print(&apos;zxp&apos;,&apos;panda&apos;,seq)</code></pre><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>python2中有ASCII str()类型，unicode()是单独的，不是byte类型。<!--more--><br>python3中有Unicode(utf-8)字符串，以及一个字节类：byte和bytearrays。</p><p>python3.x源码文件默认使用utf-8:</p><pre><code>&gt;&gt;&gt;中国 = “china”&gt;&gt;&gt;print(中国)china</code></pre><p>而在python2.x中是语法错误<br></p><p>python2.x</p><pre><code>&gt;&gt;&gt; 中国 = &quot;china&quot;SyntaxError: invalid syntax&gt;&gt;&gt; str = &quot;我是霸王&quot;&gt;&gt;&gt; str&apos;\xce\xd2\xca\xc7\xb0\xd4\xcd\xf5&apos;&gt;&gt;&gt; print str我是霸王&gt;&gt;&gt; str = u&apos;我是霸王&apos;&gt;&gt;&gt; stru&apos;\u6211\u662f\u9738\u738b&apos;</code></pre><p>python3.x</p><pre><code>&gt;&gt;&gt; str = &quot;我是霸王&quot;&gt;&gt;&gt; str&apos;我是霸王&apos;&gt;&gt;&gt; print(str)我是霸王</code></pre><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><p>python中除法包括两个运算符，<code>/</code>和<code>//</code></p><p>python2.x中的<code>/</code>除法，跟java、c相同，整数相除结果是一个整数，把小数忽略掉。浮点数的除法会保留小数部分，得到一个浮点数结果。</p><p>python3.x中<code>/</code>除法对于整数之间相除，结果也会是浮点数</p><p>python2.x</p><pre><code>&gt;&gt;&gt; 3/21</code></pre><p>python3.x</p><pre><code>&gt;&gt;&gt; 3/21.5</code></pre><p>而对于<code>//</code>除法，被称为floor除法(python3.x中的floor)，会对除法的结果自动进行一个floor操作，在python2.x和python3.x中是一致的</p><pre><code>&gt;&gt;&gt; 5//31</code></pre><p>python3.x中floor操作：向下取整，小数不存在</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; math.floor(2.2)2</code></pre><p>python2.x中floor操作：向下取整，小数存在，仍然是浮点数</p><pre><code>&gt;&gt;&gt; math.floor(3.2)3.0</code></pre><p>如果需要取整，需要<code>trunc</code>函数</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; math.trunc(5/3)1</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 Python 3 中我们现在使用 as 作为关键词。捕获异常的语法由 except exc, var 改为 except exc as var。</p><p>使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。</p><ul><li>1在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代，只有继承自BaseException的对象才可以被抛出。</li><li>2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩的写法，直接调用构造函数抛出对象即可。</li></ul><h2 id="创建迭代对象"><a href="#创建迭代对象" class="headerlink" title="创建迭代对象"></a>创建迭代对象</h2><p>在Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。这个表现十分像生成器（比如。”惰性求值”）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。</p><p>在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。</p><p>python2.x中使用xrange()和range()</p><pre><code>&gt;&gt;&gt; range(1,10,2)[1, 3, 5, 7, 9]&gt;&gt;&gt; xrange(1,10,2)xrange(1, 11, 2)&gt;&gt;&gt; list(xrange(1,10,2))[1, 3, 5, 7, 9]</code></pre><p>python3.x中使用range(),内容包含了xrange()</p><pre><code>&gt;&gt;&gt; xrange(10)Traceback (most recent call last):  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;    xrange(10)NameError: name &apos;xrange&apos; is not defined&gt;&gt;&gt; range(10)range(0, 10)&gt;&gt;&gt; list(range(1,10))[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><h2 id="八进制字面量表示"><a href="#八进制字面量表示" class="headerlink" title="八进制字面量表示"></a>八进制字面量表示</h2><p>八进制数必须写成0o777，原来的形式0777不能用了；二进制必须写成0b111。</p><p>新增了一个bin()函数用于将一个整数转换成二进制字串。 Python 2.6已经支持这两种语法。</p><p>在Python 3.x中，表示八进制字面量的方式只有一种，就是0o1000。</p><pre><code>&gt;&gt;&gt; 0777SyntaxError: invalid token&gt;&gt;&gt; 0o777511</code></pre><p>python2.x</p><pre><code>&gt;&gt;&gt; 0777511&gt;&gt;&gt; 0o777511</code></pre><h2 id="不等于运算符"><a href="#不等于运算符" class="headerlink" title="不等于运算符"></a>不等于运算符</h2><p>Python 2.x中不等于有两种写法 != 和 &lt;&gt;</p><p>Python 3.x中去掉了&lt;&gt;, 只有!=一种写法，还好，我从来没有使用&lt;&gt;的习惯</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>python3.x中不再有long类型，只有一种整性int,当它的行为跟python2.x的long相同</p><p>python3.x中，字符串和bytes类型彻底分开了。字符串是以字符为单位进行处理的，bytes类型是以字节为单位处理的。</p><h3 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h3><p>bytes数据类型在所有的操作和使用甚至内置方法上和字符串数据类型基本一样，也是不可变的序列对象。</p><p>bytes对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等。可以通过调用bytes()生成bytes实例，其值形式为 b’xxxxx’，其中 ‘xxxxx’ 为一至多个转义的十六进制字符串（单个 x 的形式为：\x12，其中\x为小写的十六进制转义字符，12为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围0-255），对于同一个字符串如果采用不同的编码方式生成bytes对象，就会形成不同的值.</p><pre><code>b = b&apos;&apos;         # 创建一个空的bytesb = byte()      # 创建一个空的bytesb = b&apos;hello&apos;    #  直接指定这个hello是bytes类型b = bytes(&apos;string&apos;,encoding=&apos;编码类型&apos;)  #利用内置bytes方法，将字符串转换为指定编码的bytesb = str.encode(&apos;编码类型&apos;)   # 利用字符串的encode方法编码成bytes，默认为utf-8类型bytes.decode(&apos;编码类型&apos;)：将bytes对象解码成字符串，默认使用utf-8进行解码。</code></pre><p>对于bytes，我们只要知道在Python3中某些场合下强制使用，以及它和字符串类型之间的互相转换，其它的基本照抄字符串。</p><p>简单的省事模式：</p><p><code>string = b&#39;xxxxxx&#39;.decode()</code> 直接以默认的utf-8编码解码bytes成string</p><p><code>b = string.encode()</code> 直接以默认的utf-8编码string为bytes</p><p>转自：<a href="http://www.runoob.com/python/python-2x-3x.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-2x-3x.html</a><br><a href="https://www.cnblogs.com/R-bear/p/7744454.html" target="_blank" rel="noopener">https://www.cnblogs.com/R-bear/p/7744454.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python实现：8种排序算法</title>
      <link href="/2019/08/22/Python%E5%AE%9E%E7%8E%B08%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/22/Python%E5%AE%9E%E7%8E%B08%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>介绍8中排序算法，包括算法的基本思路和算法的python实现。<a id="more"></a></p><ul><li>选择排序-简单选择排序</li><li>选择排序-堆排序</li><li>插入排序-直接插入排序</li><li>插入排序-希尔排序</li><li>交换排序-快速排序</li><li>交换排序-冒泡排序</li><li>归并排序</li><li>桶排序/基数排序</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>每一趟从待排序的数据元素中选出最小（最大）的元素，顺序放在待排序的数列最前，直到全部待排序的数据元素全部排完。</p><p>例子：<br><br>[4, 2, 3] 找出最小的：2,与第一个元素交换<br><br>[2, 4, 3] 找出最小的：3，与第二个元素交换<br><br>[2, 3, 4] <br></p><p>百度百科： <a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">简单选择排序</a></p><p><strong>算法实现</strong></p><pre><code>def j_sort(a):      l = len(a)      temp = 0      for j in range(0,l-1):            count = j  #记录最小元素下标            #每次找出最小元素            for i in range(j,l-1):                  if a[count] &gt; a[i+1]:                        count = i+1            #交换最小元素和待排序元素中最前一个            &apos;&apos;&apos;if count != j:                  temp = a[j]                  a[j] = a[count]                  a[count] = temp &apos;&apos;&apos;            a[j], a[count] = a[count], a[j] #实现跟上述代码一样      for i in range(0,l):            print(a[i])if __name__ == &quot;__main__&quot;:      a = [10, 2, 5, 1, 3, 7, 3]      j_sort(a)</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong><br><br>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p><p><img src="https://i.imgur.com/JpLbFCa.png" alt=""></p><p>转自：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">堆排序</a></p><p><strong>算法实现</strong></p><pre><code>def d_sort(arr):      l = len(arr)      for i in range(int(l/2-1), -1, -1):            adjustHead(arr,i,l)      # 交换堆顶和最后一个元素，并调整堆结构      for j in range(l-1, 0, -1):            arr[0], arr[j] = arr[j], arr[0] #将堆顶元素和末尾元素进行交换            adjustHead(arr, 0, j) #重新对对进行调整      for k in range(0,l):            print(arr[k])#构造大顶堆            def adjustHead(a, i, l):      temp = a[i] #取出当前元素      k = 2*i + 1 #从左子节点开始，即2*i+1      while k &lt; l:            if k+1 &lt; l &amp; a[k] &lt; a[k+1]: #若果左子节点小于右子节点，k指向右子节点                  k=k+1            if a[k] &gt; temp: #如果子节点大于父节点，将子节点赋值给父节点，并将子节点下标记录下来，后面将父节点值赋值给该子节点                  a[i] = a[k]                  i = k            else:                  break            k = 2*k + 1 #把该节点当作父节点，继续操作      a[i] = temp #将父节点值赋值给该子节点if __name__ == &quot;__main__&quot;:      a = [10,2,4,5]      d_sort(a)</code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序思想：每一趟将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素的适当位置上，直到所有待排序元素元素全部插入为止</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序是假定前i个构成的子序列是处于已排序的情况下进行排序的，然后将第i个元素与前i个构成的子序列逆序进行比较，如果是要升序排序，则比较第i个元素是否比j=i-1(i-1需要&gt;=0)的元素大，如果是则第i个元素的位置（即j+1的位置上）保持不动，反之则将j=i-1的元素放置到i的位置，再进行第i个元素与j=i-2(i-2需要&gt;=0)的,依次进行，如果第i个元素刚好比j=i-3大，则将第i个元素插入到j=i-2（即j+1的位置）上！</p><p>百度百科： <a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">直接插入排序</a></p><p><strong>算法实现</strong></p><pre><code>def zc_sort(a):      l = len(a)      j=0      for i in range(1,l):            temp = a[i]            for j in range(i-1, -1, -1):                  if  temp &lt; a[j]:  #如果第i个元素大于前i个元素中的第j个                        a[j+1] = a[j] #则第j个元素先后移1位                  else:   #如果第i个元素小于等于前i个元素中的第j个则结束循环                        break            a[j+1] = temp #将i个元素赋值给空着的位置      for i in range(0,l):            print(a[i])if __name__ == &quot;__main__&quot;:      a = [1, 10, 5, 2, 6, 7, 2]      zc_sort(a)</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>转自：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">希尔排序</a></p><p><strong>算法实现</strong></p><pre><code>def shell_sort(a):     l = int(len(a)/2)     #生成增量列表     gap_list = []     while l &gt; 0:          gap_list.append(l)          l = int(l/2)     print(gap_list)     for gap in gap_list:#增量gap，并逐步缩小增量           #print(gap)          for i in range(gap, len(a)):#从第gap个元素，逐个对其所在组进行直接插入排序操作               j = i               while j -gap &gt;= 0 and a[j-gap] &gt; a[j]:                    swap(a, j, j-gap)  #交换两个元素                    j = j - gap     for i in range(0,len(a)):          print(a[i])def swap(arr, a, b):     arr[a] = arr[a] + arr[b]     arr[b] = arr[a] - arr[b]     arr[a] = arr[a] - arr[b]if __name__== &quot;__main__&quot;:      a = [1,0,4,-1,2,7,9,8,10, 3,6,5,18]      shell_sort(a)</code></pre><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br><br>一趟快速排序的算法是：<br><br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br><br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0];<br><br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br><br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br><br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><p><strong>注意：快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</strong></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;fromid=2084344" target="_blank" rel="noopener">快速排序</a></p><p><strong>算法实现</strong><br>递归</p><pre><code>def quick_sort(arr, low, high):     #temp = a[0]     i = low     j = high     if i &gt;= j:          return arr     temp = arr[i]     while i &lt; j:          while i &lt; j and arr[j] &gt;= temp:               j = j-1          arr[i] = arr[j]          while i &lt; j and arr[i] &lt;= temp:               i = i + 1          arr[j] = arr[i]     arr[i] = temp     quick_sort(arr, low, i-1)     quick_sort(arr, j+1, high)     return arrif __name__ == &quot;__main__&quot;:     a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8]     quick_sort(a, 0, len(a)-1)     print(a)</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序算法的原理如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ul><p>百度百科： <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">冒泡排序</a></p><pre><code>def bubble_sort(arr):     length = len(arr)     while length &gt; 0:             for i in range(length-1):               if arr[i] &gt; a[i+1]:                    arr[i] = arr[i] + arr[i+1]                    arr[i+1] = arr[i] - arr[i+1]                    arr[i] = arr[i] - arr[i+1]          length -= 1if __name__ == &quot;__main__&quot;:     a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8]     bubble_sort(a)     print(a)</code></pre><h1 id="归并排序（递归）"><a href="#归并排序（递归）" class="headerlink" title="归并排序（递归）"></a>归并排序（递归）</h1><p>本文中的<strong>快速排序</strong>就是一种递归排序<br><br>先递归，在排序<br>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p><p>解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p><p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><p>转自：<a href="https://www.cnblogs.com/lulushow/p/6820727.html" target="_blank" rel="noopener">https://www.cnblogs.com/lulushow/p/6820727.html</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015" target="_blank" rel="noopener">归并排序</a></p><p><strong>算法实现</strong></p><pre><code>def Merge_Sort(lists):    if len(lists) &lt;= 1:        return lists    num = int(len(lists)/2)    left = Merge_Sort(lists[:num]) #将列表从中间分为两部分    right = Merge_Sort(lists[num:])    return Merge(left, right) #合并两个列表def Merge(left,right):    r, l=0, 0    result=[]    while l&lt;len(left) and r&lt;len(right):        if left[l] &lt; right[r]:            result.append(left[l])            l += 1        else:            result.append(right[r])            r += 1    result += left[l:]    result += right[r:]    return resultif __name__ == &quot;__main__&quot;:     a = [10, 7, 4, 2, 8, 5, 1, 3]     a = Merge_Sort(a)     print(a)</code></pre><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序又称为“桶子法”，从低位开始将待排序的数按照这一位的值放到相应的编号为0~9的桶中。等到低位排完得到一个子序列，再将这个序列按照次低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。</p><p><img src="https://i.imgur.com/XVIjAFa.jpg" alt=""></p><p>转：<a href="https://blog.csdn.net/double_happiness/article/details/72452243" target="_blank" rel="noopener">https://blog.csdn.net/double_happiness/article/details/72452243</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="noopener">基数排序</a></p><p><strong>算法实现</strong></p><pre><code>import mathdef radix_sort(arr):     radix = 10 #基数     k = int(math.ceil(math.log(max(arr),radix)))#k可以表示任意整数     #math.log对arr中最大的数取对数，log(max(arr),10),并对其取整得到最大值的位数     bucket =[[] for i in range(radix)]      for i in range(1, k+1):           for  value in arr:               bucket[int(value%(radix**i)/(radix**(i-1)))].append(value) #析取整数第k位数字（从低到高）10**2位10的二次方          del arr[:]          for each in bucket:               arr.extend(each) #桶合并          bucket = [[]for i in range(radix)]if __name__ == &quot;__main__&quot;:     a = [10, 2, 13, 44, 22, 33, 100, 612, 333, 262]     radix_sort(a)     print(a)</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode算法题目</title>
      <link href="/2019/08/22/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2019/08/22/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>leetcode是个<a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">题库</a>，里面有很编程多面试的题目，可以在线编译运行。难度比较高。如果自己能都做出来，对面大公司很有帮助。<a id="more"></a></p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p><strong>示例：</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p><strong>思路：</strong></p><p>利用python实现，先将列表转化为字典dict1，字典的键为列表元素，字典的值为对应元素的下标。</p><p>对于每个元素nums[i]，对于给定的target数，检查字典中是否有键（target-nums[i]）,如果存在则说明，该键对应的值和nums[i]的下标为对应的输出结果。注意该键对应的值不能是i!</p><p><strong>代码：</strong></p><pre><code>class Solution:    def twoSum(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: List[int]        &quot;&quot;&quot;        dict1 = {}        l = len(nums)        for i in range(0,l):            dict1[nums[i]] = i        for i in range(0,l):            temp = target - nums[i]            if (temp in dict1.keys()) and dict1.get(temp) != i:                return [i,dict1.get(temp)]</code></pre><p><strong>算法分析:</strong></p><p>时间复杂度：O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。</p><p>空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。 </p><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>示例：</strong></p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><p><strong>思路：</strong></p><p>考虑到两个链表长度不一，短的列表后面补零。</p><p>最开始的创建一个链表（ll），并赋值一个另一个值(lp)（后面链表的指针需要移动，不指向起始），并创建一个变量来存储进位的值（temp）。</p><p>首先判读两个链表是否都已到达末尾，如果没有，将两个链表的值分别赋值给两个变量（val1和val2）,如果其中一个到达末尾，则val1或val2赋值为0。然后，对两个数进行相加求余数，利用余数创建链表节点(lq)，并接在最先创建的链表(ll)后面，将节点ll先后指向下一个节点，同时计算val1+val2+temp的进位值。如果两个节点都已达到末尾，而此时还需进位值不为零（可以最后两个相加大于9），还需要创建一个节点来存储进位的值，并接在节点ll后面。</p><p><strong>代码：</strong></p><pre><code># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        ll = ListNode(0)        lp = ll        temp = 0        while l1 or l2:            if l1 == None:                val1 = 0            else:                val1 = l1.val                l1 = l1.next            if l2  == None:                val2 = 0            else:                val2 = l2.val                l2 = l2.next            lq = ListNode((val1 + val2 + temp) % 10)            ll.next = lq            ll = ll.next            temp = (val1 + val2 + temp) //10            if l1 == None and l2 == None and temp != 0:                lq = ListNode(temp)                ll.next = lq        return lp.next</code></pre><p><strong>算法分析：</strong></p><p>时间复杂度：O(n)， 我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。</p><p>空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。</p><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 无重复字符的最长子串是 “abc”，其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 无重复字符的最长子串是 “b”，其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 无重复字符的最长子串是 “wke”，其长度为 3。<br>     请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。</p><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>思路</p><p>逐个检查所有的子字符串，看它是否不含有重复的字符。</p><p>算法</p><p>假设我们有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回true，否则会返回false。 我们可以遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为true，那么我们将会更新无重复字符子串的最大长度的答案。</p><p>现在让我们填补缺少的部分：</p><p>为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为i和j。那么我们有 0≤i&lt;j≤n （这里的结束索引 j 是按惯例排除的）。因此，使用 i 从0到 n−1 以及 jj 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。</p><p>要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。</p><p><strong>代码：</strong></p><pre><code>class Solution:    def lengthOfLongestSubstring(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        def allUnique(s, start, end):            st = set()            for i in range(start,end):                if s[i] in st:                    return 0                st.add(s[i])            return 1        l = len(s)        ans = 0        for i in range(0, l):            for j in range(i+1, l+1):                if(allUnique(s,i,j)):                    ans = max(ans, j-i)        return ans</code></pre><h3 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h3><p><strong>代码：</strong></p><pre><code>class Solution:        def lengthOfLongestSubstring(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        n = len(s)        ans = i = j = 0        st = set()        while i &lt; n and j &lt; n:            if s[j] in st:                st.remove(s[i])                i = i+1             else:                st.add(s[j])                j = j + 1                ans = max(ans, j-i)        return ans</code></pre><h3 id="方法三：优化的滑动窗口"><a href="#方法三：优化的滑动窗口" class="headerlink" title="方法三：优化的滑动窗口"></a>方法三：优化的滑动窗口</h3><p><strong>代码：</strong></p><pre><code>class Solution:    def lengthOfLongestSubstring(self, s):    &quot;&quot;&quot;    :type s: str    :rtype: int    &quot;&quot;&quot;    n = len(s)    ans = i = j = 0    d = {} #将存放    st = set()    while j &lt; n:        if s[j] in d.keys():            i = max(i, d.get(s[j]))        ans = max(ans, j-i+1)        d[s[j]] = j + 1        j = j + 1    return ans                </code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进制介绍以及相互转换</title>
      <link href="/2019/08/22/%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/22/%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>进制也就是进位计数制，是人为定义的带进位的计数方法 对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。<a id="more"></a></p><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><ul><li>十进制</li><li>二进制</li><li>四进制</li><li>七进制</li><li>八进制</li><li>十六进制</li></ul><h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>十进制编码几乎就是数值本身。</p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>它由两个数码0，1组成，二进制数运算规律是逢二进一。</p><p>二进制乘法和加法基本运算法则：</p><p>0+0=0，0+1=1，1+0=1，1+1=10</p><p>0×0=0，0×1=0，1×0=0，1×1=1</p><h2 id="四进制"><a href="#四进制" class="headerlink" title="四进制"></a>四进制</h2><p>四进制是以4为基数的进位制，以 0、1、2 和 3 四个数字表示任何实数。</p><p>十进制0-12之间的相互转换：</p><p> <img src="https://i.imgur.com/3sYvUdr.png" alt=""></p><h2 id="七进制"><a href="#七进制" class="headerlink" title="七进制"></a>七进制</h2><p>七进制是以7为基数的计数系统。使用数码0-6。</p><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p>由于二进制数据的基数R较小，所以二进制数据的书写和阅读不方便，为此，在小型机中引入了八进制。八进制的基数R=8=2^3，有数码0、1、2、3、4、5、6、7，并且每个数码正好对应三位二进制数，所以八进制能很好地反映二进制。八进制用下标8或数据后面加O表示 例如：二进制数据 （ 11 101 010 . 010 110 100 ）2 对应八进制数据 (352.264)8或352.264O。</p><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>由于二进制数在使用中位数太长，不容易记忆，所以又提出了十六进制数。</p><p>十六进制数有两个基本特点：它由十六个数码：数字0～9加上字母A-F组成（它们分别表示十进制数10～15），十六进制数运算规律是逢十六进一，即基数R=16=2^4，通常在表示时用尾部标志H或下标16以示区别，在c语言中用添加前缀0x以表示十六进制数。</p><p>例如：十六进制数4AC8可写成（4AC8）16，或写成4AC8H。</p><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>对于任何一个数，我们可以用不同的进位制来表示。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，也可以用八进制表示为71(8)、用十六进制表示为39(16)，它们所代表的数值都是一样的。</p><h2 id="二进制数、十六进制数转换为十进制数（按权求和）"><a href="#二进制数、十六进制数转换为十进制数（按权求和）" class="headerlink" title="二进制数、十六进制数转换为十进制数（按权求和）"></a>二进制数、十六进制数转换为十进制数（按权求和）</h2><p>二进制数、十六进制数转换为十进制数的规律是相同的。把二进制数（或十六进制数）按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”.</p><p>例如：把（1001.01)2 二进制计算。<br><br>解：（1001.01）2<br><br>=8<em>1+4</em>0+2<em>0+1</em>1+0<em>(1/2)+1</em>(1/4)<br><br>=8+0+0+1+0+0.25<br><br>=9.25</p><p>把（38A.11)16转换为十进制数<br><br>解：（38A.11)16<br><br>=3×16的2次方+8×16的1次方+10×16的0次方+1×16的-1次方+1×16的-2次方<br><br>=768+128+10+0.0625+0.0039<br><br>=906.0664</p><h1 id="十进制数转换为二进制数，十六进制数（除2-16取余法）"><a href="#十进制数转换为二进制数，十六进制数（除2-16取余法）" class="headerlink" title="十进制数转换为二进制数，十六进制数（除2/16取余法）"></a>十进制数转换为二进制数，十六进制数（除2/16取余法）</h1><p>整数转换.一个十进制整数转换为二进制整数通常采用除二取余法，即用2连续除十进制数，直到商为0，逆序排列余数即可得到――简称除二取余法．</p><p>例：将25转换为二进制数<br><br>解：25÷2=12 余数1<br><br>12÷2=6 余数0<br><br>6÷2=3 余数0<br><br>3÷2=1 余数1<br><br>1÷2=0 余数1<br>所以25=(11001)2</p><p>同理，把十进制数转换为十六进制数时，将基数2转换成16就可以了.</p><p>例：将25转换为十六进制数<br>解：25÷16=1 余数9<br><br>1÷16=0 余数1<br><br>所以25=(19)16</p><h2 id="二进制数与十六进制数之间的转换"><a href="#二进制数与十六进制数之间的转换" class="headerlink" title="二进制数与十六进制数之间的转换"></a>二进制数与十六进制数之间的转换</h2><p>由于4位二进制数恰好有16个组合状态，即1位十六进制数与4位二进制数是一一对应的.所以，十六进制数与二进制数的转换是十分简单的.</p><p>(1）十六进制数转换成二进制数，只要将每一位十六进制数用对应的4位二进制数替代即可――简称位分四位.<br><br>例：将（4AF8B)16转换为二进制数.<br><br>解： 4 A F 8 B<br><br>0100 1010 1111 1000 1011<br><br>所以（4AF8B)16=(1001010111110001011)2</p><p>(2）二进制数转换为十六进制数，分别向左，向右每四位一组，依次写出每组4位二进制数所对应的十六进制数――简称四位合一位.<br><br>例：将二进制数（000111010110)2转换为十六进制数.<br><br>解： 0001 1101 0110<br><br>1 D 6<br><br>所以（111010110)2=（1D6）16<br><br>转换时注意最后一组不足4位时必须加0补齐4位</p><h2 id="数制转换的一般化"><a href="#数制转换的一般化" class="headerlink" title="数制转换的一般化"></a>数制转换的一般化</h2><p>1）R进制转换成十进制</p><p>任意R进制数据按权展开、相加即可得十进制数据。例如：N = 1101.0101B = 1<em>2^3+1</em>2^2+0<em>2^1+1</em>2^0+0<em>2^-1+1</em>2^-2+0<em>2^-3+1</em>2^-4 = 8+4+0+1+0+0.25+0+0.0625 = 13.3125<br><br>N = 5A.8H = 5<em>16^1+A</em>16^0+8*16^-1 = 80+10+0.5 = 90.5</p><p>2）十进制转换R 进制</p><p>十进制数转换成R 进制数，须将整数部分和小数部分分别转换.</p><p>1.整数转换———除R 取余法 规则：（1）用R 去除给出的十进制数的整数部分，取其余数作为转换后的R 进制数据的整数部分最低位数字； （2）再用R去除所得的商，取其余数作为转换后的R 进制数据的高一位数字； （3）重复执行（2）操作，一直到商为0结束。</p><p>2．小数转换—————乘R 取整法 规则：（1）用R 去乘给出的十进制数的小数部分，取乘积的整数部分作为转换后R 进制小数点后第一位数字； （2）再用R 去乘上一步乘积的小数部分，然后取新乘积的整数部分作为转换后R 进制小数的低一位数字； （3）重复（2）操作，一直到乘积为0，或已得到要求精度数位为止。</p><p>3.小数转换——整数退位法：举例：0.321d转成二进制，由于321不是5的倍数，用取余法、取整法可能要算很久，这时候我们可以采用整数退位法。原理如下：<br><br>n为转成的二进制数的小数位数<br><br>(x)10=(y)2<br><br>(x)10<em>2^n=(y)2</em>2^n<br><br>D=(x)10<em>2^n：计算10进制数，取整<br><br>D→T转成2进制数<br><br>(y)2=T/2^n=T</em>2^(-n)，T退位，位数不足前端补零<br><br>举例:<br><br>0.321转成二进制数，保留7位<br><br>0.321*2^7=41.088,取整数41<br><br>41=32+8+1即100000+1000+1=101001<br><br>退位，因只有6位而要求保留7位，所以是0.0101001</p><p>提炼至：<a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6/317457" target="_blank" rel="noopener">百度百科</a></p>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模式匹配的KMP算法</title>
      <link href="/2019/08/22/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/22/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>简单模式匹配算法的效率不高，原因在于匹配过程中的回溯。KMP匹配算法的时间复杂度是O(m+n)，优于简单算法，原因在于KMP算法到达失配点，串S不需要回溯，串P也不一定要回溯到第1个字符的位置。<a id="more"></a></p><p>模式匹配：设有两个串S和P,称在串中S中找串P的过程为模式匹配。S为主串，P为字串。</p><p>KMP算法的关键是$j$回溯到什么位置，实现KMP算法的关键是求出模式串$P$的每个字符的最大$k$值，$k$是失配时$j$需要向前回溯的最少位置。下一趟比较就可以从$S[i]$和$P[k]$开始。设主串为$S=”s_0s_1{\cdots}s_{n-1}”$，模式串为$P=”p_0p_1{\cdots}p_{m-1}”$，并设在$s_i \neq p_j$处失配。考察P串，如果发现：</p><p>$$p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\tag{1-1} $$</p><p>是失配点前的串$p_0p_1{\cdots}p_{j-1}$中“最长的相同的前缀子串和后缀子串”，其中，$p_0p_1{\cdots}p_{k-1}$是$p_0p_1{\cdots}p_{j-1}$的前缀子串，$p_{j-k}p_{j-k+1}{\cdots}p_{j-1}$是$p_0p_1{\cdots}p_{j-1}$的后缀子串。那么，由于匹配在$s_i \neq p_j$处失败，所以必有：</p><p>$$p_{j-k}{\cdots}p_{j-2}p_{j-1} = s_{i-k}{\cdots}p_{i-2}p_{i-1}\tag{1-2} $$  </p><p>综合式（1-1）和式（1-2）,可得式（1-3）：</p><p>$$p_0{\cdots}p_{k-2}p_{k-1} = s_{i-k}{\cdots}s_{i-2}s_{i-1}\tag{1-3} $$   </p><p>式（1-3）说明，下一趟匹配过程从$s_i$和$p_k$开始，即将模式串中$k$位置的字符和主串中$i$位置的字符对齐后开始下一趟比较。</p><h3 id="1-失败函数f"><a href="#1-失败函数f" class="headerlink" title="1.失败函数f"></a>1.失败函数f</h3><p>设长度为$m$的模式串$P=“p_0p_1{\cdots}p_{m-1}”$，$k$为相同的前、后缀子串长，失败函数定义为：</p><p>$$f(j) =\begin{cases}<br>-1 &amp; j=0\ |<br>\max  \left (k | 0&lt;k&lt;j 且 p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\right )\ |<br>0 &amp; other\<br>\end{cases}\tag{1-4}<br>$$</p><p>从式（1-4）可以看出，失败函数$f(j)$被定义为相同的前、后缀子串长的最大值，其含义为：当匹配在$s_i \neq p_j$处失败，$j$应该回溯的的位置$f(j)$。$f(j) \geq or \ge 0$表示下趟匹配过程从$s_i$和$p_{f(j)}$开始；$f(j)=-1$表示从下趟匹配过程从$s_{i+1}$和$p_0$开始。</p><table><thead><tr><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>P</td><td>a</td><td>b</td><td>c</td><td>a</td><td>b</td><td>c</td><td>a</td><td>b</td><td>b</td><td>a</td><td>c</td></tr><tr><td>$f(j)$</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>0</td><td>1</td></tr></tbody></table><p>$f(j)$的取决于模式串$P$自身的特性。一种特殊的情况，$P$中没有相同的字符出现，或头尾相同，其余不同，则除了$f(0)=-1$外，其他得$f(j)$均为0。也就是说，当到达失配点，$P$均回到第1个字符a_0开始下一趟匹配。</p><h3 id="2-KMP算法的C-程序"><a href="#2-KMP算法的C-程序" class="headerlink" title="2. KMP算法的C++程序"></a>2. KMP算法的C++程序</h3><p>设串P的f值已求得</p><pre><code>int FindKMP(int i, String &amp;P){    if (i&lt;0 || i&gt;n-1){        cout &lt;&lt; &quot;Out of bounds!&quot; &lt;&lt;endl;        return -1;    }    int j=0, m=P.n;    while(i&lt;n &amp;&amp; j&lt;m)    {        if( j==-1 || str[i] == P.str[j])        {            i++; j++;        }        else j=P.f[j];    return ( (j==m)?i-m:-1)    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python2.7和Python3.6安装以及文件解决</title>
      <link href="/2019/08/22/python2.7%E5%92%8Cpython3.6%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/22/python2.7%E5%92%8Cpython3.6%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<p>在实际中，可以需要同时安装python2.7和python3.6版本，在此过程中可以遇到一些问题，在此将一一陈述。<a id="more"></a></p><h2 id="Python2-7和Python3-6并存"><a href="#Python2-7和Python3-6并存" class="headerlink" title="Python2.7和Python3.6并存"></a>Python2.7和Python3.6并存</h2><p>在环境变量中添加Python两个版本的值即可，具体如下：</p><p>右键我的电脑，按下图操作：<br><img src="https://i.imgur.com/XR3VI7D.png" alt=""></p><p>添加值：</p><p><img src="https://i.imgur.com/85ex4wA.png" alt=""></p><p>在环境变量中添加：</p><pre><code>C:\Python27C:\Python27\Scripts    C:\Python36C:\Python36\Scripts</code></pre><p>打开CMD,切换Python2.7和Python3.6</p><pre><code>py -2 切换至python2.7py -3 </code></pre><p><img src="https://i.imgur.com/LtX3Wxy.png" alt=""></p><p>Ctrl+C或 输入<code>exit()</code>退出Python环境</p><p>在具体py文件中，使用</p><pre><code>#! python2# coding: utf-8</code></pre><p>可以指定解释器版本，这时只需py test.py，无需带-2或-3这种参数</p><h2 id="IDLE打开方式"><a href="#IDLE打开方式" class="headerlink" title="IDLE打开方式"></a>IDLE打开方式</h2><p>可以尝试在搜索栏中输入IDLE，然后双击，如果找不到，尝试如下方法：<br>找到<code>C:\Python27\Lib\idlelib</code>下的<code>idle.bat</code>文件，双击即可打开IDLE</p><h2 id="Python2-7的IDLE无法打开问题解决"><a href="#Python2-7的IDLE无法打开问题解决" class="headerlink" title="Python2.7的IDLE无法打开问题解决"></a>Python2.7的IDLE无法打开问题解决</h2><p>打开运行，输入如下代码：</p><pre><code>%USERPROFILE%\.idlerc</code></pre><p>会自动大量如下文件夹：</p><p><img src="https://i.imgur.com/9YIypTY.png" alt=""></p><p>删除文件夹中的三个文件</p><h2 id="pip安装第三方库"><a href="#pip安装第三方库" class="headerlink" title="pip安装第三方库"></a>pip安装第三方库</h2><pre><code>pip2.7 install numpy#仅为python2.7安装numpy库pip3.6 install numpy#仅为python3.6安装numpy库</code></pre><p><img src="https://i.imgur.com/I9XDzyO.png" alt=""></p><p>第三方库安装目录：<code>C:\Python27\Lib\site-packages</code></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DAC-MACS Effective Data Access Control for Multiauthority Cloud Storage Systems</title>
      <link href="/2018/09/06/DAC-MACS-Effective%20Data%20Access%20Control%20for%20Multiauthority%20Cloud%20Storage%20Systems/"/>
      <url>/2018/09/06/DAC-MACS-Effective%20Data%20Access%20Control%20for%20Multiauthority%20Cloud%20Storage%20Systems/</url>
      <content type="html"><![CDATA[<p>论文一<a id="more"></a></p><h1 id="多权威云存储系统的有效数据访问控制"><a href="#多权威云存储系统的有效数据访问控制" class="headerlink" title="多权威云存储系统的有效数据访问控制"></a>多权威云存储系统的有效数据访问控制</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数据访问控制是确保云上数据安全的有效方法。然而，由于数据外包和不可信的云服务器，在云存储系统中，数据访问控制成为了一个挑战性问题。现有的访问控制方案不再适合云存储系统，因为它们针对相同的数据生成多个加密副本，并且要求云服务器完全可信。基于密文策略的属性加密（CP-ABE），对于加密数据的访问策略，是个比较好的技术。但是，由于低效的解密和撤销，现有的CP-ABE方案不能直接应用来构造一个适合多权威中心的云存储系统的访问控制方案。在本文，作者提出了针对多权威云存储系统的访问控制（DAC-MACS）,其是一个高效安全的访问控制方案，并且解密和撤销效率高。另外，作者构造了一个新的多权威（CP-ABE）方案，解密效率高，同时设计一个有效的属性撤销方法，可是保证前向安全和后向安全。进一步，作者给出了一个扩展数据访问控制方案（EDAC-MACS）,其在一个弱安全假设下是安全的。</p><h2 id="一、介绍（Introduction）"><a href="#一、介绍（Introduction）" class="headerlink" title="一、介绍（Introduction）"></a>一、介绍（Introduction）</h2><p>云存储是云计算一个重要的服务。它允许数据拥有者上传数据到云服务器，利用云服务器先用户提供数据访问。数据访问控制是保证数据安全的有效方法。然而由于数据外包，云服务器可能无法完全被信任来提供数据访问控制服务，这意味着存在的基于服务的访问控制方法不再适应于云存储。为了实现不可信服务器的数据访问控制，传统方案经常加密数据并只有用户拥有密码来解密。尽管这种方案可以提供安全访问控制，但是当系统用户变多，密钥管理非常复杂。数据拥有者不得不保持在线来发送密钥给新的用户。甚至，对于每一个数据，存在多个密文副本对于拥有不同密钥的用户，这将因此巨大的存储开销。</p><p>基于密文策略的属性加密（CP-ABE）[2-6]是一种最适合于云存储系统数据访问控制的技术之一，由于它使数据拥有者可以直接的控制访问策略，并不要求数据拥有者去分发密钥。在CP-ABE方案中，有一个权威机构来负责密钥的分发和属性管理。权威中心可以是一个大学的注册办公室，公司的人力部门等等。根据属性每个用户被分配一个私钥。每个用户仅可以解密其属性满足访问策略的密文。</p><p>在云存储系统中，一个用户可能拥有多个权威中心分配的属性，数据拥有者与不同权威机构管理的用户共享数据。例如：在一个电子医疗系统中，医疗数据可能仅分享给被医院分发有“医生”属性的用户，和被医院研究中心分发有“医药研究元”属性的用户。一些CP-ABE方案[7-10]被提出针对多权威系统。然而，由于计算量较大，他们无法直接应用来构造数据访问控制方案。主要，在访问控制中，加密和解密操作要求计算量小。</p><p><em>用户撤销</em>：在云存储系统中，数据访问不是静态的，正如员工的雇佣和解聘，升职和降职，改变用户的属性是非常有必要的。为了保证用户撤销的安全性，满足如下两个要求：1）<strong>后向安全</strong>：撤销用户（其属性被撤销）不能解密新的密文，解密新的密文需要被撤销的属性。2）<strong>前向安全</strong>：新加入的拥有足够属性的用户能过解密以前发布的密文。为了实现者两个要求，一个普通的方法市重新加密所有数据。当数据量非常大时，计算开销也是巨大的。这促使我们去研究一种新的方法，可以高效地处理用户的属性撤销。</p><p><em>解密效率</em>：在CP-ABE系统中，用户需要使用自己的私钥去解密数据。不过，现在，用户通常使用移动设备（比如：智能手机、笔记本等等）来获取云数据，移动设备的计算能力不想PC一样强大。这促使我们去外包主要的解密计算量给云服务器，同时保证云服务器无法获取数据。</p><p>本文，我们首先构造了一个新的多权威CP-ABE方法，解密效率高，并为其提出了高效的属性撤销方案。然后，我们运用它来为多权威云存储系统设计一个高效的访问控制方法。本文的主要贡献可以总结如下：</p><p>1）提出了DAC-MACS（多权威云存储系统的数据访问控制），其是针对多权威中心的云存储系统的，一个高效地，安全地数据访问控制方案。其在预言机模型中是安全的，并且性能优于现有的方案。</p><p>2）构造了一个新的多权威CP-ABE方案，解密效率高。尤其，我们通过使用基于令牌的解密方法来外包解密过程的大部分计算量。</p><p>3）针对多权威CP-ABE方案，设计了一个高效及时的属性撤销方案，可以实现前向安全和后向安全。甚至，在属性撤销过程的通信开销和计算量大大降低。</p><p>与之前的方案[11]相比，我们大大提高了DAC-MACS的安全性，使其更适合于多权威中心的云存储系统。尤其，我们主要研究了由未撤销用户和被破坏用户AA之间共谋引起的安全问题。首先，通过一个安全假设，即未撤销用户不会将其收到的更新密钥发送给撤销用户，来给出一个简单的解决方案。进一步，我们抛弃上面的假设，提出了一种扩展数据访问控制方案（EDAC-MACS），其可以实现同样的安全性能。在EDAC-MACS方案中，即使在任意破坏用户AA帮助下e，撤销用户也无法获取非法的数据访问。没有上面的假设，EDAC-MACS是更符实际的来运用到云存储系统。同时，我们也给出了EDAC-MACS方案的安全分析，证明其在弱安全假设下是安全的。</p><p>论文余下部分内容如下：在第二节，我们定义了系统模型，方案架构以及安全模型。在第三节，我们提出了一种新的多权威CP-ABE方案，具有高效的解密和撤销，并被运用来构造DAC-MACS。在第四节，就安全和性能，我们分析了DAC-MACS。第五节，进一步提出了扩展DAC-MACS方案来保证弱假设下的安全性。第六节，给出了相关工作总结。最后，在第七节，给出了结论。详细地安全证明在附录中给出。</p><h2 id="二、系统模型和安全模型"><a href="#二、系统模型和安全模型" class="headerlink" title="二、系统模型和安全模型"></a>二、系统模型和安全模型</h2><h3 id="A-系统模型"><a href="#A-系统模型" class="headerlink" title="A. 系统模型"></a>A. 系统模型</h3><p>考虑到一个云存储系统有多个权威中心，正如图1所示。系统模型包括五部分：全局证书机构（CA）、属性权威中心（AAs）、云服务器（server）、数据拥有着（owners）、数据使用者（users）。</p><p><img src="https://i.imgur.com/9RQMEbR.png" alt=""></p><p><strong>CA.</strong>在系统种，CA是一个全局被信任的证书颁发机构。它建立系统，并接受系统种所有用户和AAs的注册。对于每个合法用户，对于每个合法的用户，CA分配一个全局唯一身份标识给他，同时生成一个公私钥对给该用户。然后，CA不参与任何属性管理和任何与属性有关私钥的生成。</p><p><strong>AA.</strong>每一个AA是一个独立的属性权威中心，负责根据用户的角色和身份来分发、撤销和更新用户的属性。每一个AA负责为每个其管理的属性生成一个公开属性密钥，并为他们属性所对应的每个用户生成一个私钥。</p><p><strong>Server.</strong>云服务器存储数据拥有着的数据，并向用户提供数据访问控制服务。它也帮助用户进行解密密文，其是通过生成一个解密符合实现。同时，当存在一个属性撤销时，云服务器也帮助用户更新密文。</p><p><strong>Owners.</strong>在外包数据之前，每个数据拥有者通过对称加密技术使用内容密钥（content keys）来加密数据。然后，数据拥有者针对多个AAs的属性定义一个访问控制策略，并在该策略下加密内容密钥。数据拥有者不信任服务器来做数据访问控制。相反，在系统种，他们假设服务器可能将数据给所有用户。但是，访问控制发现生在加密内部。只有当用户属性满足在密文中定义的访问策略，用户才能解密密文。</p><p><strong>Users.</strong>每个用户被分配有一个来自CS的全局用户身份，可以自由地查询来自服务器的密文。为了解密密文，每个用户提交有某些AAs一起发布给它的私钥和全部公钥给云服务器，来请求一个解密令牌。然后，用户使用收到的解密令牌和自己的全局公钥来解密密文。仅仅当用户属性满足在密文中定义的访问策略时，服务器才会生成正确的解密令牌。私钥和用户的全部公钥可以存储在服务器中，随后，如果没有更新密钥用于进一步的解密令牌生成，则用户不需要提交任何密钥。</p><h3 id="B-框架"><a href="#B-框架" class="headerlink" title="B. 框架"></a>B. 框架</h3><p><em>定义1（DAC-MACS）:</em>DAC-MACS架构包括如下几个步骤：</p><p>步骤一：系统初始化：该阶段包括如下算法：</p><ul><li>$CASetup(1^\lambda)\rightarrow (MSK, SP, (sk_{CA},vk_{CA}))$. CA初始化算法的输入仅仅为隐式安全参数$\lambda$。输出为主密钥MSK，系统系数SP,以及一对CA的签名和验证密钥$key(sk_{CA},vk_{CA})$。</li><li>$UserReg(SP,sk_{CA},Info_u) /rightarrow (uid,GPK_{(uid)},GSK_{(uid)},Cert_{(uid)})$.用户注册算法以系统参数SP，CA的签名密钥$sk_CA$和用户信息$Info_u$（即名字、生日等等）作为输入。它验证用户身份，并分配一个全局唯一用户标识$uid$给该用户。其输出用户的标识$uid$,公私钥对$\lbrace GPK_{uid},GSK_{uid} \lbrace$和一个由CA签发的证书$Cert(uid)$。</li><li>$AAReg(Info_{AA}) \rightarrow (aid)$. 属性权威注册算法将属性权威信息作为输入。它验证AA并输出一个全局权威标识$aid$给该AA。</li><li>$AASetup(SP, aid) \rightarrow (SK_{aid}, PK_{aid}, VK_{x_{uid}}, PK_{x_{uid}})$.属性权威初始化算法以系统参数SP和全局权威标识$aid$作为输入。输出一私\公权威密钥对$(SK_{aid},PK_{aid})$,每个属性$x$的版本密钥和公权威密钥集合$\lbrace VK_{x_{aid}},PK_{x_{aid}} \lbrace$。</li></ul><p>步骤二：密钥生成</p><p>-$SKeyGen(SK_{aid},SP,{P_{x_{aid}}},S_{uid,aid},Cert(uid)) \rightarrow SK_{uid,aid}$.私钥生成算法以权威私钥$SK_{aid}$，系统参数$SP$,属性公钥集合%(PK_{x——{aid}})%，描述密钥的属性集合$S_{uid,aid}$和用户的证书$uid$。其输出针对用户$uid$的密钥$SK_{uid,aid}$。</p><p>步骤三： 数据加密</p><ul><li>$Encrypt(SP, \lbrace PK_{k} \rbrace_{k \in I_{A}} \lbrace, PK_{x_k} \rbrace)^{k \in I_A}_{x_{k} \in S_{A_k}},m, alpha) \rightarrow CT$.加密算法以系统参数$SP$、来自相关权威集合$I_{A}$的公钥集合$\lbrace PK_{k} \rbrace_{k \in I_{A}}, \lbrace$、属性公钥$\lbrace, PK_{x_k} \rbrace)^{k \in I_A}_{x_{k} \in S_{A_k}}$、数据$m$和一个来自相关AAs中所有的被选属性的访问结构$alpha$。首先，该算法利用内容密钥$\kappa$使用对称加密方案加密数据$m$；然后，在访问结构$alpha$下加密内容密钥，并输出一个密文$CT$。假设密文隐含地包含访问结构。</li></ul><p>步骤四：数据解密</p>]]></content>
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 日志系统</title>
      <link href="/2018/09/05/Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/09/05/Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>日志数据可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。它可以记录下系统产生的所有行为，并按照某种规范表达出来。可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。收集你想要的数据，分析出有价值的信息，可以提高系统、产品的安全性，还可以帮助开发完善代码，优化产品。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。<a id="more"></a></p><h2 id="一、常见的日志"><a href="#一、常见的日志" class="headerlink" title="一、常见的日志"></a>一、常见的日志</h2><p>日志是一个系统管理员，一个运维人员，甚至开发人员不可或缺的东西，系统永久了偶尔会出现一些错误，需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，需要日志来做问题定位，日志还是过往时间的记录表，可以通过它知道是否被不明用户登陆过等等。</p><p>在linux中大部分的发行版都内置使用syslog系统日志，常见的日志一般存放在<code>var/log</code>中，来看看其他有哪些日志：</p><pre><code>ll /var/log</code></pre><p>根据图中所显示的日志，可以根据服务对象粗略的将日志分为两类：</p><ul><li>系统日志：主要存放系统内置程序或系统内核之类的日志信息如alternative.log,btmp等等；</li><li>应用日志：主要是安装第三方应用所产生的日志，如：tomact7,apache3等等</li></ul><p>系统日志具有有哪些，都记录了怎样的信息：</p><table><thead><tr><th>日志名称</th><th>记录信息</th></tr></thead><tbody><tr><td>alternatives.log</td><td>系统的一些更新替代信息记录</td></tr><tr><td>apport.log</td><td>应用程序崩溃信息记录</td></tr><tr><td>apt/history.log</td><td>使用 apt-get 安装卸载软件的信息记录</td></tr><tr><td>apt/term.log</td><td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td></tr><tr><td>auth.log</td><td>登录认证的信息记录</td></tr><tr><td>boot.log</td><td>系统启动时的程序服务的日志信息</td></tr><tr><td>btmp</td><td>错误的信息记录</td></tr><tr><td>Consolekit/history</td><td>控制台的信息记录</td></tr><tr><td>dist-upgrade</td><td>dist-upgrade 这种更新方式的信息记录</td></tr><tr><td>dmesg</td><td>启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td></tr><tr><td>dpkg.log    dpkg</td><td>命令管理包的日志。</td></tr><tr><td>faillog</td><td>用户登录失败详细信息记录</td></tr><tr><td>fontconfig.log</td><td>与字体配置有关的信息记录</td></tr><tr><td>kern.log</td><td>内核产生的信息记录，在自己修改内核时有很大帮助</td></tr><tr><td>lastlog</td><td>用户的最近信息记录</td></tr><tr><td>wtmp</td><td>登录信息的记录。wtmp可以找出谁正在进入系统，谁使用命令显示这个文件或信息等</td></tr><tr><td>syslog</td><td>系统信息记录</td></tr></tbody></table><p>只闻其名，不见其人，并不能明白这些日志记录的内容。首先我们来看 alternatives.log 中的信息：</p><p><img src="https://i.imgur.com/5z01zYQ.png" alt=""></p><p>从中得到的信息有程序作用，日期，命令，成功与否的返回码</p><p>对于Debain系统，使用apt-get安装软件，因在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了哪个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p><p>其他的日志格式也都类似于之前所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog。</p><p>查看的方法是使用 last 与 lastlog 工具来提取其中的信息</p><p><img src="https://i.imgur.com/xaCBhpO.png" alt=""></p><h2 id="二、配置的日志"><a href="#二、配置的日志" class="headerlink" title="二、配置的日志"></a>二、配置的日志</h2><p>这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。</p><p>这样的实现可以通过两种方式：</p><p>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；<br>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。<br>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具</p><p>rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。</p><p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd</p><p>因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看</p><pre><code>sudo apt-get updatesudo apt-get install -y rsyslogsudo service rsyslog startps aux | grep syslog</code></pre><p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务</p><p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，</p><ul><li>一个是 /etc/rsyslog.conf：主要是配置的环境，即rsyslog加载什么模块</li><li>一个是 /etc/rsyslog.d/50-default.conf：主要是配置的Filter Conditions。</li></ul><p>/etc/rsyslog.conf<br><img src="https://i.imgur.com/1lDH2Ei.png" alt=""></p><p>/etc/rsyslog.d/50-default.conf<br><img src="https://i.imgur.com/BqEWyDg.png" alt=""></p><p>看看 rsyslog 的结构框架，数据流的走向，如下图：</p><p><img src="https://i.imgur.com/YoF835G.png" alt=""></p><p>通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。</p><p><img src="https://i.imgur.com/LXDCZe2.png" alt=""></p><p>Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。</p><p>第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages。而Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看。</p><p>配置中 rsyslog 支持三种配置语法格式：</p><p>sysklogd<br>legacy rsyslog<br>RainerScript<br>sysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 $ModLoad 还有一些插件和特性只在此语法下支持。而以 $ 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置</p><p>老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。</p><p>注释有两种语法:</p><ul><li>井号 #</li><li>C-style /<em> .. </em>/</li></ul><p>执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。</p><p>模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。</p><p>legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么</p><p>模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement）</p><p>如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。</p><p>了解了 rsyslog 环境的配置文件之后，再看向 /etc/rsyslog.d/50-default.conf 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 Parser &amp; Filter Engine,它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，facility 与 priority，其配置格式如下:</p><pre><code>facility.priority　　　　　log_location</code></pre><p>其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 , 分割开,具体可见上图</p><p>rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有：</p><p>| kern    | 内核消息 |<br>| user    | 用户信息    |<br>| mail    |     邮件系统消息    |<br>| daemon    | 系统服务消息    |<br>| auth    | 认证系统    |<br>| authpriv    | 权限系统    |<br>| syslog    | 日志系统自身消息    |<br>| cron    | 计划安排    |<br>| news    | 新闻信息    |<br>| local0~7    | 由自定义程序使用    | </p><p>而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有一下几种：</p><table><thead><tr><th>类别</th><th>解释</th></tr></thead><tbody><tr><td>emergency</td><td>系统已经无法使用了</td></tr><tr><td>alert</td><td>必须立即处理的问题</td></tr><tr><td>critical</td><td>很严重了</td></tr><tr><td>error</td><td>错误</td></tr><tr><td>warning</td><td>警告信息</td></tr><tr><td>notice</td><td>系统正常，但是比较重要</td></tr><tr><td>informational</td><td>正常</td></tr><tr><td>debug</td><td>debug的调试信息</td></tr><tr><td>panic</td><td>很严重但是已淘汰不常用</td></tr><tr><td>none</td><td>没有优先级，不记录任何日志消息</td></tr></tbody></table><p><img src="https://i.imgur.com/BqEWyDg.png" alt=""></p><pre><code>auth,authpriv.*       /var/log/auth.log</code></pre><p>这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 /var/log/auth.log 日志中</p><p>而其中有类似于这样的配置信息意思有细微的差别</p><pre><code>kern.*      -/var/log/kern.log</code></pre><p><code>-</code>代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。</p><p>与日志相关的还有一个还有常用的命令 logger,logger 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。</p><pre><code>#首先将syslog启动起来sudo service rsyslog start#向 syslog 写入数据ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;#查看是否有数据写入sudo tail -f /var/log/syslog</code></pre><p><img src="https://i.imgur.com/Tba1rR8.png" alt=""></p><p>从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板</p><p>我们可以通过 man 来查看 logger 的其他用法，</p><table><thead><tr><th>参数</th><th>内容</th></tr></thead><tbody><tr><td>-i</td><td>在每行都记录进程 ID</td></tr><tr><td>-t</td><td>添加 tag 标签</td></tr><tr><td>-p</td><td>设置日志的 facility 与 priority</td></tr></tbody></table><h2 id="三、转储的日志"><a href="#三、转储的日志" class="headerlink" title="三、转储的日志"></a>三、转储的日志</h2><p>在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。</p><p>logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。</p><p>大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。</p><p>显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件</p><pre><code>cat /etc/logrotate.conf</code></pre><p><img src="https://i.imgur.com/fkmBH7L.png" alt=""></p><pre><code># see &quot;man logrotate&quot; for details  //可以查看帮助文档# rotate log files weeklyweekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )# keep 4 weeks worth of backlogsrotate 4                           //最多转储4次# create new (empty) log files after rotating old onescreate                             //当转储后文件不存在时创建它# uncomment this if you want your log files compressedcompress                          //通过gzip压缩方式转储（nocompress可以不压缩）# RPM packages drop log rotation information into this directoryinclude /etc/logrotate.d           //其他日志文件的转储方式配置文件，包含在该目录下# no packages own wtmp -- we&apos;ll rotate them here/var/log/wtmp {                    //设置/var/log/wtmp日志文件的转储参数    monthly                        //每月转储    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664    rotate 1                       //最多转储一次}</code></pre><p>当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。</p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 进程管理</title>
      <link href="/2018/09/05/Linux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2018/09/05/Linux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>介绍一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。<a id="more"></a></p><h2 id="一、进程查看"><a href="#一、进程查看" class="headerlink" title="一、进程查看"></a>一、进程查看</h2><ul><li><code>top</code>:实时的查看进程的状态</li><li><code>ps</code>:静态查看当前的进程信息</li><li><code>pstree</code>:查看当前活跃进程的属性结构</li></ul><h3 id="1-1-top工具的使用"><a href="#1-1-top工具的使用" class="headerlink" title="1.1 top工具的使用"></a>1.1 top工具的使用</h3><p>top工具是常用的一个查看工具，能实时的查看系统的一些关键信息：</p><pre><code>top</code></pre><p><img src="https://i.imgur.com/YwMabFK.png" alt=""></p><p>top是一个在前台执行的程序，所以执行后变进入到这样的一个交互界面，正因交互界面我们才可以实时的获取到系统于进程的信息，在交互界面我们eyi通过一些指令来操作和筛选，在此之前想了解显示的内容：</p><p>看到top显示的第一排：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>top</td><td>表示当前的程序名称</td></tr><tr><td>09：12：35</td><td>表示当前的系统时间</td></tr><tr><td>up 16 days, 1:09</td><td>表示当前机器已经启动了多长时间</td></tr><tr><td>1 user</td><td>表示当前系统中只有一个用户</td></tr><tr><td>load average: 0.86,0.14,0.19</td><td>分别对应1，5，15分钟内cpu的评价负载</td></tr></tbody></table><p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。</p><p>我们该如何看待这个load average 数据呢？</p><p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。</p><ul><li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li><li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li><li>load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li><li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了</li></ul><p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数</p><pre><code>#查看物理cpu的个数cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l#每个cpu的核心数cat /proc/cpuinfo | grep &quot;physical id&quot; | grep &quot;0&quot; | wc -l</code></pre><p><img src="https://i.imgur.com/xETapiv.png" alt=""></p><p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了</p><ul><li>若是 load &lt; 0.7 并不会去关注他；</li><li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li><li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li><li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li></ul><p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p><p>top 的第二行数据，基本上第二行是进程的一个情况统计</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Tasks: 28 total</td><td>进程总数</td><td>　</td></tr><tr><td>1 running</td><td>1个正在运行的进程数</td></tr><tr><td>26 sleeping</td><td>25个睡眠的进程数</td></tr><tr><td>1 stopped    　</td><td>没有停止的进程数</td></tr><tr><td>0 zombie</td><td>没有僵尸进程数</td></tr></tbody></table><p>top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计</p><p>| 内容    | 解释 |<br>| Cpu(s): 0.6us    | 用户空间进程占用CPU百分比（0.6%）|<br>| 0.2 sy    | 内核空间运行占用CPU百分比（0.2%） |<br>| 0.0 ni    | 用户进程空间内改变过优先级的进程占用CPU百分比（0.0%） |<br>| 98.6 id    | 空闲CPU百分比 |<br>| 0.6 wa    | 等待输入输出的CPU时间百分比 |<br>| 0.0 hi    | 硬中断(Hardware IRQ)占用CPU的百分比 |<br>| 0.0 si    | 软中断(Software IRQ)占用CPU的百分比 |<br>| 0.0 st    | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 | </p><p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。</p><p>top的第四行数据，这一行基本是内存的一个使用情况的统计</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>8175596 total</td><td>物理内存总量</td></tr><tr><td>1677840 free</td><td>空间的物理内存总量</td></tr><tr><td>1806640 used</td><td>使用的物理内存总量</td></tr><tr><td>4691116 buff/cache</td><td>用作内存缓存的内存量</td></tr></tbody></table><blockquote><p>注意：系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和</p></blockquote><p> top 的第五行数据，这一行基本上是交换区的一个使用情况的统计</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>0 total</td><td>交换区总量</td></tr><tr><td>0 free</td><td>空闲的交换区总量</td></tr><tr><td>0 used</td><td>使用的交换区总量</td></tr><tr><td>60208884 avail Mem</td><td>可用交换区总量</td></tr></tbody></table><p>再下面就是进程的一个情况：</p><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>PID</td><td>进程id</td></tr><tr><td>USER</td><td>该进程的所属用户</td></tr><tr><td>PR</td><td>该进程执行的优先级 priority 值</td></tr><tr><td>NI</td><td>该进程的 nice 值</td></tr><tr><td>VIRT</td><td>该进程任务所使用的虚拟内存的总数</td></tr><tr><td>RES</td><td>该进程所使用的物理内存数，也称之为驻留内存数</td></tr><tr><td>SHR</td><td>该进程共享内存的大小</td></tr><tr><td>S</td><td>该进程进程的状态: S=sleep R=running Z=zombie</td></tr><tr><td>%CPU</td><td>该进程CPU的利用率</td></tr><tr><td>%MEM</td><td>该进程内存的利用率</td></tr><tr><td>TIME+</td><td>该进程活跃的总时间</td></tr><tr><td>COMMAND</td><td>该进程运行的名字</td></tr></tbody></table><blockquote><p>注意</p></blockquote><blockquote><p>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低</p></blockquote><blockquote><p>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。</p></blockquote><blockquote><p>其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</p></blockquote><blockquote><p><strong> VIRT </strong>任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数 </p></blockquote><p>top是一个前台程序，所以是一个可以交互的：</p><table><thead><tr><th>常用交互命令</th><th>解释</th></tr></thead><tbody><tr><td>q</td><td>退出程序</td></tr><tr><td>I</td><td>切换显示平均负载和启动时间的信息</td></tr><tr><td>P</td><td>根据CPU使用百分比大小进行排序</td></tr><tr><td>M</td><td>根据驻留内存大小进行排序</td></tr><tr><td>i</td><td>忽略闲置和僵死的进程，这是一个开关式命令</td></tr><tr><td>k</td><td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td></tr></tbody></table><h3 id="1-2-ps工具的使用"><a href="#1-2-ps工具的使用" class="headerlink" title="1.2 ps工具的使用"></a>1.2 ps工具的使用</h3><p>ps也是常用查看进程的工具之一，罗列出所有信息如下：</p><pre><code>ps aux</code></pre><p><img src="https://i.imgur.com/qTY8rOh.png" alt=""></p><p>还可以在查看时，将连同部分的进程呈树状显示出来<br>    ps axjf</p><p><img src="https://i.imgur.com/TiG1vzW.png" alt=""></p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>F</td><td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员root权限</td></tr><tr><td>USER</td><td>进程的拥有用户</td></tr><tr><td>PID</td><td>进程的 ID</td></tr><tr><td>PPID</td><td>其父进程的 PID</td></tr><tr><td>SID</td><td>session 的 ID</td></tr><tr><td>TPGID</td><td>前台进程组的 ID</td></tr><tr><td>%CPU</td><td>进程占用的 CPU 百分比</td></tr><tr><td>%MEM</td><td>占用内存的百分比</td></tr><tr><td>NI</td><td>进程的 NICE 值</td></tr><tr><td>VSZ</td><td>进程使用虚拟内存大小</td></tr><tr><td>RSS</td><td>驻留内存中页的大小</td></tr><tr><td>TTY</td><td>终端 ID</td></tr><tr><td>S or STAT</td><td>进程状态</td></tr><tr><td>WCHAN</td><td>正在等待的进程资源</td></tr><tr><td>START 　</td><td>启动进程的时间</td></tr><tr><td>TIME</td><td>进程消耗CPU的时间</td></tr><tr><td>COMMAND</td><td>命令的名称和参数　</td></tr></tbody></table><p>TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程</p><p>STAT表示进程的状态，而进程的状态有很多，如下表所示</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>R</td><td>Running.运行中</td></tr><tr><td>S</td><td>Interruptible Sleep.等待调用</td></tr><tr><td>D</td><td>Uninterruptible Sleep.不可中断睡眠</td></tr><tr><td>T</td><td>Stoped.暂停或者跟踪状态</td></tr><tr><td>X</td><td>Dead.即将被撤销</td></tr><tr><td>Z</td><td>Zombie.僵尸进程</td></tr><tr><td>W</td><td>Paging.内存交换</td></tr><tr><td>N</td><td>优先级低的进程</td></tr><tr><td>&lt;</td><td>优先级高的进程</td></tr><tr><td>s</td><td>进程的领导者</td></tr><tr><td>L</td><td>锁定状态</td></tr><tr><td>l</td><td>多线程状态</td></tr><tr><td>+</td><td>前台进程</td></tr></tbody></table><p>使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来</p><pre><code>ps -l</code></pre><p>若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用</p><pre><code>ps aux | grep zsh</code></pre><p>当然如果觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示</p><pre><code>ps -afxo user,ppid,pid,pgid,command</code></pre><h3 id="1-3-pstree工具的使用"><a href="#1-3-pstree工具的使用" class="headerlink" title="1.3 pstree工具的使用"></a>1.3 pstree工具的使用</h3><p>通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。</p><pre><code>pstree</code></pre><p><img src="https://i.imgur.com/ofoWvjb.png" alt=""></p><pre><code>pstree -up#参数选择：#-A  ：各程序树之间以 ASCII 字元來連接；#-p  ：同时列出每个 process 的 PID；#-u  ：同时列出每个 process 的所屬账户名称。</code></pre><p><img src="https://i.imgur.com/iaul5wL.png" alt=""></p><h2 id="二、-进程管理"><a href="#二、-进程管理" class="headerlink" title="二、 进程管理"></a>二、 进程管理</h2><h3 id="2-1-kill命令"><a href="#2-1-kill命令" class="headerlink" title="2.1 kill命令"></a>2.1 kill命令</h3><p>当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。</p><p>前面使用 kill 命令来管理一些 job，这里将尝试用 kill 来操作下一些不属于 job 范畴的进程</p><pre><code>#使用9这个信号强制结束 gedit 进程kill -9 1608</code></pre><h3 id="2-2-进程的控制顺序"><a href="#2-2-进程的控制顺序" class="headerlink" title="2.2 进程的控制顺序"></a>2.2 进程的控制顺序</h3><p>在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？</p><p>当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了</p><p>而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制</p><pre><code>#打开一个程序放在后台，或者用图形界面打开nice -n -5 vim &amp;#用 ps 查看其优先级ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim</code></pre><p>还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试</p><pre><code>renice -5 pid</code></pre><p><img src="https://i.imgur.com/iYxWfM0.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016百度校招面试题</title>
      <link href="/2018/09/02/2016%E7%99%BE%E5%BA%A6%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/09/02/2016%E7%99%BE%E5%BA%A6%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>对前面学习命令的一个总结<a id="more"></a></p><h1 id="2016百度校招面试题"><a href="#2016百度校招面试题" class="headerlink" title="2016百度校招面试题"></a>2016百度校招面试题</h1><p>在linux中，对于文本的处理和分析是极为重要的，现在有一个文件叫做data1，同学们可以在这里下载，</p><pre><code>wget http://labfile.oss.aliyuncs.com/courses/1/data1</code></pre><p>里面记录是一些命令的记录，现在需要你从里面找出出现频率次数前3的命令并保存在/home/shiyanlou/result。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>处理文本data</li><li>将结果写入result</li><li><p>结果包含次数和命令，如“100 ls”</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2></li><li><p>cut截取(-c 8明白含义吗)</p></li><li>uniq -dc去重</li><li>sort 的参数选择-k1 -n -r</li><li><p>答案类似于 <code>cat data|....|....|....   &gt;  /home/shiyanlou/result</code></p><p>  cat data1 | cut -c 8- | sort | uniq -dc | sort -n -r &gt; result</p></li></ul><p><strong>解释：</strong></p><p><strong>在去重之间，必须先排序，否则，内容为空，具体原因不太清楚，希望清楚的可以留言，谢谢</strong></p><ul><li>cut -c 8-： 截取第8个字符之后的字符（包括第8个）</li><li>sort: 默认排序</li><li>uniq -dc: 去重并，-c在输出行前面加上每行在输出文件中出现的次数，-d仅显示重复行</li><li>sort -n -r:  按数值从大到小的顺序排列，-r以相反的顺序排序，默认从小到大，-n依照数值的大小排序</li><li>head -n -3 显示头三条</li></ul><p><img src="https://i.imgur.com/ddjM4uA.png" alt=""></p><p><strong>附件：</strong></p><p>sort -t -k:</p><p>-t后面可以设定间隔符，指定间隔符之后，就可以用-k来指定列数</p><p>将如下日期按月份排序</p><p>2017-12-09<br><br>2017-01-20<br><br>2017-04-24<br><br>2017-10-23<br></p><pre><code>sort -n -k 2 -t&apos;-&apos;</code></pre>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下软件安装</title>
      <link href="/2018/09/01/Linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2018/09/01/Linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>在此简单介绍Linux下软件安装，更多可见：<a href="https://www.zxpblog.cn/2018/08/28/Linux不同版本以及程序包安装/" target="_blank" rel="noopener">Linux不同版本以及程序包安装</a><a id="more"></a></p><p>注意本文介绍的都是基于ubuntu</p><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>比如我们想安装一个软件，名字叫做 w3m(w3m是一个命令行的简易网页浏览器)，那么输入如下命令：</p><pre><code>sudo apt-get install w3m</code></pre><p>它就表示将会安装一个软件包名为w3m的软件。</p><h2 id="apt包管理工具介绍"><a href="#apt包管理工具介绍" class="headerlink" title="apt包管理工具介绍"></a>apt包管理工具介绍</h2><blockquote><p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的多个工具，如 apt-get apt-cache apt-cdrom 等，在Debian系列的发行版中使用。</p></blockquote><p>当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了：</p><ul><li>软件源镜像服务器</li><li>软件源</li></ul><p>我们需要定期从服务器上下载一个软件包列表，使用 sudo apt-get update 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，我举个例子：我们安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 apt-get 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。</p><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p>apt-get 是用于处理 apt包的公用程序集，可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具：</p><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td>install</td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td>update</td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td>upgrade</td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update</td></tr><tr><td>dist-upgrade</td><td>解决依赖关系并升级(存在一定危险性)</td></tr><tr><td>remove</td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td>autoremove</td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td>purge</td><td>与remove相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td>clean</td><td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td></tr><tr><td>autoclean</td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><p>下面是一些apt-get常用的参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-y</td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td>-s</td><td>模拟安装</td></tr><tr><td>-q</td><td>静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td>-f</td><td>修复损坏的依赖关系</td></tr><tr><td>-d</td><td>只下载不安装</td></tr><tr><td>–reinstall</td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td>–install-suggests</td><td>同时安装APT给出的建议安装的软件包</td></tr></tbody></table><p>重新安装软件包：</p><pre><code>sudo apt-get --reinstall install w3m</code></pre><p>如果不知软件包完整名的时候，通常使用<code>Tat</code>键补全软件包名。</p><p>软件升级</p><pre><code>#更新软件源sudo apt-get#升级没有依赖问题的软件包sudo apt-upgrade#升级并解决依赖关系sudo apt-get dist-upgrade </code></pre><p>卸载软件</p><pre><code>sudo apt-get remove w3m#不保留配置文件的移除sudo apt-get purge w3m#或者sudo apt-get --purge remove w3m#移除不再需要的被依赖的软件包sudo apt-get autoremove</code></pre><p>软件搜索</p><p>当刚知道了一个软件，想先下载，需要确认仓库里面有没有，就需要用到搜索功能，命令如下：</p><pre><code>sudo apt-cache search softname1 softname2 ....</code></pre><h2 id="使用dpkg"><a href="#使用dpkg" class="headerlink" title="使用dpkg"></a>使用dpkg</h2><blockquote><p>dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。</p></blockquote><blockquote><p>dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。</p></blockquote><p>dpkg常用参数介绍：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>安装指定deb包</td></tr><tr><td>-R</td><td>后面加上目录名，用于安装该目录下的所有deb安装包</td></tr><tr><td>-r</td><td>remove，移除某个已安装的软件包</td></tr><tr><td>-I</td><td>显示deb包文件的信息</td></tr><tr><td>-s</td><td>显示已安装软件的信息</td></tr><tr><td>-S</td><td>搜索已安装的软件包</td></tr><tr><td>-L</td><td>显示已安装软件包的目录信息</td></tr></tbody></table><pre><code>#查看已经安装软件包的安装目录sudo dpkg -L w3m    </code></pre><h2 id="从二进制包安装"><a href="#从二进制包安装" class="headerlink" title="从二进制包安装"></a>从二进制包安装</h2><p>二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可</p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式基础</title>
      <link href="/2018/09/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/09/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>介绍grep，sed，awk这三个命令，而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）。<a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>正则表达式，又被正规表示式、正规表示法、针对表达式、规格表达式、常规表达法（Regular Expression,或regex、regexp、RE）。正则表达式使用单个字符来描述、匹配一系列符合某个句法规则的字符串。在很多编辑器里，正则表达式通常用来检索、替换那些符合某个模式的文本。</p><p>注意区分正则表达式与通配符的差别。</p><ul><li>在文本过滤工具里，都是用正则表达式，比如像awk，sed，等，是针对文件的内容的</li><li>而通配符多用在文件名上，比如查找find，ls，cp，等等</li></ul><p>具体内容对比，可以参考：<a href="https://blog.csdn.net/zgqxiexie/article/details/51184602" target="_blank" rel="noopener">https://blog.csdn.net/zgqxiexie/article/details/51184602</a></p><p>例子：</p><p>一个文件中，包含“shiyanlou”和“shilouyan”这两个字符，同样一个表达式：</p><pre><code>shi*</code></pre><p>如果上述表达式作为正则表达式，它将只能匹配shi；而如果不是正则表达式，而是作为一个通配符，则将同时匹配两个字符串。</p><p>原因：在正则表达式中，<code>*</code>表示匹配前面的子表达式零次或多次，比如它可以匹配”sh”,”shi”,”shii”,”shishi”等等，而作为通配符<code>*</code>表示匹配通配符后面任意多个字符，所以可以匹配文本中的字符串。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><code>|</code>表示分割，比如： <code>boy | gril</code>可以匹配“boy”或者“girl”</p><h3 id="数量限定"><a href="#数量限定" class="headerlink" title="数量限定"></a>数量限定</h3><p>数量限定出了上面讲过的<code>*</code>，还有<code>+</code>和<code>?</code>,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：</p><ul><li><code>+</code>表示前面的字符必须出现至少一次（一次或多次），例如，”goo+gle”可以匹配‘goooogle’,’gooooogle’等；</li><li><code>?</code>表示前面的字符最多出现一次（零次或一次），例如，“colou?r”可以匹配‘colour’和‘color’；</li><li><code>*</code>表示前面的字符可以不出现，也出现一次或者多次，例如，‘0*42’可以匹配42，042，0042，00042等等。</li></ul><h3 id="范围和优先级"><a href="#范围和优先级" class="headerlink" title="范围和优先级"></a>范围和优先级</h3><p><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，可以简单的理解位是否将括号内的模式串作为一个整体。例如，”gr(a|r)y”等价于gray|grey；”(grand)?father”匹配father和grandfather。</p><h3 id="语法部分"><a href="#语法部分" class="headerlink" title="语法部分"></a>语法部分</h3><p>正则表达式有多种不同的风格，下面举例一下常用的作为PCRE子集的适合于<code>perl</code>和<code>python</code>编程语言及<code>grep</code>或<code>egrep</code>的正则表达式匹配规则。</p><blockquote><p>PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库，比Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。</p></blockquote><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>建一个字符标记为一个特殊字符，或一个原义字符，比如，”n”匹配字符“n”, “/n”匹配一个换行符，序列”\“匹配”\”而“(”匹配”(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>{n}</td><td>n是一个非负整数，匹配确定的n次，例如：”o{2}”不能匹配“Bob”种的“o”,但是能匹配“book”种的两个”o”</td></tr><tr><td>{n,}</td><td>n是一个非负整数，至少匹配n次，例如：“o{2,}“不能匹配‘bob’，但可以匹配”foooood“种的所有‘o’, <code>&quot;o{1,}&quot;等价于”o+“,&quot;o{0,}&quot;等价于”o*“</code></td></tr><tr><td>{n,m }</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次，比如“o{1，3}”将匹配“fooooodv”种的前三个o</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td></tr><tr><td>.</td><td>匹配除了”\n“之外的任何单个字符，要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。</td></tr><tr><td>（pattern）</td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用户向后引用。要匹配圆括号字符，请使用“(”或“)”。</td></tr><tr><td>x竖线y</td><td>匹配x或y。 例如”z竖线food“能匹配”z“或”food”.”(z竖线f)oood”则匹配”zood“或”food“。</td></tr><tr><td>[xyz]</td><td>字符集合（character class）。匹配所包含的任意一个字符。例如，”[abc]“可以匹配”plain“中的”a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。</td></tr><tr><td>[^xyz]</td><td>排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td></tr></tbody></table><p><strong>注意</strong>：由于markdown的语法问题，表格中的竖线无法显示，会被编译成表格的一列，所以在表格中使用竖线（’|‘）的地方，写成了中文的“竖线”</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先级为从上到下从左到右，依次降低：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>(), (?:), (?=), []</td><td>括号和中括号</td></tr><tr><td>*、+、?、{n}、{n,}、{n,m}</td><td>限定符</td></tr><tr><td>^、$、\任何元字符</td><td>定位点和序列</td></tr><tr><td><code>｜</code></td><td>选择</td></tr></tbody></table><h2 id="grep模式匹配命令"><a href="#grep模式匹配命令" class="headerlink" title="grep模式匹配命令"></a>grep模式匹配命令</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>grep</code>命令用户打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。<code>grep</code>支持三种正则表达式引擎，分别用三个参数指定：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>POSIX扩展正则表达式，ERE</td></tr><tr><td>-G</td><td>POSIX基本正则表达式，BRE</td></tr><tr><td>-P</td><td>Perl正则表达式，PCRE</td></tr></tbody></table><p>在通过<code>grep</code>命令使用正则表达式之前，先介绍一下它的常用参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>将二进制文件作为文本来进行匹配</td></tr><tr><td>-c</td><td>统计以模式匹配的数目</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示匹配文本所在行的行号</td></tr><tr><td>-v</td><td>反选，输出不匹配行的内容</td></tr><tr><td>-r</td><td>递归匹配查找</td></tr><tr><td>-A n</td><td>n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td>-B n</td><td>n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td></tr><tr><td>–color=auto</td><td>将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><p><img src="https://i.imgur.com/lxmDrMs.png" alt=""></p><h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><h4 id="使用基本正则表达式：BRE"><a href="#使用基本正则表达式：BRE" class="headerlink" title="使用基本正则表达式：BRE"></a>使用基本正则表达式：BRE</h4><ul><li>位置</li></ul><p>查找<code>/etc/group</code>文件中以”shiyanlou“为开头的行</p><pre><code>grep &apos;shiyanlou&apos; /etc/groupgrep &apos;^shiyanlou&apos; /etc/group</code></pre><p><img src="https://i.imgur.com/0yauqRa.png" alt=""></p><ul><li>数量</li></ul><pre><code>#匹配以‘z’开头以‘o’结尾的所有字符串echo &apos;zero\nzo\nzoo&apos; |  grep &apos;z.*o&apos;#匹配以‘z’开头以‘o’结尾，中间包含一个任意字符的字符串echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.o&apos;#匹配以‘z’开头，以任意多个‘o’结尾的字符串echo &apos;zero\nzo\nzoo&apos; | grep &apos;zo*&apos;</code></pre><p><img src="https://i.imgur.com/AFrutHC.png" alt=""></p><ul><li>选择</li></ul><pre><code>#grep默认区分大小写，这里将匹配所有的小写字母echo &apos;1234\nabcd&apos; | greap &apos;[a-z]&apos;#将匹配所有的数字echo &apos;1234\nabcd&apos; | greap &apos;[0-9]&apos;#匹配所有数字echo &apos;1234\nabcd&apos; | greap &apos;[[:digit]]&apos;#匹配所有小写字母echo &apos;1234\nabcd&apos; | greap &apos;[[:lower:]]&apos;#匹配所有大写字母echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:upper:]]&apos;#匹配所有的数字和字母，包括：0-9，a-z,A-Zecho &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:alnum:]]&apos;#匹配所有的字母echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:alpha:]]&apos;</code></pre><p><img src="https://i.imgur.com/XPbf0jn.png" alt=""></p><p>下面包含完整的特殊符号及说明：</p><table><thead><tr><th>特殊符号</th><th>说明</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>代表英文大小写字母及数字，亦即 0-9, A-Z, a-z</td></tr><tr><td>[:alpha:]</td><td>代表任何英文大小写字母，亦即 A-Z, a-z</td></tr><tr><td>[:blank:]</td><td>代表空白键与 [Tab] 按键两者</td></tr><tr><td>[:cntrl:]</td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等</td></tr><tr><td>[:digit:]</td><td>代表数字而已，亦即 0-9</td></tr><tr><td>[:graph:]</td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td>[:lower:]</td><td>代表小写字母，亦即 a-z</td></tr><tr><td>[:print:]</td><td>代表任何可以被列印出来的字符</td></tr><tr><td>[:punct:]</td><td>代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $…</td></tr><tr><td>[:upper:]</td><td>代表大写字母，亦即 A-Z</td></tr><tr><td>[:space:]</td><td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td>[:xdigit:]</td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr></tbody></table><pre><code># 排除字符echo &apos;geek\ngood&apos; | grep &apos;[^o]&apos;</code></pre><p><img src="https://i.imgur.com/i3jDsyH.png" alt=""></p><h3 id="使用扩展正则表达式"><a href="#使用扩展正则表达式" class="headerlink" title="使用扩展正则表达式"></a>使用扩展正则表达式</h3><p>要通过<code>grep</code>使用扩展正则表达式需要加上<code>-E</code>参数，或使用<code>egrep</code>。</p><ul><li>数量</li></ul><pre><code>#只匹配”zo“echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo{1}&apos;#匹配以&apos;zo&apos;开头的所有单词echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo{1,}&apos;</code></pre><p>注意：推荐掌握{n,m}即可，+,?,*，这几个不太直观，且容易弄混淆。</p><p><img src="https://i.imgur.com/oqIBw5Z.png" alt=""></p><ul><li>选择</li></ul><pre><code># 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;$ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -E &apos;www\.(shiyanlou|google)\.com&apos;# 或者匹配不包含&quot;baidu&quot;的内容$ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -Ev &apos;www\.baidu\.com&apos;</code></pre><p><img src="https://i.imgur.com/rsEeFmm.png" alt=""></p><h2 id="sed流编辑器"><a href="#sed流编辑器" class="headerlink" title="sed流编辑器"></a>sed流编辑器</h2><p><code>sed</code>工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text “，意即，用于过滤和转换文本的流编辑器。</p><p>在 Linux/UNIX 的世界里敢称为编辑器的工具，大都非等闲之辈，比如前面的”vi/vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”这些个编辑器。sed与上述的最大不同之处在于它是一个非交互式的编辑器。</p><h3 id="sed常用参数介绍"><a href="#sed常用参数介绍" class="headerlink" title="sed常用参数介绍"></a>sed常用参数介绍</h3><p>sed命令基本格式</p><pre><code>sed [参数] [执行命令] [输入文件] ...#形如sed -i &apos;s/ad/happy&apos; test #表示将test文件中的&quot;sad&quot;替换成happy</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td>-e</td><td>用于在脚本中添加多个执行命令一次执行，在命令行中多个命令通过需要加该参数</td></tr><tr><td>-f filename</td><td>指定执行filename文件中的命令</td></tr><tr><td>-r</td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td>-i</td><td>直接修改输入文件内容，而不是打印到输出标准设备</td></tr></tbody></table><h3 id="sed编译器的执行命令"><a href="#sed编译器的执行命令" class="headerlink" title="sed编译器的执行命令"></a>sed编译器的执行命令</h3><p>sed 执行格式：</p><pre><code>[n1][,n2]command[n1][~step]command# 其中一些命令可以在后面加上作用范围，形如：$ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围$ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串</code></pre><p>其中n1,n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>s</td><td>行内替换</td></tr><tr><td>c</td><td>整行替换</td></tr><tr><td>a</td><td>插入到指定行的后面</td></tr><tr><td>i</td><td>插入到指定行的前面</td></tr><tr><td>p</td><td>打印指定行，通常与-n参数配合使用</td></tr><tr><td>d</td><td>删除指定行</td></tr></tbody></table><h3 id="sed操作举例"><a href="#sed操作举例" class="headerlink" title="sed操作举例"></a>sed操作举例</h3><h4 id="打印指定行"><a href="#打印指定行" class="headerlink" title="打印指定行"></a>打印指定行</h4><pre><code>#打印2-5行nl passwd | sed -n &apos;2,5p&apos;#打印奇数行nl passwd | sed -n &apos;1~2p&apos;</code></pre><p><img src="https://i.imgur.com/wp4CVrc.png" alt=""></p><p>注意：nl 可以将输出的文件内容自动的加上行号</p><h4 id="行内替换"><a href="#行内替换" class="headerlink" title="行内替换"></a>行内替换</h4><pre><code>#文本中”shiyanlou“全局替换成’hehe‘，并纸打印替换的那一行，注意这里不能省略最后的”p“命令sed -n &apos;s/shiyanlou/hehe/gp&apos; passwd</code></pre><p>注意： 行内替换可以结合正则表达式使用。</p><p><img src="https://i.imgur.com/BQNSaoo.png" alt=""></p><h4 id="行间替换"><a href="#行间替换" class="headerlink" title="行间替换"></a>行间替换</h4><pre><code>nl passwd | grep &apos;shiyanlou&apos;#删除第21行sed -n &apos;21c\www.shiyanlou.com&apos; passwd（这里我们只把要删的行打印出来了，并没有真正的删除，如果要删除的话，请使用-i参数）</code></pre><p><img src="https://i.imgur.com/sBRTNbn.png" alt=""></p><h2 id="awk文本处理语言"><a href="#awk文本处理语言" class="headerlink" title="awk文本处理语言"></a>awk文本处理语言</h2><p>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p><p>在大多数linux发行版上面，实际我们使用的是gawk（GNU awk，awk的GNU版本）。</p><p>nawk： 在 20 世纪 80 年代中期，对 awk语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得; gawk： 是 GNU Project 的awk解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序，但不断地对其进行了更新，以包含 NAWK 的特性; mawk 也是awk编程语言的一种解释器，mawk遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言，包含了一些没有在AWK 手册中提到的特色，同时 mawk 提供一小部分扩展,另外据说mawk是实现最快的awk。</p><h3 id="awk的基础概念"><a href="#awk的基础概念" class="headerlink" title="awk的基础概念"></a>awk的基础概念</h3><p>awk所有的操作都是基于pattern（模式）—action(动作)对来完成的，如下面的形式：</p><pre><code>pattern {action}</code></pre><p>它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。</p><p>awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p><h4 id="awk命令基本格式"><a href="#awk命令基本格式" class="headerlink" title="awk命令基本格式"></a>awk命令基本格式</h4><pre><code>awk [-F fs] [-v var=value] [-f prog-file] | &apos;program text&apos;] [file...]</code></pre><p>其中<code>-F</code>参数用于预先指定前面提高的字段分隔符（还有其他指定字段的方式），<code>-v</code>用户预先为<code>awk</code>程序指定变量，<code>-f</code>参数用户指定<code>awk</code>命令要执行的程序文件，或者在不加’-f’参数的情况下直接间程序语句放在这里。最后为<code>awk</code>需要处理的文本输入，且可以同时输入多个文本文件。</p><h3 id="awk操作体验"><a href="#awk操作体验" class="headerlink" title="awk操作体验"></a>awk操作体验</h3><pre><code>vim test#输入文本cat test</code></pre><h4 id="使用swk将文本打印到终端"><a href="#使用swk将文本打印到终端" class="headerlink" title="使用swk将文本打印到终端"></a>使用swk将文本打印到终端</h4><pre><code>awk &apos;{print}&apos; test#或者写成一行awk &apos;{print}&apos; test</code></pre><p>说明:在这个操作中我是省略了pattern，所以awk会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即print打印所有匹配项，这里是全部文本内容</p><p><img src="https://i.imgur.com/3DVhZlj.png" alt=""></p><h4 id="将test的第一行中的每个字段单独显示为一行"><a href="#将test的第一行中的每个字段单独显示为一行" class="headerlink" title="将test的第一行中的每个字段单独显示为一行"></a>将test的第一行中的每个字段单独显示为一行</h4><pre><code>$ awk &apos;{&gt; if(NR==1){&gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3&gt; } else {&gt; print}&gt; }&apos; test# 或者$ awk &apos;{&gt; if(NR==1){&gt; OFS=&quot;\n&quot;&gt; print $1, $2, $3&gt; } else {&gt; print}&gt; }&apos; test</code></pre><p><img src="https://i.imgur.com/ZwgDOrO.png" alt=""></p><p>说明:你首先应该注意的是，这里我使用了awk语言的分支选择语句if,它的使用和很多高级语言如C/C++语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是<code>NR</code>与<code>OFS</code>，这两个是awk内建的变量，<code>NR</code>表示当前读入的记录数，你可以简单的理解为当前处理的行数，<code>OFS</code>表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为<code>\n</code>换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是<code>$N</code>其中N为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了<code>$3</code>。除此之外另一个这里没有出现的<code>$0</code>，它表示引用当前记录（当前行）的全部内容。</p><h4 id="将test的第行以点为分段的字段换成以空格为风格"><a href="#将test的第行以点为分段的字段换成以空格为风格" class="headerlink" title="将test的第行以点为分段的字段换成以空格为风格"></a>将test的第行以点为分段的字段换成以空格为风格</h4><pre><code>$ awk -F&apos;.&apos; &apos;{&gt; if(NR==2){&gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3&gt; }}&apos; test# 或者$ awk &apos;&gt; BEGIN{&gt; FS=&quot;.&quot;&gt; OFS=&quot;\t&quot;  # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开  &gt; }{&gt; if(NR==2){&gt; print $1, $2, $3&gt; }}&apos; test</code></pre><p><img src="https://i.imgur.com/crQqo4i.png" alt=""> <img src="https://i.imgur.com/sdHzSiw.png" alt=""></p><p>说明：这里的<code>-F</code>参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定<code>OFS</code>我们还可以在<code>print</code> 语句中直接打印特殊符号如这里的<code>\t</code>，<code>print</code>打印的非变量内容都需要用””一对引号包围起来。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用<code>BEGIN</code>，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是<code>FS</code>赋值了新的”.”点号代替默认的” “空格</p><h3 id="awk常用的内置变量"><a href="#awk常用的内置变量" class="headerlink" title="awk常用的内置变量"></a>awk常用的内置变量</h3><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td>$0</td><td>当前记录的内容</td></tr><tr><td>$N</td><td>N表示字段号，最大值为NF变量的值</td></tr><tr><td>FS</td><td>字段分隔符，由正则表达式表示，默认为” “空格</td></tr><tr><td>RS</td><td>输入记录分隔符，默认为”\n”，即一行为一个记录</td></tr><tr><td>NF</td><td>当前记录字段数</td></tr><tr><td>NR</td><td>已经读入的记录数</td></tr><tr><td>FNR</td><td>当前输入文件的记录数，请注意它与NR的区别</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认为” “空格</td></tr><tr><td>ORS</td><td>输出记录分隔符，默认为”\n”</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux数据流重定向</title>
      <link href="/2018/09/01/Linux%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2018/09/01/Linux%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      <content type="html"><![CDATA[<p>你可能对重定向这个概念感到些许陌生，但你应该在前面的课程中多次见过&gt;或&gt;&gt;操作了，并知道他们分别是将标准输出导向一个文件或追加到一个文件中。这其实就是重定向，将原本输出到标准输出的数据重定向到一个文件中，因为标准输出(/dev/stdout)本身也是一个文件，我们将命令输出导向另一个文件自然也是没有任何问题的。<a id="more"></a></p><p>常用重定向操作：</p><pre><code>echo &apos;hello shiyanlou&apos; &gt; redirect echo &apos;www.shiyanlou.com&apos; &gt;&gt; redirectcat redirect</code></pre><p><img src="https://i.imgur.com/llngSgM.png" alt=""></p><h2 id="简单的重定向"><a href="#简单的重定向" class="headerlink" title="简单的重定向"></a>简单的重定向</h2><p>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。</p><table><thead><tr><th>文件描述符</th><th>设备文件</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>/dev/stdin</td><td>标准输入</td></tr><tr><td>1</td><td>/dev/stdout</td><td>标准输出</td></tr><tr><td>2</td><td>/dev/stderr</td><td>标准错误</td></tr></tbody></table><blockquote><p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。 </p></blockquote><p>将cat的连续输出（heredoc方式）重定向到一个文件：</p><pre><code>cat &gt; test.cpp &lt;&lt; EOF</code></pre><p>输入需要存入test.cpp文件的内容，输入EOF结束</p><p><img src="https://i.imgur.com/qXfT6xI.png" alt=""></p><p>将一个文件作为命令的输入，标准输出作为命令的输出：</p><pre><code>cat test.cpp</code></pre><p><img src="https://i.imgur.com/z7peKkU.png" alt=""></p><p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出：</p><pre><code>echo &apos;hi&apos; | cat</code></pre><p><img src="https://i.imgur.com/pSNOE2h.png" alt=""></p><p>将echo命令的输出从默认的标准输出重定向到一个普通文件：</p><pre><code>echo &quot;hello world&quot; &gt; redirectcat redirect</code></pre><p><img src="https://i.imgur.com/7aDwgCP.png" alt=""></p><h2 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h2><p>重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：</p><pre><code>#使用cat同时读取两个文件，其中一个存在，一个不存在cat test.c hello.c#可以看到上述命令，输出第一个文件的内容，还在末尾处出现了一条错误信息#下面将输出重定向到一个文件cat test.cpp hello.cpp &gt; somefile</code></pre><p><img src="https://i.imgur.com/62lQw3N.png" alt=""></p><p>遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了：</p><pre><code>#将标准错误重定向到标准输出(2&gt;&amp;1)，再将标准输出重定向到文件，注意要将重定向文件写到前面,2表示标准错误，1表示标准输出，cat test.cpp hello.cpp &gt; somefile 2&gt;&amp;1#或者只用bash提供的特殊的重定向符号`&amp;`将标准错误和标准输出同时重定向到文件cat test.cpp hello.cpp &amp;&gt;somefilehell</code></pre><p><strong>注意</strong>你应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中</p><p><img src="https://i.imgur.com/gNJmXCQ.png" alt=""></p><h2 id="使用tee命令同时重定向到多个文件"><a href="#使用tee命令同时重定向到多个文件" class="headerlink" title="使用tee命令同时重定向到多个文件"></a>使用tee命令同时重定向到多个文件</h2><p>除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用tee命令来实现：</p><pre><code>echo &quot;hello world;&quot; | tee hello</code></pre><p><img src="https://i.imgur.com/UxYABqL.png" alt=""></p><h2 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h2><p>前面的重定向操作都只是临时性的，即对当前命令有效，如何做到重定向对所有命令都有效呢？比如在一个脚本中，仅需要某一部分的命令全部进行重定向，难道要在每个命令上面加上临时重定向的操作吗？当然不需要，可以使用<code>exec</code>命令实现“永久”重定向。<code>exec</code>命令的作用是使用指定的命令替换当前的shell，即使用一个进程替换当前进程，或者指定新的重定向。</p><pre><code>#先开启一个子shellzsh#使用exec替换当前进程的重定向，将标准输出重定向到一个文件exec 1&gt;somefile#下面执行的命令的输出都将重定向到文件中，直到你退出当前shell，或取消exec的重定向lsllexitcat somefile</code></pre><p><img src="https://i.imgur.com/ewhmvXI.png" alt=""></p><h2 id="创建输出文件描述符"><a href="#创建输出文件描述符" class="headerlink" title="创建输出文件描述符"></a>创建输出文件描述符</h2><p>在shell中有9个文件描述符，前面介绍和使用了默认提供的0、1、2文件描述符。另外还可以使用3-8的文件描述符，只是它们默认没有打开而已。</p><p>使用如下命令查看当前shell进程中打开的文件描述符：</p><pre><code>cd /dev/fd/; ls -Al</code></pre><p><img src="https://i.imgur.com/AjSlCTY.png" alt=""></p><p>同样，可以使用<code>exec</code>命令创建新的文件描述符：</p><pre><code>zshexec 3&gt;somefile#先进入目录，在查看，否则可能不能得到正确的结果，然后再回到上一次的目录cd /dev/fd/;ls -Al; cd -#注意下面的命令&gt;和&amp;之间不应该有空格，如果有空格则会报错echo &quot;this a test&quot; &gt;&amp;3cat somefileexit</code></pre><p><img src="https://i.imgur.com/6ylRo5r.png" alt=""></p><h2 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h2><p>上面打开了3号文件描述符，可以使用如下操作将其关闭：</p><pre><code>exec 3&gt;&amp;-cd /dev/fd;ls -Al;cd -</code></pre><p><img src="https://i.imgur.com/LVQ1iRr.png" alt=""></p><h2 id="完全屏蔽命令的输出"><a href="#完全屏蔽命令的输出" class="headerlink" title="完全屏蔽命令的输出"></a>完全屏蔽命令的输出</h2><p>在Linux中有一个被称为“黑洞”的设备文件，所以导入它的数据都将被“吞噬”。</p><p>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。</p><p>可以实利用<code>/dev/null</code>屏蔽命令的输出：</p><pre><code>cat test.cpp hello.cpp 1&gt;/dev/null 2&gt;&amp;1</code></pre><p>上面这样的操作将使你得不到任何输出结果。</p><h2 id="使用xargs分割参数列表"><a href="#使用xargs分割参数列表" class="headerlink" title="使用xargs分割参数列表"></a>使用xargs分割参数列表</h2><p>xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题</p><p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。</p><pre><code>cut -d: -f1 &lt; /etc/passwd | sprt | xargs echo</code></pre><p>上面这个命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。</p><p><img src="https://i.imgur.com/NXaTkqH.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 进程概念</title>
      <link href="/2018/09/01/Linux%20%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/09/01/Linux%20%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。 而在此之前，我们需要对进程的基础知识有一定的了解，才能更好、更有效率的使用Linux 提供的工具。<a id="more"></a></p><h2 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h2><h3 id="1-1-程序与进程"><a href="#1-1-程序与进程" class="headerlink" title="1.1 程序与进程"></a>1.1 程序与进程</h3><p><strong>程序（procedure）</strong>：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。</p><p><strong>进程（process）</strong>：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。</p><p>简单来说，程序是为了完成某种任务而设计的软件，比如vim程序。而进程就是运行中的程序。</p><p>程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下特点：</p><ul><li><p>动态性： 进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</p></li><li><p>并发性： 进程可以做到一个时间段内，有多个进程在运行。程序只是静态的实体，所以不存在并发性。</p></li><li><p>独立性： 进程可以独立分配资源，独立接受调查，独立地运行。</p></li><li><p>异步性： 进程以不可预知的速度向前推进。</p></li><li><p>结构性： 进程拥有代码段、数据段、PCB(进程控制块，进程存在的唯一标识)。也正是因为有结构性，进程才可以做到独立地运行。</p></li></ul><blockquote><p>并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都在执行过）</p></blockquote><blockquote><p>并行：在每一个瞬间，都有多个程序在同时执行，这个必须多个CPU才行</p></blockquote><p>引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。</p><p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。</p><blockquote><p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p></blockquote><p><img src="https://i.imgur.com/BAKla96.png" alt=""></p><h2 id="二、进程的属性"><a href="#二、进程的属性" class="headerlink" title="二、进程的属性"></a>二、进程的属性</h2><h2 id="2-1-进程分类"><a href="#2-1-进程分类" class="headerlink" title="2.1 进程分类"></a>2.1 进程分类</h2><p>进程的分类，可以从两个角度来分：</p><ul><li>以进程的功能与服务的对象来分；</li><li>以应用程序的服务类型来分。</li></ul><p>第一个角度来看，可以分为用户进程与系统进程：</p><ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此来进程可以在用户的控制下运行或关闭。</li><li>系统进程： 通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。</li></ul><p>第二个角度来看，可以将进程分为交换进程、批处理进程、守护进程</p><ul><li>交换进程：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在Linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有进程用的cron（在centos系列为crond）进程，这个进程为crontab的守护进程，可以周期性的执行用户设定的某些任务。</li></ul><h2 id="2-2-进程的衍生"><a href="#2-2-进程的衍生" class="headerlink" title="2.2 进程的衍生"></a>2.2 进程的衍生</h2><p>进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？</p><p>就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？</p><p>我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？</p><blockquote><p>fork-exec是由 Dennis M. Ritchie 创造的</p></blockquote><blockquote><p>fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</p></blockquote><blockquote><p>exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段</p></blockquote><p>子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少，感兴趣的同学可以查查为什么。</p><p>既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p><p>在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。</p><p>如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。</p><p><img src="https://i.imgur.com/BlLyygB.png" alt=""></p><p>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</p><p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</p><p>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</p><p>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</p><p>通过以下的命令我们可以很明显的看到这样的结构</p><pre><code>pstree</code></pre><p>还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的</p><pre><code>ps －fxo user,ppid,pid,pgid,command</code></pre><p><img src="https://i.imgur.com/HS6uTHT.png" alt=""></p><p>可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的</p><p>使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解）</p><p>就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶</p><h2 id="2-3-进程组于Sessons"><a href="#2-3-进程组于Sessons" class="headerlink" title="2.3 进程组于Sessons"></a>2.3 进程组于Sessons</h2><p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</p><p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</p><p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，</p><p>Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。</p><blockquote><p>前台（foreground）就是在终端中运行，能与你有交互的</p></blockquote><blockquote><p>后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p></blockquote><h2 id="2-4-工作管理"><a href="#2-4-工作管理" class="headerlink" title="2.4 工作管理"></a>2.4 工作管理</h2><p>bash（Bourne-Again shell）支持工作控制（job control）,而sh(Bourne shell)不支持。</p><p>并且每个终端或者说bash只能管理当前终端中的job，不能管理其他终端中的job，比如我们当前存在两个bash分别为bash1、bash2，bash1只能管理其自己里面的job并不能管理bash2里面的job。</p><p>当知道一个进程在前台运行时，可以同用<code>Ctrl+C</code>来终止它，但是若在后台的话，则不行。</p><p>可以通过<code>&amp;</code>符号，让命令在后台运行：</p><pre><code>ls &amp; </code></pre><p><img src="https://i.imgur.com/Qw7rGCf.png" alt=""></p><p>图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p><p>我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去</p><p><img src="https://i.imgur.com/f38yS4k.png" alt=""></p><p>其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令</p><pre><code>#后面不加参数提取预设工作，加参数提取指定工作的编号#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber]</code></pre><p><img src="https://i.imgur.com/PIun1nr.png" alt=""></p><p><code>Ctrl+z</code>使得工作停止放置在后台，如果想让其在后台运行，可以使用如下命令：</p><pre><code>#与fg类似，加参则指定，不加参则取预设bg [%jobnumber]</code></pre><p><img src="https://i.imgur.com/e3K8hae.png" alt=""></p><p>既然有办法让放置在后台的工作提至前台或让它从停止变成继续运行在后台，当然也有办法删除一个工作，或者重启等：</p><pre><code>#kill的使用格式如下kill -signal %jobnumber#signal从1-64个信号值可以选择，可以这样查看kill －l</code></pre><p>其中常用的有这些信号值</p><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table><p><img src="https://i.imgur.com/bz6fhk2.png" alt=""></p><p>注意:</p><ul><li><p>若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作</p></li><li><p>若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID</p></li></ul>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ Primer Plus--数据处理（三）</title>
      <link href="/2018/08/31/C++%20Primer%20Plus%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2018/08/31/C++%20Primer%20Plus%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>介绍C++变量的命名规则，以及数据类型<a id="more"></a></p><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><pre><code>int a;a = 5;</code></pre><p>上述语句告诉程序，它正在存储整数，并使用名称a来表示该整数的值。实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为a,并将5复制到该内存单元中，然后，可以在程序中使用a来访问该内存单元。可以通过<code>&amp;</code>运算符来检索a的内存地址。</p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>C++提倡使用有一定含义的变量名，如果表示差旅费，应将其命名为cost_of_trip或costOfTrip，而不要命名为a或x等。必须遵循几种简单的C++命名规则：</p><ul><li>在名称中只能使用字母字符、数字和下划线(_);</li><li>名称的第一个字符不能是数字；</li><li>区分大小写</li><li>不能将C++关键字用作名称</li><li>以两个下划线或下划线和大写字母开头的名称被保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给实现，用作全局标识符；</li><li>C++对于名称的长度无限制，名称中所有的字符都有意义。</li></ul><p>最后两点和前几点不同，因为使用_time_stop或_Donut或__time这样的名称不会导致编译器错误，而会导致不确定性。即，不知道结果将是什么，不出现编译错误的原因是，这样的名称不是非法的，但是要保留给现实使用。全局名称指的是名称被声明的位置。</p><p><strong>命名方案</strong></p><p>在给变量命名时，可能在变量名中加入其他信息，即描述变量类型或内容的前缀，例如，可以将整型变量命名myWeight命名为intMyWeight或nMyWeight,这样，在阅读代码时，一目了然，每个变量的意义和类型。常以这种方式使用的前缀用：str或sz（表示以空字符结束的字符串）、b（表示布尔值）、p (表示指针)、c（表示单个字符）。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型是没有小数部分的数字，比如：98，-86，0。C++提供了好几种整型来存储整数。使用的内存越大，可以表示的整数值范围也越大。另外，有的类型（符号类型）可以表示正值和负值，而有的类型（无符号类型）不能表示负值。术语宽度用户描述存储整数时使用的内存量，使用的内存越多，则越宽。C++的基本整型（按照宽度递增的顺序排序）：</p><ul><li>char:该类型有一些特殊属性，常用来表示字符，而不是数字</li><li>short</li><li>int</li><li>long</li><li>long long</li></ul><p>计算机内存由一些叫做位（bit）的单元组成。C++中short、int、long和long long类型都是通过使用不同数目的位来存储值。</p><p>在不同的系统中，每种的类型的宽度都不一样，C++提供了一种灵活的标准，确保了最小长度（从C语言借鉴而来），如下：</p><ul><li>short至少16位</li><li>int至少与short一样长</li><li>long至少32位，且至少与int一样长</li><li>long long至少64位，且至少与long一样长</li></ul><p>实际上short是short int的简称，long是long int的简称。</p><p><strong>位与字节</strong></p><p>计算机内存的基本单元时位（bit）,字节（byte）通常指的是8位的内存单元。从这个意义上说，字节指的就是描述计算机内存量的度量单位，1KB等于1024字节，1MB等于1024KB。</p><p>8位的内存块可以设置出256种不同的组合，因为每一位由两种设置（0和1）,所以8位的总组合位：2^8-256。因此8位单元可以表示0-255或-128到127。每增加一位，组合数变加倍。</p><p>C++中对字节的定义与此不同，C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说可能取值的数目必须等于或超过字符数目。在美国，基本字符集通过是ASCII和EBCDIC集，它们都可以用8位来容纳，所以在使用这两种字符集的系统中，C++通常包括8位。然而，国际编程可能需要使用更大的字符集，如Uunicode,因此有些实现可能使用16位甚至32位的字符。</p><p>C++中检测类型的长度，sizeof运算符返回类型或变量的长度，单位为字节。 比如：sizeof(int),或者 对一个变量利用sizeof，如：<code>sizeof n_short</code> (short n_short;)。</p><p>在头文件climits（旧版本limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种显示的符合名称。比如：INT_MAX 为int的最大值，CHAR_BIT为字节的位数。 SHRT_MAX为short的最大值，LLONG_MAX为long long的最大值，LONG_MAX为long的最大值。INT_MIN为int的最小值。这里只给出了部分，详细的可以查看书籍P41。</p><p><strong> 符号常量–预处理方式</strong></p><p>climits文件中包含于下面类似的语句行：</p><pre><code>#define INT_MAX 32767</code></pre><p>在C++编译过程中，首先将源代码传给预处理器。在这里，#define和#include一样，也是一个预处理编译指令。该编译指令告诉预处理器：在程序中查找INT_MAX，并将所有的INT_MAX替换为32767。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化将复制和声明合并在一起。如下：</p><pre><code>int n_int = INT_MAX;</code></pre><p>可以将变量初始化为另一个变量，条件是后者是已经定义过，甚至可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中的所有值都已经定义过：</p><pre><code>int uncles = 5;int aunts = uncles;int chairs = aunts + uncles + 4;</code></pre><p>前面的初始化继承自C语言，C++还有另一个C语言没有的初始化语法：</p><pre><code>int wrens(432);</code></pre><p>注意： 如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值将是它被创建之前，相应内存单元保存的值。</p><p>在变量声明时对它进行初始化，可避免以后忘记给它赋值的情况发生。</p><h4 id="C-11初始化方式"><a href="#C-11初始化方式" class="headerlink" title="C++11初始化方式"></a>C++11初始化方式</h4><p>另一种初始化方式，这种方式用户数组和结构，但在C++98中，也可以用于单值变量：</p><pre><code>int hamburgers = {24};</code></pre><p>将大括号初始化器用于单值变量的情形不多，但在C++标准使得这种情形更多了。首先，采用这种方式时，可以使用等号（=）,也可以不使用：</p><pre><code>int emus{7};int rheas = {12}</code></pre><p>其次，大括号可以为空，即变量被初始化为零：</p><pre><code>int rocs = {};int psychis{};</code></pre><h3 id="无符号类型"><a href="#无符号类型" class="headerlink" title="无符号类型"></a>无符号类型</h3><p>前面介绍的4种整数都有一种不能存储负数值的无符号变体。其优点是可以增大变量能够存储的最大值。例如：如果short表示的范围为-32768到32767，则无符号版本的表示范围为0-65535。当然，仅当数值不会为负时才应该使用无符号类型，如人口、件数等。创建无符号版本的基本整性，只需要使用关键词unsigned来修改：</p><pre><code>unsigned short change;unsigned long long lang_lang;</code></pre><p>注意：unsigned 本身是 unsigned int 的缩写。</p><p>对于一个short变量，取short的最大值（32767），对于符号整型，对最大值加一，则该值将变为-32768。对于无符号整型，对最大值加一，则该值将变为：32768。如果将无符号整数0，减一则该值会变成65535。</p><p>可以看出，这些整型变量的行为就像里程表，如果超越了限制，其值将为范围另一端的取值。</p><h3 id="选择整型类型"><a href="#选择整型类型" class="headerlink" title="选择整型类型"></a>选择整型类型</h3><p>int被设置为对目标计算机而言最为“自然”的长度。自然长度指的是计算机处理起来效率最高的长度。如果没有其他要求，则应该使用int。</p><p>如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用32位。即使系统上int为32位，也应该这样。如果存储的值大于20亿，可使用long long。</p><p>如果short比int小，则使用short可以节省内存。通常，仅当有大型整型数组时，才有必要使用short。如果节省内存很重要，则应使用short而不是int，即使它们的长度一样。例如，如果将程序从int为16位的系统移植到int为32的系统，则用户存储int数组的内存量将加倍，但short不会受影响。</p><p>如果只需要使用一个字节，可使用char。</p><h3 id="整型字面量"><a href="#整型字面量" class="headerlink" title="整型字面量"></a>整型字面量</h3><p>整型字面量（常量）是显式地书写常量，如212或1776。C++能够以三种不同的计数方式来书写整型：基数为10、8和16。如果第一位为1~9，则基数为10（十进制）；如果第一位为0，第二位1~7，则基数为8（八进制）；如果前两位为0X或0x，则基数为16（十六进制）。具体进制问题：<a href="https://www.zxpblog.cn/2019/08/22/%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" target="_blank" rel="noopener">转</a></p><p>在默认情况下，cout以十进制格式显示整数，而不管这些整数在程序中如何书写，如：</p><pre><code>int waits = 0X42;cout &lt;&lt; waits; //输出结果为66</code></pre><p>这些表达方式仅仅是为了表达上的方便。例如：如果CGA视频内存段为十六进制B000，则不必在程序中使用之前将它转换为十进制45056，而只需使用0xB000。但是不管把值书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制。</p><p>如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。头文件iostream提供了控制符endl,用于指示cout重起一行。同样，它还提供了控制符dec、hex和oct,分别表示用于指示cout以十进制、十六进制和八进制格式显示整数。</p><pre><code>using namespace std;int chest = 42;cout &lt;&lt; hex;cout &lt;&lt; chest; //输出2acout &lt;&lt; oct;cout &lt;&lt; chest; //输出52</code></pre><p>诸如cout&lt;&lt;hex;等代码不会显示在屏幕上显示任何内容，而只是修改cout显示整数的方式。因此，控制符，hex实际上是一条消息，告诉cout采取何种行为。</p><h3 id="C-如何确定常量的类型"><a href="#C-如何确定常量的类型" class="headerlink" title="C++如何确定常量的类型"></a>C++如何确定常量的类型</h3><p>程序的声明中将特定的整型变量的类型告诉了C++编译器，但编译器是如何确定常量的类型呢？假设在程序中使用一个常量表示一个数字：</p><pre><code>cout &lt;&lt; &quot;Year = &quot; &lt;&lt; 2018 &lt;&lt; endl;</code></pre><p>程序将1492存储为int、long还是其他类型呢？答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型存储为int。</p><p>关于后缀，后缀是放在常量后面的字母，用于表示类型。具体如下：</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>l或L</td><td>long常量</td></tr><tr><td>ul</td><td>unsigned long常量</td></tr><tr><td>ll或LL</td><td>long long常量</td></tr><tr><td>LU或UL</td><td>ungigned long常量</td></tr><tr><td>ull或Ull或uLL或ULL</td><td>unsigned long long 常量</td></tr></tbody></table><p>对于长度，C++中不同进制，采用存储整型的规则不同：</p><table><thead><tr><th>进制</th><th>存储类型</th></tr></thead><tbody><tr><td>十进制</td><td>使用后面能过存储该数的最小类型来表示： int、long 、long long</td></tr><tr><td>八进制和十六进制</td><td>使用后面几种类型中能过存储该数的最小类型来表示： int、unsigned int、long、unsigned long、long long 、unsigned long long</td></tr></tbody></table><p>十六进制数0x9C40（40000）将被表示为unsigned int，这是因为十六进制常用来表示内存地址，而内存地址没有符号。</p><h3 id="char类型：字符和小整数"><a href="#char类型：字符和小整数" class="headerlink" title="char类型：字符和小整数"></a>char类型：字符和小整数</h3><p>char类型是专门为存储字符而设计的。编程语言通过使用字母的数值编码来存储字符。因此char类型是另一种整型。它足够长，能过表示计算机系统中的所有字符—字母、数字、标点符号等等。实际上，很多系统支持的字符不操作128个，因此用一个字节就可以表示所有的符号。虽然，char最常用来处理字符，但也可以将它用做比short更小的整型。</p><p>在美国，最常用的符号集是ASCII字符集。例如，字符A的编码是65，字母M的编码为77。</p><pre><code>char ch;cout &lt;&lt; &quot;Enter a chararcter: &quot; &lt;&lt; endl;cin &gt;&gt; ch;cout &lt;&lt; &quot;Thank you for the &quot; &lt;&lt; ch &lt;&lt; &quot; character&quot; &lt;&lt; endl;</code></pre><p>输入M,结果输出为 Thank you for the M character.程序打印的是M,而不是77。通过查看内存可知，77是存储在变量ch中的值。这种神奇的力量来自cin和cout,而不是char，这些工具完成了转换工作。输入时，cin将键盘输入的M转换为77；输出是cout将77转换为M。</p><p>如果将77存储在int变量中，则cout将把它显示为77(也就是说cout显示两个字符7)。C++中书写字符字面量：将字符用单引号括起来。如’M’。（注意：C++对字符用单引号对字符串使用双引号，这两者差别比较大）。cout引入一项新特性–cout.put()函数，该函数显示一个字符。</p><pre><code>char ch = &apos;M&apos;; int i = ch;cout &lt;&lt; i; //结果为77ch = ch + 1;i = ch;cout &lt;&lt; i //结果为78cout.put(ch); //结果为N</code></pre><p>上面程序中，ch存储的实际上是整数，因此可以对其使用整数操作，如加一。</p><pre><code>char ch;cin &gt;&gt; ch; //输入5，实际上ch存储的整数53（5的ASCII编码）</code></pre><p>上述代码将读取字符“5”.并将其对应的字符编码存储到ch变量中。</p><pre><code>int n;cin &gt;&gt; n; //输入5</code></pre><p>上述代码获取字符“5”，并将其转换为对应的数字5，并存储到n变量中。</p><h4 id="成员函数cout-put"><a href="#成员函数cout-put" class="headerlink" title="成员函数cout.put()"></a>成员函数cout.put()</h4><p>cout.put()成员函数提供了一种显示字符的方法，可以代替&lt;&lt;运算符。cout.put存在的必要性：在c++的Release2.0之前，cout将字符变量显示为字符，而将字符常量（如‘M’和‘N’）显示为数字。问题是，C++早期版本将字符常量存储为int类型。也就是说，‘M’的编码将被存储在一个16或32为单元中。而char变量一般占8位。下面的语句从常量“M”中赋值左边的8位到变ch中：</p><pre><code>char ch = &apos;M&apos;</code></pre><p>遗憾的是，对于cout来说，‘M’和ch看上去有天壤之别，虽然存储的值一样。下面的语句将打印字符M的ASCII码，而不是字符M:</p><pre><code>cout &lt;&lt; &apos;M&apos;;</code></pre><p>但是下面打印字符M:</p><pre><code>cout.put(&apos;M&apos;);</code></pre><p>C++Release2.0之后，将字符常量存储位char类型，而不是int,意味着cout现在可以正确处理字符常量。</p><h4 id="char字面值"><a href="#char字面值" class="headerlink" title="char字面值"></a>char字面值</h4><p>在C++中，书写字符常量的方式有多种，对于常规字符（字母，数字和标点符号），最简单的方法是将字符用单引号括起来。这种表示法代表的是字符的数字编码。例如，ASCII系统中的对应情况如下：</p><ul><li>‘A’为65，即字符A的ASCII</li><li>‘a’为97</li><li>‘0’为48</li><li>‘ ‘为32</li><li>‘!’为33</li></ul><p>这种表示法优于数值编码，更加清晰，而不需要知道编码方。如果系统使用的是EBCDIC,则A的编码值不是65，但’A‘表示的仍然是字符A。</p><p>转义字符： 有些字符不能之间通过键盘输入到程序中，比如：回车等。C++提供了一种特殊的表示方法–转义字符。例如：\”将双引号作为常规字符，\t表示水平制表符等等。</p><p>将转移字符作为字符常量时，应用单引号括起来；将他放在字符串中不要使用单引号。</p><p>基于字符八进制和十六进制编码来使用转义字符。例如，Ctrl+Z的ASCII码为26，对应的八进制编码为032，十六进制编码为0X1a。可以使用下面的转义字符来表示该字符： \032或\x1a。</p>]]></content>
      
      <categories>
          
          <category> C++ Primer Plus学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ Primer Plus--开始学习（二）</title>
      <link href="/2018/08/31/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C++/"/>
      <url>/2018/08/31/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C++/</url>
      <content type="html"><![CDATA[<p>C++基本语法介绍<a id="more"></a></p><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>C++对<strong>大小写敏感</strong>，比如：将cout替换成Cout或COUT，都无法通过编译。</p><p>C++程序包括的元素：</p><ul><li>注释： 由前缀//标识</li><li>预处理器编译指令#include</li><li>函数头： int main()</li><li>编译指令：using namespace</li><li>函数体：用{}括起</li><li>使用C++的cout工具显示消息的语句</li><li>结束main()函数的return语句</li></ul><h2 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h2><pre><code>int main(){    statements    return 0;}</code></pre><p>这几行代码构成了函数的定义。<br>定义由两部分组成：</p><ul><li>第一行：int main()叫函数头（functon definition），函数头对函数与程序其他部分之间的接口进行了总结；</li><li>花括号中包括的部分叫做函数体，函数体指出函数应该做什么计算机指令。</li></ul><h3 id="作为接口的函数头"><a href="#作为接口的函数头" class="headerlink" title="作为接口的函数头"></a>作为接口的函数头</h3><p>C++函数可以被其他函数调用，函数头描述了函数与调用函数之间的接口。</p><ul><li>位于函数名的前部分叫做函数的返回类型，他描述的是从函数返回给调用它的函数的信息。</li><li>函数名括号中的部分叫做形参列表，或参数列表，它描述的是从调用函数传递给被调用的函数的信息。</li></ul><p>注：main()通常不被程序的其他部分调用，而被启动代码调用，启动代码是由编译器添加到程序中的，是程序和操作系统之间的桥梁。</p><p>C++中合法的函数头：</p><pre><code>int main()int main(void)</code></pre><p>main（）中如果结尾未遇到返回语句，则默认添加语句结尾：<code>retrun 0;</code>，不适应于其他函数。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>//</code>表示注释，单行注释</p><p><code>/*</code>注释部分<code>*/</code> 多行注释</p><h2 id="预处理器和iostream文件"><a href="#预处理器和iostream文件" class="headerlink" title="预处理器和iostream文件"></a>预处理器和iostream文件</h2><p>如果程序中使用到C++的输入或输出工具，必须提供如下两行代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;</code></pre><p>注意：以上代码在C++98标准中实现，如果编译器不接受上述两行代码，说明它没有遵守标准C++98。</p><p><code>#include &lt;iostream&gt;</code>指令导致预处理将iostream文件中的内容添加到程序中。iostream中的io指的是输入和输出。C++的输入/输出方案涉及iostream文件中的多个定义。为了使用cout来显示消息，第一个程序需要这些定义。#include编译指令导致iostream文件的内容随源代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将取代程序中的代码行<code>#include &lt;iostream&gt;</code>。源文件并没有被修改，而是源代码文件和iostream组合成的一个复合文件，编译的下一个阶段将使用到该文件。</p><h2 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h2><p>iostream这样的文件叫做包含文件（include file）—由于它被包含在其他文件中，也被叫做头文件（header file）—由于他被包含在文件的起始处。</p><p>C++包含了C中的头文件，C中的头文件以h为扩展名，比如：math.h，仍可以使用C中math.h头文件。C++中的头文件没有扩展名。注意，C中的有些头文件被转换为C++头文件，文件被重新命名，去掉扩展名h，并在文件名称前面添加前缀c(表明来自C语言)。例如：C++版本的math.h为cmath。</p><p>C++旧式风格，头文件以.h结尾，比如：iostream.h</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>如果使用iostream，而不是iostream.h，则应使用下面的命名空间编译指令来使iostream中的定义对程序可用：</p><pre><code>using namespace std;</code></pre><p>这被称之为using编译指令。</p><p>命名空间支持是C++的一项特性，旨在让编写大型程序以及将多个厂商现有的代码组合起的程序时更容易，它还有助于组织程序。一个潜在的问题，当使用两个以及封装好的产品，而它们同时使用了wanda()函数。这样当使用wanda()函数的时候，编译器不知道指的哪个版本。</p><p>命名空间让厂商将其产品封装在一个叫做命令空间的单元中，这样可以用命名空间来指出想使用哪个厂商的产品。Microflop可以将其定义放到一个名为Microflop的命名空间中。这样，其的wanda（）函数的全称为Microflop::wanda();同样，Piscine公司的wanda()版本表示为：Piscine::wanda()。这样，程序就可以使用命名空间来区分不同的版本。</p><p>类、变量和函数是C++编译器的标准组建，它们被放置在命名空间std中。仅当头文件没有扩展h时，情况才是如此。</p><p>实际中如上三种方式等级：</p><pre><code>std:cin&gt;&gt; a;std::cout &lt;&lt;&quot;jjj&quot;;std::cout&lt;&lt;std::endl;using std::cout;using std::endl;using std:cin;using namespace std #偷懒写法</code></pre><h2 id="使用cout进行C-输出"><a href="#使用cout进行C-输出" class="headerlink" title="使用cout进行C++输出"></a>使用cout进行C++输出</h2><pre><code>cout &lt;&lt;&quot;come up&quot;</code></pre><p><code>&lt;&lt;</code>表示把字符串发送给cout，该符号指出了信息流动的路径。cout是一个预定义的对象，知道如何显示字符串、数字和单个字符等等。</p><p>cout对象表示一个流，其属性是在iostream文件中定义的，cout的对象包括一个插入运算符”&lt;&lt;”,它可以将右侧的信息插入到流中。</p><p>上面代码，将字符串插入到输出流中，因此，与其说程序显示了一条消息，不如说它将一个字符串插入到了输出流中。</p><p>注意：插入运算符<code>&lt;&lt;</code>跟按位左移运算符<code>&lt;&lt;</code>一样，其实这是一个运算符重载的例子。通过重载，同一个符合将有不同的含义。编译器通过上下文来确定运算符的含义。C本身也有一些运算符重载，比如：<code>&amp;</code>符合既有地址运算符，又表示AND运算符；<code>*</code>既表示乘法，又表示指针解除引用。</p><h3 id="控制符endl"><a href="#控制符endl" class="headerlink" title="控制符endl"></a>控制符endl</h3><p>endl表示重起一行，在输出流中插入endl将导致屏幕光标移到下一行。endl同样也在头文件iostream中定义，且位于命名空间std中。</p><pre><code>cout&lt;&lt;&quot;The Good, the&quot;;cout&lt;&lt;&quot;Bad,&quot;;</code></pre><p>输出结果：The Good, the Bad,</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p><code>&#39;/n&#39;</code></p><p><code>cout&lt;&lt;endl;</code></p><p>两者区别：enld确保程序继续运行前刷新输出（即将其立即显示在屏幕上）；而使用’\n’不能提供这样的保证。</p><h2 id="C-源代码格式化"><a href="#C-源代码格式化" class="headerlink" title="C++源代码格式化"></a>C++源代码格式化</h2><p>C++中使用’;’表示语句的结尾。因此在C++中，回车的作用就和空格或制表符相同。也就是几条语句可以放在同一行，用空格或制表符隔开。</p><p>C++代码风格：</p><ul><li>每条语句占一行</li><li>每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。</li><li>函数中的语句都要相对花括号进行缩进</li><li>与函数名相关的圆括号周围没有空白</li></ul><h2 id="C-语句"><a href="#C-语句" class="headerlink" title="C++语句"></a>C++语句</h2><p>C++程序是一组函数，而每个函数又是一组语句。C++有好几种语句：声明语句创建变量，复制语句给变量提供一个值。</p><h3 id="声明语句和变量"><a href="#声明语句和变量" class="headerlink" title="声明语句和变量"></a>声明语句和变量</h3><pre><code>int carrots</code></pre><p>这条语句提供了两项信息：</p><ul><li>需要的内存以及该内存单元的名称，具体，这条语句指出程序需要足够的存储来存储一个整数。</li><li>给存储单元指定名称，该声明语句指出，此后程序将使用名称carrots来标识存储在该单元中的值，carrots被称为变量。</li></ul><p><strong>声明变量的重要性</strong>：</p><p>python中，在使用新名称时创建变量，而不用显式地进行声明。看上去比较友好，问题是如果变量名写错，将在不知情的情况下创建一个新的变量。如下：</p><pre><code>castleDark = 34castleDank = castleDark + MoreGhostsprint(castleDark)</code></pre><p>由于castleDank拼写错误，因此所作的修改实践上并没有修改castleDark。这种错误很难发现，因为并没有违反python的任何规则。然后，在C++中，违反了使用变量前必须声明它的规则，因此编译器将捕获这种错误。</p><p>C中的变量声明通常位于函数的开头，不过C++的变量声明没有这种限制，C++的通常做法是在首次使用变量前声明它，这样不必再程序中查找，以了解变量的类型。</p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>赋值语句将赋值给存储单元，例如：</p><pre><code>carrots = 25;</code></pre><p>将整数25赋给变量carrots表示的内存单元。</p><p>符号’=’叫做赋值运算符。C++和C有一项不寻常的特性—可以连续使用赋值运算符。例如：</p><pre><code>int steinway;int baldwin;int yamaha;yamaha = balwin = steinway = 88;</code></pre><p>赋值将从右至左进行。首先，将88被赋值给steinway,然后，steinway的值被赋值给baldwin，继续进行。</p><p>赋值之前可以修改变量的值，比如：</p><pre><code>carrots = carrots - 1;</code></pre><h3 id="cout的新花样"><a href="#cout的新花样" class="headerlink" title="cout的新花样"></a>cout的新花样</h3><p>cout前面都是用来打印字符串，而它还可以用来打印变量：</p><pre><code>cout &lt;&lt; carrots;</code></pre><p>程序没有打印carrots，而是打印存储在carrots中的值，即25。实际上，这将两个操作合而为一。首先，cout将carrots替换为其当前值25；然后，把值转换为合适的输出字符。打印之前，cout必须将整数形式转化为字符的形式。</p><p>字符串’15‘和整数25有天壤之别：</p><ul><li>字符串存储的是书写该该数字时使用的字符，即字符2和5。程序在内部存储的是字符2和字符5的编码。要打印字符串，cout只需要打印字符串中的各个字符即可。</li><li>整数25被存储为数值，计算机不是单独存储每个数字，而是将25存储为二进制数。</li></ul><p>C语言中，使用特殊代码（%s和%d）来指出打印字符串和整数。如果让printf()打印字符串，但又错误的提供了一个整数，由于printf()不够精密，因此根本发现不了错误，而是输出一串乱码。</p><pre><code>printf(&quot;%s&quot;, &quot;25&quot;);printf(&quot;%d&quot;, 25);</code></pre><p>而C++中cout比较智能，其智能来自C++的面向对象特性。实际中，C++插入运算符（&lt;&lt;）将根据其后的数据类型相应的调整其行为，这是一个运算符重载的例子。</p><h2 id="其他C-语句"><a href="#其他C-语句" class="headerlink" title="其他C++语句"></a>其他C++语句</h2><h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><pre><code>cin &gt;&gt; carrots;</code></pre><p>从这条语句，可知，信息从cin流向carrots。cin使用&gt;&gt;运算符从输入流中抽取字符，运算符右侧提供一个变量，以接受抽取的信息。”&lt;&lt;”和”&gt;&gt;”用来指示信息流的方向。</p><p>cin同样是一个智能对象，它可以将通过键盘输入的一系列字符（即输入）转换为接受信息的变量能过接受的形式。</p><pre><code>int carrots;cin &gt;&gt; carrots;</code></pre><p>上述例子，程序将carrots声明为一个整性变量，因此输入被转换为计算机用来存储整数的数字形式。</p><h3 id="cout进行封装"><a href="#cout进行封装" class="headerlink" title="cout进行封装"></a>cout进行封装</h3><pre><code>cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots&quot; &lt;&lt; endl;</code></pre><p>跟如下代码等价：</p><pre><code>cout &lt;&lt; &quot;Now you have &quot;;cout &lt;&lt; carrots ;cout &lt;&lt; &quot; carrots&quot;;cout &lt;&lt; endl;</code></pre><p>也可写成如下形式：</p><pre><code>cout &lt;&lt; &quot;Now you have &quot;     &lt;&lt; carrots     &lt;&lt; &quot; carrots&quot;     &lt;&lt; endl;</code></pre><h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><p>类是用户定义的一种数据类型。类之于对象就像类型之于变量，即类定义描述的是数据格式及其用法，而对象则是根据数据格式创建的实体。比如：类就好比所有著名演员，则对象就是好比某个著名演员，如，蛙人Kermit。扩展这种类比，表示演员的类中包括该类可执行的操作的定义，如念某句台词，表达悲伤，接受奖励。</p><pre><code>int carrotss;</code></pre><p>上面的代码创建了一个类型为int的变量（carrots）。也就是说，carrots可以存储整型，可以按特定的方式使用—例如，用户加和减。</p><p>又如，cout是一个ostream类对象，ostream类定义描述了ostream对象表示的数据以及可以对它执行的操作。如将数字或字符串插入到输出流中。同样，cin是一个istream类，也定义在iostream中。</p><p><strong>注意</strong>：类描述了一种数据类型的全部属性，包括可使用它执行的操作，对象是根据这些描述创建的实体。</p><p>类描述指定了可对类对象执行的所有操作，要对特定对象执行这些允许的操作，需要给该对象发送一条消息。例如：希望cout对象显示一个字符串，应向它发送一条消息，告诉它，“对象，显示这些内容！”。</p><p>C++提供了两种发送消息的方式：</p><ul><li>使用类方法（本质上就是函数调用）；</li><li><p>重新定义运算符，cin和cout采用的就是这种方式。</p><p>  cout &lt;&lt; “I am not a crook”;</p></li></ul><p>上面的语句使用重新定义&lt;&lt;运算符将‘显示的消息’发送给cout。消息带有一个参数—即显示的字符串。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++函数分为两类：有返回值和无返回值。</p><h3 id="使用有返回值的函数"><a href="#使用有返回值的函数" class="headerlink" title="使用有返回值的函数"></a>使用有返回值的函数</h3><p>有返回值的函数将生成一个值，而这个值可赋给变量或在其他表达式中使用。例如，C/C++库中的sqrt()函数，它返回平方根，如下：</p><pre><code>x = sqrt(6.25);</code></pre><p>表达式sqrt(6.25)将调用sqrt()函数，表达式sqrt(6.25)被称为<strong>函数调用</strong>，被调用的函数被称为<strong>被调用函数</strong>（called function）,包含函数调用的函数叫做<strong>调用函数</strong>。</p><pre><code>int main(){    x = sqrt(6.25)}</code></pre><p>其中的main()函数叫做调用函数， sqrt()叫做被调用函数。括号中的值6.25是发送给函数(sqrt())的消息，以这种方式发送给函数的值叫做参数。<br>被调用函数返回的值叫做函数的返回值（return value）。</p><p><strong>函数原型</strong>之于函数就像变量声明之于变量—指出涉及的类型。例如，C++库将sqrt()函数定义成将一个看（可能）带小数部分的数字（6.25）作为参数，并返回一个相同类型的数字。sqrt()的函数原型如下：</p><pre><code>double sqrt(double);//函数原型</code></pre><p>第一个double意味着sqrt()返回一个double值，括号中的double一位sqrt()需要一个double参数。因此该原型对sqrt()的描述和下面代码中使用的函数相同：</p><pre><code>double x;x = sqrt(6.25);</code></pre><p>原型结尾的分号表明它是一条语句，这使得它是一个原型，而不是函数头。如果省略分号，编译器将把这行代码解释为函数头，并要求提供函数体。</p><p>在程序中使用sqrt()是，必须通过原型，可以用两种方式提供来实现：</p><ul><li>在源代码文件中输入函数原型</li><li>包含头文件cmath（老系统math.h），其中定义了原型</li></ul><p>第二种方法更好，因为头文件更有可能使原型正确。对于C++库中的每个函数，都在一个或多个头文件中提供了其原型，可以通过手册或在线帮助查看函数描述来确定应使用哪个头文件。</p><p>函数原型和函数定义不要混淆，可以看出：</p><ul><li>函数原型只描述函数接口，也就是说，它描述的是发送给函数的信息和返回的信息</li><li>而函数定义包含了函数的代码，如计算平方根的代码</li></ul><p>C/C++将库函数的这两项特性（原型和定义）分开，库文件中包含了函数的编译代码，而头文件中则包含了原型。</p><pre><code># include &lt;iostream&gt;# include &lt;cmath&gt;int main(){    using namespace std;    double area;    cin &gt;&gt; area; //area = 152 ,cin智能地将其转化为152.0（double类型）    double side;    side =  sqrt(area); //double  side =  sqrt(area)//初始化    cout &lt;&lt; side;    return 0;}</code></pre><h3 id="使用函数库"><a href="#使用函数库" class="headerlink" title="使用函数库"></a>使用函数库</h3><p>C++库函数存储在库文件中，编译器编译程序时，它必须在库文件搜索您使用的函数。至于自动搜索哪个库文件，将因编译器而异。如果运行程序时，得到一条消息，指出_sqrt()是一个没有定义的外部函数，则很可能是由于编译器不能自动搜索math库，（编译器倾向于给函数名添加下划线前缀—提示它们对程序具有最后的发言权）。如果在Linux(Gnu编译器)中遇到该问题，可能需要在命令行末尾添加<code>-lm</code>选项：</p><pre><code>g++ sqrt.cpp -lm</code></pre><p>Unix系统，同样添加’-lm’选项。</p><h3 id="函数变体"><a href="#函数变体" class="headerlink" title="函数变体"></a>函数变体</h3><p>有些函数需要多项信息，这些函数使用多个参数，参数间使用都号分开。例如，数据函数pow()接受两个参数，返回值为以第一个参数为底，第二参数为指数的幂，该函数的原型如下：</p><pre><code>double pow(double,double);double answer = pow(5.0, 8.0);</code></pre><p>不接受参数的函数,原型如下：</p><pre><code>int rand(void)</code></pre><p>没有返回值的函数，例如，编写一个函数，它按美元、美分格式蔑视数字，当向它传递参数23.5时，它将在屏幕上显示$23.5。原型如下：</p><pre><code>void bucks(double)</code></pre><h3 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h3><pre><code>#include &lt;iostream&gt;void simon(int); //函数原型int main(){    using namespace std;    simon(3)//调用函数simon    int count;    cin &gt;&gt;count;    simon(count);    count &lt;&lt; &quot;Done!&quot; &lt;&lt; endl;    return 0;}void simon(int n)//定义simon函数{    using namespace std;    cout &lt;&lt; &quot;Simon says touch your toes &quot; &lt;&lt; n &lt;&lt; &quot; times.&quot; &lt;&lt;endl;}</code></pre><p>函数格式：</p><pre><code>type functionsname(arguementlist){    statements;}</code></pre><p>C++中定义的函数一般位于main()之后，不允许将函数定义嵌套在另一个函数定义中，每个函数的定义都是独立的，所有创建的函数的时平等的。</p><p>函数头：</p><p>上述程序的函数头为：</p><pre><code>void simon(int n)</code></pre><p>void表明没有返回值，因此调用simon()不会生成可在main()中将其赋给变量的数字。因此函数调用方式如下：</p><pre><code>simon(3);</code></pre><p>括号中的<code>int n</code>表明，使用simon()时，应提供一个int参数。函数调用时，传递的值将被赋值给n。</p><pre><code>int main()</code></pre><p>开头的int表明，main()返回一个整数值，空括号表明，main()没有参数。对于有返回值的函数，应使用关键字return来提供返回值，并结束函数。入main()函数末尾：</p><pre><code>return 0;</code></pre><p>main()函数的返回值返回给操作系统，并不是返回给程序的其他部分。通常的约定，退出值为0则意味着程序运行成功，为非0则意味着存在问题。如果，C++程序无法打开文件，可以将它设计为返回一个非零值。</p><p><strong>关键字</strong></p><p>关键字是计算机语言中的词汇，比如：int、void、return和double。因为这心关键字有专用，因此不能用作他用。<strong>另外main不是关键字，当最好不要将其用作变量名，不然会引发错误</strong>。</p><h3 id="用户定义的有返回值的函数"><a href="#用户定义的有返回值的函数" class="headerlink" title="用户定义的有返回值的函数"></a>用户定义的有返回值的函数</h3><pre><code># include &lt;iostream&gt;int stonetolb(int); //原型声明int main(){    using namespace std;    int stone = 4;    int pounds = stonebolb(stont); //接受调用函数的返回值    count &lt;&lt; pounds &lt;&lt; endl;    return 0;}int stonetolb(int sts) //函数定义{    return 14 * sts; //函数返回值}</code></pre><h3 id="在多函数程序中使用using编译指令"><a href="#在多函数程序中使用using编译指令" class="headerlink" title="在多函数程序中使用using编译指令"></a>在多函数程序中使用using编译指令</h3><p>将编译指令放在函数外面，所有函数都可以访问命名空间std:</p><pre><code>#include &lt;iostream&gt;using neamespace std;void simon(int);int main(){        sinmon(3);    return 0;} void simon(int n){    cout &lt;&lt; n;}</code></pre><p>当前通行的理念是，只让需要访问命名空间std的函数访问它是更好的选择。例如只有mian()函数使用cout，因此没必要让函数stonelb()能过访问命名空间std。因此编译指令放在main()函数中。</p><p>总之，让程序能够访问命名空间std的方法有多种，下面是其中的四种：</p><ul><li>将using namespace std; 放在函数定义之前，让文件中的所有函数都能够使用命名空间std中的所有的元素。</li><li>将using namespace std；放在特定的函数定义中，让该函数能够使用命名空间std中的所有元素。</li><li>在特定的函数中使用类似using std::cout;这样的编译指令，而不是using namespace std;，让该函数能过使用指代的元素，如cout。</li><li>完全不使用编译指令using，而在需要使用命名空间std中的元素是，使用前缀std::,如下所示：<br><code>std::cout &lt;&lt; &quot;I am using cout&quot; &lt;&lt; std::endl;</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++程序有一个或多个被称为函数的模块组成。程序从main()函数开始执行，因此该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值类型和函数期望通过参数传递给它的信息的类型。</p><p>C++语句有多种类型，包括如下6种：</p><ul><li>声明语句</li><li>赋值语句</li><li>消息语句：将消息发送给对象，激发某种行动</li><li>函数调用：执行函数</li><li>函数原型：声明函数的类型、函数接受的参数数量和类型</li><li>返回语句：将一个值从被调用函数那里返回到调用函数</li></ul><p>类是用户自定义的数据类型规范，详细描述了如何表示信息以及对数据执行的操作。对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。</p><p>C++提过了两个用户处理输入和输出的预定义对象（cin和cout），它们是istream和ostream类的实例，这两个类在iostream文件中定义。</p>]]></content>
      
      <categories>
          
          <category> C++ Primer Plus学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络与信息安全研究方向</title>
      <link href="/2018/08/29/%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"/>
      <url>/2018/08/29/%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/</url>
      <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/zhangvalue/article/details/78056559" target="_blank" rel="noopener">https://blog.csdn.net/zhangvalue/article/details/78056559</a></p><ul><li>1、信息安全算法类：包括密码算法、信息隐藏与检测算法、数字水印嵌入与检测算法、数据挖掘与过滤算法、量子密码算法等。</li><li>2、信息安全协议类：包括认证协议、密钥交换与管理协议、电子支付协议、多方安全计算协议以及安全协议的安全性分析理论与方法等。</li><li>3、信息系统安全类：包括可信计算、安全体系结构、操作系统安全、数据库安全、服务器安全以及信息系统安全评估理论与方法等。</li><li>4、网络安全类：包括信息对抗、网络攻防、入侵检测、网络可生存、网络安全管理、移动网络安全、无线网络安全、物联网安全，以及恶意代码检测、防御与应急处置等。</li><li>5、信息安全应用类：包括电子政务、电子商务、信息安全基础设施以及新技术应用带来的安全问题及解决方案等。</li><li>6、安全测试与仿真类：网络与信息安全仿真，安全测试理论与模型，安全测试技术等。</li><li>7、信息安全技术类：等级保护技术、三网融合与安全管理、信息安全应急响应体系、网络监测与监管技术等。</li><li>8、新一代网络技术类：网络体系结构、路由/交换技术、协议工程、网络虚拟化、认知网络、IPv4/IPv6过渡技术、NGN/NGI平台应用等。</li><li>9、新一代计算技术：网格计算、并行/分布式计算、适/效用计算、服务计算。</li><li>10、安全专用芯片：密码算法与协议实现、安全处理器与协处理器设计、芯片攻击与安全防护、安全芯片应用。</li><li>11、数字版权管理安全（DIM）:认证/授权访问控制、安全数据传输、可信管理与可信评估、信息内容安全技术、数字水印、数字权限管理。</li><li>12、云计算与物联网安全：云计算/物联网安全模型、云计算/物联网安全需求与策略、云计算/物联网用户隐私保护、云计算/物联网基础设施安全防护</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 研究方向 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ Primer Plus--预备知识（一）</title>
      <link href="/2018/08/29/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/08/29/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>介绍C++的一些基本概念，起源，以及如何编译执行。<a id="more"></a></p><h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h2><p>C++融合了3种不同的编程方式：</p><ul><li>C语言代表的过程性语言</li><li>C++在C语言的基础上添加的类代表面向对象语言</li><li>C++模板支持的泛型编程</li></ul><h2 id="c演员编程原理"><a href="#c演员编程原理" class="headerlink" title="c演员编程原理"></a>c演员编程原理</h2><p>计算机语言要处理两个概念–算法和数据，数据是程序使用和处理的信息，而算法是程序使用的方法。</p><p>C语言强调的是编程的算法方面，C语言的设计是自顶向下的，其理念是将大型程序分解成小型、便于管理的任务。程序员可以开发程序党单元(函数)来表示各个任务的模块，根据执行的操作来构思一个程序。C语言具有使用结构化编程的特性，比如：while、if、for等语句。</p><h2 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h2><p>OOP强调的是数据，OOP不想过程性编程那样，试图使问题满足语言的过程性，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。</p><p>C++中，类是一种规范，描述了这种新型数据格式，对象是根据这种规范（类）构造的特定数据结构。比如：类可以描述公司管理人员的基本特征（姓名，工资，职位等），而对象则代表特定的管理人员（zxp, 1000000,董事长）。</p><p>类规定了可使用哪些数据表示对象，以及可以对这些数据执行哪些操作（方法，即函数）。比如：绘制矩形的计算机绘图程序种，定义的数据包括：矩形的顶点位置，长，宽，颜色等，定义的操作可以包括：移动，改变大小，改变颜色等等。当使用该程序绘图时，需要根据类创建一个对象，该对象保存了描述矩形的所有数据值，因此可以使用类方法来修改矩阵。</p><p>OOP程序设计，首先设计类，它们准确的表达了程序需要处理的内容。然后，设计一个使用这些类的对象程序。从低级组织（如：类）到高级组织（如：程序）的处理过程叫做自下而上（bottom-up）的编程。</p><p>OOP编程不仅仅可以将数据和方法合并成类，还可以创建可重用的代码，多态可以让运算符和函数创建多个定义等。</p><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p><strong>泛型</strong>指的是创建独立类型的代码。C++中的数据表示类型包括：整数，小数，字符，字符串，用户定义等等。如果对不同类型的数据进行排序，通常需要为每种类型创建一个排序函数。泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，将其用户各种实际类型。C++模板提供了这种任务的机制。</p><p>泛型编程（generic programming）与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。OOP是一个管理大型项目的工具，而泛型编程提成了执行常见任务（如对数据排序和合并）的工具。</p><h2 id="起源（了解）"><a href="#起源（了解）" class="headerlink" title="起源（了解）"></a>起源（了解）</h2><p>C和C++都起源于贝尔实验室。Bjarne Sroustrup于20世纪80年代开发了C++。</p><p>名称C++来自C语言中的递增运算符++,该运算符将变量加1。名称表明C++是C的扩展版本。</p><h2 id="程序创建过程"><a href="#程序创建过程" class="headerlink" title="程序创建过程"></a>程序创建过程</h2><ul><li>使用文本编辑器编写程序，将其保存为文件，这个文件就是源代码；</li><li>编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言—机器语言。包含了翻译后的程序的文件就是程序的目标代码。</li><li>将目标代码与其他代码链接起来。例如：C++程序通常使用库，C++库包含一系列计算机例程（被称为函数）的目标代码，这些函数可以执行诸如在屏幕显示信息或计算平方根等任务。链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本。包含该最终产品的文件被称为可执行代码。</li></ul><h2 id="创建源代码文件"><a href="#创建源代码文件" class="headerlink" title="创建源代码文件"></a>创建源代码文件</h2><p>在unix系统上，可以使用vi等编辑器编辑，其中只能实现编译和链接，执行程序，要求在系统命令行输入命令。<br>在windows系统中，可以edlIn、edit或其他编辑器</p><p>给源文件命名时，必须使用正确的后缀，将文件表示为C++文件，不仅可以表示该文件是C++源代码，还将这种信息告知编译器。</p><p>Unix中，区分大小写，C程序使用：c(小写)，C++程序使用：C(大写)，还可以使用cc、cxx表示C++源代码。</p><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p><strong>Linuxg编译和链接</strong></p><p>编译test.cpp文件，生成a.out可执行文件：</p><pre><code>g++ test.cpp</code></pre><p>运行可执行文件：</p><pre><code>./a.out</code></pre><p>linux安装gcc:</p><pre><code>yum install gcc-c++</code></pre>]]></content>
      
      <categories>
          
          <category> C++ Primer Plus学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单的文本处理</title>
      <link href="/2018/08/29/%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
      <url>/2018/08/29/%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文介绍<code>tr</code>（注意不是tar），<code>col</code>，<code>join</code>，<code>paste</code>命令。实际上是管道操作命令的延续，所以我们依然将结合管道来熟悉这些命令的使用。<br><a id="more"></a></p><h2 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h2><p><code>tr</code>命令可以用来删除一段文本信息中的某些文字，或者将其进行转换。</p><p>使用方式：</p><pre><code>tr [option] ... SET1 [SET2]</code></pre><p>常用的选项有：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td>-s</td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table><pre><code>#删除hello world中所有的&apos;o&apos;,&apos;l&apos;,&apos;d&apos;echo &quot;hello world&quot; | tr -d &apos;old&apos;#将&quot;hello&quot;中的ll,去重为一个lecho &quot;hello&quot; | tr -s &apos;l&apos;    </code></pre><p><img src="https://i.imgur.com/bhOSBjW.png" alt=""></p><pre><code>#将输入文本，全部转换为大写或小写输出echo &apos;input some text heRe&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;#上面的&apos;[:lower:]&apos;&apos;&apos;[:upper:]&apos;,也可以简单的写作&apos;[a-z]&apos;&apos;[A-Z]&apos;,当然反过来将大写变小写也是可以的echo &apos;input some text heRE&apos; |tr &apos;[:upper:]&apos;&apos;[:lower:]&apos;</code></pre><p><img src="https://i.imgur.com/NQfzexu.png" alt=""></p><h2 id="col命令"><a href="#col命令" class="headerlink" title="col命令"></a>col命令</h2><p><code>col</code>命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作</p><p>格式： <code>cal [option]</code></p><p>常用的选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-x</td><td>将Tab转换为空格</td></tr><tr><td>-h</td><td>将空格转换为Tab（默认选项）</td></tr></tbody></table><pre><code>#查看/etc/protocols中的不可见字符，可以看到很多^I，这其实就是Tab转义成可见字符的符号cat -A /etc/protocols</code></pre><p><img src="https://i.imgur.com/jHJCxb9.png" alt=""></p><pre><code>#使用col -x将/etc/protocols中的Tab转换为空格，然后再使用cat查看，会发现^I不见了cat /etc/protocols | col -x | cat -A </code></pre><p><img src="https://i.imgur.com/yEiNyL4.png" alt=""></p><h2 id="join命令"><a href="#join命令" class="headerlink" title="join命令"></a>join命令</h2><p>该命令就是用于将两个文件中包含相同内容的那一行合并在一起。在数据库中也有该命令，作用基本相同。</p><p>使用方式： <code>join [option] ... file1 file2</code></p><p>常用的选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定分隔符，默认为空格</td></tr><tr><td>-i</td><td>忽略大小的差异</td></tr><tr><td>-1</td><td>指定第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td>-2</td><td>指定第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><pre><code>#创建两个文件echo &apos;1 hello&apos; &gt; file1echo &apos;2 hello&apos; &gt; file2join file1 file2# 将/etc/passwd与/etc/shadow两个文件合并，指定以&apos;:&apos;作为分隔符sudo join -t&apos;:&apos; /etc/passwd /etc/shadow</code></pre><p><img src="https://i.imgur.com/9pll2OA.png" alt=""></p><pre><code># 将/etc/passwd与/etc/group两个文件合并，指定以&apos;:&apos;作为分隔符, 分别比对第4和第3个字段sudo join -t&apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group</code></pre><p><img src="https://i.imgur.com/hTRFbZu.png" alt=""></p><h2 id="paste命令"><a href="#paste命令" class="headerlink" title="paste命令"></a>paste命令</h2><p><code>paste</code>命令有<code>join</code>命令类似，不过它是在不对比数据的情况下，简单地将多个文件合并在一起，以<code>Tab</code>隔开。</p><p>使用格式：<code>paste [option] file ...</code></p><p>常用的选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>指定合并的分隔符，默认是Tab</td></tr><tr><td>-s</td><td>不合并到一行，每个文件为一行</td></tr></tbody></table><pre><code>echo hello &gt; file1echo shiyanlou &gt; file2echo www.shiyanlou.com &gt; file3paste -d &apos;:&apos; file1 file2 file3paste -s file1 file2 file3</code></pre><p><img src="https://i.imgur.com/xseVLUc.png" alt=""></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Windows/dos 与 Linux/UNIX 文本文件一些特殊字符不一致</p><p>如断行符 Windows 为 CR+LF(\r\n)，Linux/UNIX 为 LF(\n)。使用cat -A 文本 可以看到文本中包含的不可见特殊字符。Linux 的\n表现出来就是一个$，而 Windows/dos的表现为^M$，可以直接使用dos2unix和unix2dos工具在两种格式之间进行转换，使用file命令可以查看文件的具体类型。</p><p>不过现在希望你在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。</p><pre><code>tr -d &apos;^M&apos;</code></pre><p><img src="https://i.imgur.com/KaeX98u.png" alt=""></p><p><a href="https://blog.csdn.net/fan_hai_ping/article/details/8352087" target="_blank" rel="noopener">https://blog.csdn.net/fan_hai_ping/article/details/8352087</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>命令执行顺序控制与管道</title>
      <link href="/2018/08/28/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
      <url>/2018/08/28/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93/</url>
      <content type="html"><![CDATA[<p>顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等，高效率使用 Linux 的技巧。<a id="more"></a></p><h1 id="命令执行顺序控制"><a href="#命令执行顺序控制" class="headerlink" title="命令执行顺序控制"></a>命令执行顺序控制</h1><p>通常情况下，我们每次只能在终端输入一条命令，按下回车执行，执行完成后，我们再输入第二条命令，然后再按回车执行……,当有时候我们会一次输入多条命令，这个时候的执行过程又是如何的呢？下面我们将为大家详细讲解下命令的执行顺序的控制问题。</p><h2 id="顺序执行多条命令"><a href="#顺序执行多条命令" class="headerlink" title="顺序执行多条命令"></a>顺序执行多条命令</h2><p>当我们需要使用apt-get安装一软件时，然后安装完成后立即运行安装软件，又凑巧你的主机才更换的软件源还没有更新软件表，那么可能有如下一系列操作：</p><pre><code>sudo apt-get update#等待更新 sudo apt-get install somen-tool #some-tool是指具体的软件包#等待安装some-tool</code></pre><p>如上操作，可以使用一条命令执行完成，不需要多次输入，简单的顺序执行可以使用<code>;</code>来完成，以上操作可以如下输入进行：</p><pre><code>sudo apt-get update;sudo apt-get install some-tool;some-tool</code></pre><h2 id="有选择的执行命令"><a href="#有选择的执行命令" class="headerlink" title="有选择的执行命令"></a>有选择的执行命令</h2><p>顺序执行多条命令时，可能前面的命令执行不成功，而后面的命令依赖上一条命令的结果，那么就会造成，花了很长的时间，却得到了一个错误的结果，而且有时候只管还无法判断结果是否正确，那么需要有选择性的执行命令。比如上一条执行成功才继续执行下一条，或者不成功又该做出什么样的选择。</p><p>使用<code>which</code>来查看是否安装某个命令，如果找到命令，则执行该命令，否则什么也不做：</p><pre><code>which cowsy&gt;/dev/null &amp;&amp; cowsay -f head-in ihch~</code></pre><p>上面的<code>&amp;&amp;</code>就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果。同时<code>||</code>表示当上一条命令执行结果不为0($?≠0)时则执行后面的命令。</p><pre><code>which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&apos;&quot;</code></pre><p><img src="https://i.imgur.com/kZurZLI.png" alt=""></p><p><code>||</code>和<code>&amp;&amp;</code>结合使用：</p><pre><code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</code></pre><p><img src="https://i.imgur.com/GGm5mRq.png" alt=""></p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是一种通信机制，通常用户进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</p><p>管道又分为匿名管道和具名管道；在实际中使用一些过滤程序是经常会用到的就是匿名管道，在命令行中由<code>|</code>分割符表示。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</p><h2 id="管道例子"><a href="#管道例子" class="headerlink" title="管道例子"></a>管道例子</h2><pre><code>ls -al /etc</code></pre><p>将<code>/etc</code>下的文件全部打印出来，内容太多，屏幕不能完全显示，可以使用滚动条或快捷键来查看，不太友好，不过可以使用管道，一行一行查看：</p><pre><code>ls -al /etc | less</code></pre><p>通过管道将前一个命令<code>ls</code>的输出作为下一个命令<code>less</code>的输入，然后一行一行查看</p><h2 id="cut命令：打印每一行的某一个字段"><a href="#cut命令：打印每一行的某一个字段" class="headerlink" title="cut命令：打印每一行的某一个字段"></a>cut命令：打印每一行的某一个字段</h2><p>打印<code>/etc/passwd</code>文件中以’:’为分隔符的第1个字段和第6个字段分布表示用户名和其目录：</p><pre><code>cut /etc/passwd -d &apos;:&apos; -f 1,6</code></pre><p>打印<code>/etc/passwd</code>文件中指定的内容：</p><pre><code># 前五个（包含第五个）$ cut /etc/passwd -c -5# 前五个之后的（包含第五个）$ cut /etc/passwd -c 5-# 第五个$ cut /etc/passwd -c 5# 2到5之间的（包含第五个）$ cut /etc/passwd -c 2-5</code></pre><h2 id="grep-在文本中或stdin中查找匹配字符串"><a href="#grep-在文本中或stdin中查找匹配字符串" class="headerlink" title="grep: 在文本中或stdin中查找匹配字符串"></a>grep: 在文本中或stdin中查找匹配字符串</h2><p><code>grep</code>命令非常强大，相当常用的一个命令，结合正则表达式可以实现非常复杂却很高效的匹配和查找。</p><p><code>grep</code>命令的一般格式：</p><pre><code>grep 【命令选项】 ... 用户匹配的表达式 [文件]...</code></pre><p>例子：查找<code>/home/shiyanlou</code>目录下的包行“shiyanlou”文本的文件</p><pre><code>grep -rnI &quot;shiyanlou&quot;</code></pre><p><code>-r</code>参数表示递归搜索子目录中的文件，<code>-n</code>表示打印匹配先行号,’-I’表示忽略二进制文件。</p><p>使用正则表达式的例子：</p><pre><code>export | grep &quot;.*yanlou$&quot;</code></pre><p>其中<code>$</code>就表示一行的末尾,<code>*</code>匹配前面的子表达式任意次,<code>.</code>匹配除“\n”和”\r”之外的任何单个字符</p><h2 id="wc命令：计数工具"><a href="#wc命令：计数工具" class="headerlink" title="wc命令：计数工具"></a>wc命令：计数工具</h2><p><code>wc</code>命令用户统计并输出一个文件中行、单词和字节的数目，比如输出<code>/etcpasswd</code>文件中的统计信息：</p><pre><code>wc /etc/passwd</code></pre><p>输出行数、单词数、字节数：</p><p><img src="https://i.imgur.com/Xok3vW8.png" alt=""></p><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p><pre><code># 行数$ wc -l /etc/passwd# 单词数$ wc -w /etc/passwd# 字节数$ wc -c /etc/passwd# 字符数$ wc -m /etc/passwd# 最长行字节数$ wc -L /etc/passwd</code></pre><p><img src="https://i.imgur.com/9CWHENm.png" alt=""></p><p>注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的</p><p>结合管道来操作，统计<code>/etc</code>下面所有目录数：</p><pre><code>ls -dl /etc/*/ | wc -l</code></pre><p><img src="https://i.imgur.com/hoq5qaT.png" alt=""></p><h2 id="sort排序命令"><a href="#sort排序命令" class="headerlink" title="sort排序命令"></a>sort排序命令</h2><p>该命令功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p><p>默认为字典排序：</p><pre><code>cat /etc/passwd | sort</code></pre><p>反转排序：</p><pre><code>cat /etc/passwd | sort -r</code></pre><p>按特定字段排序：</p><pre><code>cat /etc/passwd | sort -t&apos;:&apos; -k 3</code></pre><p>上面的-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：</p><pre><code>cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n</code></pre><p><img src="https://i.imgur.com/GPmxfoO.png" alt=""></p><h2 id="uniq去重复命令"><a href="#uniq去重复命令" class="headerlink" title="uniq去重复命令"></a>uniq去重复命令</h2><p><code>uniq</code>命令可以用于过滤或者输出重复行。</p><p><strong>过滤行</strong></p><p>使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p><pre><code>history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq</code></pre><p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p><pre><code>history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq# 或者 history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u</code></pre><p><img src="https://i.imgur.com/3uPB6JI.png" alt=""></p><p>这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。</p><p><strong>输出重复行</strong></p><pre><code># 输出重复过的行（重复的只输出一个）及重复次数$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc# 输出所有重复的行$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D</code></pre>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux不同版本以及程序包安装</title>
      <link href="/2018/08/28/Linux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%AE%89%E8%A3%85/"/>
      <url>/2018/08/28/Linux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>Linux版本介绍，以及程序包安装命令介绍<a id="more"></a></p><h2 id="Linux系统版本"><a href="#Linux系统版本" class="headerlink" title="Linux系统版本"></a>Linux系统版本</h2><ul><li>RedHat(红帽)系列： Redhat、Centos、Fedora等</li><li>Debian(得比恩)系列： Debian、Ubuantu等</li></ul><h2 id="程序包安装"><a href="#程序包安装" class="headerlink" title="程序包安装"></a>程序包安装</h2><h3 id="RedHat系列"><a href="#RedHat系列" class="headerlink" title="RedHat系列"></a>RedHat系列</h3><ul><li>常见的安装包格式rpm包，安装rpm包的命令是”rpm -参数”</li><li>包管理工具yum</li><li>支持tar包</li></ul><h3 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h3><ul><li>常见的安装包格式deb包，安装deb包的命令是”dpkg -参数”</li><li>包管理工具apt-get</li><li>支持tar包</li></ul><p>tar 只是一种压缩文件格式，所以，它只是把文件压缩打包而已。</p><p>rpm 相当于windows中的安装文件，它会自动处理软件包之间的依赖关系。优缺点来说，rpm一般都是预先编译好的文件，它可能已经绑定到某种CPU或者发行版上面了。</p><h2 id="yum安装命令"><a href="#yum安装命令" class="headerlink" title="yum安装命令"></a>yum安装命令</h2><p>YUM（Yellow dog Updater, Modified ）是Yellow Dog Linux开发的。 Yellow Dog Linux原本是一套完全源于Red Hat但运作于先前使用IBM PPC平台的MAC机器，原本以为这个版本已经消失，没想到最新消息是他们推出了在Sony PS3上面运作的版本。 CentOS及Fedora的基本预设安装中即将YUM列入其内。 </p><p>使用方法：</p><ul><li>编辑/etc/yum.conf档案详细设定请参考： <a href="http://linux.vbird.org/linux_server/0450apt.php" target="_blank" rel="noopener">简易APT/YUM伺服器设定</a></li><li>基本指令： （如果yum在工作过程中需要使用者回应，可加上-y参数直接回答yes ）</li></ul><p>| yum install softwarename1 [softwarename2…..] | 安装套件 |<br>| yum update [softwarename 1 softwarename2…] | 更新套件，不指定套件名则更新所有可更新的套件 |<br>| yum list | 列出目前在yum server 上面有的套件 |<br>| yum info | 类似rpm -qi |<br>| yum clean | 移除下载到本机的packages 或headers |<br>| yum remove softwarename1 [softwarename2…..]    | 移除已经安装的套件 | </p><p>注1：Red Hat近年来致力于将一个设定档切割成很多小设定档。 以yum.conf为例，Red Hat将其分割成xxx.repo档放置在/etc/yum.repos.d这个目录下。 并在yum.conf档里增加一行注解： PUT YOUR REPOS HERE OR IN separate files named file.repo in /etc/yum.repos.d。 个人可视喜好决定。</p><h2 id="apt安装命令"><a href="#apt安装命令" class="headerlink" title="apt安装命令"></a>apt安装命令</h2><p>Debian开发，目前也有porting到其他版本，要在Red Hat系的Fedora或CentOS使用也是可以的。</p><p>使用方法：</p><p>编辑/etc/apt/sources.list ，设定所选用的版本，如stable，testing，unstable及套件来源站台或装置。 档案详细设定请参考： 了解Debian系统的哲学</p><p>基本指令：</p><p>| apt-setup    | 设定/etc/apt/souces.list |<br>| apt-get update    | 软体资料库同步 |<br>| apt-get install softwarename1 [softwarename2…..]    | 安装软体 |<br>| apt-get remove softwarename 1 [softwarename 2…]    |  移除软体(保留设定档） |<br>| apt-get –purge remove softwarename 1 [softwarename 2…]    |  移除软体(不保留设定档） |<br>| apt-cache search softwarename    | 列出所有sofrwarename的套件 |<br>| apt-upgrade [softwarename 1 softwarename2…]    |  更新套件，不指定套件名则更新所有可更新的套件 |<br>| apt-get clean(autoclean)    | 删除系统暂存的deb(autoclean只会将比目前系统旧版的套件删除) |<br>| apt-get dist-upgrade    |  转换系统的版本（需在/etc/apt/sources.list指定stable，testing或unstable） | </p><p>转自：<a href="https://www.cnblogs.com/zhangfeionline/p/5893748.html" target="_blank" rel="noopener">张飞在线</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux任务计划crontab</title>
      <link href="/2018/08/27/Linux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab/"/>
      <url>/2018/08/27/Linux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab/</url>
      <content type="html"><![CDATA[<p>时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本文将带你很好的利用 Linux 系统的计划工具<a id="more"></a></p><p>crontab 命令常见于 Unix 和类 Unix 的操作系统之中（Linux 就属于类 Unix 操作系统），用于设置周期性被执行的指令。</p><h2 id="Crontab简介"><a href="#Crontab简介" class="headerlink" title="Crontab简介"></a>Crontab简介</h2><p><code>Crontab</code>命令从输入设备读取指令，并将其存于<code>crontab</code>文件中，以供之后读取和执行。crontab存储的指令在守护进程激活，crond为其守护进程，每一分钟会检查一次是否预定的作业需要执行。</p><p>通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell　script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。</p><pre><code># Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name command to be executed</code></pre><h2 id="crontab使用"><a href="#crontab使用" class="headerlink" title="crontab使用"></a>crontab使用</h2><p>运行如下命令，添加一个集合任务：</p><pre><code>crontab -e</code></pre><p>详细的格式可以使用<code>man</code>命令查看：</p><pre><code>man crontab</code></pre><p>给出一个例子来完成一个任务的添加，该任务是每分钟在/home/zxp目录下创建一个以当前年月日时分秒为名字的空文件：</p><pre><code>*/1 * * * * touch /home/zxp/$(date + /%H/%m/%d/%H/%M/%S)</code></pre><blockquote><p>注意 “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p></blockquote><p><img src="https://i.imgur.com/T6DV5Oj.png" alt=""></p><p>查看添加的任务：</p><pre><code>crontab -l</code></pre><p>默认cron是自动启动的，可以通过如下命令查看是否启动:</p><pre><code>ps aux | grep cronpgrep cron</code></pre><p>启动crontab:</p><pre><code>sudo cron -f &amp;</code></pre><p>当不再需要这个任务时，可以使用如下命令：</p><pre><code>crontab -r</code></pre><h2 id="crontab深入"><a href="#crontab深入" class="headerlink" title="crontab深入"></a>crontab深入</h2><p>每个用户使用 crontab -e 添加计划任务，都会在 <code>/var/spool/cron[/crontabs]</code> 中添加一个该用户自己的任务文档，这样目的是为了隔离。</p><p>如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 /etc/crontab 文件就可以。</p><p>cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。</p><p>在/etc下，cron相关的文件和目录有：</p><p><img src="https://i.imgur.com/u9iyxSl.png" alt=""></p><p>每个目录的作用：</p><ul><li>/etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行；</li><li>/etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行；</li><li>/etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行；</li><li>/etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；<br>系统默认执行时间可以根据需求进行修改。</li></ul><p>转自：<a href="https://www.shiyanlou.com" target="_blank" rel="noopener">实验楼</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux中的帮助命令</title>
      <link href="/2018/08/25/Linux%E4%B8%AD%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/25/Linux%E4%B8%AD%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>转自：<a href="https://www.shiyanlou.com" target="_blank" rel="noopener">实验楼</a></p><p><strong>实验知识点</strong></p><ul><li>内建命令与外部命令之分</li><li>help , man , info命令的使用以及区别<a id="more"></a></li></ul><h1 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h1><blockquote><p><strong>内建命令</strong>实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</p></blockquote><blockquote><p><strong>外部命令</strong>是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。</p></blockquote><p>简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用　type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的。</p><p><img src="https://i.imgur.com/ZLCpZe6.png" alt=""></p><p>#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中<br>xxx is a shell builtin</p><p>#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中<br>xxx is /usr/bin/xxx</p><p>#若是得到alias的结果，说明该指令为命令别名所设定的名称；<br>xxx is an alias for xx –xxx</p><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>zsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令,首先进入bash:</p><pre><code>bash</code></pre><p>尝试如下命令：</p><pre><code>help ls</code></pre><p><img src="https://i.imgur.com/TUrUXwO.png" alt=""></p><p>这是因为<strong>help命令用户显示shell内建命令</strong>的简要帮助信息。帮助信息中显示该命令的简要说明以及一些参数的使用和说明。</p><p>外部命令帮助查看：</p><pre><code>ls --help</code></pre><p>其实外部命令都具有一个参数<code>--help</code>。</p><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p><code>man</code>命令得到的内容比<code>help</code>命令更详细，而且<code>man</code>命令没有内建和外部命令区分，因为<code>man</code>工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，包括一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。</p><pre><code>man lsman ls (章节数)</code></pre><p>在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节</p><table><thead><tr><th>章节数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Standard commands （标准命令）</td></tr><tr><td>2</td><td>System calls （系统调用）</td></tr><tr><td>3</td><td>Library functions （库函数）</td></tr><tr><td>4</td><td>Special devices （设备说明）</td></tr><tr><td>5</td><td>File formats （文件格式）</td></tr><tr><td>6</td><td>Games and toys （游戏和娱乐）</td></tr><tr><td>7</td><td>Miscellaneous （杂项）</td></tr><tr><td>8</td><td>Administrative Commands （管理员命令）</td></tr><tr><td>9</td><td>其他（Linux特定的）， 用来存放内核例行程序的文档。</td></tr></tbody></table><p> 打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面</p><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>该命令一般bash中自带</p><pre><code>info ls</code></pre><p>得到的信息是不是比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多</p><p>man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的　GNU　工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。</p><p><strong>注释：</strong><br>Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell 。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。bash是大多数Linux系统以及Mac OS X默认的shell，它能运行于大多数类Unix风格的操作系统之上。<br><br>详细见：<a href="https://blog.csdn.net/sujz12345/article/details/54565056" target="_blank" rel="noopener">Linux之bash介绍</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十大数据结构</title>
      <link href="/2018/08/24/%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/08/24/%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>算法+数据结构=编程<a id="more"></a></p><p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MTQzNzU2NA==&amp;mid=2651662400&amp;idx=1&amp;sn=01bc405903147ee4b21134f59dff9b06&amp;chksm=bd4c0fd38a3b86c5f82d32adf653e799a1cee631cb6821b857d6771687d93831271fde52a700&amp;mpshare=1&amp;scene=23&amp;srcid=0819ZBXPPG2xl22aKHLdKwb4#rd" target="_blank" rel="noopener">大数据文摘公众号</a></p><ul><li>数组（列表）</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树（这是一种高效的树形结构，但值得单独说明）</li><li>散列表（哈希表）</li><li>字典</li><li>元组</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。</p><p><img src="https://i.imgur.com/hUYJfsC.jpg" alt=""></p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><p>以下是数组的两种类型：</p><ul><li>一维数组（如上所示）</li><li>多维数组（数组的数组）</li></ul><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><ul><li>Insert——在指定索引位置插入一个元素</li><li>Get——返回指定索引位置的元素</li><li>Delete——删除指定索引位置的元素</li><li>Size——得到数组所有元素的数量</li></ul><h2 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h2><ul><li>寻找数组中第二小的元素</li><li>找到数组中第一个不重复出现的整数</li><li>合并两个有序数组</li><li>重新排列数组中的正值和负值</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。</p><p>可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除：</p><p><img src="https://i.imgur.com/bWUcIYF.jpg" alt=""></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><ul><li>Push——在顶部插入一个元素</li><li>Pop——返回并移除栈顶元素</li><li>isEmpty——如果栈为空，则返回true</li><li>Top——返回顶部元素，但并不移除它</li></ul><h2 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h2><ul><li>使用栈计算后缀表达式</li><li>对栈的元素进行排序</li><li>判断表达式是否括号平衡</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。</p><p>一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。</p><p>下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除：</p><p><img src="https://i.imgur.com/Zr2ydAS.jpg" div="" align="center"></p><p>移除先入队的元素、插入新元素</p><h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><ul><li>Enqueue() —— 在队列尾部插入元素</li><li>Dequeue() ——移除队列头部的元素</li><li>isEmpty()——如果队列为空，则返回true</li><li>Top() ——返回队列的第一个元素</li></ul><h2 id="面试中关于队列的常见问题"><a href="#面试中关于队列的常见问题" class="headerlink" title="面试中关于队列的常见问题"></a>面试中关于队列的常见问题</h2><ul><li>使用队列表示栈</li><li>对队列的前k个元素倒序</li><li>使用队列生成从1到n的二进制数</li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p>链表包括以下类型：</p><p>单链表（单向）<br>双向链表（双向）</p><h2 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h2><ul><li>InsertAtEnd 在链表的末尾插入指定元素</li><li>InsertAtHead 在链接列表的开头/头部插入指定元素</li><li>Delete  从链接列表中删除指定元素</li><li>DeleteAtHead 删除链接列表的第一个元素</li><li>Search  从链表中返回指定元素</li><li>isEmpty 如果链表为空，则返回true</li></ul><h2 id="面试中关于链表的常见问题"><a href="#面试中关于链表的常见问题" class="headerlink" title="面试中关于链表的常见问题"></a>面试中关于链表的常见问题</h2><ul><li>反转链表</li><li>检测链表中的循环</li><li>返回链表倒数第N个节点</li><li>删除链表中的重复项</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一组以网络形式相互连接的节点。节点也称为顶点。 一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。</p><p><img src="https://i.imgur.com/qcRYa9G.jpg" alt=""></p><h2 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a>图的类型</h2><ul><li>无向图</li><li>有向图</li></ul><h2 id="在程序语言中，图可以用两种形式表示："><a href="#在程序语言中，图可以用两种形式表示：" class="headerlink" title="在程序语言中，图可以用两种形式表示："></a>在程序语言中，图可以用两种形式表示：</h2><ul><li>邻接矩阵</li><li>邻接表</li></ul><h2 id="常见图遍历算法"><a href="#常见图遍历算法" class="headerlink" title="常见图遍历算法"></a>常见图遍历算法</h2><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><h2 id="面试中关于图的常见问题"><a href="#面试中关于图的常见问题" class="headerlink" title="面试中关于图的常见问题"></a>面试中关于图的常见问题</h2><ul><li>实现广度和深度优先搜索</li><li>检查图是否为树</li><li>计算图的边数</li><li>找到两个顶点之间的最短路径</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。</p><p>树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：<br><img src="https://i.imgur.com/wAMjjBW.jpg" alt=""></p><ul><li>Root 根节点</li><li>Parent 父节点</li><li>Child 子节点</li><li>Leaf 叶子节点</li><li>Sibling 兄弟节点</li></ul><h2 id="以下是树形结构的主要类型："><a href="#以下是树形结构的主要类型：" class="headerlink" title="以下是树形结构的主要类型："></a>以下是树形结构的主要类型：</h2><ul><li>N元树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>AVL树</li><li>红黑树</li><li>2-3树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><h2 id="面试中关于树结构的常见问题："><a href="#面试中关于树结构的常见问题：" class="headerlink" title="面试中关于树结构的常见问题："></a>面试中关于树结构的常见问题：</h2><ul><li>求二叉树的高度</li><li>在二叉搜索树中查找第k个最大值</li><li>查找与根节点距离k的节点</li><li>在二叉树中查找给定节点的祖先节点</li></ul><h1 id="字典树（Trie）"><a href="#字典树（Trie）" class="headerlink" title="字典树（Trie）"></a>字典树（Trie）</h1><p>字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。</p><p>以下是在字典树中存储三个单词“top”，“so”和“their”的例子：</p><p><img src="https://i.imgur.com/gNIj2Md.jpg" alt=""></p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。</p><h2 id="面试中关于字典树的常见问题"><a href="#面试中关于字典树的常见问题" class="headerlink" title="面试中关于字典树的常见问题"></a>面试中关于字典树的常见问题</h2><ul><li>计算字典树中的总单词数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建T9字典（字典树+ DFS ）</li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p><h2 id="散列数据结构的性能取决于以下三个因素："><a href="#散列数据结构的性能取决于以下三个因素：" class="headerlink" title="散列数据结构的性能取决于以下三个因素："></a>散列数据结构的性能取决于以下三个因素：</h2><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。</p><p><img src="https://i.imgur.com/xlEJuB7.jpg" alt=""></p><h2 id="面试中关于哈希结构的常见问题："><a href="#面试中关于哈希结构的常见问题：" class="headerlink" title="面试中关于哈希结构的常见问题："></a>面试中关于哈希结构的常见问题：</h2><ul><li>在数组中查找对称键值对</li><li>追踪遍历的完整路径</li><li>查找数组是否是另一个数组的子集</li><li>检查给定的数组是否不相交</li></ul><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件系统概念</title>
      <link href="/2018/08/19/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/08/19/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>文件系统和硬盘分区基本概念介绍<a id="more"></a><br><strong>文件系统</strong>：是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。<br>从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p><p><strong>硬盘分区</strong>：实质上是对硬盘的一种格式化。当我们创建分区时，就已经设置好了硬盘的各项物理参数，指定了硬盘主引导记录(即Master Boot Record，一般简称为MBR)和引导记录备份的存放位置。而对于文件系统以及其他操作系统管理硬盘所需要的信息则是通过之后的高级格式化，即Format命令来实现。</p><p><strong>簇</strong>：是指可分配的用来保存文件的最小磁盘空间，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。所以,簇越小，保存信息的效率就越高。</p><p><strong>主引导记录</strong>：（MBR，Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。</p><p><strong>硬盘大小</strong>： 实际中，给硬盘分区时，按照1G=1024M来设置，但是显示的结果都不是整数。比如：将分区设置为10G,显示的确实9.XXG。原因是：<br><br>正确计算公式</p><pre><code>(N-1)*4+1024*N式中N为想要的大小，单位为GB。最终计算出来的结果为MB.</code></pre><p>例如：想要设置分区为2G,则<br>（2-1）<em>4+1024</em>2=2052M<br>设置分区时应该为2052M</p><h1 id="分区状态"><a href="#分区状态" class="headerlink" title="分区状态"></a>分区状态</h1><p>三种：主分区、扩展分区和逻辑分区</p><p>主分区：是一个比较单纯的分区，通常位于硬盘的最前面一块区域中，构成逻辑C磁盘。其中的主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区，负责把引导权移交给活动分区的DOS或其他操作系统。此段程序损坏将无法从硬盘引导，但从软驱或光驱引导之后可对硬盘进行读写。</p><p>扩展分区：仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区(实际上也就是下一个逻辑磁盘)的起始位置，以此起始位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘。</p><p><strong>三者解释：</strong><br><br>主分区能够激活，通常用来引导系统。扩展分区本身并不能直接用来存放数据，逻辑分区是扩展分区进一步分割出来的区块，通常用来存储数据。如果将逻辑分区比作房间，那么扩展分区就好比客房区(包括若干个房间)</p><p><strong>主分区和活动分区：</strong><br><br>主分区也被称为主磁盘分区，是磁盘分区的一中类型，其主要作用是用来安装操作系统。一个硬盘最多可创建4个主分区。活动分区是基于主分区的，磁盘分区中的任意主分区都可以设置为活动分区。如果电脑上4个主分区都安装了不同的系统，那被标记为活动分区的主分区将用于初始引导，即启动活动分区内安装的系统。</p><p><strong>逻辑分区和扩展分区：</strong><br><br>因为主分区最多可以创建4个，我们需要使用扩展分区打破4的限制。在磁盘上可以创建多个逻辑分区而创建的这些逻辑分区都被称为扩展分区，您可以用主分区和逻辑分区中储存数据，但是不能用扩展分区储存，因为扩展分区是我们对逻辑分区的总称，只是一中称呼。</p><p><strong>例子</strong>：通常我们会先在硬盘上划分一个主分区，就是我们常说的C分区，用于安装操作系统，然后将其他的空间全部作为扩展分区，并根据需要，将扩展分区分成几个逻辑分区，即D、E等分区。</p><h1 id="分区格式"><a href="#分区格式" class="headerlink" title="分区格式"></a>分区格式</h1><p>windows:FAT16、FAT32、NTFS、exFAT<br>Linux: ext2、ext3、Linux swap、VFAT、ext4、</p><p><strong>FAT和NNTFS区别</strong><br><br>FAT32：随着大容量硬盘的出现，从Windows 98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。<br><br>NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。<br><br>其实白话说就是FAT格式的分区单个文件夹文件不支持大于4G的文件，NTFS可以支持无限大的，不过相对FAT格式不稳定是真的，xp一般系统是FAT格式的，现在的分区一般都选测NTFS格式的了，文件存储大了</p><h1 id="分区表类型"><a href="#分区表类型" class="headerlink" title="分区表类型"></a>分区表类型</h1><p><strong>GPT分区</strong>: GUID磁盘分区表（GUIDPartition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。至少可以划分128个主分区。gtp不在有分区的概念。</p><p><strong>MBR分区</strong>：只能划分四个分区，最多支持2T的磁盘</p><p><strong>两者区别</strong>：</p><ul><li><p>内存支持：mbr最多支持2T，而gpt理论上是无限制的。</p></li><li><p>在MBR硬盘中，分区信息直接存储于主引导记录（MBR）中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。</p></li><li><p>分区：mbr最多支持四个主分区，gpt没有限制。如果你想跑多系统，mbr最多4个而gpt没有限制。</p></li><li><p>系统：win7只能用mbr分区（也可以但是很麻烦，不建议），从Win8开始微软建议你使用gpt。</p></li><li><p>其它：gpt是由uefi启动的，而uefi是后来才提出的概念，兼容性和稳定性不如bios+mbr。</p></li><li>对于总容量大于2TB的硬盘，必须选择GPT分区表，才能识别所有的硬盘容量。MBR分区表由于自身设计的局限性，最大只能支持2TB的地址空间。对于超过2TB的大硬盘，如果使用MBR分区表，将无法识别和使用2TB后的空间。</li></ul><p>BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。用于加载电脑最基本的程序代码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。只支持MBR分区。</p><p>UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS（基本输入/输出系统），UEFI旨在提高软件互操作性和解决BIOS的局限性。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而达到开机程序化繁为简节省时间的目的。只支持GPT分区。</p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 硬盘分区 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mock模拟数据生成接口</title>
      <link href="/2018/08/17/Mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/08/17/Mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>Easy Mock是一个可视化，并且能快速生成模拟数据的服务。<a id="more"></a></p><h1 id="Mock解决的问题"><a href="#Mock解决的问题" class="headerlink" title="Mock解决的问题"></a>Mock解决的问题</h1><p><br><br>开发时，后端还没完成数据输出，前端只好写静态模拟数据。<br><br>数据太长了，将数据写在js文件里，完成后挨个改url。<br><br>某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。<br><br>想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。<br><br>特殊的格式，例如IP,随机数，图片，地址，需要去收集。<br></p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>官方地址：<a href="https://easy-mock.com/login" title="Easy Mock" target="_blank" rel="noopener">https://easy-mock.com/login</a></p><p>直接输入账号，密码，如果未注册，会直接注册。<br>进入如下页面，按图操作<br><img src="https://i.imgur.com/T7ZlKQu.png" alt=""></p><p><br><br>文档中给出了基本教程<br><br><img src="https://i.imgur.com/EFCIDDm.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Mock数据模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>环境变量与文件查找</title>
      <link href="/2018/08/16/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
      <url>/2018/08/16/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>介绍环境变量的作用与用法，及几种搜索文件的方法。学会这些技巧可以高效地使用 Linux 。<a id="more"></a></p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。<br><code>变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。</code></p><p>shell创建变量</p><pre><code>declare tmp</code></pre><p>shell变量复制</p><pre><code>temp=zxp</code></pre><p>输出变量</p><pre><code>echo $temp</code></pre><p><strong>注意</strong>：并不是任何形式的变量名都是可用的，变量名只能是英文字母、数字或者下划线，且<strong>不能以数字</strong>作为开头</p><h2 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。</p><p>通常我们会涉及到的变量类型有三种：</p><ul><li>当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。</li><li>Shell 本身内建的变量。</li><li>从自定义变量导出的环境变量。<br>也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：</li></ul><table><thead><tr><th>命 令</th><th>说 明</th></tr></thead><tbody><tr><td>set</td><td>显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。</td></tr><tr><td>env</td><td>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td></tr><tr><td>export</td><td>显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</td></tr></tbody></table><h3 id="环境变量永久生效"><a href="#环境变量永久生效" class="headerlink" title="环境变量永久生效"></a>环境变量永久生效</h3><p>按变量的生存周期来划分，Linux 变量可分为两类：</p><ul><li><p>永久的：需要修改配置文件，变量永久生效；</p></li><li><p>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。</p></li></ul><p>介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。<br>查看每个用户的永久生效的环境变量：</p><pre><code>cd /home/用户名ls -a</code></pre><h2 id="命令查找路径与顺序"><a href="#命令查找路径与顺序" class="headerlink" title="命令查找路径与顺序"></a>命令查找路径与顺序</h2><p>Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。</p><p>查看PATH环境变量路径：</p><pre><code>echo $PATH</code></pre><p>其中给出的路径存放可执行文件，当在shell中执行命令时，系统就会安装PATH中设定的路径依次到目录中查找，如果找到同名文件，则执行先找到的文件。</p><h3 id="创建Shell脚本"><a href="#创建Shell脚本" class="headerlink" title="创建Shell脚本"></a>创建Shell脚本</h3><p>创建脚本文件，并打开<br>    gedit hello_world.sh</p><p>在打开的文本中输入：</p><pre><code>#！ /bin/bash   //该行不是注释，不能少for((i=0; i&lt;10; i++));do    echo &quot;hello world&quot;doneexit 0</code></pre><p>为文件添加可执行权限</p><pre><code>chmod 755 hello_shell.sh</code></pre><p>执行脚本</p><pre><code>./hello_shell.sh</code></pre><h2 id="创建C语言程序"><a href="#创建C语言程序" class="headerlink" title="创建C语言程序"></a>创建C语言程序</h2><p>创建并打开一个文件</p><pre><code>gidit hello_world.c</code></pre><p>在文本中输入</p><pre><code>#include &lt;stdio.h&gt;int main(void){     printf(&quot;hello world&quot;);    return 0;}</code></pre><p>保存后，使用gcc生成可执行文件：</p><pre><code>gcc -o hello_world hello_world.c</code></pre><p><em>gcc生成二进制文件默认具有可执行文件，不需修改</em></p><p>在/当前目录修创建一个目录<code>mybin</code>,并将上述文件移动到其中<br>    mkdir mybin<br>    mv hello_shell.sh hello_world mybin/</p><p>并进入<code>mybin</code>目录，运行上述两个程序：</p><pre><code>cd mybin./hello_shell.sh./hello_world</code></pre><p>回到上一级目录，再运行程序，则发现提示命令找不到，除非加上命令的完整路径，但比较麻烦，可以进该路径添加到PATH环境变量。</p><h2 id="添加自定义路径到“PATH”环境变量"><a href="#添加自定义路径到“PATH”环境变量" class="headerlink" title="添加自定义路径到“PATH”环境变量"></a>添加自定义路径到“PATH”环境变量</h2><pre><code>PATH=$PATH:/home/shiyanlou/mybin</code></pre><p><strong><code>=</code>之前之后不能添加空格，否则会提示变量不存在</strong><br><br>注意：路径必须是绝对路径</p><p>这样在任意目录中，都可以执行上述两个文件，直接输入文件名即可执行。<br>到此，如果退出终端，再打开则会发现失效，可以添加一种自动执行的方式：<br>在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 <code>.zshrc</code>，相应 Bash 的配置文件为<code>.bashrc</code>。它们在 <code>etc</code> 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。</p><pre><code>echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</code></pre><p>上述命令中 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 &gt; 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。</p><h2 id="变量修改和删除"><a href="#变量修改和删除" class="headerlink" title="变量修改和删除"></a>变量修改和删除</h2><p>变量的修改有以下几种方式：</p><table><thead><tr><th>变量设置方式</th><th>说明</th></tr></thead><tbody><tr><td>${变量名#匹配字串}</td><td>从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td>${变量名##匹配字串}</td><td>从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td>${变量名%匹配字串}</td><td>从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td>${变量名%%匹配字串}</td><td>从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td>${变量名/旧的字串/新的字串}</td><td>将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td>${变量名//旧的字串/新的字串}</td><td>将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><h2 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h2><pre><code>unset temp</code></pre><h2 id="环境变量立即-生效"><a href="#环境变量立即-生效" class="headerlink" title="环境变量立即 生效"></a>环境变量立即 生效</h2><p>在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如：</p><pre><code>source .zshrcc</code></pre><p><code>source</code>命令还有一个别名就是 <code>.</code>，注意与表示当前路径的那个点区分开，虽然形式不一样，但作用和使用方式一样，上面的命令如果替换成<code>.</code>的方式就该是:</p><pre><code>. ./.zshrc</code></pre><p>注意第一个点之后必须有个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。</p><h1 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h1><p>与搜索相关的命令常用的有 whereis，which，find 和 locate 。</p><h2 id="whereis简单快捷"><a href="#whereis简单快捷" class="headerlink" title="whereis简单快捷"></a>whereis简单快捷<br></h2><pre><code>whereis find</code></pre><p><img src="https://i.imgur.com/QHit5bQ.png" alt=""></p><p>找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。</p><h2 id="locate快而全"><a href="#locate快而全" class="headerlink" title="locate快而全"></a>locate快而全</h2><p>通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。</p><pre><code>locate 文件名</code></pre><p>安装软件包：<code>yum install mlocate</code></p><h2 id="which小而精"><a href="#which小而精" class="headerlink" title="which小而精"></a>which小而精</h2><p><code>which</code>本身是 <code>Shell</code> 内建的一个命令，通常使用 <code>which</code>来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令：</p><pre><code>which man</code></pre><h2 id="find精而细"><a href="#find精而细" class="headerlink" title="find精而细"></a>find精而细<br></h2><p>find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p><pre><code>find / -name 文件名  //w文件名查找find /etc/ -name interfaces  //表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。</code></pre><p><strong><br>注意</strong> find 命令的路径是作为第一个参数的， 基本命令格式为 <code>find [path] [option] [action]</code> 。</p><p>与时间相关的命令参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-atime</td><td>最后访问时间</td></tr><tr><td>-ctime</td><td>最后修改文件内容的时间</td></tr><tr><td>-mtime</td><td>最后修改文件属性的时间</td></tr></tbody></table><p>下面以 -mtime 参数举例：</p><ul><li><code>-mtime n：n</code> 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li><li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li><li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li><li><p><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名<br></p><p>  find ~ -mtime 0 //查找当天(24小时之内)右改动的文件<br>  find ~ -newer /home/shiyanlou/Code  //列出目录下比 Code 文件夹新的文件</p></li></ul><p>以上内容来自:<a href="https://www.shiyanlou.com" target="_blank" rel="noopener">实验楼</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python实现：用位运算符实现加法，不允许使用 “+”</title>
      <link href="/2018/08/16/Python%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20%E2%80%9C+%E2%80%9D/"/>
      <url>/2018/08/16/Python%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20%E2%80%9C+%E2%80%9D/</url>
      <content type="html"><![CDATA[<p>计算两个整数a、b的和，但是不能使用“+”操作符。<a id="more"></a><br>即：给定a=1,b=2，返回结果3</p><h1 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h1><h2 id="1、位运算符"><a href="#1、位运算符" class="headerlink" title="1、位运算符"></a>1、位运算符</h2><p>利用位运算实现加法，即计算机利用二进制进行运算，当然离不开位运算</p><p><img src="https://i.imgur.com/V2JKW9z.jpg" alt=""></p><h2 id="2、异或运算"><a href="#2、异或运算" class="headerlink" title="2、异或运算"></a>2、异或运算</h2><p>相同为0，不同为1</p><pre><code>1 ^ 1 = 01 ^ 0 = 10 ^ 1 = 10 ^ 0 = 0</code></pre><p>要实现加法，先考虑1位数的加法，不考虑进位，如下：<br>    1 + 1 = 0<br>    1 + 0 = 1<br>    0 + 1 = 1<br>    0 + 0 = 0<br>可知，上面的表达式可以用位运算符”^”代替，接下来考虑进位</p><h2 id="3、与运算"><a href="#3、与运算" class="headerlink" title="3、与运算"></a>3、与运算</h2><p>都为1,则为1</p><p>上面的加法可以表示为：<br>    0 &amp; 0 = 不进位<br>    1 &amp; 0 = 不进位<br>    0 &amp; 1 = 不进位<br>    1 &amp; 1 = 进位   </p><p>从上推到，可得：</p><p>位运算中，用“&lt;&lt;”表示向左移动一位，即“进位”，我么可以用以下表达式实现进位：</p><pre><code>（x&amp;y&lt;&lt;1</code></pre><p>于是可以得到如下两个表达式：</p><pre><code>x^y //执行加法（x&amp;y&lt;&lt;1 //进位操作</code></pre><p>两位数的加法：</p><pre><code>11+01=100 //实际的二进制算法//推算表达式11^01=1011&amp;01&lt;&lt;1 = 10</code></pre><p>由于不能使用加法，接着按上述算法计算：</p><pre><code>10^10 =00(10&amp;10)&lt;&lt;1=100</code></pre><p>到此，就可以得出结论，总结如下定理：</p><p><strong>定理一</strong>：设a，b位两个二进制数，则a+b=a^b+(a&amp;b)&lt;&lt;1 <br><br>证明： a^b是不考虑进位的加法结果，当二进制位同时为1时，才有进位，因此(a&amp;b)&lt;&lt;1 是进位产生的值，称为进位补偿，将两者相加便是完整加法结果。<br><br><strong>定理二</strong>：利用定理一可以实现只用位运算进行加法运算。<br><br>证明： 利用定理一中的等式不停对自身进行迭代，每迭代一次，进位补仓右边就多一位0，因此最多需要加数二进制位数长度次迭代，进为补偿就变为0，这时运算结束。</p><h2 id="4、Python实现"><a href="#4、Python实现" class="headerlink" title="4、Python实现"></a>4、Python实现</h2><pre><code>#不使用“+”来求两个数的和def newadd(a, b):      ta = a&amp;b        tb = a^b      while(ta):            t_a = tb            t_b = ta&lt;&lt;1            ta = t_a &amp; t_b            tb = t_a ^ t_b      print(&apos;a+b=&apos;, tb)if __name__ == &quot;__main__&quot;:      newadd(4,5)&apos;&apos;&apos;计算过程：a = 100  //4b = 101  //5ta = 100  //4tb = 001  //1进入循环循环t_a = 001 t_b = 1000 //8ta = 0000 //0tb = 1001 //9退出循环&apos;&apos;&apos;</code></pre><p>转自：<a href="http://t.pae.baidu.com/s?s=bai-paallr" target="_blank" rel="noopener">http://t.pae.baidu.com/s?s=bai-paallr</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 面试题目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django安装（二）</title>
      <link href="/2018/08/16/Django%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/08/16/Django%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Python之Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django简介（一）</title>
      <link href="/2018/08/16/Django%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/08/16/Django%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Django是使用Python开发的开源Web开发框架。使用Django，你能以最小的代价构建和维护高质量的Web应用。<a id="more"></a></p><h2 id="使用Django的原因："><a href="#使用Django的原因：" class="headerlink" title="使用Django的原因："></a>使用Django的原因：</h2><ul><li><p>Django诞生于新闻网站的环境中，它所提供的特性非常适合开发内容类的网站（例如：博客，交流社区，图片分享站等等……）。因为Django是在快节奏的新闻编辑环境中开发的，它的设计目的是使常见的Web开发任务变得快速而简单。</p></li><li><p>Django是开源的，不是商业项目或者科研项目，它集中力量解决Web开发中所遇到的一系列问题。因此，Django每天都在现有的基础上进步，以适应不断更迭的开发需求。这样即节省了开发时间，也提高了后期维护的效率。</p></li></ul><h2 id="Django概览"><a href="#Django概览" class="headerlink" title="Django概览"></a>Django概览</h2><p>在Django建立网站的过程中，我分为3个Python文件（models.py, urls.py, views.py） 和HTML模板文件（template.html）来讲解。</p><h3 id="设计模型Model"><a href="#设计模型Model" class="headerlink" title="设计模型Model"></a>设计模型Model</h3><p>Django无需数据库就可以使用，通过对象关系映射器（Object-relational mapping）,仅使用python代码就可以描述数据结构。</p><pre><code>from django import modelsclass book(models.Model):    name = models.CharField(max_length=100)    pud_date = models.DateField()</code></pre><p><code>models.py</code>    文件主要用一个Python类来描述数据表。称为模型（model）。运用这个类，你可以通过简单的Python代码来创建、检索、更新、删除数据库中的记录而无需写一条由一条的SQL语句。在这里我们创建了一个book模型，并定义了name和pub_date属性。</p><h3 id="设计视图views"><a href="#设计视图views" class="headerlink" title="设计视图views"></a>设计视图views</h3><p>在模型定义之后，我们便可以在视图中引用模型，通常，根据视图参数检索数据，加载一个模板，并使用检索到的数据呈现模板。</p><pre><code>form django.shortcuts import renderfrom .models import Persondef book_archive(request, year):    book_list = Person.objects.filter(birth_year = year)    content = {% raw %}{'year': year, 'book_list': book_list}{% endraw %}    return render(request, &apos;books/year_archive.html&apos;, context)</code></pre><p><code>views.py</code>文件包含了页面的业务逻辑。 <code>book_archive()</code>函数叫做视图。 这里还用到了year_archive.html模板。</p><h3 id="设计链接URLs"><a href="#设计链接URLs" class="headerlink" title="设计链接URLs"></a>设计链接URLs</h3><p>优雅简洁的Url解析式是衡量高品质网站的重要标准。Django鼓励使用漂亮的URL设计。使用这些优美的URL,只需要建立URL和Python回调函数简单的映射关系。</p><pre><code>from django.urls import pathfrom . import viewsulrpatterns = [    path(&apos;book/&lt;int:year&gt;&apos;, views.year_archive)]</code></pre><p><code>urls.py</code>指出了什么样的 URL 调用什么视图。 在这个例子中<code>books/xxxxx</code>将会调用 <code>year_archive()</code>这个函数。也就是说，在进入这个链接时，会返回视图函数的结果。</p><h3 id="设计模板"><a href="#设计模板" class="headerlink" title="设计模板"></a>设计模板</h3><p>Django拥有强大的模板功能，使用该模板能设计处强大的web页面</p><pre><code>{% raw %}{%block title%}Books for {{year}}{%endblock%}{{%block content}}<h1> Articles for {{years}} </h1>{% for book in book_list %}<p>{{book.name}}</p><p>Published{{book.put_date | date: "F j, Y"}}</p>{% endfor %}{% end block %}{% endraw %}</code></pre><p><code>year_archive.html</code>是 html 模板。 使用带基本逻辑声明的模板语言，如{% for book in book_list %}，它试图将函数返回的结果显示在网页上。</p><p>Django的这种结构我们称之为MTV模式：M代表模型(Model)，T代表模板(Template)，V代表视图(View)。这三个分别代表了三种不同功能的Web应用，各司其职，又彼此合作。</p><p>转自：<a href="https://www.shiyanlou.com/courses/1127" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/1127</a></p>]]></content>
      
      <categories>
          
          <category> Python之Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序开发工具调试</title>
      <link href="/2018/08/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95/"/>
      <url>/2018/08/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>小程序开发过程中，调试是让程序跑起来的关键。<a id="more"></a><br>第一步：点击调试器</p><p><img src="https://i.imgur.com/ACdgBOh.png" alt=""></p><p>第二步：点击sources</p><p><img src="https://i.imgur.com/D59w6ea.png" alt=""></p><p>第三步：在目录中找到需要调试的js文件，打开图中文件，注意不是后缀为js的文件，而是js？[sm]的文件</p><p><img src="https://i.imgur.com/tZKGrVq.png" alt=""></p><p>第四步： 在文件中设置断点<br><br>将鼠标移到文件最左侧，点击即可设置断点</p><p><img src="https://i.imgur.com/Mv5G61K.png" alt=""><br><strong>快捷键ctrl+b进入调试</strong><br><br>第五步：点击红色箭头按钮，继续执行到下一个断点<br><br>点击蓝色按钮，继续执行&lt;/r.<br>点击黄色按钮，单步调试<br><img src="https://i.imgur.com/fIZSVCX.png" alt=""></p><p>第六步：查看变量值<br><br>方法一： 鼠标放在变量上，即可显示变量值<br><img src="https://i.imgur.com/bFqe8vy.png" alt=""></p><p>方法二：在调试器窗口，点开Scope标签，然后再点开相应变量</p><p><img src="https://i.imgur.com/Row1z1q.png" alt=""></p><p>方法三：使用console.log(options);打印出来，在console窗口可以查看</p>]]></content>
      
      <categories>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git + TortoiseGit安装教程和环境部署</title>
      <link href="/2018/08/15/Git%20+%20TortoiseGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/15/Git%20+%20TortoiseGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>对于程序员而言，版本管理是不可缺少的一部分，利用Gitlab或Github对代码进行管理大大提高的效率，本文介绍如何搭建环境。<a id="more"></a></p><p>工作模式： 生成公私钥对，将公钥部署到github上，然后利用保存在本地的私钥去连接github</p><p>第一步: 下载Git: <a href="https://git-scm.com/downloads" title="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>第二步： 下载TortoiseGit: <a href="https://tortoisegit.org/download/" target="_blank" rel="noopener">https://tortoisegit.org/download/</a></p><p>第三步： 安装以上两个软件，如果英语不ok的，可以安装tortoisegit语言包（<a href="https://download.tortoisegit.org/tgit/2.6.0.0/TortoiseGit-LanguagePack-2.6.0.0-64bit-zh_CN.msi" target="_blank" rel="noopener">简体中文语言包</a>）</p><p>在安装TortoiseGit后，第一次配置时，选择语言</p><p><img src="https://i.imgur.com/9eXOV7H.png" alt=""></p><p>或者在TortoiseGit的设置进行设置，如下：<br><br>首先鼠标右键，移到TortoiseGit上，点击Setting,进入如下页面，即可进行设置</p><p><img src="https://i.imgur.com/x8bqPCu.png" alt=""></p><p>第三步： 密钥生成及部署</p><p>在电脑搜索栏输入PuTTygen，打开软件</p><p><img src="https://i.imgur.com/bpnbfmw.png" alt=""></p><p>点击Generate</p><p><img src="https://i.imgur.com/DuP2F0a.png" alt=""></p><p>在红色方框内不停移动鼠标，10秒左右，进入如下页面：</p><p><img src="https://i.imgur.com/DXOtW6Q.png" alt=""></p><p>点击Save private key,将私钥保存到本地：</p><p><img src="https://i.imgur.com/hFAjehH.png" alt=""></p><p>点击是，并输入私钥文件名</p><p>接着将公钥填到Github或Gitlab中，这里以github为例，gitLab相同：<br> 首页点击右上角的头像，并选择点击setting</p><p><img src="https://i.imgur.com/NIuRTsI.png" alt=""></p><p>然后点击 SSH Keys</p><p><img src="https://i.imgur.com/FcQBKu3.png" alt=""></p><p>接着点击创建一个ssh Key, 并将复制的公钥填入Key一栏中：</p><p><img src="https://i.imgur.com/Hef7aPM.png" alt=""></p><p>第四步： 利用本地的私钥去连接Github，并克隆（clone）代码包到本地</p><p>在需要存放代码的目录下，点击右键，并点击 git clone（git 克隆），进入如下页面：</p><p><img src="https://i.imgur.com/2LnKwQI.png" alt=""></p><p>根据图中指示填好，然后点击ok，即可将代码克隆到本地</p><p>其中的URL在Github上保存的代码包顶部地址</p><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>第一步： 右键点击 git commit </p><p><img src="https://i.imgur.com/O4HrZkB.png" alt=""></p><p>第二步： 右键点击 TortoiseGit,并点击push（推送）：</p><p><img src="https://i.imgur.com/oP3J76W.png" alt=""></p><p>点击ok即可</p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序开发前言</title>
      <link href="/2018/08/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%89%8D%E8%A8%80/"/>
      <url>/2018/08/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>在这里，将介绍开发小程序的前期准备，和开发框架的了解<a id="more"></a></p><p>第一步 注册微信小程序账号：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" title="链接送上" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a></p><p>第二步 开发环境安装： <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18081317" title="链接送上" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18081317</a></p><p>第三步 小程序开发架构的了解，将是本文的重点</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>进入开发工具，可见如下图的目文件：</p><p><img src="https://i.imgur.com/xPSgVkj.png" alt=""></p><p>utils中的文件处理全局配置<br><br>pages下还有文件夹，每个文件夹对应一个页面，每个文件加下的文件管理对应的页面</p><ul><li>app.json: 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等<br></li><li>project.config.json: 在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发   者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。<br></li><li>page.json: 可以独立定义每个页面的一些属性，例如顶部颜色、是否允许下拉刷新等等</li><li>wxml：相当于web开发中的html文件，用来描叙页面的结构<br></li><li>wxss: 相当于web开发中的css文件,兼容大部分css的特性<br></li><li>Js: 负责用户交互,响应用户的点击、获取用户的位置等等<br></li></ul><h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><ul><li>逻辑层：逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。</li><li>开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。<br>视图层：框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示；将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。</li></ul>]]></content>
      
      <categories>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手机抓包软件：charles安装及教程</title>
      <link href="/2018/08/13/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%EF%BC%9Acharles%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/13/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%EF%BC%9Acharles%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>手机app或微信小程序开发过程中，解决数据传输过程中的问题，抓包软件必不可少<a id="more"></a></p><h1 id="0、准备："><a href="#0、准备：" class="headerlink" title="0、准备："></a>0、准备：</h1><p>电脑关闭防火墙、其他代理或者翻墙软件</p><h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h1><p>最新版地址：<a href="https://www.charlesproxy.com/latest-release/download.do#" target="_blank" rel="noopener">charles</a></p><p>本教程使用v4.2.6</p><p>安装一路next即可</p><h1 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h1><p><strong>第一步</strong>： 查看本机IP</p><p>  方法一：运行-&gt;输入cmd-&gt;在命令行中输入：ipconfig<br><br>  方法二：在charles中点击Help-&gt;Local IP Adress</p><p><img src="https://i.imgur.com/8cxacvx.png" alt=""><br><br>第一行为本地IP,后面两行为虚拟IP</p><p><strong>第二步</strong>： 查看端口</p><p><img src="https://i.imgur.com/vZ8LWDH.png" alt=""></p><p><strong>第三步</strong>：手机上设置代理</p><p>安装证书</p><p> 复制<a href="http://charlesproxy.com/getssl或http://www.charlesproxy.com/ssl.zip" target="_blank" rel="noopener">http://charlesproxy.com/getssl或http://www.charlesproxy.com/ssl.zip</a> 到手机浏览器打开，点击 here 下载，安装，信任；</p><p>手机和电脑连接到同一局域网，在wifi中设置代理，ios如下：</p><p><img src="https://i.imgur.com/FVD46mi.png" alt="">  <img src="https://i.imgur.com/YS5YY45.png" alt=""></p><p>电脑端弹出connction from “IP”,点击allow</p><p><strong>第四步</strong>： 电脑端安装证书</p><p>点击help-&gt;SSL Proxying-&gt; install Charles root certificate</p><p><img src="https://i.imgur.com/A1lKaZK.png" alt=""></p><p>一路next即可安装</p><p>第五步：设置SSL代理</p><p>点击proxying-&gt;ssl proxying settings</p><p><img src="https://i.imgur.com/Y2fKZVp.png" alt=""></p><p>点击Add</p><p> <img src="https://i.imgur.com/2TIvQNX.png" alt=""></p><p>在host中填入：*通配符<br>在port中填入：443</p><h1 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h1><ul><li>Structure：树状结构显示，将网络请求按访问的域名分类；</li><li>Sequence：水平结构显示，将网络请求按访问的时间排序</li><li>垃圾桶图标 ： 功能是clear，清理掉所有请求显示信息</li><li>Filter ： 过滤，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求</li><li>Overview ： 查看这次请求的详细内容，例如耗时详细列车了请求开始时间、结束时间，响应开始时间、结束时间，总耗时、DNS耗时、网络延时等。 </li><li><p>对于Size也详细列出了请求头大小、响应头大小、压缩比例等内容。 </p></li><li><p>URL：进行网络请求的链接；</p></li><li>Status：当前状态，complete表示请求完成；</li><li>Responce Code：返回码。不同的接口，不同的请求结果，返回码都不同；</li><li>Protocol：使用的协议；</li><li>Method：请求方式，如GET请求，POST请求等；</li><li>Kept Alive：判断当前是否正在链接（活跃）；</li><li>Content-Type:发送的内容类型，如这里用的是XML文本，以UTF8的方式发送；</li><li>Client Address：客户端的IP地址；</li><li>Remote Address：远程服务器的IP；</li><li>Timing: <ul><li>Request Start Time：请求开始的时间；</li><li>Request End Time：请求结束的时间；</li><li>Response Start Time：返回开始的时间；</li><li>Response End Time : 返回结束的时间；</li><li>Duration : 总时间；</li></ul></li><li>Size: <ul><li>Request Header ：请求的头部大小；</li><li>Response Header：返回的头部大小；</li><li>Request : 请求发送的大小；</li><li>Response：返回数据的大小；</li><li>Total：所有数据大小；</li><li>Request Compression : 请求压缩；</li><li>Response Compression : 返回压缩；</li></ul></li><li>Request ： 查看请求内容（底下的Headers，Query String， Cookies，Raw。） <ul><li>Headers：发送请求的头部信息； </li><li>Query String : 发送参数列表；</li><li>Cookies： 浏览器缓存；</li><li>Raw：发送的原生数据，包括了头部和参数；</li></ul></li><li>Reponse : 查看响应内容 <ul><li>Headers：是返回的头部信息；</li><li>Text：返回信息（除去头部）后的文本； </li><li>Hex：返回信息的16进制表示；</li><li>XML：我返回的数据是XML。如果你返回的是JSON，这里就会显示JSON；</li><li>XML Text：如果你返回JSON，这里会显示JSON Text；</li><li>Raw：返回的所有原生数据，包括头部；</li></ul></li><li>Summary: 查看发送数据的一些简要信息（主机，状态码，数据的类型，header和body大下，加载时间，总时间）</li><li>Chart: Summary中简要信息以图表形式展示</li><li>Notes: 其他信息</li></ul><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>You may need to configure your browser or application to trust the Charles Root Certificate<br><br>由于手机虽然安装了证书，但是未信任</p><p>解决方案：<br><br>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可.</p><p>转自：<a href="https://blog.csdn.net/zhangxiang_1102/article/details/77855548" target="_blank" rel="noopener">更多详细内容见此</a></p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 手机抓包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim教程</title>
      <link href="/2018/08/13/Vim%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/13/Vim%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>本文介绍linux中的编辑器vim操作,以及基本命令操作<a id="more"></a></p><h1 id="Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式："><a href="#Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：" class="headerlink" title="Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式："></a>Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：</h1><ul><li>普通模式(Normal mode)</li></ul><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p><p>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</p><p>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</p><ul><li>插入模式(Insert mode)</li></ul><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p><p>在插入模式中，可以按ESC键回到普通模式。</p><p>可视模式(Visual mode)<br>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p><ul><li>选择模式(Select mode)<br>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</li></ul><ul><li>命令行模式(Command line mode)<br>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</li></ul><ul><li>Ex模式(Ex mode)<br>这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。</li></ul><p>这其中我们常用到就是普通模式、插入模式和命令</p><pre><code>vim  文件名 //如果文件名不存在，会自动创建文件并打开vim nginx.conf //进入普通模式a 或 i  //进入插入模式Esc  //退出插入模式，进入普通模式： //退出普通模式，进入命令行模式命令行模式下： wq保存退出</code></pre><h1 id="游标移动"><a href="#游标移动" class="headerlink" title="游标移动"></a>游标移动</h1><p>按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右（小写L）</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>w</td><td>移动到下一个单词</td></tr><tr><td>b</td><td>移动到上一个单词</td></tr></tbody></table><h1 id="从普通模式进入插入模式"><a href="#从普通模式进入插入模式" class="headerlink" title="从普通模式进入插入模式"></a>从普通模式进入插入模式</h1><p>按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右（小写L）</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>w</td><td>移动到下一个单词</td></tr><tr><td>b</td><td>移动到上一个单词</td></tr></tbody></table><h1 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h1><pre><code>:w 文件名 //可以将文档另存为其他文件名或存到其它路径下:w //保存文件:w test //另存为test文件</code></pre><h1 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h1><p>命令行模式下退出vim<br>从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑</p><p>以下为其它几种退出方式：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:q!</td><td>强制退出，不保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq!</td><td>强制保存并退出</td></tr><tr><td>:w &lt;文件路径&gt;</td><td>另存为</td></tr><tr><td>:saveas 文件路径</td><td>另存为</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr></tbody></table><p>普通模式下退出vim<br>普通模式下输入Shift+zz即可保存退出vim</p><h1 id="普通模式下删除vim文本信息"><a href="#普通模式下删除vim文本信息" class="headerlink" title="普通模式下删除vim文本信息"></a>普通模式下删除vim文本信息</h1><p>进入普通模式，使用下列命令可以进行文本快速删除：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除游标所在的字符</td></tr><tr><td>X</td><td>删除游标所在前一个字符</td></tr><tr><td>Delete</td><td>同x</td></tr><tr><td>dd</td><td>删除整行</td></tr><tr><td>dw</td><td>删除一个单词（不适用中文）</td></tr><tr><td>d$或D</td><td>删除至行尾</td></tr><tr><td>d^</td><td>删除至行首</td></tr><tr><td>dG</td><td>删除到文档结尾处</td></tr><tr><td>d1G</td><td>删至文档首部</td></tr></tbody></table><h1 id="vim重复命令（普通模式下）"><a href="#vim重复命令（普通模式下）" class="headerlink" title="vim重复命令（普通模式下）"></a>vim重复命令（普通模式下）</h1><pre><code>. 表示重复执行上次命令  //向输入x删除第一个字符，再输入.接着删除一个字符10x 表示删除10连续个字符3dd 表示删除3行文本dw或daw 删除一个单词dNw 删除N个单词</code></pre><p>#游标快速跳转</p><h2 id="行间跳转"><a href="#行间跳转" class="headerlink" title="行间跳转."></a>行间跳转.</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nG(n Shift+g)</td><td>游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号)</td></tr><tr><td>gg</td><td>游标移动到到第一行</td></tr><tr><td>G(Shift+g)</td><td>到最后一行</td></tr></tbody></table><h2 id="行内跳转"><a href="#行内跳转" class="headerlink" title="行内跳转"></a>行内跳转</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>到下一个单词的开头</td></tr><tr><td>e</td><td>到当前单词的结尾</td></tr><tr><td>b</td><td>到前一个单词的开头</td></tr><tr><td>ge</td><td>到前一个单词的结尾</td></tr><tr><td>0或^</td><td>到行头</td></tr><tr><td>$</td><td>到行尾</td></tr><tr><td>f&lt;字母&gt;</td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td></tr><tr><td>F&lt;字母&gt;</td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td></tr><tr><td>t&lt;字母&gt;</td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td></tr><tr><td>T&lt;字母&gt;</td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td></tr></tbody></table><h1 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h1><h2 id="复制及粘贴"><a href="#复制及粘贴" class="headerlink" title="复制及粘贴"></a>复制及粘贴</h2><p>普通模式中使用y复制</p><p>普通模式中，yy复制游标所在的整行（3yy表示复制3行）</p><p>普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。</p><p>普通模式中，y$ 复制至行尾。含光标所在处字符。</p><p>普通模式中，yw 复制一个单词。</p><p>普通模式中，y2w 复制两个单词。</p><p>普通模式中，yG 复制至文本末。</p><p>普通模式中，y1G 复制至文本开头。</p><p>普通模式中使用 p 粘贴</p><p>普通模式中，p(小写)代表粘贴至光标后（下）<br>普通模式中，P(大写)代表粘贴至光标前（上）</p><h2 id="剪切及粘贴"><a href="#剪切及粘贴" class="headerlink" title="剪切及粘贴"></a>剪切及粘贴</h2><p>dd删除命令其实是剪切，每次dd删除文档内容后，使用p来粘贴，这样可以实现—-交换上下行</p><h1 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h1><h2 id="字符的替换及撤销操作"><a href="#字符的替换及撤销操作" class="headerlink" title="字符的替换及撤销操作"></a>字符的替换及撤销操作</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>r+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td>R</td><td>连续替换，直到按下Esc</td></tr><tr><td>cc</td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td>cw</td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td>C(大写)</td><td>替换游标以后至行末</td></tr><tr><td>~</td><td>反转游标所在字母大小写</td></tr><tr><td>u{n}</td><td>撤销一次或n次操作</td></tr><tr><td>U(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td>Ctrl+r</td><td>redo，即撤销undo的操作</td></tr></tbody></table><h2 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h2><p>普通模式下操作 </p><pre><code>&gt;&gt; 整行向右缩进&lt;&lt; 整行向左回退</code></pre><p>普通模式下，对shftwidth值进行设置，可以控制缩进和回退e字符数</p><pre><code>:set shiftwidth? //查看当前缩进字符数:set shiftwidth=10 //设置缩进字符数为10</code></pre><p>shiftwidthn可以简写为sw</p><h2 id="调整文本位置"><a href="#调整文本位置" class="headerlink" title="调整文本位置"></a>调整文本位置</h2><p>命令行模式下，操作光标所在的行</p><pre><code>:ce //本行内容剧中:ri //本行内容靠右:le //本行内容靠左</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>普通模式下，输入 <em>/</em>, 然后输入需要查找的字符串，按回车即可进行查找。 <em>? </em>功能与 <em>/</em> 功能相同，只不过 <em>?</em>向下查找。进入查找之后，在字符串之后输入<em>n</em>和<em>N</em> 可以继续查找，<em>n</em>表示继续查找，<em>N</em>表示方向查找</p><h2 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h2><p>普通模式下输入*寻找游标所在处的单词<br><br>普通模式下输入#同上，但 # 是向前（上）找，*则是向后（下）找<br><br>普通模式下输入g*同* ，但部分符合该单词即可<br><br>普通模式下输入g#同# ，但部分符合该单词即可<br></p><h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><h3 id="vim编辑多个文件"><a href="#vim编辑多个文件" class="headerlink" title="vim编辑多个文件"></a>vim编辑多个文件</h3><pre><code>vim 1.txt 2.txt</code></pre><p>默认进入<em>1.txt</em>文件的编辑界面<br></p><ul><li>命令行模式下输入<em> :n </em>编辑 <em>2.txt </em>文件，可以加<em> ! </em>即<em> :n! </em>强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件<br></li></ul><ul><li>命令行模式下输入<em> :N </em>编辑 <em>1.txt </em>文件，可以加<br><em>! </em>即 <em>:N!</em> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li></ul><h3 id="进入vim后打开新文件"><a href="#进入vim后打开新文件" class="headerlink" title="进入vim后打开新文件"></a>进入vim后打开新文件</h3><ul><li>命令行模式下输入<code>:e 3.txt</code> 打开新文件<code>3.txt</code></li><li>命令行模式下输入<code>:e#</code>回到前一个文件</li><li>命令行模式下输入<code>:ls</code>可以列出以前编辑过的文档</li><li>命令行模式下输入<code>:b 2.txt</code>（或者编号）可以直接进入文件2.txt编辑</li><li>命令行模式下输入<code>:bd 2.txt</code>（或者编号）可以删除以前编辑过的列表中的文件项目</li><li>命令行模式下输入<code>:e! 4.txt</code>，新打开文件<code>4.txt</code>，放弃正在编辑的文件</li><li>命令行模式下输入<code>:f</code> 显示正在编辑的文件名</li><li>命令行模式下输入<code>:f new.txt</code>，改变正在编辑的文件名字为<code>new.txt</code></li></ul><h3 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a>恢复文件</h3><p>如果因为断电等原因造成文档没有保存，可以采用恢复方式，<code>vim -r</code>进入文档后，输入<code>:ewcover 1.txt</code>来恢复</p><pre><code>vim -r 1.txt</code></pre><h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><h3 id="可视模式命令简介"><a href="#可视模式命令简介" class="headerlink" title="可视模式命令简介"></a>可视模式命令简介</h3><ul><li>在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。</li><li>在普通模式下输入 Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取。</li><li>在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取。</li><li>在可视模式下输入 d 删除选取区域内容<br>在可视模式下输入y复制选取区域内容<h3 id="可视模式命令练习"><a href="#可视模式命令练习" class="headerlink" title="可视模式命令练习"></a>可视模式命令练习</h3></li><li>在普通模式下9G跳转到第9行,输入Shift+v（小写V），进入可视模式进行行选择，选中5行，按下&gt;&gt;缩进，将5行整体缩进一个shiftwidth</li><li>在普通模式下输入 Ctrl+v（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后x删除整列</li></ul><h2 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h2><p>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入 :new 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 Ctrl+w也可以），除了 :new 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：</p><p><strong>注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。</strong></p><ul><li>命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt</li><li>命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt</li><li>普通模式下Ctrl+w s 将当前窗口分割成两个水平的窗口</li><li>普通模式下Ctrl+w v 将当前窗口分割成两个垂直的窗口</li><li>普通模式下Ctrl+w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</li><li>普通模式下Ctrl+w o 打开一个视窗并且隐藏之前的所有视窗</li><li>普通模式下Ctrl+w j 移至下面视窗</li><li>普通模式下Ctrl+w k 移至上面视窗</li><li>普通模式下Ctrl+w h 移至左边视窗</li><li>普通模式下Ctrl+w l 移至右边视窗</li><li>普通模式下Ctrl+w J 将当前视窗移至下面</li><li>普通模式下Ctrl+w K 将当前视窗移至上面</li><li>普通模式下Ctrl+w H 将当前视窗移至左边</li><li>普通模式下Ctrl+w L 将当前视窗移至右边</li><li>普通模式下Ctrl+w 减小视窗的高度</li><li>普通模式下Ctrl+w + 增加视窗的高度</li></ul><h2 id="创建加密文档"><a href="#创建加密文档" class="headerlink" title="创建加密文档"></a>创建加密文档</h2><pre><code>vim -x nginx.conf</code></pre><p>根据提示输入密码，下次打开文件时，需要输入密码</p><h2 id="vim执行外部命令"><a href="#vim执行外部命令" class="headerlink" title="vim执行外部命令"></a>vim执行外部命令</h2><p>在命令行模式中输入!可以执行外部的shell命令</p><ul><li><code>:!ls</code> 用于显示当前目录的内容</li><li><code>:!rm FILENAME</code>用于删除名为 FILENAME 的文件</li><li><code>:w FILENAME</code>可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li></ul><h2 id="vim中查看帮助"><a href="#vim中查看帮助" class="headerlink" title="vim中查看帮助"></a>vim中查看帮助</h2><ul><li>普通模式下按F1打开vim自己预设的帮助文档</li><li>命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件</li><li>命令行模式下输入:ver 显示版本及参数</li></ul><h2 id="功能设定"><a href="#功能设定" class="headerlink" title="功能设定"></a>功能设定</h2><h3 id="vim的功能设定"><a href="#vim的功能设定" class="headerlink" title="vim的功能设定"></a>vim的功能设定</h3><p>可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用</p><h3 id="获取目前的设定"><a href="#获取目前的设定" class="headerlink" title="获取目前的设定"></a>获取目前的设定</h3><ul><li>命令行模式下输入:set或者:se显示所有修改过的配置</li><li>命令行模式下输入:set all 显示所有的设定值</li><li>命令行模式下输入:set option? 显示option的设定值</li><li>命令行模式下输入:set nooption 取消当前设定值<h3 id="set功能的说明"><a href="#set功能的说明" class="headerlink" title="set功能的说明"></a>set功能的说明</h3></li><li>命令行模式下输入:set autoindent(ai) 设置自动缩进</li><li>命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开</li><li>命令行模式下输入:set background=dark或light，设置背景风格</li><li>命令行模式下输入:set backup(bk) 设置自动备份，默认未打开</li><li>命令行模式下输入: set cindent(cin) 设置C语言风格缩进<br>-<br>以上内容来自<a href="https://www.shiyanlou.com/courses/2" title="实验楼" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/2</a>，为作者边学习，边摘抄和总计的内容</li></ul>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPN安装后无法连接到互联网</title>
      <link href="/2018/08/13/VPN%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91/"/>
      <url>/2018/08/13/VPN%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91/</url>
      <content type="html"><![CDATA[<p> VPN安装后无法连接到互联网问题解决方案<a id="more"></a><br>赛风（psiphon）下载地址<a href="https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct" target="_blank" rel="noopener">https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct</a></p><p>使用vpn时，出现浏览器无法连接到互联网问题解决：</p><p><img src="https://i.imgur.com/J1OUsRC.png" alt=""></p><p>原因是浏览器开启了局域网代理：</p><p><img src="https://i.imgur.com/73gPHHW.png" alt=""></p><p><img src="https://i.imgur.com/wKG7Mte.png" alt=""></p><p><img src="https://i.imgur.com/Q1iTRqq.png" alt=""></p><p><img src="https://i.imgur.com/D5vuZFK.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPN资源</title>
      <link href="/2018/08/13/VPN%E8%B5%84%E6%BA%90md/"/>
      <url>/2018/08/13/VPN%E8%B5%84%E6%BA%90md/</url>
      <content type="html"><![CDATA[<p>VPN资源：赛风和兰灯<a id="more"></a></p><p>赛风：<a href="https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct" title="https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct" target="_blank" rel="noopener">https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct</a></p><p>兰灯：<a href="http://pan.bcoderss.com/?dir=lan" title="http://pan.bcoderss.com/?dir=lan" target="_blank" rel="noopener">http://pan.bcoderss.com/?dir=lan</a>  (包括安卓、windows、mac和linux端资源)</p>]]></content>
      
      
        <tags>
            
            <tag> VPN </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown教程</title>
      <link href="/2018/08/12/Markdown%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/12/Markdown%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Markdown安装，升级，以及语法介绍<a id="more"></a></p><h1 id="升级Pro版本"><a href="#升级Pro版本" class="headerlink" title="升级Pro版本"></a>升级Pro版本</h1><h2 id="邮箱地址："><a href="#邮箱地址：" class="headerlink" title="邮箱地址："></a>邮箱地址：</h2><pre><code>Soar360@live.com</code></pre><h2 id="授权秘钥："><a href="#授权秘钥：" class="headerlink" title="授权秘钥："></a>授权秘钥：</h2><pre><code>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</code></pre><p>作者：hecatonchires<br>链接：<a href="https://www.jianshu.com/p/8a1bd4892291" target="_blank" rel="noopener">https://www.jianshu.com/p/8a1bd4892291</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p><p>来自：<a href="https://www.jianshu.com/p/8a1bd4892291" target="_blank" rel="noopener">https://www.jianshu.com/p/8a1bd4892291</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>支持六级标题</p><pre><code># 一级标题## 二级标题### 三级标题</code></pre><p>注意：#之后必须加一个空格，当然有些编辑器不用，但最后还是添加</p><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><pre><code>&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;内容填写在这里&lt;/font&gt;</code></pre><p>效果：<font color="#0099ff" size="5" face="黑体">内容填写在这里</font></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code> </li><li>斜体    <code>Ctrl + I</code> </li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等，详细语法参考帮助？。</p><p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考[Github][2].  </p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>Markdown　Extra</strong>　表格语法：</p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>. </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见[math.stackexchange.com][1].</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>更多LaTex语法请参考 [这儿][3].</p><h2 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h2><p>可以渲染序列图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 [这儿][4],</li><li>关于 <strong>流程图</strong> 语法，参考 [这儿][5].</li></ul><h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="noopener">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p><p>博客发表后，本地缓存将被删除。　</p><p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p></blockquote><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ol><li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li><li>IE９以下不支持</li><li>IE９，１０，１１存在以下问题<ol><li>不支持离线功能</li><li>IE9不支持文件导入导出</li><li>IE10不支持拖拽文件导入</li></ol></li></ol><h1 id="数学公式语法"><a href="#数学公式语法" class="headerlink" title="数学公式语法"></a>数学公式语法</h1><p>转：<a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">https://www.jianshu.com/p/a0aa94ef8ab2</a></p><p><a href="https://blog.csdn.net/yzr1183739890/article/details/64130912" target="_blank" rel="noopener">https://blog.csdn.net/yzr1183739890/article/details/64130912</a>:花括号</p><p><a href="https://blog.csdn.net/huanhuan_Coder/article/details/79325071" target="_blank" rel="noopener">https://blog.csdn.net/huanhuan_Coder/article/details/79325071</a></p><h1 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h1><p>转自：<a href="https://www.jianshu.com/p/191d1e21f7ed" title="其他语法" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></p>]]></content>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用的压缩/解压工具：zip和tar</title>
      <link href="/2018/08/11/Linux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7zip%E5%92%8Ctar/"/>
      <url>/2018/08/11/Linux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7zip%E5%92%8Ctar/</url>
      <content type="html"><![CDATA[<p>知识点：zip命令、tar命令、压缩与解压常用组合<a id="more"></a></p><h1 id="常用压缩包格式"><a href="#常用压缩包格式" class="headerlink" title="常用压缩包格式"></a>常用压缩包格式</h1><table><thead><tr><th>文件后缀名</th><th>说明</th></tr></thead><tbody><tr><td>*.zip</td><td>zip 程序打包压缩的文件</td></tr><tr><td>*.rar</td><td>rar 程序压缩的文件</td></tr><tr><td>*.7z</td><td>7zip 程序压缩的文件</td></tr><tr><td>*.tar</td><td>tar 程序打包，未压缩的文件</td></tr><tr><td>*.gz</td><td>gzip 程序（GNU zip）压缩的文件</td></tr><tr><td>*.xz</td><td>xz 程序压缩的文件</td></tr><tr><td>*.bz2</td><td>bzip2 程序压缩的文件</td></tr><tr><td>*.tar.gz</td><td>tar 打包，gzip 程序压缩的文件</td></tr><tr><td>*.tar.xz</td><td>tar 打包，xz 程序压缩的文件</td></tr><tr><td>*tar.bz2</td><td>tar 打包，bzip2 程序压缩的文件</td></tr><tr><td>*.tar.7z</td><td>tar 打包，7z 程序压缩的文件</td></tr></tbody></table><h1 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h1><pre><code>zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop</code></pre><p>将Desktop目录下的子文件打包成shiyanlou.zip压缩文件，<code>-r</code>表示递归打包包含子目录的全部内容，<code>-q</code>表示安静模式，不向屏幕显示内容，<code>-o</code>表示输出文件，须在其后紧跟打包输出文件名（shiyanlou.zip）。</p><pre><code>du -h shiyanlou.zip </code></pre><p><code>du</code>命令查看打包文件的大小。<code>-h</code>表示文件大小可读，<code>-d</code>表示查看所查文件的深度，打印在屏幕上。</p><p>加密创建zip包：<br><br>使用<code>-e</code>参数</p><pre><code>zip -r -e -o shiyanlou_e.zip /home/shiyanlou/Desktop</code></pre><p>跟着屏幕提示输入密码</p><p><strong>注意</strong>：： 关于<code>zip</code>命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：</p><pre><code>zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop</code></pre><h1 id="unzip解压zip文件"><a href="#unzip解压zip文件" class="headerlink" title="unzip解压zip文件"></a>unzip解压zip文件</h1><pre><code>unzip shiyanlou.zip</code></pre><p>u使用安静模式,将文件解压到指定目录：</p><pre><code>unzip -q shiyanlou.zip -d ziptest</code></pre><p>上述目录不存在，将会自动创建，如果不想解压只想查看压缩包的内容，可以使用<code>-l</code>参数：</p><pre><code>unzip -l shiyanlou.zip</code></pre><p><strong>注意</strong>：中文的兼容性问题，windows系统创建的压缩文件，如果有中文文档或文件名为中文，默认采用GBK或其他编码，而Linux上默认使用的是UTF-8编码。</p><p>使用<code>-o</code>参数指定编码类型：</p><pre><code>unzip -o GBK 中文压缩文件.zip</code></pre><h1 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h1><p>tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。</p><p><strong>创建一个tar包：</strong></p><pre><code>tar -cf shiyanlou.tar home/shiyanlou/Desktop</code></pre><p><img src="https://i.imgur.com/t43P6f3.png" alt=""><br>不能使用相对路径，不然会提示图中问题</p><p>上面命令中，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用户指定创建的文件，注意文件名必须紧跟在<code>-f</code>参数之后，比如不能写出<code>tar -fc shiiyanlou.tar</code>,可以写成<code>tar -f shiyanlou.tar -c</code>。<br><br><code>-v</code>参数以可视的方式输出打包的文件，</p><p><strong>解压一个tar包：</strong><br><br>解压参数：<code>-x</code><br><br>指定已存在的目录： <code>-C</code><br></p><pre><code>tar -xf shiyanlou.tar -C tardir</code></pre><p><strong>只查看不解包文件：</strong><br><br>参数： -t</p><pre><code>tar -tf shiyanlou.tar</code></pre><p>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）：<br>    tar -cphf etc.tar /etc</p><p><strong>使用gzip来压缩文件</strong></p><p>添加<code>-z</code>参数</p><pre><code>tar -czf shiyanlou.tar.gz home/shiyanlou/Desktop</code></pre><p><strong>解压<code>*.tar.gz</code>文件</strong></p><pre><code>tar -xzf shiyanlou.tar.gz</code></pre><p>要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：</p><table><thead><tr><th>压缩文件格式</th><th>参数</th></tr></thead><tbody><tr><td>*.tar.gz</td><td>-z</td></tr><tr><td>*.tar.xz</td><td>-J</td></tr><tr><td>*tar.bz2</td><td>-j</td></tr></tbody></table><p>tar 命令的参数很多，不过常用的就是上述这些，需要了解更多你可以查看 man 手册获取帮助。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>常用命令：</p><ul><li>zip：<ul><li>打包 ：zip something.zip something （目录请加 -r 参数）</li><li>解包：unzip something.zip</li><li>指定路径：-d 参数</li></ul></li><li>tar：<ul><li>打包：tar -cf something.tar something</li><li>解包：tar -xf something.tar</li><li>指定路径：-C 参数</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo搭建属于自己的博客</title>
      <link href="/2018/08/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/08/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本文将介绍利用Hexo搭建博客的教程，包括其中遇到问题的解决方案，包括：添加域名等等内容，本人亲自实践过，希望对您有所帮助，如果遇到其他问题，可联系本人。<a id="more"></a></p><h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h1><p>Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>Nodejs:<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>Github账号，并创建新仓库</p><p>新建仓库如下：<br><img src="https://i.imgur.com/Qt2pUjV.png" alt=""><br><img src="https://i.imgur.com/FSsJniC.png" alt=""></p><h1 id="安装Nodejs："><a href="#安装Nodejs：" class="headerlink" title="安装Nodejs："></a>安装Nodejs：</h1><p>一路next即可</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>安装一路next，重点在配置</p><p>首先将安装目录添加进环境变量</p><p>然后设置用户名和邮箱</p><pre><code>$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com</code></pre><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>在所要存放博客文件的文件夹下右键，点击git bash</p><p>输入如下命令：</p><pre><code>npm install -g hexo-cli</code></pre><h1 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h1><pre><code>hexo init </code></pre><h1 id="安装依赖依赖包"><a href="#安装依赖依赖包" class="headerlink" title="安装依赖依赖包"></a>安装依赖依赖包</h1><pre><code>npm install</code></pre><h1 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h1><p>在博客目录下找到_config.yml,修改如下内容<br><br><strong>在修改配置文件时，建议使用Notepad++进行编辑，原因是缩进和空格会影响代码能否成功提交</strong></p><pre><code># Sitetitle: 平步青云winsubtitle:description: 建站 Linux Python C++ 编程语言keywords: 建站 Linux Python C++ 编程语言author: zxplanguage: zh-Hanstimezone:deploy:  type: git  repository: https://github.com/zxpgo/blog.git# 博客仓库地址 #repository: https://github.com/xxx/xxx.github.io.git </code></pre><p>博客仓库地址见本文开头第二张图片内的地址</p><p>注意：<strong>：之后必须添加一个空格再添加内容</strong></p><p>否则会有如下错误：<br><img src="https://i.imgur.com/Z9xaVfN.png" alt=""></p><h1 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h1><pre><code>hexo new &quot;文章名字&quot;</code></pre><h1 id="本地站点生成"><a href="#本地站点生成" class="headerlink" title="本地站点生成"></a>本地站点生成</h1><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><pre><code>hexo g</code></pre><p>显示如下信息，表示成功</p><p><img src="https://i.imgur.com/UpMYKme.png" alt=""></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><pre><code>hexo s</code></pre><p>显示如下信息，表示成功：</p><p><img src="https://i.imgur.com/ENe7sIs.png" alt=""></p><p>到此本地的配置结束</p><p>打开浏览器，输入localhost:4000查看</p><h1 id="部署Github"><a href="#部署Github" class="headerlink" title="部署Github"></a>部署Github</h1><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo dhexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。（个人习惯，非必需）hexo g #生成静态文件，每次改动之后都需要执行以下这个命令。hexo d #这个才是真正的部署命令，这里用的都是简写形式</code></pre><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a><font color="#f00">问题一</font></h2><p>运行时出错，由于还没有添加sshkey，具体教程如下：<br>打开Git Bash</p><p>设置Git的user name和email：（前面以及设置）</p><pre><code>git config --global user.name &quot;aqiongbei&quot; #改成你的注册Github的用户名git config --global user.email &quot;aqiongbei@gmail.com&quot; #改成你的注册Github的邮箱</code></pre><h2 id="生成SSH密钥："><a href="#生成SSH密钥：" class="headerlink" title="生成SSH密钥："></a>生成SSH密钥：</h2><p>生存密钥：</p><pre><code>ssh-keygen -t rsa -C &quot;aqiongbei@gmail.com&quot; #改成你注册Github的邮箱</code></pre><p>返回提示如下：</p><p><img src="https://i.imgur.com/ONTwjSc.png" alt=""></p><p>然后会提示，不用理，直接按回车，一共三次。<br>在C:\Users\Neckpain.ssh得到 id_rsa 和 id_rsa.pub 文件，说明生成成功</p><h2 id="添加密钥到-Github"><a href="#添加密钥到-Github" class="headerlink" title="添加密钥到 Github"></a>添加密钥到 Github</h2><p>打开 Github，登录自己的账号后<br>点击自己的头像-&gt;settings-&gt;SSH Keys-&gt;Add SSH key<br>将本地 id_rsa.pub 中的内容粘贴到 Key 文本框中，随意输入一个 title，点击 Add Key 即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Git里面继续输入</p><pre><code>ssh -T git@github.com</code></pre><p>返回</p><p><img src="https://i.imgur.com/ztaoOqM.png" alt=""></p><p>则说明验证成功。</p><h2 id="问题一-1"><a href="#问题一-1" class="headerlink" title="问题一"></a><font color="#f00">问题一</font></h2><p>ERROR Deployer not found: git</p><p><img src="https://i.imgur.com/g0NwgIs.png" alt=""></p><p>解决方案如下：</p><pre><code>npm install --save hexo-deployer-git</code></pre><h2 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h2><p>首先购买域名，博主在阿里云购买，记得实名认证</p><p>首先在域名控制台添加记录，</p><p><img src="https://i.imgur.com/KvOvo9Q.png" alt=""></p><p>记录一般添加两条，具体如下:</p><p><img src="https://i.imgur.com/m3HfCIE.png" alt=""></p><p>其中的ip通过ping命令获取github服务器ip,其中仓库的URL为：</p><pre><code>github&apos;用户名&apos;.github.io</code></pre><p>具体可见下图：</p><p><img src="https://i.imgur.com/KiuLQXH.png" alt=""></p><p>然后在github的博客代码处添加一个CNMAE文件，不要后缀，或者在本地的source文件（所有提交的文件都放在该目录下）中添加该文件，并提交，</p><p>内容为申请的域名</p><pre><code>www.zxpblog.cnzxpblog.cn</code></pre><p>最后还得在setting中的Custom domain处添加域名，必须加www, 如下<br><img src="https://i.imgur.com/ZbIj49r.png" alt=""></p><p><img src="https://i.imgur.com/RPLwY5K.png" alt=""></p><h1 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h1><p>在本地博客目录下打开git bash</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>在_config.yml中找到theme修改为下载的主题名</p><p><img src="https://i.imgur.com/RPI4qld.png" alt=""></p><p>重新部署到github即可</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h1 id="底部添加访问量统计"><a href="#底部添加访问量统计" class="headerlink" title="底部添加访问量统计"></a>底部添加访问量统计</h1><p>部分主题自带访问量统计，不用配置<br>打开\themes\主题名字\layout_partials\footer.swig文件,不同具体footer文件的后缀可能不同，在顶部添加如下代码：</p><pre><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>接着在合适的地方添加需要显示的统计数字代码（同上文件）：</p><pre><code>&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;  本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><p>两种统计方式：</p><ul><li>同一用户连续点击n篇文章，记录n次访问量</li><li>  <span id="busuanzi_container_site_pv"><br>  本站总访问量<span id="busuanzi_value_site_pv"></span>次<br>  </span></li></ul><ul><li>同一用户连续点击n篇文章，记录1次访问量</li><li>  <span id="busuanzi_container_site_uv"><pre><code>本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次</code></pre>  </span></li></ul><h1 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h1><p>首先安装 hexo-generator-feed包</p><pre><code>npm install hexo-generator-feed</code></pre><p>在配置文件中添加如下代码：</p><pre><code>#RSS配置feed:    type: atom    path: atom.xml    limit: 20    hub:    content:    content_limit:       content_limit_delim: &apos; &apos;</code></pre><p>主题不同，添加方式可能不同，NEXT主题 _<br>CONFIG.YML文件中有个 RSS的配置，直接设置为 TRUE就可以了 </p><h1 id="Yelee主题"><a href="#Yelee主题" class="headerlink" title="Yelee主题"></a>Yelee主题</h1><p><a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">http://moxfive.coding.me/yelee/</a></p><h1 id="Hexo中的Yelee主题，首页不显示文章摘要"><a href="#Hexo中的Yelee主题，首页不显示文章摘要" class="headerlink" title="Hexo中的Yelee主题，首页不显示文章摘要"></a>Hexo中的Yelee主题，首页不显示文章摘要</h1><p>转自：<a href="https://blog.csdn.net/youshaoduo/article/details/78709160" target="_blank" rel="noopener">https://blog.csdn.net/youshaoduo/article/details/78709160</a></p><h1 id="首页显示文章摘要"><a href="#首页显示文章摘要" class="headerlink" title="首页显示文章摘要"></a>首页显示文章摘要</h1><p>方法一：在需要显示的摘要之后添加如下代码：</p><pre><code>&lt;!--more--&gt;</code></pre><p>方法二： 自动截取方法<br>转自：<a href="https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/" target="_blank" rel="noopener">https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/</a></p><h1 id="添加文章访问量统计"><a href="#添加文章访问量统计" class="headerlink" title="添加文章访问量统计"></a>添加文章访问量统计</h1><p>themes\yelee\layout_partial\footer.ejs中添加如下代码：</p><pre><code>&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>在article.ejs中&lt;%- partial(‘post/tag’) %&gt;后添加如下代码：</p><pre><code>&lt;span id=&quot;busuanzi_container_page_pv&quot; style =&quot;display:block&quot;&gt;     |阅读量(&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;)&lt;/span&gt;</code></pre><p>在theme/source/css/style.styl文件中设置格式</p><pre><code>#busuanzi_container_page_pv{display:block  !important;padding-top:4px;color: #bebebe;//margin-left:200px;}</code></pre><h2 id="问题系列："><a href="#问题系列：" class="headerlink" title="问题系列："></a>问题系列：</h2><h3 id="出现Template-render-error：（unknown-path）"><a href="#出现Template-render-error：（unknown-path）" class="headerlink" title="出现Template render error：（unknown path）"></a>出现Template render error：（unknown path）</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在使用hexo g生成文章的时候，报错如下:</p><p>ATAL Something’s wrong. Maybe you can find the solution here: <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">http://hexo.io/docs/troubleshooting.html</a><br>Template render error: (unknown path)<br>  unexpected end of file</p><h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>当文章中有}}时,且这两个括号未被代码块包含，解析会出问题</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><pre><code>{% raw %} 含有双大括号的内容{% endraw %}</code></pre><p>转自：<a href="https://www.jianshu.com/p/738ebe02029b" target="_blank" rel="noopener">https://www.jianshu.com/p/738ebe02029b</a></p>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件系统操作与磁盘管理</title>
      <link href="/2018/08/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2018/08/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p><code>df</code>,<code>du</code>,<code>mount</code>命令的使用，以及磁盘相关知识学习。<a id="more"></a></p><h1 id="查看磁盘和目录的容量"><a href="#查看磁盘和目录的容量" class="headerlink" title="查看磁盘和目录的容量"></a>查看磁盘和目录的容量</h1><pre><code>df</code></pre><p><img src="https://i.imgur.com/aDgUG9N.png" alt=""></p><p>dev/sda1：是对应这主力硬盘的分区，后面的数字表示分区号，数字前面的字母a表示第几块硬盘（也可能是可移动磁盘）。如果主机上有多快磁盘，可能会出现/dev/sdb,/dev/sdc，这些磁盘设备都会放在/dev目录下以文件的存在形式。</p><p>1k.块：表示磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用容量和可用容量。</p><p>接下来的命令，显示结果一目了然：</p><pre><code>df -h</code></pre><p><img src="https://i.imgur.com/81DFdeQ.png" alt=""></p><h1 id="du查看目录容量"><a href="#du查看目录容量" class="headerlink" title="du查看目录容量"></a>du查看目录容量</h1><pre><code>du  //默认以块的大小展示du -h  //以更易读的方式展示</code></pre><p><code>-d</code>参数指定查看目录的深度</p><pre><code>du -h -d 0 ~ //只查看1级目录的深度du -h -d 1 ~ //查看2级</code></pre><p>常用参数：<br>    du -h //以k,M,G为单位，提高信息的可读性<br>    du -a //同-aall,显示目录中所有文件的大小<br>    du s  //同–summarize 仅仅显示终极，只列出最后加总的值</p><font color="red" size="5" face="黑体">下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作</font><h1 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h1><p><code>dd</code>命令简介</p><p><code>dd</code>命令用于转换和复制文件，不过它的复制不同于<code>cp</code>。Linux中，<strong>一切即文件</strong>，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，主持在各自的驱动程序中实现了对应的功能，<code>dd</code>也可以读取文件或写入这些文件。于是<code>dd</code>也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。<code>dd</code>程序也可以在复制时处理数据，例如转换字节序、或在ASCII与EBCDIC编码间互换。</p><p><code>dd</code>命令行语句与其他的Linux程序不同，因为它的命令选项格式为<code>选项=值</code>，而不是标准的<code>--选项 值</code>或<code>-选项=值</code>。<code>dd</code>默认从标准输入中读取，并写入到标准输出中，但可以用选项<code>if</code>（input file输入文件）和<code>of</code>(output file输出文件)改变。</p><pre><code>//输出到文件dd of=test bs=10 count=1    dd if=/dev/stdin of=test bs=10 count=1//输出到标准输出dd if=/dev/stdin of=/dev/stdout bs=10 count=1//在打完这个命令后，继续在终端打字，作为你的输入</code></pre><p>上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。</p><p><code>dd</code>在拷贝的同时可以实现数据转换，例子：将输出的英文字符转换为大写在输入文件：</p><pre><code>dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</code></pre><p><img src="https://i.imgur.com/ACPF222.png" alt=""></p><p><code>dd</code>命令创建虚拟镜像文件</p><p><code>dd</code>完成创建虚拟磁盘的步骤<br>第一步:从/dev/zero设置创建一个容量为265M的空文件</p><pre><code>dd if=/dev/zero of=virtual.img bs=1M count=256du -h virtual.img</code></pre><p><img src="https://i.imgur.com/G0psdj4.png" alt=""></p><p>第二步：将上述创建文件格式化（写入文件系统）</p><p><strong>使用mkfs命令格式化磁盘</strong></p><p>可以在命令行输入<code>sudo mkfs</code> 然后按下<code>tab</code>键，可以看到多个以mkfs为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。</p><pre><code>sudo mkfs.ext4 virtual.img</code></pre><p><img src="https://i.imgur.com/ziq3dEE.png" alt=""></p><p><strong>ext4</strong>：EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。<br><br>可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。</p><p>第三步： 使用<code>count</code>命令挂载磁盘到目录树</p><p>用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。</p><p>Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。</p><p>查看主机已经挂载的文件系统：</p><pre><code>sudo mount</code></pre><p><img src="https://i.imgur.com/QsmEmnJ.png" alt=""></p><p>输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。</p><p>挂在磁盘到目录树,<code>mount</code>命令的一般格式为:</p><pre><code>mount 【optons】 [source] [directory]</code></pre><p>以下常用操作：</p><pre><code>mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro[文件系统源]]] [挂载点]</code></pre><p>将创建的磁盘镜像挂载到/mnt目录：</p><pre><code>mount -o loop -t ext4 virtual.img /mnt //也可以省略挂载类型，很多时候 mount 会自动识别/以只读方式挂载mount -o loop --ro virtual.img /mnt//或者mount -o loop,ro virtual.img /mnt</code></pre><p><img src="https://i.imgur.com/0VTliSx.png" alt=""></p><p>使用umount命令卸载已挂载磁盘</p><pre><code>命令格式 sudo umount 已挂载设备名或者挂载点，如：sudo umount /mnt</code></pre><p><strong><code>fdisk</code>为磁盘分区</strong></p><p>查看磁盘分区表信息</p><pre><code>sudo fdisk -l</code></pre><p><img src="https://i.imgur.com/w7hlBSI.png" alt=""></p><pre><code>sudo fdisk virtual.imgm：为帮助手册n: 创建新分区，接着输入分区号，分区起始和结尾，两个相减为分区大小w: 写入新建分区p: 查看现有分区</code></pre><p><img src="https://i.imgur.com/m8upwZ1.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux介绍</title>
      <link href="/2018/08/11/Linux%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/08/11/Linux%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>Liunx支持多用户登陆，共享一些主机的资源,但他们也分别有自己的用户空间,用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，<a id="more"></a>但是由于 Linux 的 用户管理 和 权限机制，不同用户不可以轻易地查看、修改彼此的文件。</p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
