<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ Primer Plus--对象和类（十）]]></title>
    <url>%2F2018%2F10%2F25%2FC%2B%2B%20Primer%20Plus--%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象编程（OOP） 10.1 过程性编程和面向对象编程采用过程性编程时，首先考虑要遵循的步骤，然后考虑如何表示这些数据（并不需要程序一直运行，用户可能希望能够将数据存储在一个文件中，然后从这个文件中读取数据）。 对于OOP程序员，首先考虑数据–不仅考虑如何表示数据，还要考虑如何使用数据。总之，采用OOP方法时，首先从用户的角度考虑DVD–描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。 10.2 抽象和类生活中充满复杂性，处理复杂性的方法之一是简化和抽象。将问题的本质特征提取出来，并根据特征来描述解决方案。 10.2.1 类型指定基本类型完成三项工作： 决定数据对象需要的内存数据； 决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）； 决定可使用数据对象执行的操作和方法。 对于内置类型，有关操作的信息被内置到编译器中。但在C++中定义用户自定义的类型时，必须自己提供这些信息。 10.2.2 C++类类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。下面来看一个表示股票的类： 首先，必须考虑如何表示股票。可以将一股作为一个基本单元，定义一个表示一股股票的类。然而，这意味着需要100个对象才能表示100股，这不现实。相反，eyi将某人当前持有的某种股票作为一个基本单元，数据表示中包含它持有的股票数据。一种比较现实的方法是，必须记录最初够买价格和购买价格等内容。另外，还必须管理诸如拆股等事件。首先定义就考虑这么多因素有些苦难，因此我们对其进行简化。具体地说，应该将可执行的操作限制为： 获得股票 增持 卖出股票 更新股票价格 现实关于所持股票的信息 可以根据上述清单定义stock类型的公有接口。为支持该接口，需要存储一些信息。再次进行简化，例如，不考虑标准的美式股票计价方式。我们将存储下面的信息： 公司名称 所持股票数量 每股价格 股票总值 接下来定义类，一般来说，类规范由两个部分组成： 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。 类方法定义：描述如何实现类成员函数。 接口 接口是一个共享框架，供两个系统交互时使用；例如，用户可能是您，而程序可能是字处理器。使用字处理器时，您不能直接将脑子中想到的词传输到计算机内存中，而必须同程序提供的交互接口。您敲打键盘时，计算机将字符串显示到屏幕；您移动鼠标时，计算机移动屏幕上的光标；您无意间单击鼠标时，计算机对您输入的段落进行奇怪的处理。程序接口将您的意图转换为存储在计算机中的具体信息。 对于类，我们说的公共接口。在这里，公众是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成的。接口让程序员能够编写与类交互的代码，从而让程序能够使用类对象。例如，要计算sting对象中包含多少个字符，您无需打开对象，只需要使用sting类提供的size()方法。类设计禁止公共用户直接访问类，但公众可以使用方法size()。方法size()是用户和string类对象之间的公共接口的组成部分。通常，方法getline()是对象istream类的公共接口的组成部分，使用cin的程序不是直接与cin对象内部交互来读取一行输入，而是使用getline()。 为开发一个类并编写一个使用它的程序，需要完成多个步骤。这里将开发过程分为多个阶段，而不是一次性完成。通过，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。第一个文件，它是Stock类的类声明。 类名首字母大写。 stock00.hca 先看一下类的通用特性。首先，C++关键字class指出这些代码定义了一个类设计（不同于模板参数中，在这里，关键字class和typename不是同意词，不能使用typename代替class）。这种语法指出，Stock是这个新类的类型名。该声明让我们能够声明Stock类型的变量–称为对象或实例。每个对象都表示一支股票。例如，下面的声明创建两个Stock对象，它们名称分别为sally和solly: Stock sally; Stock solly; 例如，sally对象可以表示Sally持有的某公司股票。 接下来，要存储的数据以类数据成员（如company和shares）的形式出现。例如，sally的company成员存储了公司的名称，share成员存储了sally持有的股票数量，…。同样，要执行的操作以类函数成员（方法，如sell()或update()）的形式出现。成员函数可以就地定义（如set_tot()），也可以用原型表示。将数据和方法组合成一个单元是类最吸引人的特性。有了这种设计，创建Stock对象时，将自动制定使用对象规则。 1.访问控制关键字private和public，描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友员函数，参见第11章）来访问对象的私有成员。例如，要修改Stock类的shares成员，只能通过Stock的成员函数。因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。C++还提供了第三个访问控制关键字protected（第13章介绍）。 类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏是一种封装，将实现的细节隐藏在私有部分中，就像Stock类对set_tot()所做的那样，也是一种封装。封装的另一个例子是，将函数定义和类声明放在不同的文件中。 数据隐藏不仅可以防止直接访问数据，还可以让开发者无需了解数据是如何标识的。例如，show()成员将显式某支股票的总价格（还有其他内容），这个值可以存储在对象中，也可以在需要时通过计算得到。从使用类的角度看，使用哪种方法没有声明区别。所需要知道的只是各种成员函数的功能；即，需要知道成员函数接受什么样的参数以及返回生命类型的值。原则是将实现细节从接口设计中分离出来。如果以后找到了更好的、实现数据表示或成员函数细节的方法，可以对这些细节进行修改，而无需修改程序接口，这使得程序维护起来更容易。 2.控制对成员的访问：公有还是私有]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小技巧]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[给初学者的Python小技巧，非常实用，可以用在你的程序中，代码瞬间变得高大上，看起来还有Pythonic（很Python）的感觉。 交换两个值a, b = 4, 10 print(a, b) a, b = b, a print(a, b) 在很多语言中，交换两个变量不得不引入一个临时变量，而Python可以直接交换，无需引入第三者。 评价列表中的字符串&gt;&gt;&gt; a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;] &gt;&gt;&gt; print(&quot; &quot;.join(a)) python is awesome 虽然你可以用“+”操作来合并多个字符串，但是使用join方法效率会更高哦。 查找列表中出现最频繁的元素&gt;&gt;&gt; a = [1, 2, 4, 3, 1, 2, 1, 3, 1] #方法一 &gt;&gt;&gt; print(max(set(a), key = a.count)) 1 #方法二 &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; cnt = Counter(a) &gt;&gt;&gt; print(cnt.most_common(3)) [(1, 4), (2, 2), (3, 2)] set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。 Counter在统计计算的时候给了我们很大的便利，无需自己再去造个轮子。 检查两个字符是否有相同的字符构成&gt;&gt;&gt; str1 = &quot;abc&quot; &gt;&gt;&gt; str2 = &quot;bcd&quot; &gt;&gt;&gt; Counter(str1) == Counter(str2) False &gt;&gt;&gt; str1 = &quot;abcd&quot; &gt;&gt;&gt; str2 = &quot;abcd&quot; &gt;&gt;&gt; Counter(str1) == Counter(str2) True 列表反转&gt;&gt;&gt; a = [5, 4, 3, 2, 1] &gt;&gt;&gt; print(a[::-1]) [1, 2, 3, 4, 5] &gt;&gt;&gt; for ele in reversed(a): print(ele) 1 2 3 4 5 &gt;&gt;&gt; reversed(a) &lt;list_reverseiterator object at 0x0000022DB7E244A8&gt; &gt;&gt;&gt; b = reversed(a) &gt;&gt;&gt; print(list(b)) [1, 2, 3, 4, 5] 列表有个reverse方法，也是反转列表，但是它是对原列表进行反转，而不是返回一个新的列表 装置二维数组&gt;&gt;&gt; original = [[&apos;a&apos;,&apos;b&apos;],[&apos;c&apos;,&apos;d&apos;],[&apos;e&apos;,&apos;f&apos;]] &gt;&gt;&gt; transposed = zip(*original) &gt;&gt;&gt; print(list(transposed)) [(&apos;a&apos;, &apos;c&apos;, &apos;e&apos;), (&apos;b&apos;, &apos;d&apos;, &apos;f&apos;)] 链式比较&gt;&gt;&gt; print(4 &lt; 6 &lt; 7) True &gt;&gt;&gt; print(1 == 6 &lt; 7) False &gt;&gt;&gt; print(1 &lt; 6 == 7) False 链式函数调用&gt;&gt;&gt; def product(a, b): return a * b &gt;&gt;&gt; def add(a, b): return a + b &gt;&gt;&gt; b = True &gt;&gt;&gt; print((product if b else add)(5, 7)) 35 拷贝列表&gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; b = a &gt;&gt;&gt; b[0] = 10 &gt;&gt;&gt; a [10, 2, 3, 4, 5] &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b[0] = 11 &gt;&gt;&gt; b [11, 2, 3, 4, 5] &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; print(list(a)) [1, 2, 3, 4, 5] &gt;&gt;&gt; print(a.copy()) [1, 2, 3, 4, 5] &gt;&gt;&gt; from copy import deepcopy &gt;&gt;&gt; l = [[1, 2], [3, 4]] &gt;&gt;&gt; l2 = deepcopy(l) &gt;&gt;&gt; print(l2) [[1, 2], [3, 4]] 字典get&gt;&gt;&gt; d = {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; print(d.get(&apos;c&apos;, 3)) 3 &gt;&gt;&gt; d {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; print(d.get(&apos;a&apos;, 3)) 1 找不到时，返回默认值 按字典的值排序&gt;&gt;&gt; d = {&apos;a&apos;: 1, &apos;b&apos;: 3, &apos;c&apos;: 2} &gt;&gt;&gt; print(sorted(d.items(), key = lambda x: x[1])) [(&apos;a&apos;, 1), (&apos;c&apos;, 2), (&apos;b&apos;, 3)] &gt;&gt;&gt; from operator import itemgetter &gt;&gt;&gt; print(sorted(d.items(), key=itemgetter(1))) [(&apos;a&apos;, 1), (&apos;c&apos;, 2), (&apos;b&apos;, 3)] &gt;&gt;&gt; print(sorted(d, key=d.get)) [&apos;a&apos;, &apos;c&apos;, &apos;b&apos;] for elsea = [1, 2, 3, 4, 5] for el in a: if el == 0: break else: print(&quot;did not brek out of for loop&quot;) ==================== RESTART: C:/Users/zxp/Desktop/11.py ==================== did not brek out of for loop 将列表转成用逗号分割的字符串&gt;&gt;&gt; items = [&apos;foo&apos;, &apos;bar&apos;, &apos;xyz&apos;] &gt;&gt;&gt; print(&apos;,&apos;.join(items)) foo,bar,xyz &gt;&gt;&gt; numbers = [2, 3, 4, 5] &gt;&gt;&gt; print(&apos;,&apos;.join(map(str, numbers))) 2,3,4,5 &gt;&gt;&gt; data = [2, &apos;hello&apos;, 3, 4.4] &gt;&gt;&gt; print(&apos;,&apos;.join(map(str, data))) 2,hello,3,4.4 合并字典&gt;&gt;&gt; d1 = {&apos;a&apos;: 1} &gt;&gt;&gt; d2 = {&apos;b&apos;: 2} &gt;&gt;&gt; print({**d1, **d2}) {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; print(dict(d1.items() | d2.items())) {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; d1.update(d2) &gt;&gt;&gt; d1 {&apos;a&apos;: 1, &apos;b&apos;: 2} 获取列表中最大值与最小值的位置&gt;&gt;&gt; lst = [3, 1, 2, 4] &gt;&gt;&gt; def minIndex(lst): return min(range(len(lst)), key=lst.__getitem__) &gt;&gt;&gt; def maxIndex(lst): return max(range(len(lst)), key=lst.__getitem__) &gt;&gt;&gt; print(minIndex(lst)) 1 &gt;&gt;&gt; print(maxIndex(lst)) 3 移除列表中重复的元素&gt;&gt;&gt; items = [2, 2, 3, 3,1] &gt;&gt;&gt; newitems = list(set(items)) &gt;&gt;&gt; print(newitems) [1, 2, 3] &gt;&gt;&gt; from collections import OrderedDict &gt;&gt;&gt; items = [&apos;foo&apos;, &apos;bar&apos;, &apos;bar&apos;, &apos;foo&apos;] &gt;&gt;&gt; print(list(OrderedDict.fromkeys(items).keys())) [&apos;foo&apos;, &apos;bar&apos;] 转自:https://mp.weixin.qq.com/s/k_coGMYUd8aBpqX67yWQbw]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--内存模型和名称空间（九）]]></title>
    <url>%2F2018%2F10%2F18%2FC%2B%2B%20Primer%20Plus--%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[单独编译，存储持续性、作用域和链接性，定位运算符，名称空间。 9.1 单独编译和C语言一样，C++允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独地编译这些文件，然后将它们链接成可执行文件的程序。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。 大多数C++环境提供了其他工具来帮助管理。比如：Linux系统具有make程序，可以跟踪程序依赖文件以及这些文件的最后修改时间。运行make时，如果检测上次编译后修改了源文件，make将记住重新构建所需的步骤。大多数继承环境都在project菜单中提供了类似的工具。 C++提供了#include来处理不同文件使用同一个结构的问题。与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该文件头。这样，要修改结构声明时，只需在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。因此，可以将原来的程序分成三部分： 头文件：包含结构声明和使用这些结构的函数的原型。 源代码文件：包含与结构有关的函数的代码。 源代码文件：包含调用与结构相关的函数的代码。 这是一种非常有用的组织程序的策略。例如，如果编写另一个程序，也需要使用这些函数，则只需要包含头文件，并将函数文件添加到项目列表或make列表中即可。另外，这种组织方式也与OOP方法一致。一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操作用户定义类型的函数的代码。这两个文件组成了一个软件包，可用于各种程序中。 请不要将函数定义或变量声明放在头文件中。这样做对于简单的情况可能是可行的，但通过会迎来麻烦。例如，如果头文件包含一个函数定义，然后在其他两个文件中包含该头文件，则同一个程序中包含同一个函数的两个定义，除非函数是内联的，否则这将出错。 下面列出了头文件中包含的内容： 函数原型 使用#define或const定义的符合常量 结构声明 类声明 模板声明 内联函数 将结构放在头文件中式可以的，因为它们不会创建变量，而只是在源代码文件中声明结构时，高旭编译器如何创建变量。同样，模板声明不是被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。被声明未const的数据和内联函数有特殊的链接属性，因此可以放在头文件中。 下面三个程序是将第7章中坐标转换程序分成几个独立部分后得到的结果。注意，在包含头文件时，使用“coordin.h”，而不是&lt;coordin.h&gt;。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录。如果没有在那里找到头文件，则将在标准位置查找，因此在包含自己的头文件时，应使用双引号而不是尖括号。 coordin.h #ifndef COORDIN_H_ #define COORDIN_H_ struct polar { double distance; double angle; }; struct rect { double x; double y; }; polar rect_to_polar(rect xypos); void show_polar(polar dapos); #endif file1.cpp #include &lt;iostream&gt; #include &quot;coordin.h&quot; using namespace std; int main() { rect rplace; polar pplace; cout &lt;&lt; &quot;Enter the x and y value: &quot;; while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) { pplace = rect_to_polar(rplace); show_polar(pplace); cout &lt;&lt; &quot;Nest two number(q to quit): &quot;; } return 0; } file2.cpp #include &lt;iostream&gt; #include &lt;cmath&gt; #include &quot;coordin.h&quot; using namespace std; polar rect_to_polar(rect xypos) { polar answer; answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y); answer.angle = atan2(xypos.y, xypos.x); return answer; } void show_polar(polar dapos) { const double Rad_to_deg = 57.29577951; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; dapos.distance; cout &lt;&lt; &quot;, Angle = &quot; &lt;&lt; dapos.angle * Rad_to_deg &lt;&lt; &quot; degrees.\n&quot;; } 编译多文件 g++ file1.cpp file.cpp -o file 运行可执行文件 ./file 结果： Enter the x and y value: 30 100 Distance = 104.403, Angle = 73.3008 degrees. Nest two number(q to quit): q 我们讨论的是根据文件进行单独编译，但为保持通用性，C++标准使用了术语”翻译单元”，而不是文件；文件并不是计算机组织信息时的唯一方式。出于简化的目的，可将文件术语解释为“翻译单元”。 头文件管理 在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef(即if not defint)的。下面的代码片段意味着仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#ifndef和endif之间的语句： #ifndef COORDIN_H_ ... #endif 通常，使用#define语句用来创建符合常量，如下： #define MAXIMUM 4096 但只要将#define用于名称，就足以完成该名称的定义，如下： #define COORDIN_H_ 使用这种技术将文件内容包含在#ifdef中： #ifndef COORDIN_H_ #define COORDIN_H_ ... #endif 编译器首次遇到该文件时，名称COORDIN_H_没有定义（根据include文件名来选择名称，并加上一些下划线，以创建一个在其他地方不太可能被定义的名称）。在这种情况下，编译器将查看#ifndef和#endif之间的内容，并读取定义COORDIN_H_的这一行。如果在同一文件中遇到其他包含coordin.h的代码，编译器将知道COORDIN_H_已经被定义了，从而跳到#endif后面的一行上。注意，这种方法并不能防止编译器将文件包含两次，而只是让它忽略地磁包含之外的所有内容。大多数标准C/C++头文件都使用这种防护方案。否则，可能在一个文件中定义同一个结构两次，这将导致错误。 多个库的链接 C++标准允许每个编译器设计人员以他认为合适的方式实现名称修饰（第8章已经介绍），因此由不同的编译器创建的二进制模板可能无法正确地链接。即，两个编译器将为同一个函数生成不同的修饰名称。名称的不同将使链接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有对象文件或库都是由同一个编译器生成的。如果有源代码，通常可以用自己的编译器重新编译源代码来消除链接错误。 9.2 存储连续性、作用域和链接性接下来扩展第4章对内存方案的讨论，即存储类别如何影响信息在文件间的共享。先复习一下内存有关的知识。C++使用三种不同的方案存储数据，这些方案区别在于数据保留在内存的时间。 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。 静态存储存储性：在函数定义外定义的变量和使用的关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。 线程存储持续性（C++11）：当前，多核处理很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量使用关键字thread_local声明的，则其声明周期与所属的线程一样长。（本系列不讨论） 动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时候被称为自由存储或堆。 下面介绍，各种变量合适在作用域内或可间以及链接性的细节。链接性决定了哪些可在文件间共享。 9.2.1 作用域和链接作用域描述了名称在文件（翻译单元）的多大范围可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件的函数定义之前定义的变量则可在所有函数中使用。 链接性描述了名称如何在不同单元（文件）间共享。链接性为外部的名称可文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。 C++函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的。 9.2.2 自动存储持续性在默认情况下，在函数中声明的函数参数和变量的存储性为自动，作用域为局部，没有链接性。即，如果在main()中声明一个名为tesas的变量，并在函数oil()中也声明一个名为tesax变量，则创建了两个独立的变量—只有在定义它们的函数中才能使用它们。 如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。例如，假设在main()的开头定义了一个名为teledeli的变量，然后在main()中开始一个新的代码块，并其中定义了一个新的websight，则teledeli在内部代码块和外部代码块都是可见的，而wabsight就只在内部代码块中可见，它的作用域是从定义它的位置到该代码块的结尾： int main() { int teledeli = 5; { int websight = -2; cout &lt;&lt; websight &lt;&lt; &apos; &apos; &lt;&lt; teledeli &lt;&lt; endl; } cout &lt;&lt; teledeli &lt;&lt; endl; } 而，如果将内部代码块中的变量命名为teledeli，而不是websight，使得有两个同名的变量（一个位于外部代码块中，另一个位于内部代码块中）。在这种情况下，程序执行内部代码块中的语句时，将teledeli解释为局部代码块变量。新的定义隐藏了以前的定义，新定义可见，旧定义暂时不见。在程序离开该代码块时，原来的定义又重新可见。 auto.cpp #include &lt;iostream&gt; using namespace std; void oil(int x); int main() { int texas = 31; int year = 2018; cout &lt;&lt; &quot;In main(), texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; oil(texas); cout &lt;&lt; &quot;In main(), texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; return 0; } void oil(int x) { int texas = 5; cout &lt;&lt; &quot;In oil(), texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; cout &lt;&lt; &quot;In oil(), x = &quot; &lt;&lt; x &lt;&lt; &quot;, &amp;x = &quot;&lt;&lt; &amp;x &lt;&lt; endl; { int texas = 113; cout &lt;&lt; &quot;In block, texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; cout &lt;&lt; &quot;In block, x = &quot; &lt;&lt; x &lt;&lt; &quot;, &amp;x = &quot;&lt;&lt; &amp;x &lt;&lt; endl; } cout &lt;&lt; &quot;Post-block, texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; } 结果 In main(), texas = 31, &amp;texas = 0x7fffa7f13e28 In oil(), texas = 5, &amp;texas = 0x7fffa7f13dfc In oil(), x = 31, &amp;x = 0x7fffa7f13dec In block, texas = 113, &amp;texas = 0x7fffa7f13df8 In block, x = 31, &amp;x = 0x7fffa7f13dec Post-block, texas = 5, &amp;texas = 0x7fffa7f13dfc In main(), texas = 31, &amp;texas = 0x7fffa7f13e28 执行main()时，程序为texas分配空间，使得这些变量可见。当程序调用oil()时，这些变量仍留在内存中，但不可见。为两个新变量（x和texas）分配内存，从而使它们可见。在执行到oil()中的内部代码块时，新的texas将不可见，它被一个更新的定义代替。然而，变量x仍可见，这是因为该代码块中没有定义x变量。当程序流程离开该代码块时，将释放最新的texas使用的内存，而第二个texas再次可见。当oil()函数结束时，texas和x都将过期，而最初的texas再次变得可见。 使用C++11中的auto C++11中，关键字auto用于自动类型推断。但在C语言和以前的C++中，auto的含义截然不同，它用于显式地指出变量为自动存储： int froob(int n) { auto float ford; ... } 由于只能将关键字auto用于默认为自动的变量，因此程序员几乎不使用它。它的主要用途是指出当前变量为局部自动变量。 在C++11中，这种用法不再合法。指定标准的人不愿引入新关键字，因为这样做可能导致将关键字用于其他目的代码非法。考虑到auto的老用法很少使用，因此赋予其新含义比引入新关键字是更好的选择。 1.自动变量的初始化可以使用任何在声明时其值为已知的表达式来初始化自动变量，下面的示例初始化变量x,y和z： int w; int x = 5; int big = INT_MAX - 1; int y = 2 * x; cin &gt;&gt; w; int z = 3 * w; 2.自动变量和栈由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以称为栈，是由于新数据被象征性地放在原有数据的上面（即，在相邻的内存单元中，而不是在同一内存单元中），当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。 程序使用两个指针来跟踪栈，一个指针指向栈低—栈的开始位置；另一个指针指向栈顶–下一个可以内存单元。当函数调用时，其自动变量将加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。 栈是LIFO(后进先出)的，即最后加入栈的变量最先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。 3.寄存器关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量： register int count_fast; 这旨在提供访问变量的速度。 在C++之前，这个关键字在C++中的用法始终未变，只是随着硬件和编译器变得越来越复杂，这种提示表明变量用的很多，编译器可对其做特殊处理。在C++中，这种提示作用也失去了，关键字register只是显式地指出变量是自动的。鉴于关键字register只能用于原本就是自动的变量，使用它的唯一原因是指出程序员想使用一个自动变量，这个变量的名称可能于外部变量相同。这与auto以前的用途完全相同。然后，保留关键字register的重要原因是，避免使用了该关键字的现有代码非法。 9.2.3 静态持续变量和C语言一样，C++也为静态存储持续性变量提供了3中链接性：外部链接（可在其他文件中访问）、内部链接（只能在当前文件中访问）和无链接（只能在当前函数或代码块中访问）。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化为静态变量，编译器将把他设置为0.在默认情况下，静态数组和结构每个元素或成员的所有都设置为0。 下面介绍如何创建3种静态持续变量： 要想创建链接性为外部的静态持续变量，必须在代码块的外部声明它； 要想创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符； 要创建没有链接性的静态持续变量，必须在代码块内部声明它，并使所以static限定符。 下面的代码说明了3种变量： int gloabl =1000; //静态持续性变量，外部链接 static int one_file = 50; //静态持续性变量，内部链接 int main() {...} void fun1(int n) { static int count = 0; //静态持续性变量，没有链接性 int llama = 0; } void fun2(int q) {...} 正如前面指出的，所有静态持续变量（global\one_file\count）在整个程序执行期间都存在。 在fun1中声明的变量count作用域为局部，没有链接性，这意味只能在fun1()函数中使用它，就像自动白llama一样。然而，与llama不同的是，即使在func1()函数没有被执行时，count也留在内存中。 global和one_file的作用于都为整个文件，即从声明位置到文件结尾的范围内都可以被使用。具体说，可以在main()、fun1()和fun2()中使用它。由于one_file的链接性为内部，因此只能在包含上述代码的文件中使用它；由于global的链接性为外部，因此可在程序的其他文件中使用它。 所有的静态持续性变量又下述初始化特征：未被初始化的静态变量的所有为被设置为0。这种变量被称为零初始化的。 下表总结了5中变量的存储特性。 5种变量存储方式 存储描述 持续性 作用域 链接性 如何声明 自动 自动 代码块 无 在代码块中 寄存器 自动 代码块 无 在代码块中，使用关键字register 静态，无链性 静态 代码块 无 在代码块中，使用关键字static 静态，外部链接性 静态 文件 外部 不在任何函数内 静态，内部链接性 静态 文件 内部 不在任何函数内，使用关键字static 静态变量初始化 除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件时初始化变量。动态初始化意味着变量将在编译后初始化。 初始形式由什么因素决定？首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容就可计算表达式，编译器将执行常量表达式初始化。必要时，编译器将执行简单计算。如果没有足够的信息，变量将被动态初始化。情况如下代码： #include &lt;cmath&gt; int x; //零初始化 int y = 5; //常量表达式初始化 long z = 13 * 13; //常量表达式初始化 const double pi = 4.0 * atan(1.0); //动态初始化 首先，x,y,z和pi被零初始化。然后，编译器计算常量表达式，并将y和z分别初始化为5和169。但要初始化pi，必须调用函数atan()，这需要等到函数被链接且程序执行时。 常量表达式并非只能是使用字面常量的算术表达式。例如，它还可以使用sizefo运算符： int enough = 2 * sizeof(long) + 1; C++新增了关键字constexpr，这增加了创建常量表达式的方式。 9.2.4 静态持续性、外部链接性链接性未外部的变量简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言是都是外部的。 1.单定义规则一方面，在每个使用外部变量的文件中，都必须声明它；另一方面，C++有“单定义规则”，该规则指出，变量只能有一次定义。为满足这种需求，C++提供了两种变量声明，一种是定义声明或简称定义，它给变量分配存储空间；另一种是引用声明或简称声明，它不给变量分配存储空间，因为它引用已有变量。 引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间: double up; extern int blem; //声明 extern char gr = &apos;z&apos;; //定义，因为初始化 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，但在使用该变量的其他所有文件中，都必须使用关键字extern声明它： //file1.cpp extern int cats = 20; //定义 int dogs = 22; //定义 int fleas; //定义 //file2.cpp //使用来自文件file1.cpp的变量cats,dogs extern int cats; extern int dogs; //file3.cpp //使用来自文件file1.cpp的变量cats,dogs,fleas extern int cats; extern int dogs; extern int fleas; 在这里，所有文件都使用了file1.cpp中定义的变量cats和dogs，但file2.cpp没有重新声明变量fleas，因此无法访问它。在file1.cpp中，关键字extern并非必不可少，因为即使省略它，效果也相同。 注意，单定义规则并非意味着不能有多个变量的名称相同。例如，在不同函数中声明的同名自动变量是彼此独立，它们都有自己的地址。另外，正如前面示例所表示的，局部变量可能隐藏同名的全局变量。然而，虽然程序中可包含多个同名的变量，单每个变量都只有一个定义。 如果在函数中声明了一个与外部变量同名的变量，这种声明将被视为一个自动变量的定义，当程序执行自动变量所属的函数时，该变量将位于作用域内。 external.cpp #include &lt;iostream&gt; using namespace std; double warming = 0.3; void update(double dt); void local(); int main() { cout &lt;&lt; &quot;Global warming is &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; update(0.1); cout &lt;&lt; &quot;Global warming is &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; local(); cout &lt;&lt; &quot;Global warming is &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; return 0; } support.cpp #include &lt;iostream&gt; using std::cout; extern double warming; void update(double dt); void local(); void update(double dt) { extern double warming; warming += dt; cout &lt;&lt; &quot;Updating global warming to &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; } void local() { double warming = 0.8; cout &lt;&lt; &quot;Local warming = &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; cout &lt;&lt; &quot;But global warming = &quot; &lt;&lt; ::warming &lt;&lt; &quot;dgrees.\n&quot;; } 结果 Global warming is 0.3 degrees. Updating global warming to 0.4 degrees. Global warming is 0.4 degrees. Local warming = 0.8 degrees. But global warming = 0.4dgrees. Global warming is 0.4 degrees. main()和update()都可以访问外部变量warming，注意update()修改了warming，这种修改在随后的使用该变量时显现出来了。 在external.cpp中，warming的定义如下： double external = 0.3; //定义 在support.cpp中，使用关键字external声明变量warming，让该文件中的函数能够使用它： extern double warming; //使用来自external文件中的变量warming 另外，函数update()使用关键字extern重新声明了变量warming，这个关键字的意思是，通过这个关键字的意思是，通过这个名称使用在外部定义的变量。由于即使省略该声明，update()的功能也相同，因此该声明是可选的。它指出了函数被设计成使用外部变量。 local()函数表明，定义与全局变量同名的局部变量后，局部变量将隐藏全局变量。例如，local()函数显示warming的值时，将使用warming的局部定义。 C++提供了作用域解析运算符（::）。放在变量前面时，该运算符表示使用的全局变量版本。因此，local()将warming显示为0.8，但::warming显示为0.4。 全局变量和局部变量 所有的函数能访问全局变量，因此不用传递参数。但易于访问的代价很大–程序不可靠。程序越能避免对数据进行不必要的访问，就越能保持数据的完整性。通过情况下，应使用局部变量，应在需要知晓时才传递数据，而不应不加区分地使用全局变量来使数据可用。全局变量尤其适合于表示常量数据，因为这样可以使用关键字const来防止数据被修改。比如，月份数组： const char * const months[12] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;Auguest&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; } 第一个const表示数组中的元素为常量，防止修改字符串，而第二个const表示数组中每个指针始终指向它最初指向的字符串。 9.2.5 静态持续性、内部链接性将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部。在多文件中程序，内部链接性和外部链接性之间的差别很有意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都具有外部链接性，即可以在其他文件中使用。 如果要在其他文件中使用相同的名来表示其他变量，该如何办呢？只需省略关键字extern即可吗？ //file1.cpp int errors; //file2.cpp int errors; void froobins(){cout &lt;&lt; errors;} 这种做法将失败，因为它违反了单定义规则。file2.cpp中的定义试图创建一个外部变量，因此程序将包含errors的两个定义，这是错误的。 如果文件定义了一个静态外部变量，其名称与另一个文件声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量： //file1.cpp int errors; //file2.cpp static int errors = 5; void froobins(){cout &lt;&lt; errors;} 这没有违反单定义规则，因为关键字static指出标识符errors的链接性为内部，因此并非要提供外部定义。 注意：在多文件程序中，可以在一个文件中定义一个外部变量。使用该变量的其他文件必须使用关键字extern声明它。 可使用外部变量在多个文件程序的不同部分之间共享数据；可使用链接为内部的静态变量在同一个文件中的多个函数之间共享数据。另外，如果将作用域为整个文件的变量变为静态，就不必担心其名称与其他文件中的做业务为整个文件的变量发送冲突。 下面程序演示了如何处理链接性为外部和内部的变量。 twofile1.cpp #include &lt;iostream&gt; int tom = 3; //外部变量 int dick = 30; //外部变量 static int harry = 300; //静态外部变量 void remote_access(); using namespace std; int main() { cout &lt;&lt; &quot;main() reports the following addresses:\n&quot; ; cout &lt;&lt; &amp;tom &lt;&lt; &quot; = &amp;tom. &quot; &lt;&lt; &amp;dick &lt;&lt; &quot; = &amp;dick, &quot;; cout &lt;&lt; &amp;harry &lt;&lt; &quot; = &amp;harry\n&quot;; remote_access(); return 0; } twofile2.cpp #include &lt;iostream&gt; extern int tom; //声明，使用twofile1.cpp中定义的tom变量 static int dick = 10; //覆盖外部变量dick int harry = 200; //外部变量定义，不与twofile1.cpp中的harry冲突 using namespace std; void remote_access() { cout &lt;&lt; &quot;remote_access() reports the following addresses:\n&quot;; cout &lt;&lt; &amp;tom &lt;&lt; &quot; = &amp;tom, &quot; &lt;&lt; &amp;dick &lt;&lt; &quot; = &amp;dick, &quot;; cout &lt;&lt; &amp;harry &lt;&lt; &quot; = &amp;harry&quot;; } 结果 main() reports the following addresses: 0x60104c = &amp;tom. 0x601050 = &amp;dick, 0x601054 = &amp;harry remote_access() reports the following addresses: 0x60104c = &amp;tom, 0x601058 = &amp;dick, 0x60105c = &amp;harry 从上述地址可知，这两个文件使用了同一个tom变量，但使用了不同的dick和harry变量。 9.2.6 静态存储持续性、无链接性创建无连接性的局部变量，将static限定符用于代码块中定义的变量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。这意味着虽然该变量只在该代码块中可用，但它在该代码块中不处于活动状态时仍然存在。因此，在两次函数调用之间，静态局部变量的值将保持不变。 另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化。以后调用函数时，将不会像自动变量那样再次被初始化。 static.cpp #include &lt;iostream&gt; using namespace std; const int ArSize = 10; void strcount(const char * str); int main() { char input[ArSize]; char next; cout &lt;&lt; &quot;Enter a line:\n&quot;; cin.get(input, ArSize); while (cin) { cin.get(next); while (next != &apos;\n&apos;) cin.get(next); strcount(input); cout &lt;&lt; &quot;Enter next lin (empty line to quit):\n&quot;; cin.get(input, ArSize); } cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } void strcount(const char * str) { static int total = 0; int count = 0; cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; contains &quot;; while (*str++) count ++; total += count; cout &lt;&lt; count &lt;&lt; &quot; characters\n&quot;; cout &lt;&lt; total &lt;&lt; &quot; characters total.\n&quot;; } 结果 Enter a line: nice pants &quot;nice pant&quot; contains 9 characters 9 characters total. Enter next lin (empty line to quit): thanks &quot;thanks&quot; contains 6 characters 15 characters total. Enter next lin (empty line to quit): parting is such sweet sorrow &quot;parting i&quot; contains 9 characters 24 characters total. Enter next lin (empty line to quit): ok &quot;ok&quot; contains 2 characters 26 characters total. Enter next lin (empty line to quit): Bye. 该程序中使用了一种处理行输入可能长于目标数组的方法，cin.get(input, ArSize)将一直读取输入，直到达到行尾或读取了ArSize-1个字符为止。它把换行符留在队列中。该程序使用cin.get(next)读书行输入后的字符。如果next是换行符，在说明cin.get(input, ArSize)读取了整行；否则说明行中还有字符没有被读取。随后，程序使用一个循环来丢弃余下的字符。该程序还是用cin.get(char*, int)读取空行将导致cin为false。 注意到，每次函数被调用时，自动变量count被重置为0。而静态变量total只在程序运行时被设置为0，以后在两次函数调用之间，其值保持不变，因此能够记录读取的字符总数。 9.2.7 说明符和限定符有些被称为存储说明符或cv-限定符的C++关键字提供了其他有关存储的信息。下面是存储说明符： auto(C++中不再是说明符): 在C++之前，可以在声明中使用关键字auto指出变量为自动变量，但在C++11中，auto用于自动类型推断。 register: 关键字register用于在声明中指示寄存器存储，而在C++11中，它指示显示地指出变量是自动的。 static: 关键字static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。 extern: 关键字extern表明引用声明，即声明引用在其他地方定义的变量。 thread_local(C++新增): 关键字thread_lcoal指出变量的持续性雨其所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。 mutable： 关键字mutable的含义将根据const来解释。thread_local可与static或extern结合使用。 1. CV限定符下面是cv限定符： const volatile 最常用的cv-限定符是const，它表明，内存被初始化后，程序边便不能再对它进行修改。 关键字volatile表明，即使程序代码没有对他内存单元进行修改，其值也可能发送变化。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件（而不是程序）可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条与剧中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次时间之间不会变化。如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。 2. mutablemutable可以指出，即使结构（或类）变量为const，其某个成员也可以被修改。例如： struct data { char name[30]; mutable int accesses; }; const data veep = {&quot;Clodde&quot;, 0}; strcpy(veep.name, &quot;Joye&quot;); // 非法 veep.accesses++; //被声明为mutable，所以是合法的 veep的const限定符禁止程序修改veep的成员，但accesses成员的mutable说明符是的accesses不受这种限制。 3. 再谈const在C++中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部，但const全局变量的链接性为内部。即，在C++看来，全局const定义就像使用了static说明符一样： const int fingers = 10; //同static const int fingers = 10一样 int main() {...} C++修改了常量类型的规则。例如，假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都将包含类似下面的定义： const int fingers = 10; const char * waring = &quot;Wak!&quot;; 如果全局const声明的链接性像常规变量那样为外部的，则根据单定义规则，这将出错。即，只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明。另外，只有使用extern关键字的声明才能进行初始化： extern const int fingers; //不能被初始化 extern const char * waring; 因此，需要为某个文件使用一组定义，而其他文件使用另一组声明。然而，由于外部定义的const数据的链接性为内部，因此可以在所有文件中使用相同的声明。 内部链接性还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是其所属文件私有的，这就是能够将常量定义放在头文件中的原因。这样，只要在两个源代码文件中包括同一个头文件，则它们可以获得同一组常量。 如果出于某种原因，程序员希望某个常量的链接为外部，则可以使用extern关键字来覆盖默认的内部链接性： extern const int states = 50; 在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。这与常规外部变量不同，定义常规外部变量时，不必使用extern，但使用该变量的其他文件中必须使用extern，然而，鉴于单个const在多个文件之间共享，因此只有一个文件可对其进行初始化。 在函数或代码块中声明const，其作用域为代码块，即仅当程序执行该代码块中的代码时，该常量才可用的。这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量冲突。 9.2.8 函数和链接性和变量一样，函数也有链接性，虽然可选择的范围比变量小。和C语言一样，C++不允许在一个函数中定义另一个函数，因此所有的函数的存储新都自动为静态的，即在整个程序执行期间都一直存在。默认情况下，函数的链接性为外部的，即可以文件间共享。 实际上，可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，不过这是可选的。还可以使用关键字static将函数的链接性设置为内部，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字： static int private(double x); static int private(double x) {...} 这意味着该函数只在这个文件中可见，还意味着可以在其他文件中可以定义同名函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。 单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。 内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。然而，C++要求同一个函数的所有内联定义都必须相同。 C++在哪里查找函数 假设在程序的某个文件中调用了一个函数，C++将到哪里去寻找该函数的定义呢？如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；否则，编译器（包括链接程序）将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。 9.2.9 语言链接性另一种形式的链接性–称为语言链接性也对函数有影响。 首先介绍一些背景知识，链接程序要求每个不同的函数都有不同的符合名。在C语言中，一个名称只对应一个函数，因此容易实现。为满足内部需要，C语言编译器可能将spiff这样的函数名翻译为_spiff。这种方法称为C语言链接性。但在C++中，同一名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称矫正或名称修饰（参考第八章），为重载函数生成不同的符号名称。例如，可能将spiff(int)转换为_spiff_i，而将spiff(double,double)转换为_spiff_d_d。这种方法被称为C++语言链接。 链接程序寻找与C++函数调用匹配的函数时，使用的方法与C语言不同。但如果要在C++程序中使用C库中预编译的函数。将出现什么情况？例如： spiff(22); //spiff(int)来子一个C库 它在C库文件中的符号名称为_spiff，但对于我们假设的链接程序来说，C++查询约定是查找符号名称_spiff_i。为解决这种问题，可以用函数原型来指出要使用的约定： extern &quot;C&quot; void spiff(int); extern void spiff(int); extern &quot;C++&quot; spiff(int); 第一个原型使用C语言链接性；而后面的两个使用C++语言链接性。第二个原型是通过默认方式指出这一点的。 C和C++链接性是C++标准指出的说明符，但实现可提供其他语言链接性说明符。 9.2.10 存储方案和动态分配前面介绍C++用来为变量（包括数组和结构）分配内存的5中方案，它们不适用于使用C++运算符new(或C函数malloc())分配内存，这种内存被称为动态内存。第4章介绍过，动态内存有运算符new和delete控制，而不是由作用域和链接性规则控制。因此，可以在一个函数中分配动态内存，而在另一个函数中将其释放。与自动内存不同，动态内存不是LIFO，其分配和释放顺序要取决于new和delete在何时以何种方式被使用。通常，编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，另一块用于动态存储。 虽然存储方案概念不再适用于动态存储，但适用于用来跟踪动态内存的自动和静态指针变量。例如，假设一个函数中包含下面的语句： float * p_fees = new float[20]; 由new分配的80个字节（假设float为4个字节）的内存将一直保留再内存中，直到使用delete运算符将其释放。但当包含该声明的语句块执行完毕时，p_fees指针将消失。如果希望另一个函数能够使用这80个字节中的内容，则必须将其地址传递或返回给该函数。另一方面，如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都可以使用它。另外，通过在另一个文件中使用下述声明，便可在其中使用该指针： extern float * p_fees; 注意： 当程序结束时，由new分配的内存通常都将被释放，不过情况也并不总是这样。例如，在不那么健壮的操作系统中，有某些情况下，请求大型内存块将导致该代码块在程序结束不会被自动释放。最佳的做法是，使用delete来释放new分配的内存。 1.使用new运算符初始化为内置的标量类型分配存储空间并初始化，可在类型后后面加上初始值，并将其用括号括起来： int * pi = new int (6); double * pd = new double (99.99); 这种语法也可用于由合适构造函数的类型。 然而，要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11: struct where {double x; double y; double z}; where * one = new where{3.5, 4.5, 6.6}; int *ar = new int [4] {1,2,3,4}; 在C++11中，还可以将列表初始化用于单值变量： int * pin = new int {6}; double * pdo = new double {99.99}; 2.new失败时new可能找不到请求的内存量。在最初的10年中，C++在这种情况下让new返回空指针，但现在将引发异常std::bad_alloc。第15章通过一些简单的例子演示了这两种方法的工作原理。 3.new: 运算符、函数和替换函数运算符new和new[]分别调用如下函数： void * operator new(std::size_t); void * operator new[](std::size_t); 这些函数被称为分配函数，它们位于全局名称空间中。同样，也有由delete和delete[]调用的释放函数： void operator delete(void *); void operator delete[] (void *); 它们使用第11章将讨论的运算符重载语法。std::size_t是一个typedef，对应于合适的整型。对于下面这样的基本语句： int * pi = new int; 被转换为下面的语句： int * pi = new(sizeof(int)); 而下面的语句： int * pa = new int [14]; 被转换为下面这样： int * pa = new(14 * sizeof(int)); 使用new的语句也可能包含初始值，因此，使用new运算符时，不仅仅调用new()函数。 同样， 下面的语句： delete pi; 将转换位如下函数调用： delete (pi); C++将这些函数称为可替换的。这意味着如果您有足够的知识和意愿，可为new和delete提供替换函数，并根据需要对其进行定制。例如，可定义作用域为类的替换函数，并对其进行定制，以满足该类的内存分配需求。在代码中，仍将使用new运算符，但它将调用您定义的new()函数。 4.定位new运算符通过，new负责在堆中找到一个足以能够满足需求的内存块。new运算符还有另一个种变体，被称为定位new运算符，它让您能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。 要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；然后将new运算符用于提高了所需地址的参数。除需要指定参数外，句法与常规new运算符相同。具体说，使用定位new运算符时，变量后面可以有方括号，也可以没有。下面的代码演示了new运算符的4种用法： #include &lt;new&gt; struct chaff { char dross[20]; int slag; }; char buffer1[50]; char buffer2[500]; int main() { chaff *p1, *p2; int *p3, *p4; //常规new运算符 p1 = new chaff; p3 = new int [20]; //定位new运算符 p2 = new (buffer1) chaff; p4 = new (buffer2) int [20]; } 出于简化的目的，这个示例使用两个静态数组来定位new运算符提供内存空间。因此，上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。 下面程序使用常规new运算符和定位new运算符创建动态分配的数组。 newplace.cpp #include &lt;iostream&gt; #include &lt;new&gt; using namespace std; const int BUF = 512; const int N = 5; char buffer[BUF]; int main() { double *pd1, *pd2; int i; cout &lt;&lt; &quot;Calling new and placement new:\n&quot;; pd1 = new double[N]; pd2 = new (buffer) double[N]; for (i = 0; i &lt; N; i++) pd2[i] = pd1[i] = 1000 + 20.0 * i; cout &lt;&lt; &quot;Memory addresser:\n&quot; &lt;&lt; &quot; heap: &quot; &lt;&lt; pd1 &lt;&lt; &quot; static: &quot; &lt;&lt; (void *) buffer &lt;&lt; endl; cout &lt;&lt; &quot;Memory contens:\n&quot;; for (i = 0; i &lt; N; i++) { cout &lt;&lt; pd1[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd1[i] &lt;&lt; &quot;;&quot;; cout &lt;&lt; pd2[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd2[i] &lt;&lt; endl; } cout &lt;&lt; &quot;\n Calling new and placement new a secong time:\n&quot;; double *pd3, *pd4; pd3 = new double[N]; pd4 = new (buffer) double[N]; for (i = 0; i &lt; N; i++) pd3[i] = pd4[i] = 1000 + 400 * i; cout &lt;&lt; &quot;Memory contents:\n&quot;; for (i = 0; i &lt; N; i++) { cout &lt;&lt; pd3[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd3[i] &lt;&lt; &quot;;&quot;; cout &lt;&lt; pd4[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd4[i] &lt;&lt; endl; } cout &lt;&lt; &quot;\n Calling new and placement new a secong time:\n&quot;; delete [] pd1; pd1 = new double[N]; pd2 = new (buffer + N * sizeof(double)) double[N]; for (i = 0; i &lt; N; i++) pd2[i] = pd1[i] = 1000 + 60.0 * i; cout &lt;&lt; &quot;Memory contens:\n&quot;; for (i = 0; i &lt; N; i++) { cout &lt;&lt; pd1[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd1[i] &lt;&lt; &quot;;&quot;; cout &lt;&lt; pd2[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd2[i] &lt;&lt; endl; } delete [] pd1; delete [] pd3; return 0; } 结果 alling new and placement new: Memory addresser: heap: 0x72a010 static: 0x6021a0 Memory contens: 1000 at 0x72a010;1000 at 0x6021a0 1020 at 0x72a018;1020 at 0x6021a8 1040 at 0x72a020;1040 at 0x6021b0 1060 at 0x72a028;1060 at 0x6021b8 1080 at 0x72a030;1080 at 0x6021c0 Calling new and placement new a secong time: Memory contents: 1000 at 0x72a040;1000 at 0x6021a0 1400 at 0x72a048;1400 at 0x6021a8 1800 at 0x72a050;1800 at 0x6021b0 2200 at 0x72a058;2200 at 0x6021b8 2600 at 0x72a060;2600 at 0x6021c0 Calling new and placement new a secong time: Memory contens: 1000 at 0x72a010;1000 at 0x6021c8 1060 at 0x72a018;1060 at 0x6021d0 1120 at 0x72a020;1120 at 0x6021d8 1180 at 0x72a028;1180 at 0x6021e0 1240 at 0x72a030;1240 at 0x6021e8 5.程序说明定位new运算符确实将数组pd2放在了数组buffer中，pd2和buffer的地址都是0x6021a0。然而，它们的类型不同，pd2是double指针，而buffer是char指针。（顺便说一句，这也是程序使用(void $\ast$)对buffer进行强制转换的原型，如果不这样做，cout将显示一个字符串。）。同时，常规new将数组pd1放在很远的地方，其地址为0x72a010，位于动态管理的堆中。 需要指出的第二点是，第二个常规new运算符查找一个新的内存块，其起始地址为0x72a040；但第二个定位new运算符分配与以前相同的内存块；起始地址为00FD9138的内存块。定位new运算符使用传递给它的地址，它不跟踪哪些内存块已被使用，也不查找未使用的内存块。这将一些内存管理的负担交给了程序员。例如，在第三次调用定位new运算符时，提供了一个从数组buffer开头算起的偏移量，因此将分配性的内存： pd2 = new (buffer + N * sizeof(double)) double[N]; 第三点差别是，是否使用delete来释放内存。对于常规new运算符，下面的语句释放起始地址为0x72a010的内存块，因此接下来再次调用new运算符时，该内存块是可用的： delete [] pd1; 然而，程序中没有使用delete来释放定位new运算符分配的内存。事实上，在这个例子不能这样做。buffer指定的内存是静态内存，而delete只能用于这样的指针：指向常规new运算符分配的堆内存。即，数组buffer位于delete的管辖区之外，下面的语句将引发运行阶段错误： delete [] pd2; 另一方面，如果buffer是使用常规new运算符创建的，便可以使用常规delete运算符来释放整个内存块。 定位new运算符的另一种用法，将其与初始化结合使用，从而将信息放在特定的硬件地址处。 定位new运算符的工作原理：基本上，它只是返回传递给它的地址，并将其强制转换为void $\ast$，以便能够赋给任何指针类型。但这说的是默认定位new函数，C++允许程序员重载定位new函数。 将定位new运算符用于类对象时，情况更复杂，将在第12章介绍。 6.定位new的其他形式将向常规new调用一个接受一个参数的new()函数一样，标准定位new()调用一个接受两个参数的new()函数： int * pi = new int; //调用new(sizeof(int)) int * p1 = new(buffer) int; //调用new(sizeof(int), buffer) int * p2 = new(buffer) int[40]; //调用new(40*sizeof(int), buffer) 定位new函数不可替换，但可重载。它至少需要接受两个参数，其中第一个指向std::size_t，指出了请求的字节数。这样的重载函数都被称为定义new，即使额外的参数没有指定位置。 9.3 名称空间在C++中，名称可以时变量、函数、结构、枚举、类以及类和结构的成员。当随着项目的增大，名称空间的冲突可能也将增加。使用多个厂商的类库时，可能导致名称冲突。例如，两个库可能都定义了名为List、Tree和Node的类，但定义的方式不兼容。用户可能希望使用一个库的List类，而使用另一个库的Tree类。这种冲突被称为名称空间问题。 C++提供了名称空间工具，以便更好地控制名称的作用域。 9.3.1 传统的C++名称空间首先介绍一些术语： 声明区域：是可以在其中进行声明的区域。例如，可以在函数外面声明全部变量，对于这种变量，其声明区域为其声明所在文件。对于在函数中声明的变量，其声明区域为其声明所在代码块。 潜在作用域： 变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。 然而，变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。例如，在函数中声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一个文件中声明的全局变量（对于这种变量，声明区域为整个文件）。变量对程序而言可见的范围被称为作用域。 C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域声明e名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发送冲突。 9.3.2 新的名称空间特性C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另一个名称空间的相同名称冲突，同时允许程序的其他使用该名称空间中声明的东西。例如，下面的代码使用新的关键字namespace创建了两个名称空间： namespace Jack{ double pail; void fetch(); int pal; struct Well{...}; } namespace Jill{ double bucket(double n) {...} double fetch; int pal; struct Hill{...}; } 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，默认情况下，在名称空间中声明的名称的链接性为外部（除非它引用了常量）。 除了用户定义的名称空间外，还存在另一个名称空间–全局名称空间。它对应于文件级声明区域，因此前面所说的全局变量被描述为位于全局名称空间中。 任何名称空间中的名称都不会于其他名称空间中的名称发送冲突。因此，Jack中的fetch可以于Jill中的fetch共存，Jill中的Hill可以于外部Hill共存。名称空间中的声明和定义规则同全局声明和定义规则相同。 名称空间是开放的，即可以把名称加入到已有的名称空间中。例如，下面这条语句将名称goose添加到Jill中已有的名称列表中： namespace Jill{ char * goose (const char *); } 同样，原来的Jack名称空间为fetch()函数提供了原型。可以在该文件后面再次使用Jack名称空间来提供函数的代码： namespace Jack{ void fetch() {...} } 当然，需要有一种办法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析运算符::，使用名称空间来限定该名称： Jack::pail = 12.34; Jill::Hill mole; Jack::fetch(); 未被装饰的名称（如pail）称为未限定的名称；包含名称空间的名称（如Jack::pail）称为限定的名称。 1.using声明和using编译指令C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。using声明使特定的标识符可用，using编译指令使整个名称空间可用。 using声明由被限定的名称和它前面的关键字uing组成： uing Jill::fetch;//using声明 using声明将特定的名称添加到它所属的声明区域中。例如main()中的using声明Jill::fetch将fetch添加到main()定义的声明区域中。完成该声明后，便可以使用名称fetch代替Jill::fetch。下面的代码段说明了这几点： namespace Jill{ double bucket (double n){...} double fetch; struct Hill{...}; } char fetch; int main() { using Jill::fetch; double fetch; //非法的 cin &gt;&gt; fetch; //读取一个值到Jill::fetch cin &gt;&gt; ::fetch; //读取一个值到全局fetch } 由于using声明将名称添加到局部声明区域中，因此这个示例避免了将另一个局部变量也命名未fetch。另外，和其他局部变量一样，fetch也将覆盖同名的全局变量。 在函数的外面使用using声明时，将把名称添加到全局名称空间中： void other(); namespace Jill{ double bucket (double n){...} double fetch; struct Hill{...}; } using Jill::fetch; int main() { cin &gt;&gt; fetch; other(); } void other() { cout &lt;&lt; fetch; } using声明使一个名称可用，而using编译指令使所有的名称都可用。using编译指令由名称空间和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符： using namespace Jack; 在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。这种情况出现多次： #include &lt;iostream&gt; using namespace std; 在函数中使用using编译指令。将使其中的名称在该函数中可用，如下： int main() { using namespace Jack; ... } using编译指令和using声明，它们增加了名称冲突的可能性。即，如果名称空间jack和jill，并在代码中使用作用域解析运算符，则不会存在二义性： jack::pal = 3; jill::pal = 10; 变量jack::pal和jill::pal是不同的标识符，表示不同的内存单元。然而，如果使用using声明，情况将发送变法： using jack::pal; using jill::pal; pal = 3; 事实上，编译器不允许同时使用上述两个using声明，因为这将导致二义性。 2.using编译指令和using声明之笔记使用using编译指令导入一个名称空间中所有的名称，像大量使用作用域解析运算符。而使用using声明时，像声明了相应的名称一样。如果某个名称在函数中声明了，则不能使用using声明导入相同的名称。然而，使用using编译指令，将进行名称解析，就像在包含using声明和名称空间本身最小声明区域中声明了名称一样。下面的示例，名称空间未全局的。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。不过仍可像下面的示例中那样使用作用域解析运算符： namespace Jill{ double bucket(double n){...} double fetch; struct Hill{...}; } char fetch; int main() { using namespace Jill; Hill Thrill; double water = bucket(2); double fetch; //创建一个局部变量fetch，隐藏Jill::fetch和全局fetch cin &gt;&gt; fetch; cin &gt;&gt; ::fetch; cin &gt;&gt; Jill::fetch; } int foom() { Hill top; //错误的 Jill::Hill crest; //合理的 } 在main()中，名称Jill::fetch被放在局部名称空间中，但其作用域不是局部，因此不会覆盖全局的fetch。然而，局部声明的fetch将隐藏Jill::fetch和全局fetch。然而，如果使用作用域解析运算符，则后两个fetch变量都是可用的。 需要指出的另一点是，虽然函数中的using编译指令将名称空间的名称视为在函数之外声明的，但它不会使得该文件中的其他函数能够使用这些名称。因此，在前一个例子中，foom()函数不能使用未限定的表示符Hill。 注意：假设名称空间和声明区域定义了相同的名称如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称回发送冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间的版本。 一般来说，使用using声明比使用using编译指令更安全，这是由于它只是导入指定的名称。如果该名称与局部名称发送冲突，编译器将指出来。using编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发送冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确直到添加了哪些名称。 本书的大部分示例采用的方法： #include &lt;iostream&gt; int main() { using namespace std; 首先，#include 语句将头文件iostream放到名称空间std中；然后，using编译指令使该名称空间在main()函数中可用。有些示例采取下述方法： #include &lt;iostream&gt; using namespace std; 这将名称空间std中的所有内容导出到全局名称空间中。使用这种方法的主要原因是方便。它易于完成，同时如果系统不支持名称空间，可以将前两行替换成： #incluce &lt;iostream.h&gt; 然而，名称空间的支持者希望有更多的选择，既可以使用解析运算符，也可以使用using声明，即，不要这样做： using namespace std; 而这样做： int x; std::cin &gt;&gt; x; std::cout &lt;&lt; x &lt;&lt; std::endl; 或者这样做： using std::cin; using std::cout; using std::endl; int x; cin &gt;&gt; x; cout &lt;&lt; x; 可以用嵌套名称空间来创建一个包含常用using声明的名称空间（下一节介绍）。 3.名称空间的其他特性可以将名称空间声明进行嵌套： namespace elements { namespace fire{ int flame; ... } float water; } 这里，flame指的是elements::fire::flame。同样，可以使用下面的usin编译指令使内部的名称可用： using namespace elements::fire; 另外，也可以在名称空间中使用using编译指令和using声明，如下： namespace myth{ using Jill::fetch; using namespace elements; using std::cout; } 假设要访问Jill::fetch。由于Jill::fetch现在位于名称空间myth中，因此可以如下访问： std::cin &gt;&gt; myth::fetch; 当然，由于它也位于Jill名称空间中，仍可以称作Jill::fetch std::cout &lt;&lt; Jill::fetch; 如果没有与之冲突的局部变量，则也可以这样做： using namespace myth; cin &gt;&gt; fetch; using编译指令是可传递的（A&gt;B,B&gt;C -&gt; A&gt;C）。在这种情况下，下面的语句将导入名称空间myth和elements： using namespace myth; 这条编译指令与下面两条编译指令等价： using namespace myth; using namespace elements; 可以名称空间创建别名，例如，假设有下面的名称空间： namespace my_very_favorite_things {...} 则可以使用下面的语句让mvft成为my_very_favorite_things别名： namespace mvft = my_very_favorite_things; 可以使用这种技术来简化对嵌套名称空间的使用： namespace MEF = myth::elements::fire; using MEF::flame; 4.未命名的名称空间可以通过声明名称空间的名称来创建未命名的名称空间： namespace{ int ice; int bandycoot; } 这就像后面跟着using编译指令一样，即，在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域的末尾。从这个方面看，它们与全局变量相似。然而，由于这种名称空间没有名称，因此不能显式地使用using编译指令和using声明来使用它在其他位置都可用。具体地说，不能在未命名空间所属文件之外的其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。例如： static int counts; int others(); int main(){} int others(){} 采用名称空间的方法如下： namespace {int counts;} int others(); int main(){} int others(){} 9.3.3 名称空间示例该程序的第一个文件是头文件，其中包含头文件中常包含的内容：常量、结构定义和函数原型。在这个例子中，这些内容放在两个名称空间中。第一个名称空间叫做pers，其中包括Person结构的定义和两个函数原型—一个用来用人民填充结构，另一个函数显式结构的内容；第二个名称空间叫做debts，定义了一个结构，该结构用来存储人名和金额。该结构使用Person结构，因此debts名称空间使用一条using编译指令，让pers中的名称在debts名称空间可用。 namesp.h #include &lt;iostream&gt; namespace pers { struct Person { std::string fname; std::string lname; }; void getPerson(Person &amp;); void showPerson(const Person &amp;); } namespace debts { using namespace pers; struct Debt { Person name; double amount; }; void getDebt(Debt &amp;); void showDebt(const Debt &amp;); double sumDebts(const Debt ar[], int n); } 第二个文件是源代码文件，它提供了头文件中的函数原型对应的定义。在名称空间中声明的函数名的作用与为整个名称空间，因此定义和声明必须位于同一名称空间中。这正是名称空间的开放性发挥的地方。通过包含namesp.h导入原来的名称空间。然后，该文件将函数定义添加入到两个名称空间中。 namesp.cpp #include &lt;iostream&gt; #include &quot;namesp.h&quot; namespace pers { using std::cout; using std::cin; void getPerson(Person &amp; rp) { cout &lt;&lt; &quot;Enter first name: &quot;; cin &gt;&gt; rp.fname; cout &lt;&lt; &quot;Enter last name: &quot;; cin &gt;&gt; rp.lname; } void showPerson(const Person &amp; rp) { std::cout &lt;&lt; rp.lname &lt;&lt; &quot;, &quot; &lt;&lt; rp.fname; } } namespace debts { void getDebt(Debt &amp; rd) { getPerson(rd.name); std::cout &lt;&lt; &quot;Enter debt: &quot;; std::cin &gt;&gt; rd.amount; } void showDebt(const Debt &amp; rd) { showPerson(rd.name); std::cout &lt;&lt; &quot;: $&quot; &lt;&lt; rd.amount &lt;&lt; std::endl; } double sumDebts(const Debt ar[], int n) { double total = 0; for (int i = 0; i &lt; n; i++) total += ar[i].amount; return total; } } 第三个文件是一个源代码文件，它使用了名称空间中声明和定义的结构和函数。 namessp.cpp #include &lt;iostream&gt; #include &quot;namesp.h&quot; void other(); void another(); int main() { using debts::Debt; using debts::showDebt; Debt golf = {{&quot;Benny&quot;, &quot;goatsniff&quot;}, 120.0}; showDebt(golf); other(); another(); return 0; } void other() { using std::cout; using std::cin; using std::endl; using namespace debts; Person dg = {&quot;Doobles&quot;, &quot;Glister&quot;}; showPerson(dg); cout &lt;&lt; endl; Debt zippy[3]; int i; for (i = 0; i &lt; 3; i++) getDebt(zippy[i]); for (i = 0; i &lt; 3; i++) showDebt(zippy[i]); cout &lt;&lt; &quot;Total debt: $&quot; &lt;&lt; sumDebts(zippy, 3) &lt;&lt; endl; } void another() { using pers::Person; Person collector = {&quot;Milo&quot;, &quot;Rightshift&quot;}; pers::showPerson(collector); std::cout &lt;&lt; std::endl; } 结果 goatsniff, Benny: $120 Glister, Doobles Enter first name: Z Enter last name: xp Enter debt: 1000 Enter first name: W Enter last name: xp Enter debt: 2000 Enter first name: Y Enter last name: xp Enter debt: 3000 xp, Z: $1000 xp, W: $2000 xp, Y: $3000 Total debt: $6000 Rightshift, Milo 在第三个文件中，main()函数首先使用了两个using声明： using debts::Debt; using debts::showDebt; 注意，using声明只是用了名称，例如，第二个using声明没有描述showDebt的返回类型或函数特征标，而只是给出名称；因此，如果函数重载，则一个using声明将导入所有的版本。另外，虽然Debt和showDebt都使用了Person类型，但不必导入任何Person名称，因为debt名称空间有一条包含pers名称空间的using编译指令。 接下来，other()函数采用了一种不太好的方法，即使用一条using编译指令导入整个名称空间： using namespace debts; 由于debts中的using编译指令导入了pers名称空间，因此other()函数可用使用Person类型和showPerson()函数。 最后，another()函数使用using声明和作用域解析运算符来访问具体名称： using pers::Person; pers::showPerson(collector); 9.3.4 名称空间及其前途指导原则： 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。 如果开发了一个函数库或类库，，将其放在一个名称空间中。 仅将编译指令using作为一种将旧代码转换为使用名称看似吗的权宜之计。 不要在腾文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序行为。如果非要使用编译指令using，应将其放在所有预处理编译指令#include之后。 导入名称时，首先十三亿作用域解析运算符或using声明的方法。 对于using声明，首先将其作用域设置为局部而不是全局。 使用名称空间的主旨时简化大型编程项目的管理工作。对于只有一个文件的简单程序，使用using编译指令是没影响。 老式头文件（如iostream.h）没有使用名称空间，但心头文件（如iostream）使用了std名称空间。 9.4 总结头文件 存储方案：作用域、持续性、链接性 名称空间： using声明，usign编译指令，作用域解析运算符]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--函数探幽（八）]]></title>
    <url>%2F2018%2F10%2F12%2FC%2B%2B%20Primer%20Plus--%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内联函数、按引用传递变量、默认的参数值、函数动态以及模板函数。 8.1 C++内联函数内联函数是C++为提高运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。 编译过程的最终产品是可执行程序–由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后逐步执行这些指令。 常规函数调用也是程序跳到另一个地址，并在函数结束时返回。下面更详细介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来。即，编译器将使用相应的函数的代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序包含该函数代码的10个副本。 应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间吗将只占用整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以声明非内联调用使用的大部分时间。由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非函数经常被调用。 要使用这项特性，必须采取下述措施之一： 在函数声明前加上关键字inline; 在函数定义前加上关键字inline。 通常的做法是省略原型，将整个定义放在本应提供原型的地方。 程序员请求将函数作为内联函数时，编译器不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己(内联函数不能递归)，因此不将其作为内联函数；而有些编译器没有启动或实现这这种特性。 inline.cpp #include &lt;iostream&gt; using namespace std; inline double square(double x) {return x * x;} int main() { double a, b; double c = 13.0; a = square(5.0); b = square(5.5+7.5); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c; cout &lt;&lt; &quot;, c squared = &quot; &lt;&lt; square(c++) &lt;&lt; endl; cout &lt;&lt; &quot;Now c = &quot; &lt;&lt; c &lt;&lt; endl; return 0; } 结果 a = 25, b = 169 c = 13, c squared = 169 Now c = 14 输出表明，内联函数和常规函数一样，也是按值来传递参数的。尽管程序没有提供独立的原型，但C++原型特性仍在起作用。这是因为在函数首次使用前出现了整个函数定义充当了原型。 内联与宏 inline工作是C++新增的特定。C语言使用预处理语句#define来提高宏—内联代码的原始实现。例如： #define SQUARE(x) x*x 这并不是通过传递参数实现的，而是通过文本替换实现的–x是“参数”的符号标记。 a = SQUARE(4.5 + 7.5); b = SQUARE(c++); 上述语句不能正常工作，可以通过使用括号来进行改进: #define SQUARE(x) ((x)*(x)) 但仍然存在问题，即弘不能按值传递。即使使用新的定义，SQUARE(c++)仍将c递增两次，程序inline.cpp中，内联函数square()计算的c的结果，传递它，以计算其平方值，然后将c递增一次。 8.2 引用变量C++增加了一种复合类型–引用变量。引用是已定义的变量的别名(另一个名称)。例如：如果将twain作为clement变量的引用，则可以交替使用twain和clement来表示变量。 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计来说，引用也是必不可少的。 8.2.1 创建应用变量C++给&amp;符号赋予了另一个含义，将其用来声明用于。例如，要将rodents作为rats变量的别名，可以这样做： int rats; int &amp; rodents = rats; 其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的char$\ast$指的是指向char的指针一样，int&amp;指的是指向int的引用。上述声明允许将rats和rodents互换–它们指向相同的值和内存单元。 firstref.cpp #include &lt;iostream&gt; using namespace std; int main() { int rats = 101; int &amp; rodents = rats; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; rodents ++; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;rats addresss = &quot; &lt;&lt; &amp;rats; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; return 0; } 结果 rats = 101, rodents = 101 rats = 102, rodents = 102 rats addresss = 0x7ffc899ccdf4, rodents address = 0x7ffc899ccdf4 创建rats的指针和引用： int rats = 101; int &amp; rodents = rats; int * prats = &amp;rats; 这样，表达式rodents和$\ast$都可以同rats互换；表达式&amp;rodents和prats都可以同&amp;rats互换。 引用与指针差别之一是：引用必须在声明引用的时将其初始化，而不能像指针那样，先声明，再赋值。 引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就一致效忠于它。即： int &amp; rodents = rats; 实际上是下述代码的伪装表示： int * const pr = &amp;rats; 其中，因此rodents扮演的角色与表达式$\ast$pr相同。 sceref.cpp #include &lt;iostream&gt; using namespace std; int main() { int rats = 101; int &amp; rodents = rats; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;rats address = &quot; &lt;&lt; &amp;rats; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; int bunnies = 50; rodents = bunnies; cout &lt;&lt; &quot;bunnies = &quot; &lt;&lt; bunnies; cout &lt;&lt; &quot;, rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;bunnies address = &quot; &lt;&lt; &amp;bunnies; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; return 0; } 结果 rats = 101, rodents = 101 rats address = 0x7ffddcafd674, rodents address = 0x7ffddcafd674 bunnies = 50, rats = 50, rodents = 50 bunnies address = 0x7ffddcafd670, rodents address = 0x7ffddcafd674 最初，rodents引用的rats，但随后程序试图将rodents作为bunnies的引用： rodents = bunnies; 咋一看，这种意图暂时成功，因此rodents的值从101变成了50，rats的值也变成了50。但是bunnies的地址与rats和rodents的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效： rats = bunnies; 即，这意味着将bunnies变量的值赋给rats变量。简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 程序员试图这样做： int rats = 101; int *pt = &amp;rats; int &amp; rodents = *pt; int bunnies = 50; pt = &amp;bunnies; 将rodents初始化为$\ast$pt使得rodents指向rats，接下来将pt改为指向bunnies，并不能改变rodents和rats的值，即rodents引用的是rats。 8.2.2 将引用作为函数参数引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。 交换两个变量的值，对使用引用和使用指针进行比较。 swaps.cpp #include &lt;iostream&gt; using namespace std; void swapr(int &amp; a, int &amp; b); void swapp(int * p, int * q); void swapv(int a, int b); int main() { int wallet1 = 300; int wallet2 = 250; cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; &quot;Using references to swap contents:\n&quot;; swapr(wallet1, wallet2); cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; &quot;Using pointers to swap contents:\n&quot;; swapp(&amp;wallet1, &amp;wallet2); cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; &quot;Using values to swap contents:\n&quot;; swapv(wallet1, wallet2); cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; return 0; } void swapr(int &amp; a, int &amp; b) { int temp = a; a = b; b = temp; } void swapp(int * p, int * q) { int temp = *p; *p = *q; *q = temp; } void swapv(int a, int b) { int temp = a; a = b; b = temp; } 结果 wallet1 = 300, wallet2 = 250 Using references to swap contents: //第一交换，成功 wallet1 = 250, wallet2 = 300 Using pointers to swap contents: //在第一次交换的基础上，交换，成功 wallet1 = 300, wallet2 = 250 Using values to swap contents: //交换失败 wallet1 = 300, wallet2 = 250 引用和指针方法都成功地交换了两个值，而按值传递的方法没能完成这项工作。 按引用传递和按值传递看来相同，只能通过隐形或函数定义才能知道swapr()是按引用传递的。按引用传递的函数和按值传递的函数的代码，唯一区别是声明函数参数的方式不同。 void swapr(int &amp; a, int &amp; b) void swapv(int a, int b) 当然还有内在区别，在swapr()中，变量a和b是wallet1和wallet2的别名，所以交换a和b的值相当于交换wallet1和wallet2的值。但在swapv()中，变量a和b是wallet1和wallet2的副本，因此交换a和b的值并不会影响wallet1和wallet2的值。 比较按引用传递的函数和按指针传递的函数，第一区别是声明函数的方式： void swapr(int &amp; a, int &amp; b) void swapp(int * p, int * q) 另一个区别是指针版本需要在函数使用p和q的整个过程中使用解除引用运算符$\ast$。 8.2.3 引用的属性和特别之处使用两个函数计算参数的立方，其中一个函数接受double类型的参数，另一个接受doulbe引用。 cubes.cpp #include &lt;iostream&gt; double cube(double a); double refcube(double &amp;ra); using namespace std; int main() { cout &lt;&lt; cube(x) &lt;&lt; &quot; = cube of &quot; &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; refcube(x) &lt;&lt; &quot; = cube of &quot; ; cout &lt;&lt; x &lt;&lt; endl; //主要该处x必须重启一行 return 0; } double cube(double a) { a *= a * a; return a; } double refcube(double &amp;ra) { ra *= ra * ra; return ra; } 结果 27 = cube of 3 27 = cube of 27 注意，如果程序中命令修改为如下： cout &lt;&lt; refcube(x) &lt;&lt; &quot; = cube of &quot; &lt;&lt; x &lt;&lt; endl; 输出结果为： 27 = cube of 3 refcube()函数修改main()函数中的x的值，而cube()没有影响。如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。例如： double refcube(const double &amp;ra); 如果要编写类似于上述示例的函数(即使用基本数值类型)，应采用按值传递的方式，而不要采用按引用传递的方式。当数据量比较大(如结构和类)时，引用参数将很有用。 按引用传递时，传递引用的参数的限制更严格，比如：不能使用x+0.2这样： doulbe z = refcube(x+0.2); //非法 如果这样做，由于x+0.2不是double类型的变量，因此程序创建一个临时的无名变量，并将其初始化为表达式x+0.2的值。然后，ra将成为该临时变量的引用。 临时变量、引用参数和const 如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这种做。 如果引用参数是const，则编译器将下面两种情况下生成临时变量： 实参的类型正确，但不是左值 实参的类型不正确，但可以转换为正确的类型 左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左右的实体，但这是引入关键字const之前的情况。现在，常规变量和const变量都可视为左值，因此可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可能修改的左值。 重新定义refcube()，使其接受一个常量引用参数： double refcube(const double &amp; ra) { return ra * ra * ra; } 现在考虑如下代码： double side = 3.0; double * pd = &amp;side; double &amp; rd = side; long edge = 5L; double lens[3] = {2.1,2.3,1.4}; double c1 = refcube(side); double c2 = refcube(lens[2]); double c3 = refcube(rd); double c4 = refcube(*pd); double c5 = refcube(edge); //ra是临时变量 double c6 = refcube(7.0); //ra是临时变量 doubel c7 = refcube(side+1.0); //ra是临时变量 参数side、lens[2]、rd和$\ast$pd都是有名称的、double类型的数据对象，因此可以为其创建引用，而不要临时变量。然而，edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，参数7.0和side+1.0的类型正确，但没有名称，在这些情况下，编译器将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器边可以随意将其删除。 如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将组织这种意图的实现。解决方法是：禁止创建临时变量。 现在来看refcube()函数。该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而是函数在可处理的参数种类方面更同样。因此，如果声明将引用指定为const，C++将在必要时生成临时变量。实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值。 注意：如果函数调用的参数不是左值或相应const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。 应尽可能使用const 将引用参数声明为常数数据的引用的理由有三个： 使用const可以避免无意中修改数据的编程错误； 使用const使函数能够处理const和非const实参，否则将只能接受非const数据； 使用const引用使函数能够正确生成并使用临时变量。 C++11新增了另一种引用–右值引用。这种引用可指向右值，是使用&amp;&amp;声明的： double &amp;&amp; rref == sqrt(36.0); double j = 15.0; double &amp;&amp; jref = 2.0*j+18.5; cout &lt;&lt; rref &lt;&lt; endl; cout &lt;&lt; jref &lt;&lt; end; 新增右值引用的主要目的是，让库设计人员能够提供有些操作的更有效实现。以前的引用(使用&amp;声明的引用)现在称为左值引用。 8.2.4 将引用用于结构引用非常适合用于结构和类（C++的用户定义类型）。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。 使用结构引用参数的方式与基本变量引用相同，只需在声明结构参数时使用引用运算符&amp;即可。比如： struct free_throws { string name; int made; int attempts; float percent; }; 则可以这样编写函数原型，在函数中将指向该结构的引用作为参数： woid set_pc(free_throws &amp; ft); 如果不希望函数修改传入的结构，可使用const： void display(const free_throws &amp; ft); strtref.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; struct free_throws { string name; int made; int attempts; float percent; }; void display(const free_throws &amp; ft); void set_pc(free_throws &amp; ft); free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source); int main() { free_throws one = {&quot;Ifelsa Branch&quot;, 13, 14}; free_throws two = {&quot;Andor Knott&quot;, 10, 16}; free_throws three = {&quot;Minnie Max&quot;, 7, 9}; free_throws four = {&quot;Whily Looper&quot;, 5, 9}; free_throws five = {&quot;Long Long&quot;, 6, 14}; free_throws team = {&quot;Throwgoods&quot;, 0, 0}; free_throws dup; set_pc(one); display(one); accumulate(team, one); display(team); display(accumulate(team, two)); accumulate(accumulate(team, three), four); display(team); dup = accumulate(team, five); cout &lt;&lt; &quot;Displyaing team:\n&quot;; display(team); cout &lt;&lt; &quot;Display dup after assignment:\n&quot;; display(dup); set_pc(four); accumulate(dup,five) = four; cout &lt;&lt; &quot;Displaying dup after ill-advised assignment:\n&quot;; display(dup); return 0; } void display(const free_throws &amp; ft) { cout &lt;&lt; &quot;Name: &quot; &lt;&lt; ft.name &lt;&lt; endl; cout &lt;&lt; &quot; Made: &quot; &lt;&lt; ft.made &lt;&lt; &quot;\t&quot;; cout &lt;&lt; &quot;Attempts: &quot; &lt;&lt; ft.attempts &lt;&lt; &quot;\t&quot;; cout &lt;&lt; &quot;Percent: &quot; &lt;&lt; ft.percent &lt;&lt; endl; } void set_pc(free_throws &amp; ft) { if (ft.attempts != 0) ft.percent = 100.0f * float(ft.made) / float(ft.attempts); else ft.percent = 0; } free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source) { target.attempts += source.attempts; target.made += source.made; set_pc(target); return target; } 结果 Name: Ifelsa Branch Made: 13 Attempts: 14 Percent: 92.8571 Name: Throwgoods Made: 13 Attempts: 14 Percent: 92.8571 Name: Throwgoods Made: 23 Attempts: 30 Percent: 76.6667 Name: Throwgoods Made: 35 Attempts: 48 Percent: 72.9167 Displyaing team: Name: Throwgoods Made: 41 Attempts: 62 Percent: 66.129 Display dup after assignment: Name: Throwgoods Made: 41 Attempts: 62 Percent: 66.129 Displaying dup after ill-advised assignment: Name: Whily Looper Made: 5 Attempts: 9 Percent: 55.5556 1.程序说明该程序首先初始化了多个结果对象。如果指定的初始值比成员少，余下的成员(这里是percent)将被设置为零。第一个函数调用如下： set_pc(one); 由于函数set_pc()的形参ft为引用，因此ft指向one，函数set_pc()的代码设置成员one.percent。按值传递不行，因此这将导致设置的是one的临时拷贝的成员percent。另一种方法是使用指针参数，并传递结构的地址，要复杂些。 下一个函数调用如下： display(one); 由于display()显示结构的内容，而不修改它，因此这个函数使用了一个const引用参数。就这个函数而言，也可按值传递，但与复制原始结构的拷贝相比，使用引用可节省时间和内存。 再下一个函数调用如下： accumulate(team, one); 函数accumulate()接收两个结构参数，并将第二结构的成员attempts和made的数据添加到第一个结构的相应成员中。只修改了第一个结构，因此第一个参数为引用，而第二个参数为const引用： free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source) 当前讨论的函数调用没有使用它，就目前而言，原本可以将返回值声明void，但请看下述函数调用： display(accumulate(team, two)); 首先，结构对象team作为第一个参数传递给了accumulate()。意味着在函数accumulate()中，target指向的是team。函数accumulate()修改team，在返回指向它的引用。注意到返回语句如下： return target; 光看这条语句并不能知道返回的是引用，但函数头和原型中指出了这一点。如果返回类型被声明为free_throws而不是free_throws &amp;，上述返回语句将返回target（即team）的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象。 接下来，将accumulate()的返回值作为参数传递给了display()，这意味着将team传递给了display()。display()的参数为引用，这意味着函数display()中的ft指向是team，因此将显示team的内容。 2.为何要返回引用下面更深入地讨论返回引用与传统返回机制的不同。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。 double m = sqrt(16.0); cout &lt;&lt; sqrt(25.0); 在第一天语句中，值4.0被复制到一个临时位置，然后被复制给m。在第二条语句中，值5.0被复制到一个临时位置，然后被传递给cout。 dup = accumulate(team, five); 如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到dup，其效率更高。 3. 返回引用时需要注意的问题返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。应避免写下面这样的代码： const free_throws &amp; clone2(free_throws &amp; ft) { free_throws newguy; newguy = ft; return newguy; } 该函数返回一个指向临时变量的引用，函数运行完毕它将不再存在。也应避免返回指向临时变量的指针。 为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数。正如accumulate()一样，第一个引用就是这个作用。 另一种方法是用new来分配新的存储空间。前面使用过，使用new为字符串分配内存空间，并返回指向该内存空间的指针。下面是使用引用来完成类似的工作： const free_throws &amp; clone(free_throws &amp; ft) { free_throws * pt; *pt = ft; return *pt; } 第一条语句创建一个无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构。上述代码似乎会返回结构，但函数声明表明，该函数实际上将返回这个结构的引用。这样，便可以这样使用该函数： free_throws &amp; jolly = clone(three); 这使得jolly成为新结构的引用，这种方法存在一个问题：在不再需要new分配的内存时，应使用delete来释放它们。调用clone()隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。第16章讨论的auto_ptr模板以及C++新增的unique_ptr可帮助程序员自动完成释放工作。 4. 为何将const用于引用返回类型程序中： accumulate(dup, five) = four; 其效果如下：首先将five的数据添加到dup中，再使用four的内容覆盖dup的内容。这条语句为何能够通过编译呢？在赋值语句中，左边必须是可修改的左值，即在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。在这里，函数返回值指向dup的引用，它确实标识的是一个这样的内存块，因此这条语句是合法的。 另一方面，常规（非引用）返回类型是右值—不能通过地址访问的值。这种表达式可出现在赋值语句的右边，但不能出现在左边。其他右值包括字面值(如10.0)和表达式(x+y)。显然，获取字面值的地址没有意义，但为何常规函数返回值是右值呢？这是因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在。 假设要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需要将返回类型声明为const引用： const free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source); 现在返回类型为const，是不可修改的左值，因此下面的赋值语句不合法： accumulate(dup, five) = four; 返回类型为const引用后，下面的语句仍合法： display(accumulate(team, two)); 这是因为display()的形参也是const free_throws &amp;类型。但下面的赋值语句不合法，因此accumulate()的第一形参不是const: accumulate(accumualte(team, three), four); 在此，影响不大，仍可以这样做： accumulate(team, three); accumulate(team, four); 8.2.5 将引用用于对象将类对象传递给函数是，C++通过的做法是使用引用。例如，可以通过使用引用，让函数将类string、ostream、istream、ofstream和ifstream等类的对象作为参数。 使用string类，演示一些不同的设计方案。这个例子的基本思想是:创建一个函数，它将指定的字符串加入到另一个字符串的前面和后面。下面程序提供了三个函数，然后其中的一个存在非常大的缺陷，可能导致程序崩溃甚至不通过编译。 strquote.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; string version1(const string &amp; s1, const string &amp; s2); const string &amp; version2(string &amp; s1, const string &amp; s2); const string &amp; version3(string &amp; s1, const string &amp; s2); int main() { string input; string copy; string result; cout &lt;&lt; &quot;Enter a string: &quot;; getline(cin, input); copy = input; cout &lt;&lt; &quot;Your string as entered: &quot; &lt;&lt; input &lt;&lt; endl; result = version1(input, &quot;***&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; result = version2(input, &quot;###&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Resetting original string.\n&quot;; input = copy; result = version3(input, &quot;@@@&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; return 0; } string version1(const string &amp; s1, const string &amp; s2) { string temp; temp = s2 + s1 + s2; return temp; } const string &amp; version2(string &amp; s1, const string &amp; s2) { s1 = s2 + s1 + s2; return s1; } const string &amp; version3(string &amp; s1, const string &amp; s2) { string temp; temp = s2 + s1 + s2; return temp; } 结果： Enter a string: It&apos;s my fault Your string as entered: It&apos;s my fault Your string enhanced: ***It&apos;s my fault*** Your original string: It&apos;s my fault Your string enhanced: ###It&apos;s my fault### Your original string: ###It&apos;s my fault### Resetting original string. Your string enhanced: Your original string: It&apos;s my fault 编译时给出警告 strquote.cpp: 在函数‘const string&amp; version3(std::string&amp;, const string&amp;)’中: strquote.cpp:50:9: 警告：返回了对局部变量的‘temp’的引用 [-Wreturn-local-addr] string temp; 即version3尝试返回一个局部变量的引用。temp是一个新的string对象，只在函数version1()中有效，该函数执行完毕，它将不再存在。因此返回指向temp的引用不可行，因此该函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中，然后在main()中，该存储单元的内容被复制到一个名为result的strin中。 将C-风格字符串用作string对象引用参数 对于函数version1()，可能注意到有趣的一点：该函数的两个形参(s1和s2)的类型都是const sting &amp;，但实参(input和”$\ast\ast\ast$”)的类型分别为string和const char *。由于input的类型为string，因此让s1指向它没有任何问题，然而，程序怎么能够接受char指针赋给string引用呢？ 这里有两点需要说明：首先，string类定义了一种char$\ast$到string的转换功能，这使得可以使用C-风格字符日来初始化string对象。其次，本章前面讨论过的类型为const引用的形参的一个属性。假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。例如，将int实参传递给const double &amp;形参时，就是以这种方式处理的。同样，也可以将实参char$\ast$或const char$\ast$传递给形参const string &amp;。 这种属性的结果是，如果形参类型为const string &amp;，在调用函数时，使用的实参可以是string对象或C-风格字符串，如用引号括起来的字符串字面量、自空字符结尾的char数组或指向char的指针变量。因此，下面代码是可行的： result = version1(input, &quot;***&quot;); 函数version2()不创建临时string对象，而是这将修改原来的string对象。由于s1指向main()中一个对象(input)的引用，因此将s1作为引用返回是安全的。由于s1指向input的引用，调用该函数将带来修改input的副作用。 verson3()函数的做法是错误的非法的。它存在一个致命的错误：返回一个指向version3()中声明的变量的引用。这个函数能够通过编译（但编程器会给出警告），但当程序试图执行该函数时将崩溃。具体地说，问题是由下面的赋值语句引起的： result = version3(input, &quot;@@@&quot;); 程序试图引用已经释放的内存。 8.2.6 对象、继承和引用ostream和ofstream类凸显了引用的一个有趣属性。ofstream对象可以使用ostream类的方法，这使得文件输入/输出的格式与控制台输入/输出相同。使得能够将特性从一个类传递到另一个类的语言特性被称为继承，这将在第13章讨论。简单地说，ostream是基类，而ofstream是派生类。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性。 继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制转换。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类作为参数，也可以将派生类对象作为参数。例如：参数类型为ostream &amp;的函数可以接受ostream对象(如 cout)或声明的ofstream对象作为参数。 下面程序，通过调用一个函数将数据写入文件和显示到屏幕上来说明这一点。该程序要求用户输入望远镜物镜和一些目镜的焦距，然后计算并显示每个目镜的放大倍数。放大倍数等于物镜的焦距除以目镜的焦距。 filefun.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; void file_it(ostream &amp; os, double fo, const double fe[], int n); const int LIMIT = 5; int main() { ofstream fout; const char * fn = &quot;ep-data.txt&quot;; fout.open(fn); if (!fout.is_open()) { cout &lt;&lt; &quot;Can&apos;t open &quot; &lt;&lt; fn &lt;&lt; &quot;. Bye.\n&quot;; exit(EXIT_FAILURE); } double objective; cout &lt;&lt; &quot;Enter the focal length of your telescope objective in mm: &quot;; cin &gt;&gt; objective; double eps[LIMIT]; cout &lt;&lt; &quot;Enter the focal lengths, in mm, of &quot; &lt;&lt; LIMIT &lt;&lt; &quot; eyepieces:\n&quot;; for (int i = 0; i &lt; LIMIT; i++) { cout &lt;&lt; &quot;Eyepiece #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; ; cin &gt;&gt; eps[i]; } file_it(fout, objective, eps, LIMIT); file_it(cout, objective, eps, LIMIT); return 0; } void file_it(ostream &amp; os, double fo, const double fe[], int n) { ios_base::fmtflags initial; initial = os.setf(ios_base::fixed); os.precision(0); os &lt;&lt; &quot;Foacal length of objective: &quot; &lt;&lt; fo &lt;&lt; &quot; mm\n&quot;; os.setf(ios::showpoint); os.precision(1); os.width(2); os &lt;&lt; &quot;f.1 eyepiece&quot;; os.width(15); os &lt;&lt; &quot;magnification&quot; &lt;&lt; endl; for (int i = 0; i &lt; n; i++) { os.width(12); os &lt;&lt; fe[i]; os.width(15); os &lt;&lt; int (fo/fe[i] + 0.5) &lt;&lt; endl; } os.setf(initial); } 结果： Enter the focal length of your telescope objective in mm: 1800 Enter the focal lengths, in mm, of 5 eyepieces: Eyepiece #1: 30 Eyepiece #2: 19 Eyepiece #3: 14 Eyepiece #4: 8.8 Eyepiece #5: 7.5 Foacal length of objective: 1800 mm f.1 eyepiece magnification 30.0 60 19.0 95 14.0 129 8.8 205 7.5 240 对于该程序，最重要的一点是，参数os（其类型为ostream &amp;）可以指向ostream对象（如cout），也可以指向ofstream对象（如fcout）。 方法setf()让您能够设置各种格式化状态。例如，方法调用setf(ios_base::fixed)将对象置于使用定点表示法模式；set(ios_base::showpoint)将对象置于显示小数点的模式，即使小数部分为零。方法precision()指定显示多少位小数。所有这些设置都将保持不变，直到再次调用相应的方法重新设置它们。方法width()设置下一次输出操作使用的字段宽度，这种设置只在显示下一值时有效，然后将恢复到默认设置。默认的字段宽度为零，这意味着刚好能容纳下要显示的内容。 函数file_it()使用了两个有趣的方法调用： ios_base::fmtflags initial; initial = os.setf(ios_base::fixed); ... os.setf(initial); 方法setf()返回调用它之前有效的所有格式设置。ios_base::fmtflags是存储这种信息所需的数据类型名称。因此，将返回值赋给initial将存储调用file_it()之前的格式化设置，然后便可以使用变量initial作为参数来调用setf()，将所有的格式化设置恢复到原来的值。因此，该函数将对象回到传递给file_it()之前的状态。 需要说明的最后一点，每个对象都存储了自己的格式化设置。因此，当程序将cout传递给file_it()时，cout的设置将被修改，然后被恢复；当程序将fout传递给file_it()时，fout的设置将被修改了，然后被恢复默认。 8.2.7 何时使用引用参数使用引用参数的主要原因有两个： 程序员能够修改调用函数中的数据对象 通过传递引用而不是整个数据对象，可以提高程序的运行速度 当数据对象比较大时（如结果和类对象），第二个原因最重要。这些也是使用指针参数的原因。 对于使用传递值而不作修改的函数。 如果数据对象很小，如内置数据类型或小型结构，则按值传递。 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。 如果数据对象是比较大的结构，则使用const指针和const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这种特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。 对于修改调用函数中数据的函数： 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码(其中x是int)，则很明显，该函数将修改x。 如果数据对象是结构，则使用引用或指针。 如果数据对象是数组，则只能使用指针。 如果数据对象是类对象，则使用引用。 当然，这只是一些值得原则，很可能有充分的理由做出其他选择。 8.3 默认参数默认参数指的是当函数调用中省略了实参时自动使用的一个值。 由于编译器通过查看原因来了解函数所使用的参数数目，因此函数原型必须将可能的默认参数告知程序。方法是将值赋给原型中的参数。例如： char * left (const char * str, int n = 1); 对于带参数列表的函数，必须从右到左添加默认值。即要为某个参数设置默认值，则必须为它右边的所有参数提供默认： int harpo(int n, int m = 4, int j = 5); int chico(int n, int m = 6, int j); //非法的 int groucho(int k = 1, int m = 2, int n = 3); 丽日，harpo()原型允许调用该函数时提供1、2或3个参数： beeps = harpo(2); beeps = harpo(1,8); beeps = harpo(8,7,6); 实参按从左至右的顺序依次被赋给相应的形参，而不能跳过任何参数。因此，下面的调用是不允许的： beeps = harpo(3, ,8); left.cpp #include &lt;iostream&gt; using namespace std; const int ArSize = 80; char * left(const char * str, int n = 1); int main() { char sample[ArSize]; cout &lt;&lt; &quot;Enter a string:\n&quot;; cin.get(sample, ArSize); char *ps = left(sample, 4); cout &lt;&lt; ps &lt;&lt; endl; delete [] ps; ps = left(sample); cout &lt;&lt; ps &lt;&lt; endl; delete [] ps; return 0; } char * left(const char * str, int n)//注意在函数定义时，不要添加默认参数，否则会报错 { if (n &lt; 0) n = 0; char * p = new char[n+1]; int i; for (i = 0; i &lt; n &amp;&amp; str[i]; i++) p[i] = str[i]; while (i &lt;= n) p[i++] = &apos;\0&apos;; return p; } 结果 Enter a string: forthcoming fort f 为了防止用户要求的字符数目可能多于字符串包含的字符数，为预防这种情况，函数使用了一个组合测试： i &lt; n &amp;&amp; str[i] i&lt;n测试让循环复制了n个字符后就终止。测试的第二部分–表达式str[i]，是要复制的字符的编码。遇到空值字符后，循环结束。 另一种设置新字符串长度的方法是，将n设置为传递的值和字符长度中较小的一个： int len = strlen(str); n = (n &lt; len) ? n : len; char *p = new char[n+1]; 这件确保new分配的空间不会多余存储字符串所需的空间。如果用户执行像left(“Hi!”, 1000)这样的调用，这种方法很有用。第一种方法是，将“Hi!”复制到由1000个字符组成的数组中，并将除前3个字符之外的所有字符都设置为空值字符；第二种方法是，将“Hi！”复制到由4个字符组成的数组中。但由于添加了另一个函数调用strlen()，因此程序将更长，运行速度将检查，同时还必须包括头文件cstring。 如果调用strlen()所需的时间很长，则可以让left()直接确定n和字符串长度哪个小。例如，当m的值等于n或到达字符串结尾时，下面的循环都将停止： int m = 0; while (m &lt;= n &amp;&amp; str[m] != &apos;\0&apos;) // 也可以写成while (m &lt;= n &amp;&amp; str[m]) m++; char *p = new char[m+1]; 8.4 函数重载函数重载指的是可以有多个同名的函数，因此对名称进行了重载。可以通过函数重载来设计一系列函数–它们完成相同的工作，但使用不同的参数列表。C++根据使用上下文来确定要使用的重载函数版本。 函数重载的关键是函数的参数列表–也称为函数特征标。如果两个函数的参数数目和类型相同，同时参数的排序顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。例如，可以定义一组原型如下print()函数： void print(const char * str, int width); void print(double d, int width); void print(long l, int width); void print(int i, int width); void print(const char * str); 使用print()函数时，编译器根据所采用的用法使用相应特征标的原型。 使用被重载的函数时，需要在函数调用中使用正确的参数类型，例如，对如下面的语句： unsigned int year = 3210; print(year, 6); print()调用与哪个原型匹配呢？它不与任何原型匹配！没有匹配的原型并不会自动停止使用其他的某个函数，因为C++将尝试使用标准类型强制转换进行匹配。如果原型只有第二个，则函数调用print(year,6)将把year转换为doule类型。但在上面的代码中，有3个将数字作为第一个参数的原型，因此有3种转换year的方式。在这种情况下，C++拒绝这种函数调用，并将其视为错误。 一些看起来彼此不同的特征标是不能共存的，例如： double cube(double x); double cube(double &amp; x); 编译器考虑这个问题时，请看如下代码： cout &lt;&lt; cube(x); 参数x与double x原型和 double &amp; x原型都匹配，因此编译器不知道究竟使用哪个原型。为避免这种混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。 匹配函数时，并不区分const和非const变量。 void dribble(char * bits); void dribble(const char * cbits); void babble(char * bits); void drivel(const char * bits); 下面列出了各种函数调用对应的原型： const char p1[20] = &quot;How&apos;s the weather?&quot;; char p2[20] = &quot;How&apos;s business?&quot;; dribble (p1); dribble(p2); dabble(p1); //不匹配 dabble(p2); drivel(p1); drivel(p2); dribble()函数有两个原型，一个用于const指针，另一个用于常规指针，编译器根据实参是否为const来决定使用哪个原型。dabble()函数只与带非const参数的调用匹配，而drivel()函数可以与带const和非const参数的调用匹配。drivel()和dabble()在行为上有这种差别，主要是由于将非const值赋给const变量是合法的，但反之是非法的。 请记住，是特征标，而不是函数类型使得可以对函数进行重载。例如，下面两个声明是互斥的： long gronk(int n, float m); double gronk(int n, float m); 因此，C++不允许以这种方式重载gronk()。返回类型可以不同，但特征标也必须不同： long gronk(int n, float m); double gronk(float n, float m); 重载引用参数 类设计和STL经常使用引用参数，因此直到不同引用类型的重载很有用： void sink(doube &amp; r1); void sank(const double &amp;r2); void sunk(double &amp;&amp; r3); 左值引用参数r1与可修改的左值参数匹配；const左值引用参数r2与可修改的左值参数、const作者参数和右值参数(如两个double值的和)匹配；最后，右值引用参数r3与右值匹配。注意到r1或r3匹配的参数都与r2匹配。 注意到与r1或r3匹配的参数都与r2匹配。这就带来一个问题：如果重载使用这三种参数的函数，结果将如何？答案是将调用最匹配的版本： void staff(doube &amp; rs); void staff(const double &amp; rcs); void stove(double &amp; r1); void stove(const double &amp; r2); void stove(double &amp;&amp; r3); 这让您根据参数是左值、const还是右值来定制函数的行为： double x = 55.5; const double y = 32.0; stove(x); //调用stove(double &amp;) stove(y); //调用stove(const double &amp;) stove(x+y); //调用 stove(doubel &amp;&amp;) 如果没有定义stove(double &amp;&amp;)，stove(x+y)将调用函数stove(const double &amp;)。 8.4.1 重载示例前面创建了left()函数，它返回一个指针，指向字符串的前n个字符。下面添加另一个left()函数，它返回整数的前n位。 一种方法是，先计算数字包含多少位，将数字除以10便可以去掉一位，因此可以使用除法来计算数位。更准确的，可以使用下面循环： nsigned digits = 1; while (n /= 10) digits++; 上述循环计算每次删除n中的一位时，需要多少次才能删除所有的位。 现在假设数字共有5位，并要返回前3位，则将这个数除以10再除以10，便可以得到所需的值。每除以10就删除数字的最后一位。要直到需要删除多少位，只需要将总数减去要获得的位数即可。可以如下编写： ct = digits - ct; while(ct--) num /= 10; return num; leftover.cpp #include &lt;iostream&gt; unsigned long left(unsigned long num, unsigned ct); char * left (const char * str, int n = 1); using namespace std; int main() { char * trip = &quot;Hawaii!!&quot;; unsigned long n = 12345678; int i; char * temp; for (i = 1; i &lt; 10; i++) { cout &lt;&lt; left(n, i) &lt;&lt; endl; temp = left(trip, i); cout &lt;&lt; temp &lt;&lt; endl; delete [] temp; } return 0; } unsigned long left(unsigned long num, unsigned ct) { unsigned digits = 1; unsigned long n = num; if (ct == 0 || num == 0) return 0; while (n /= 10) digits++; if (digits &gt; ct) { ct = digits - ct; while(ct--) num /= 10; return num; } else return num; } char * left(const char * str, int n) { if (n &lt; 0) n = 0; char * p = new char [n+1]; int i; for (i = 0; i &lt; n &amp;&amp; str[i]; i++ ) p[i] = str[i]; while (i &lt;= n) p[i++] = &apos;\0&apos;; return p; } 结果： 1 H 12 Ha 123 Haw 1234 Hawa 12345 Hawai 123456 Hawaii 1234567 Hawaii! 12345678 Hawaii!! 12345678 Hawaii!! 8.4.2 何时使用函数重载函数重载一般使用在：仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。另外，是否可以通过使用默认参数来实现同样的目的。例如，可以用两个重载函数来代替面向字符串的left()函数： char * left(const char * str, unsigned n); char * left(const char * str); 使用一个带默认参数的函数要简单些。只需编写一个函数，程序也只需为一个函数请求内存；需要修改函数时，只需修改一个。然而，如果需要使用不同类型的参数，则默认参数便不管用了，在这种情况下，应使用函数重载。 名称修饰 C++如何跟踪每一个重载函数？它给这些函数指定了秘密身份。使用C++开发工具中的编辑器编写和编译程序时，C++编译器将执行一些神奇的操作–名称修饰或名称矫正，它根据函数原型中指定的形参类型对每个函数名进行加密。请看下述未经修饰的函数原型： long MyFunctionFoo(int, float); 这种格式对于人类来说很合适；我们直到函数接受两个参数，并返回一个long值。而编译器将名称转换为不太好看的内部表示，来描述该接口，如下所示： ？MyfunctionFoo@@YAXH 对原始名称进行的表面看来无意义的修饰将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异。 8.5 函数模板函数模板是通用的函数描述，即它们使用泛型来定义函数。其中的泛型可以具体的类型(如int或double)替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型的方式编写程序，因此有时也称为通用编程。由于类型是用参数表示的，因此模板特性有时也称为参数化类型。 前面，定义了一个交换两个int的值的函数。假设要交换两个double值，则一种方法是复制原来的代码，并用double替换所有的int。如果需要需要交换两个char值，可以再次使用同样的技术。进行这种修改将浪费宝贵时间，且容易出错。 C++的函数模板功能能自动完成这一过程，可以节省时间，而且更可靠。 函数模板允许以任意类型的方式来定义函数。例如，可以这样建立一个交换模板： template &lt;typename AnyType&gt; void Swap(AnyType &amp; a, AnyType &amp;b) { AnyType temp; temp = a; a = b; b = temp; } 第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和type是是必需的，除非可以使用关键字class代替typename。另外，必须使用尖括号。类型名可以任意选择，只要遵守C++命名规则即可。模板不创建任何函数，而只是告诉编译器如何定义函数。需要交换int的函数时，编译器将按模板创建这样的函数，并用int代替AnyType。同样，需要交换double的函数时，编译器将按模板创建这样的函数，并用double代替AnyType。 在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。即，可以如下编写模块定义： template &lt;class AnyType&gt; void Swap(AnyType &amp; a, AnyType &amp;b) { AnyType temp; temp = a; a = b; b = temp; } funtemp.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b); int main() { int i = 10; int j = 20; cout &lt;&lt; &quot;i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; Swap(i, j); cout &lt;&lt; &quot;Now i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; double x = 24.5; double y = 81.4; cout &lt;&lt; &quot;x, y = &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl; Swap(x, y); cout &lt;&lt; &quot;Now x, y = &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl; return 0; } template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp; temp = a; a = b; b = temp; } 结果 i, j = 10, 20 Now i, j = 20, 10 x, y = 24.5, 81.4 Now x, y = 81.4, 24.5 当Swap()函数接受两个int参数，因此编译器生成该函数的int版本。即用int替换所有的int，生成下面的代码： void Swap(int &amp;a, int &amp;b) { int temp; temp = a; a = b; b = temp; } 程序员看不到这些代码，当编译器确实生成并在程序中使用了它们。 注意函数模板不能缩短可执行程序。对于上述程序，最终仍将有两个独立的函数定义，就像以手工的方式定义了这些函数一样最终代码不包含任何模板，而只包含为程序生成的时间函数。 更常见的情形时是，将模板放在头文件中，并在需要使用模板的文件中包含头文件。 8.5.1 重载的模板需要多个对不同类型使用同一种算法的函数时，可使用模板。然而，并非所有的类型都使用相同的算法。为满足这种需求，可以像重载常规函数一样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须相同。例如，上面程序新增了一个交换模板，用于交换两个数组中的元素。 cat twotemps.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b); template &lt;typename T&gt; void Swap(T a[], T b[], int n); void Show(int a[]); const int Lim = 4; int main() { int i = 10, j = 20; cout &lt;&lt; &quot;i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; Swap(i, j); cout &lt;&lt; &quot;Now i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; int d1[Lim] = {0,7,0,4}; int d2[Lim] = {1,9,6,9}; cout &lt;&lt; &quot;Original arrays:\n&quot;; Show(d1); Show(d2); Swap(d1, d2, Lim); cout &lt;&lt; &quot;Swapped arrays:\n&quot;; Show(d1); Show(d2); return 0; } template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp; temp = a; a = b; b = temp; } template &lt;typename T&gt; void Swap(T a[], T b[], int n) { T temp; for (int i = 0; i &lt; n; i++) { temp = a[i]; a[i] = b[i]; b[i] = temp; } } void Show(int a[]) { for (int i = 0; i &lt; Lim; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } 结果： i, j = 10, 20 Now i, j = 20, 10 Original arrays: 0 7 0 4 1 9 6 9 Swapped arrays: 1 9 6 9 0 7 0 4 8.5.2 模板的局限性假设有如下模板函数： template &lt;class T&gt; void f(T a, T b) {} 通常，代码假定可执行哪些操作。例如，下面的代码假定定义了赋值，但如果T是数组，这种假设将不成立: a = b; 同样，下面语句假设定义了&lt;，但如果T为结构，该假设便不成立： if (a &gt; b) 另外，为数组名定义了运算符，但由于数组名为地址，因此它比较的是数组的地址，而这可能不是您所希望的。下面的语句假定为类型T定义了乘法运算，但如果T为数组、指针或结构，这种假设便不成立： T c = a*b; 总之，编写的函数模板很可能无法处理某些类型。另一方面，有时候通用化是有意义的，但C++语法不允许这样左。例如，将两个包含位置坐标的结构相加是有意义的，虽然没有为结构定义运算+。一种解决方案是，C++允许您重载运算符+，以便能够将其用于特定的结构或类。这样使用运算符+的模板便可处理重载了运算符的结构。另一种解决方案是，为特定类型提供具体化的模板定义，接下来介绍。 8.5.3 显示具体化假设定义了如下结构： struct job { char name[40]; double salary; int floor; } 另外，希望能够交换两个这种结构的内容。原来模板使用下面的代码来完成交换： temp= a; a = b; b = temp; 由于C++允许将一个结构赋给另一个结构，因此即使T是一个job结构，上述代码也适用。然而，假设只想交换salary和floor成员，而不交换name成员，则需要使用不同的代码，但Swap()的参数将保持不变，因此无法使用模板重载来提供其他代码。 然而，可以提供一个具体化函数定义–称为显式具体化，其中包含所需的代码。当编译器找到与函数调用的具体化定义时，将使用该定义，而不再寻找模板。 C++标准定义的形式： 1.第三代具体化C++98标准选择了下面的方法： 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板以及它们的重载版本。 显式具体化的原型和定义应以teplate&lt;&gt;开头，并通过名称来指出类型。 具体化优先于常规模板，而非模板函数由于具体化和常规模板。 下面是用于交换job结构的非模板函数、模板函数和具体化的原型： void Swap(job &amp;, job &amp;); template &lt;typename T&gt; void Swap(T &amp;, T &amp;); template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;); //具体化 下面看一看显式具体化的工作方式。 2.显式具体化示例twoswap.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b); struct job { char name[40]; double salary; int floor; }; template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2); void Show(job &amp;j); int main() { cout.precision(2); cout.setf(ios::fixed,ios::floatfield); int i = 10, j = 20; cout &lt;&lt; &quot;i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; Swap(i,j); cout &lt;&lt; &quot;Now, i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; job sue = {&quot;Susan&quot;, 73000.6, 7}; job sidney = {&quot;Sidney&quot;, 78060.7, 9}; cout &lt;&lt; &quot;Before job swapping:\n&quot;; Show(sue); Show(sidney); Swap(sue, sidney); cout &lt;&lt; &quot;After job swapping:\n&quot;; Show(sue); Show(sidney); return 0; } template &lt;typename T&gt; void Swap(T &amp; a, T &amp; b) { T temp; temp = a; a = b; b = temp; } template &lt;&gt; void Swap&lt;job&gt;(job &amp; j1, job &amp; j2) { double t1; t1 = j1.salary; j1.salary = j2.salary; j2.salary = t1; int t2; t2 = j1.floor; j1.floor = j2.floor; j2.floor = t2; } void Show(job &amp;j) { cout &lt;&lt; j.name &lt;&lt; &quot;: $&quot; &lt;&lt; j.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; j.floor &lt;&lt; endl; } 结果： i, j = 10, 20 Now, i, j = 20, 10 Before job swapping: Susan: $73000.60 on floor 7 Sidney: $78060.70 on floor 9 After job swapping: Susan: $78060.70 on floor 9 Sidney: $73000.60 on floor 7 8.5.4 实例化和具体化在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。例如，在上述程序中，函数调用Swap(i,j)导致编译器生成Swap()的一个实例，该实例使用int类型。模板并非函数定义，但使用int的模板实例是函数定义，这种实例化被称为隐式实例化。 最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化。这意味着可以直接命令编译器创建特定的实例，如Swap()。其语法是，声明所需的种类–用&lt;&gt;符号指出类型，并在声明前加上关键字template: template void Swap&lt;int&gt;(int, int); 实现了这种特性的编译器看上上述声明后，将使用Swap()模板生成一个使用int类型的实例。即，该声明的意思是：使用Swap()模板生成int类型的函数定义。 与显式实例化不同的是，显式具体化使用下面两个等价的声明之一： template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;); template &lt;&gt; void Swap(int &amp;, int &amp;); 区别在于，这些声明的意思是：不要使用Swap()模板生成函数定义，而应使用专门为int类型显式地定义的函数定义。这些原型必须有自己的函数定义。显式具体化声明在关键字templat包含&lt;&gt;，而显式实例化没有。 警告： 试图在同一个文件中使用同一种类型的显式实例和显式具体化将出错。 还可以通过在程序中使用函数来创建显式实例化。例如，请看下面代码： templatte &lt;class T&gt; T Add(T a, T b) { return a + b; } int m = 6; double x = 10.2; cout &lt;&lt; Add&lt;double&gt;(x, m) &lt;&lt; endl; 这里的模板与函数调用Add(x,m)不匹配，因为该模板要求两个函数参数的类型相同。但通过使用Add(x,m),可强制为double类型实例化，并将参数m强制转换为double类型，以便与函数Add(double,double)的第二个参数匹配。 如果对Swap()做类型的处理： int m = 5; double x = 14.3; Swap&lt;double&gt;(m, x); 这将为类型double生成一个显式实例化，不幸的是，这些代码不管用，因此的哥形参的类型为double &amp;，不能只想int变量m。 隐式实例化、显式实例化和显式具体化统称为具体化。它们的相同之处在于，它们表示都是使用具体类型的函数定义，而不是通用描述。 引入显式实例化后，必须使用新的语法–在声明中使用前缀template和template&lt;&gt;，以区分显式实例化还是显式具体化。通常，功能越多，语法规则也越多。下面的代码片段中间了这些概念： template &lt;class T&gt; void Swap(T &amp;a , T &amp;b); template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;);//显式具体化 int main() { template void Swap&lt;char&gt;(char &amp;, char &amp;); //显式实例化 short a, b; Swap(a, b); //隐私实例化 job n, m; Swap(n, m); //使用显式具体化 char g, h; Swap(g, h); //使用显式实例化 } 编译器看到char的显式实例化后，将使用模板定义来生成Swap()的char版本。对于其他Swap()调用，编译器根据函数调用中实际使用的参数，生成相应的版本。例如，当编译器看淡函数调用Swap(a,b) 后，将生成Swap(a,b)的short版本，因为两个参数的类型都是short。当编译器看到Swap(n,m)后，将使用short类型提供的独立定义(显式具体化)。当编译器看到Swap(g,h)后，将使用处理显式实例化时生成的模板具体化。 8.5.5 编译器选择使用哪个函数版本对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数的定义，尤其是有多个参数时。这个过程称为重载解析。大致了解一下这个过程是如何进行的： 第一步：创建候选函数列表。其中包含于被调用函数的名称相同的函数和函数模板。 第二步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为doule，从而与doule形参匹配，而模板可以为float生成一个实例。 第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。 考虑只有一个函数参数的情况，如下面的调用： may(&apos;B&apos;); 首先，编译器将寻找候选者，即名称为may()的函数和函数模板。然后，寻找那些可以用一个参数调用的函数。例如，下面的函数符合要求，因为其名称和被调用的函数函数相同，且可只给它传递一个参数： void may(int); #1 float may(flaot, flaot = 3); #2 void may(char); #3 char * myay(const char *); #4 char may (const char &amp;); #5 template &lt;class T&gt; void may(const T &amp;); #6 template &lt;class T&gt; void may(T *); #7 注意，只考虑特征标，而不考虑返回类型。其中的两个函数(#4和#7)不可行，因为整型类型不能被隐式地转换（即没有显式强制类型转换）为指针类型。剩余的一个模板可用来生成具体化，其中T被替换为char类型。这样剩余5个可行的函数，其中的每一个函数，如果它式声明唯一一个函数，都可以被使用。 接下来，编译器必须确定哪个可行函数是最佳的。它查看为使函数调用参数与可行的候选函数的参数匹配所需进行的转换。通过从最佳到最差的顺序如下所述： 完全匹配，但常规函数优先于模板。 提升转换（例如，char和short自动转换为int, float自动转换为double）。 标准转换（例如，int转换为char，long转换为double）. 用户定义的转换，如类声明中定义的转换。 例如，函数#1优先于函数#2，因为char到int的转换为提升转换，而char到float的转换是标准转换。函数#3、函数#5和函数#6都优先于函数#1和#2，因为它们都是完全匹配的。#3和#5优先于#6，因为#6是函数模板。如果两个函数(如#3和#5)都完全匹配，将如何办？通常，有两个函数完全匹配是一种错误，但这一规则有两个例外。下面，深入探讨这一点： 1. 完全匹配和最佳匹配完全匹配允许的无关紧要的转换： 从实参 到形参 Type Type &amp; Type &amp; Type Type [] Type $\ast$ Type (argument-list) Type ($\ast$)(argument-list) Type const Type Type volatile Type Type $\ast$ const Type Type $\ast$ volatile Type $\ast$ Type表示任意类型，例如int实参与int &amp;形参完全匹配。Type(argument-list)意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的。volatile下一章介绍。 假设有下面的函数代码： struct blot {int a, char b[10]}; blot ink{25, &quot;spots&quot;}; recycle(ink); 在这种情况下，下面的原型都是完全匹配的： void recycle(blot); #1 void recycle(const blot); #2 void recycle(blot &amp;); #3 void recycle(const blot &amp;); #4 正如预期的，如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译程将生成一条错误消息，该消息可能会使用诸如“ambiguous(二义性)”这样的词语。 然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。即，在recycle()示例中，如果只定义了函数#3和#4是完全匹配的，则将选择#3，因为int没有被声明为const。然而，const和非const之间的区别只适用于指针和引用指向的数据。即，如果只定义了#1和#2，则将出现二义性。 一个完全匹配优先于另一个的另一种情况是，其中一个是非模板函数，而另一个不是。在这种情况下，非模板函数将优先于模板函数（包括显式具体化）。 如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如，这意味着显式具体化将优先于使用模板隐式生成的具体化： struct blot {int a; char b[10]}; template &lt;class Type&gt; void recycle(Type t); template &lt;&gt; void recycle&lt;blot&gt; (blot &amp; t); blot ink = {25, &quot;spots&quot;}; recycle(int); 术语“最具体”并不一定意味显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。例如，请看下面两个模板： template &lt;class Type&gt; void recycle(Type t); #1 template &lt;class Type&gt; void recyclle(Type * t); #2 recycle(&amp;ink); recyele(&amp;ink)调用与#1模板匹配，匹配时间Type解释为blot $\ast$。recycle(&amp;ink)函数调用也与#2模板匹配，这样Type被解释为blot。因此两个隐式实例–recycle&lt;blot$\ast$&gt;(blot$\ast$)和recycle(bloat$\ast$)发送到可行函数池中。 在这两个模板函数中，recycle&lt;blot$\ast$&gt;(blot$\ast$)被认为是更具体地，因为在生成过程中，它需要进行地转换更少。即，#2模板已经显式指出，函数参数是指向Type的指针，因为出可以直接用blot标识Type；而#1模板见Type作为函数参数，因此Type必须被解释为指向blot的指针。即，在#2模板中，Type已经被具体化为指针，因为说它“更具体”。 2. 部分排序规则实例下述程序有两个用来显式数组内容的模板定义。第一个定义（模板A）假设作为参数传递的数组中包含了要显式地数据；第二个定义（模板B）假设数组元素为指针，指向要显示地数据。 temptempover.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void ShowArray(T arr[], int n); template &lt;typename T&gt; void ShowArray(T * arr[], int n); struct debts { char name[30]; double amount; }; int main() { int things[6] = {13, 31, 103, 301, 310, 130}; struct debts mr_E[3] = { {&quot;Volfe&quot;, 2400.0}, {&quot;Foxe&quot;, 1300.0}, {&quot;Stout&quot;, 1800.0} }; double *pd[3];//3个指针组成的数组 for (int i = 0; i &lt; 3; i++) pd[i] = &amp;mr_E[i].amount; cout &lt;&lt; &quot;Listing Mr. E&apos;s counts of things:\n&quot;; ShowArray(things, 6); cout &lt;&lt; &quot;Listing Mr. E&apos;s debts:\n&quot;; ShowArray(pd, 3); return 0; } template &lt;typename T&gt; void ShowArray (T arr[], int n) { cout &lt;&lt; &quot;Template A\n&quot;; for (int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; } template &lt;typename T&gt; void ShowArray(T * arr[], int n) { cout &lt;&lt; &quot;Template B\n&quot;; for (int i = 0; i &lt; n; i++) cout &lt;&lt; *arr[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; } 结果 Listing Mr. E&apos;s counts of things: Template A 13 31 103 301 310 130 Listing Mr. E&apos;s debts: Template B 2400 1300 1800 标识符things是一个int数组的名称，因为与下面的模板匹配： template &lt;typename T&gt; #模板A void ShowArray(T arr[], int n); pd是一个doulbe $\ast$数组的名称，这与下面的模板匹配： template &lt;typename T&gt; #模板B void ShowArray(T * arr[], int n); 如果将模板B删除，则编译器将使用模板A来显示pd内容，因此显示的将是地址，而不是值。 简而言之，重载解析将寻找最匹配的函数。如果只存在一个这样的函数，则选择它；如果存在多个这样的函数，但其中只有一个是非模板函数，则选择该函数；如果存在多个适合的函数，且它们都为模板函数，但其中有一个函数比其他函数具体，则选择该函数。如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数具体，则函数调用将不是确定的，因此是错误；当然，如果不存在匹配函数，则也是错误。 3. 创建自定义选择在有些情况下，可通过编写合适的函数的调用，引导编译器做出您希望的选择。下面程序，将模板函数定义放在文件开头，从而无需提供模板原型。与常规函数一样，通过在使用函数前提供模板函数定义，让他充当原型。 choices.cpp #include &lt;iostream&gt; using namespace std; template &lt;class T&gt; //#1 T lesser(T a, T b) { return a &lt; b ? a : b; } int lesser (int a, int b) //#2 { a = a &lt; 0 ? -a : a; b = b &lt; 0 ? -b : b; return a &lt; b ? a : b; } int main() { int m = 20; int n = -30; double x = 15.5; double y = 25.9; cout &lt;&lt; lesser(m, n) &lt;&lt; endl; //使用#2 cout &lt;&lt; lesser(x, y) &lt;&lt; endl; //使用#1 cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl; //使用#1 cout &lt;&lt; lesser&lt;int&gt;(x, y) &lt;&lt; endl;//使用#1 return 0; } 结果 20 15.5 -30 15 上述程序提供了一个模板和一个标准函数，其中模板返回两个值较小的一个，而标准函数返回两个值绝对值较小的那个。如果函数定义是在使用函数前提供的，它将充当原型，因此这个示例无需提供原型 lesser&lt;&gt;(m, n); &lt;&gt;指出，编译器应选择模板，而不是非模板函数；编译器注意到实参的类型为int，因此使用int替代T对模板进行示例化。 最后，lesser(x, y)这条语句要求进行显示实例化，将使用显示实例化得到的函数。x和y的值将被强制转换为int，该函数返回一个int值 4.多个参数的函数将有多个参数的函数调用与有多个参数的原型进行匹配时，情况将非常复杂。编译器必须考虑所有参数的匹配情况。如果找到比其他可行函数都合适的函数，则选择该函数。一个函数要比其他函数都合适，其所有参数的匹配程度都必须不必其他函数差，同时至少有一个参数的匹配程度比其他函数都高。 8.5.6 模板函数的发展在C++发展的早期，大多数人都没有想到模板函数和模板类会有这么强大而有用。 1.是什么类型在C++98中，编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型。如下： template &lt;class T1, class T2&gt; void ft(T1 x, T2 y) { ?type? xpy = x + y; ... } xpy应为什么类型。由于不知道ft()将如何使用，因此无法预先知道这一点。正确的类型可能是T1、T2或其他类型。例如，T1可能是double，而T2可能是int，在这种情况下，两个变量的和将为double类型。T1可能是short，而T2可能是int，在这种情况下，两个变量的和为int。T1还可能是short，而T2可能是char，在这种情况下，加法运算将导致自动整型提升，因此结果类型为int。另外，结构和类可能重载运算符+，这导致问题更加复杂。 2.关键字decltype(C++11)C++11新增的关键字decltype提供了解决方案，可这样使用该关键字： int x; decltype(x) y; //是y的类型跟x相同 给decltype提供的参数可以是表达式，因此在前面的模板函数ft()中，可使用下面的代码： decltype(x + y) xpy; xpy = x + y; 另一种方法是，将这两条语句合二为一： decltype(x + y) xpy = x + y; decltype比这些示例演示的更复杂些。为确定类型，编译器必须遍历一个核对表。假设有如下声明： decltype(expression) var; 则核对表的简化版如下： 第一步：如果expression是一个没有用括号括起来的标识符，则var的类型与该标识符的类型相同，包括const等限定符： double x = 5.5; double y = 7.9; double &amp;rx = x; const double * pd; decltype(x) w; dexltype(rx) u = y; decltype(pd) v; 第二步：如果expression是一个函数调用，则var的类型与函数的返回类型相同： long indeed(int); decltype(indeed(3)) m; 注意：并不会实际调用函数，编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。 第三步： 如果expression是一个左值，则var为指向其类型的引用。这好像意味着前面的w应为引用类型，因为x是一个左值。但别忘了，这种情况已经在第一步处理过了。要进入第三步，expression不能是用未用括号括起来的标识。那么，expression是用括号括起来的标识符： double xx = 4.4; decltype((xx)) r2 = x; //r2是doule &amp; 类型 decltype(xx) w = x; //w是double类型 顺便说一句，括号并不会改变表达式的值和左值性。例如下面两条语句等效： xx = 98.6; (xx) = 98.6; 第四步：如果前面的条件都不满足，则var的类型与expresssion类型相同： int j = 3; int &amp;k = j; int &amp;n = j; decltype(j+6) i1; //i1为int decltype(100L) i2; //i2为long decltype(k+n) i3; //i3为int 请注意，虽然n和k都是引用，但表达式k+n不是引用，它是两个int的和，因此类型为int。 如果需要多次声明，可结合typedef和decltyep: template &lt;class T1, class T2&gt; void ft(T1 x, T2 y) { typedef decltype(x + y) xytype; xytype xpy = x + y; xytype arr[10]; xytyep &amp; rxy = arr[2]; ... } 3. 另一种函数声明的语法（C++后置返回类型）另一个相关的问题是decltype本身无法解决的。如下不完整的模板函数： template &lt;class T1, class T2&gt; ?type? t(T1 x, T2 y) { ... return x + y; } 同样，无法预先知道x和y相加得到的类型。好像可以将返回类型设置为decltype(x+y)。但不幸的是，此时还未声明参数x和y，它们不在作用域内。必须在声明参数后使用decltype。为此，C++新增了一种声明和定义函数的语法。下面使用内置类型来说明这种语法的工作原理。对于下面的原型： double h(int x, float y); 使用新增的语法可编写成这样： auto h (int x, float y) -&gt; double; 这将返回类型移动到参数声明后面。-&gt;double被称为后置返回类型。其中auto是一个占位符，表示后置返回类型提供的类型。这是C++新增给auto的一种角色。这样语法可以用于函数定义： auto h(int x, float y) -&gt; double {...} 通过结合使用这种语法和decltype，便可给出gt()指定返回类型，如下： template&lt;class T1, class T2&gt; auto gt(T1 x, T2 y) -&gt; decltype(x + y) { return x + y; } 现在decltype在参数声明后面，因此x和y位于作用域内。 8.6 总结函数 引用变量： &amp; k 默认参数 重载 模板 模板重载]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软面试题目--字母易位词]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%BE%AE%E8%BD%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE--%E5%AD%97%E6%AF%8D%E6%98%93%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目两个单词如果包含相同的字母，次序不同，则称为字母易位词(anagram)。例如，“silent”和“listen”是字母易位词，而“apple”和“aplee”不是易位词。请定义函数检查两个单词是否是字母易位词。可以假设两个单词字母均为小写。要求算法复杂度尽量低。 1. 方法一思路首先，最基本的思路，便是检测字符串s1中的字符是否都出现在s2中（在s1和s2长度一样的前提下）。为了解决“apple”和“aplee”不是易位词的这种情况，不能仅仅判断出现在s2中就可以了，还需要做个标记。这里可以考虑将字符串转换为list，对于比较过的便设置为None。算法代码设计如下： 代码def anagram(s1, s2): if len(s1) != len(s2): return false alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(s2) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 += 1 if found: alist[pos2] = None #匹配一个字符除掉该字符，防止apple和aplee这种类型匹配 else: stillOK = False break pos1 += 1 return stillOK if __name__ == &quot;__main__&quot;: print(anagram(&quot;apple&quot;,&quot;aplee&quot;)) 让我们考虑一下算法复杂度。可以从字符串s2来考虑，对于s2中的每个元素，s1都会从头开始进行遍历一次，所以算法的复杂度为： 即算法的复杂度为O(n^2)。 2.方法二思路母易位词即为各个字母的数目相同，而顺序不一致。因而，如果对字符串按照字母顺序排序后，那么两个字符串应该完全一致。这样算法复杂度是否更低？ 代码def anagram(s1, s2): if len(s1) != len(s2): return False alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 while pos &lt; len(s1): if alist1[pos] == alist2[pos]: pos += 1 else: return False return True if __name__ == &quot;__main__&quot;: print(anagram(&quot;badc&quot;,&quot;abcd&quot;)) 这样算法复杂度是否是O(n)了呢？因为仅仅进行了n次比较啊。当然不是，为什么呢？因为事先先对两个字符串进行了排序，而排序的复杂度并未计入。所以，此种算法的复杂度即为O(nlogn+n)，为O(nlogn)。复杂度比方法一的复杂度降低了。 3.方法三思路从另外一个角度思考，字母一共有多少个？很明显，只有26个（只考虑小写字母）。那么，我们可以为字符串s1和s2分别设置26个计数器，然后判断这对应位置的计数是否相等，如果对应计数完全相等，则为字母易位词。 代码def anagram(s1, s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i]) - ord(&apos;a&apos;) c1[pos] += 1 for i in range(len(s2)): pos = ord(s2[i]) - ord(&apos;a&apos;) c2[pos] += 1 j = 0 while j &lt; 26: if c1[j] == c2[j]: j += 1 else: return False return True if __name__ == &quot;__main__&quot;: print(anagram(&quot;badc&quot;,&quot;abcd&quot;)) 附件： &apos;&apos;&apos;两个单词如果包含相同的字母，次序不同，则称为字母易位词(anagram)。 例如，“silent”和“listen”是字母易位词，而“apple”和“aplee”不是 易位词。请定义函数检查两个单词是否是字母易位词。可以假设两个单词字母 均为小写。要求算法复杂度尽量低。&apos;&apos;&apos; #方法一 &apos;&apos;&apos;def anagram(s1, s2): if len(s1) != len(s2): return false alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(s2) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 += 1 if found: alist[pos2] = None #匹配一个字符除掉该字符，防止apple和aplee这种类型匹配 else: stillOK = False break pos1 += 1 return stillOK&apos;&apos;&apos; #方法二 &apos;&apos;&apos;def anagram(s1, s2): if len(s1) != len(s2): return False alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 while pos &lt; len(s1): if alist1[pos] == alist2[pos]: pos += 1 else: return False return True&apos;&apos;&apos; #方法三 def anagram(s1, s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i]) - ord(&apos;a&apos;) c1[pos] += 1 for i in range(len(s2)): pos = ord(s2[i]) - ord(&apos;a&apos;) c2[pos] += 1 j = 0 while j &lt; 26: if c1[j] == c2[j]: j += 1 else: return False return True if __name__ == &quot;__main__&quot;: print(anagram(&quot;badc&quot;,&quot;abcd&quot;)) 转自: https://mp.weixin.qq.com/s/v_186DNtc2w3JfAY0Yj9_Q]]></content>
      <tags>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别(二)--感知器算法]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[感知器算法 原理 python实现import numpy as np def Perception(x,w,c): count = 1#记录训练失败的样本数量 k = 0#迭代计数 while count:#记录训练失败的样本数量为0，则循环结束 count = 0 for i in range(np.shape(x)[0]): temp = sum(w*x[i][:])#计算W^T(k)X k += 1 if temp &lt;= 0: #如果W^T(k)X&lt;=0，更新权重，如果W^T(k)X&gt;0，权重不变 w = w + c*x[i][:]#更新权重 count += 1 #利用count来判断所有训练都得到了正确的分类结果， #count=0,所有W^T(k)X&gt;0,即得到所有训练都得到了正确的分类节 print(&apos;#&apos;,c,&apos; k=&apos;,k)#输出迭代次数 return w if __name__ == &quot;__main__&quot;: x =np.array([[0,0,0,1],[1,0,0,1],[1,0,1,1],[1,1,0,1], [0,0,-1,-1],[0,-1,-1,-1],[0,-1,0,-1],[-1,-1,-1,-1]])#写成增广矩阵形式 w = np.array([-1,-2,-2,0])#权重向量 #c = 1#校正增量系数 #p = Perception(x,w,c) #print(p) for c in range(1,101): p = Perception(x,w,c) print(p)]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式机器学习框架--参数服务器]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6--%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在大规模数据上跑机器学习任务是过去十多年内系统架构师面临的主要挑战之一，许多模型和抽象先后用于这一任务。 参数服务器的概念最早来自Alex Smola于2010年提出的并行LDA的框架[4]。它通过采用一个分布式的Memcached作为存放参数的存储，这样就提供了有效的机制用于在分布式系统不同的Worker节点之间同步模型参数，而每个Worker只需要保存它计算时所依赖的一小部分参数即可。当然，这里存放参数的存储跟做OLTP应用中的Key-Value抽象有所不同，因为以Key-Value为单元进行频繁的参数数据交互会导致过高的通信开销，因此参数服务器通常采用数学封装来进行参数同步，比如向量，张量，矩阵的行列等。 上图的sampler是并行LDA里的组件，可类比为通用参数服务器框架里的计算单元。Smola提出的模型是最早的参数服务器抽象，随后出现了许多改进，最出名的应当是Google的跨界高人Jeff Dean 2012年进一步提出了第一代Google大脑的解决方案DistBelief[5]，主要用于超大规模深度学习网络的训练。DistBelief将巨大的深度学习模型分布存储在全局的参数服务器中，计算节点通过参数服务器进行信息传递，很好地解决了SGD和L-BFGS算法的分布式训练问题。由于SGD和L-BFGS是机器学习的普遍性优化问题，因此尽管DistBelief是作为深度学习的系统框架而提出，但DistBelief的核心结构却可以应用到多种普通机器学习手段中。相比最早的参数服务器模型，DistBelief把该模型扩展成为更加通用和灵活的框架，豆瓣的Paracel[3]正是参考DistBelief的直接实现，先来看看Paracel和DistBelief模型： 图中是分布式异步SGD架构流程图，运行时，需要把训练数据分为多个子集，然后在每个子集上运行模型的多个副本，模型通过集中式的参数服务器通信，参数服务器存放了模型的全部参数和状态。异步体现在两方面：模型的副本独立运行；参数服务器的分片也各自独立运行。DistBelief没有过多谈论系统实现，从Paracel里我们可以看到具体的工程实现：总体上Paracel实现非常简单，参数服务器直接采用内存hashtable，并封装了对分网络，图，稀疏矩阵，稠密矩阵等数据格式用于参数同步。Paracel解决的另一问题是straggler问题：由于一些软硬件的原因，节点的计算能力往往不尽相同。对于迭代问题来说，每一轮结束时算得快的节点都需等待算得慢的节点算完，再进行下一轮迭代。这种等待在节点数增多时将变得尤为明显，从而拖慢整体的性能。Paracel放宽了“每个迭代步都等待”这个约束：当在一轮迭代结束时，算得快的节点可以继续下一轮迭代，但不能比最慢的节点领先参数s个迭代步。当领先超过s个迭代步，Paracel才会强制进行等待。这样异步的控制方式既从整体上省去了等待时间，也能间接地帮助慢的节点赶上。从优化问题的角度来看，虽然单迭代步收敛得慢了，然而每个迭代步的时间开销变少了，总体上收敛也就变快了。这种做法又叫Staleness Synchronous Parallel (SSP)，基本思想是允许各机器以不同步调对模型进行更新，但是加一个限制，使得最快的机器的进度和最慢机器的进度之差不要太大。这样做的好处是：既减轻慢的机器拖整个系统的后腿，又能保证模型的最终收敛。 SSP是由CMU Eric Xing的Petuum项目组提出的[6]，Paracel引入SSP使得豆瓣的参数服务器方案工程上更加成熟，在Paracel内部，SSP的等待通过调用MPI来实现。关于一致性收敛和Petuum，在下边还会有介绍。关于参数服务器，另一个重要的方面是容错设计。在几十台机器的集群上运行，这也许并不是一个问题，但是如果在有上千台机器的集群上运行任务，节点发生任务失败的概率就会大很多，如果缺乏容错设计，就会导致任务重启，从而浪费大量时间。不过，在Paracel的代码里并没有找到相关的处理逻辑，通常容错处理需要借助于Checkpoint来做快照，这样任务重启时无需从头进行，比如DistBelief就是这样处理。跟豆瓣的工程师咨询后已经确认，在开源版本的Paracel里确实还没有相关设计。 上面讲述了不少参数服务器的背景和系统结构，那么为什么参数服务器能够具备更好的性能呢？仍以SGD为例说明：在传统同步SGD中，如果一台机器失效，整个训练过程将会延时；但是对于异步SGD来讲，如果某个模型副本的一台机器失效，其他模型副本仍然继续处理样本并更新参数服务器中的模型参数，因此异步SGD具备更好的鲁棒性。此外，多种异步处理形式给最优化过程带来进一步的随机性：模型实例最可能是使用一个稍微过时的参数来计算梯度，因为这时其他的副本可能已经更新了参数服务器上的参数。除此之外还有其他随机的来源，因为参数服务器组的每台机器是行为独立的，所以无法保证在给定时间点上，每个节点的参数被更新的次数相同，或者以同样的顺序被更新。更进一步，因为模型副本使用不同的线程来获取参数和推送梯度值，故在同一时间戳上，单个副本内的参数将有额外的稍微不一致的现象。尽管对于非凸问题的这些操作的安全性缺乏理论基础，但是在实践中，这种放松一致性要求的做法是相当有效的。传统同步SGD的最优化过程，每次迭代选取的方向是由全部训练数据决定，或者由随机选定的一小部分训练集指定(mini-batch)。而异步的做法由于上述更多的随机性则会同时在很多方向上由不同的mini-batch选定不同梯度方向，这就好比整个最优化过程是以一个区域为单位进行的，而区域内的点代表不同SGD的过程，因此这种并行化的工作会带来性能上的提升。 介绍另外一个重要项目，来自Alex Smola的高徒——李沐设计的参数服务器[7]。这个项目在早期拥有一个独立域名http://parameterserver.org，后来因为李沐和陈天奇等国内英才成立的DMLC深度学习项目组，之前的项目也进行了重构因此转移到[7]所在的地址，而项目的背景介绍则在[8]和[9]。从架构上来说，ps-lite跟Paracel并没有什么不同，作为参数服务器，都需要一个全局分布式的key-value用来存储算法的模型或参数。当计算节点需要某个参数的时候，可以从参数服务器上读取。用户可定义不同的函数在参数服务器端对参数进行更新、过滤等操作。在大部分情况下，计算节点之间的通信都是通过参数服务器进行。 ps-lite应当属于第三代参数服务器，就是提供了更加通用的设计，在架构上包含一个Server Group和若干个Worker Group： Server Group用来做参数服务器，每个Server Node存放一个参数分片，由Server Manager管理整个Server Group，维持整个Server Group的元数据的一致性视图，以及参数分片情况。 每个Worker Group运行一个应用，Worker Node只跟Server Node通信用来更新参数，Worker Node之间没有任何交互。每个Worker Group内有一个调度器，负责给Worker Nodes分配任务以及监控，如果有Worker Node挂掉或者新加入，调度器负责重新调度剩余的任务。 跟Paracel不同，ps-lite提供了多种数据一致性选择： Sequential：这种情况下，所有任务顺序进行，因此数据严格一致，不会出现不同副本看到的数据有不同的情况，因此实际上跟前文介绍的BSP是等价的。 Eventual：这种情况下，所有任务并行执行，因此拥有最大的随机性。Eventual只适用于对于数据一致没有要求，非常健壮的算法，比如SGD。 Bounded Delay：每个任务需要设置最大超时时间，在该时间之前如果有任务未结束，那么新任务将会等待。Bounded Delay类似于上面的SSP，只不过这是用时间而SSP则是用迭代次数。 转自：http://chuansong.me/n/2161528]]></content>
      <tags>
        <tag>分布式机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(四)--网络层]]></title>
    <url>%2F2018%2F10%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E5%9B%9B)--%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络层 4.1 网络层提供的两种服务借助于电信网的成功经验，让网络复杂可靠交付。电信网使用昂贵的程控交换机，用面向链接的通信方式，使电信网络能够向用户(实际上使电话机)提供可靠传输的服务。计算机网络也应该模仿打电话所使用的面向连接的通信方式。当计算机进行通信时，也应当先建立连接(但在分组交换中使建立一条虚电路VC)以保证双方通信所需的一切网络资源。然后，双方就沿着已建立的虚电路发送分组。这样的分组首部不需要填写完整的目的主机地址，而只需要填写这条虚电路的编号(一个不大的整数)，因而减少了分组的开销。这种通信方式如果再使用可靠传输的网络协议，就可使所发的分组无差错按序到达终点，当然也不会丢失、不重复。在通信结束以后释放虚电路。具体如下图： 计算机网络的端系统是有智能的计算机，计算机有很强的差错处理能力，因此，因特网在设计上就采用了和电信网完全不同的思路。 这种思路就是：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络在发送分组时不需要先建立连接。每一个分组独立发送，所传送的分组可能出错、丢失、重复和失序，当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这种网络中的路由器比较简单，价格低廉。如果主机中的进程之间的通信需要是可靠的，那么就由路由网络的主机中的运输层负责（包括差错处理、流量控制）。如下图： 4.2 网际IP协议网际协议IP是TCP/IP体系中两个主要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套使用的还有三个协议： 地址解析协议ARP 网际空值报文协议ICMP 网际组管理协议IGMP 还有一个协议叫做逆地址解析协议RARP，是和ARP协议配合使用的，但现在已被淘汰不使用了。 下图画出了这三个协议和网际协议IP的关系。在这一层中，ARP画在最下面，因为IP经常要使用这个协议。ICMP和IGMP画在这一层的上部，因为它们要使用IP协议。这三个协议后面陆续介绍。由于网际协议IP是用来使互联起来的许多计算机网络能够进行通信，因此TCP/IP体系中的网络层常常称为网际层或IP。 4.2.1 虚拟互连网络]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格理论与密码学--格基约减算法与实现（四）]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6--%E6%A0%BC%E5%9F%BA%E7%BA%A6%E5%87%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二维格中的高斯约减算法，以及著名的LLL算法，该算法能够解决某些维数较低的格中的SVP问题和CVP问题。三随着格维数的增高，该算法的运行效果也随之减弱，以至于对高维度的格来说，即使LLL算法，也无法很好地解决SVP和CVP问题。所以大多数基于格理论的密码系统的安全性，都依赖于LLL算法以及其他格基约减算法能否高效解决apprSVP和apprCVP问题的困难性。 4.1 二维格中的高斯格基约减算法高斯提出了如何在二维格中找出一组优质基的算法，这个算法的根本思想是：从一个基向量中交替减去另一个基向量的倍数，直到再没有更好的改进为止。没有更好的改进，就是没事算法中的一个特定的条件要求。 给定一个二维格$L \subset R^2$，它的一组基向量为$v_1$和$v_2$，并假设$||v_1|| &lt; ||v_2||$。这个条件很容易实现，因为即使不能够直接满足上述条件，只需要将$v_2$和$v_2$交换位置即可。然后通过从向量$v_2$中减去$v_1$的倍数来达到减少$v_2$的目的。若可以从$v_2$中减去$v_1$任意倍数，则可以利用如下式中的$v^{\ast}_2$来代替$v_2$: $v_2^{\ast} = v_2 - \frac{v_1 \cdot v_2}{||v1||^2} v_1$ 由上式可以看出，向量$v^{\ast}_2$和向量$v_1$是正交的，并且向量$v^{\ast}_2$就是$v_2$在$v_1$证据补上的投影，如下图： 但上述做法在实际中并不可行，因为通过上式计算出来的向量$v^{\ast}_2$很可能根本不在格$L$中。所以，在实际应用中只允许从向量$v_2$中减去$v_1$的整数倍。为了达到跟上式相近的结果，利用下式的向量来取代$v_2$: $v_2 - m v_1, m = \lceil \frac{v_1 \cdot v_2}{||v1||^2} \rceil$ 如果$v_2$仍旧比$v_1$长，那么算法结束；否则，交换向量$v_1$和$v_2$，然后重复上述过程。高斯证明了这个过程可以在有限步后结束，并且最终的基向量具有良好的正交性质。算法4.1对上述程序给出了严格的描述。 更准确地说，当这个算法终止的时候，向量$v_1$就是格$L$中最短的非零向量。因此算法4.1很好地解决了SVP问题。 例4.1 4.2 LLL格基约减算法及其衍生和变形4.2.1 LLL格基约减算法高斯格基约算法给出了一个在二维格中找到最短非零向量的有效方法。但是这个方法具有一定的局限性，因为随着格维数的增加，寻找最短向量也变得越来越困难。1982年，Lenstra、Lenstra和Lovasz提出了著名的LLL算法。该算法思想源于Lagrange、Gauss、Hermite、Korkine-Zolotareff等的二次型理论及Minkovski的数的几何理论。 给定格$L$的一组基$\lbrace v_1,\dots, v_n\rbrace$，然后对他进行约减。约减的主要目的是将这组任意给定的基转化为一组正交性较好的优质基，并使得这个优质基中的各个向量尽量短。即，首先要得到能够通过算法找到的最短向量，然后，找到比这个最短向量稍长一点的向量，依次类推，直到最后找到这组基中的最后一个向量为止。或者，要使得在这个优质基中的向量之间具有相当好的正交性，即两个向量的点乘$v_i \cdot v_j$尽可能地接近零。 根据Hadamard不等式能够得到： $delL = vol(F) \leq ||v_1||||v_2||\dots||v_n||$]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格理论与密码学--格的定义与相关性质（三）]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6--%E6%A0%BC%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[格中计算性难题 3.2 格中的计算性难题与格相关的基本计算性难题有： 在格中寻找最短的非零向量（最短向量问题SVP） 在格中寻找与指定非格向量最为接近的向量（最近向量问题CVP） 首先介绍两个最基本的格难题： 最短向量问题(SVP): 在格$L$中寻找一个最短的非零向量，基寻找一个非零向量$v \in L$，使它的欧几里得范数$||v||$最小。 最近向量问题(CVP): 给定一个不在格$L$中的向量$w \in R^m$，寻找一个向量$v \in L$，使它最接近$w$，即寻找一个向量$v \in L$，使欧几里得范数$||w-v||$最小。 注意： 在格中可能存在不止一个最短的非零向量。例如，在$Z^2$中，$(0,\pm1)$和$(\pm,0)$这四个向量都是SVP解。这种情形适用于CVP。 CVP和SVP这一类问题都属于非常深奥的难题。随着格的维度$n$的增加，它们在计算上也越来越难解。另外，即使是对SVP和CVP的近似解，在理论和应用数学的诸多领域都有着惊人的应用。一般来说，CVP被认为是NP难问题，SVP在特定的“随机规约假设”下也被认为是NP难问题。 在实际应用中，用到了一些很重要的SVP和CVP的变形形式，如下： 最短基问题(SBP)：寻找格的一个基$v_1,v_2,\dots,v_n$，使它 在某些情况下最短。例如，可能需要使下式最小： $max_{i \leq i \leq n}||v_i||$ 或 $\sum_{i=1}^n||v_i||^2$ 因此，可能有许多版本的SBP，这取决于如何定义基的“大小”。 近似最短向量问题(apprSVP)：设$\Psi (n)$是$n$的一个函数。在$n$维格$L$中，寻找一个非零向量，使其不大于最短非零向量的$\Psi (n)$倍。即，如果$v_{最短}$是$L$的最短非零向量，那么寻找一个非零向量$v \in L$，使其满足： $||v|| \leq \Psi (n) ||v_{最短}||$ 不同的函数$\Psi(n)$可以形成不同版本的apprSVP。比如，如要求设计一个算法，用于寻找非零的向量$v \in L$，满足： $||v|| \leq 3 \sqrt{n}||v_{最短}||$ 或 $||v|| \leq 2^{n/2}||v_{最短}||$ 很明显，前者的算法比后者要强，但如果格的维度不大，即使对后者的解也可能是非常有用的。 近似最近向量问题(apprCVP)。这和apprSVP类似，只不过要找的是对CVP的近似解。]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--函数(C++的编程模块)（七）]]></title>
    <url>%2F2018%2F10%2F04%2FC%2B%2B%20Primer%20Plus--%E5%87%BD%E6%95%B0(C%2B%2B%E7%9A%84%E5%8F%98%E6%88%90%E6%A8%A1%E5%9D%97)%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数 7.1 复习函数的基本知识使用C++函数，必须完成的工作： 提供函数定义 提供函数原型 调用函数 库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数。 7.1 定义函数可以将函数分成两类：没有返回值的函数和有返回值的函数。没有返回值的函数称为void函数，其通用格式如下： void functionName(parameterList) { statement return ; } 其中，parameterList指定了传递给函数的参数类型和数量。可选的返回语句标记了函数的结尾；否则函数将在右花括号处结束。void类型的函数，通常用来执行某种操作。比如，打印执行文字n次： void cheers(int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; &quot;cheers&quot; &lt;&lt; endl; } 参数列表int n 意味着调用函数cheers()时，应将一个int值作为参数传递给它。 有返回值的函数将生成一个值，并将它返回给调用函数。通用格式如下： typeName functionName(parameterList) { statement return value; } 有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量，也可以是表达式，只是其结果的类型必须为typeName类型或可以被转换为typeName（比如，如果声明的返回类型为double,而函数返回一个int表达式，则该int值被强制转换为double）。 C++对返回值的类型有一定的限制：不能是数组，但可以是其他任何类型—整型、浮点数、指针，甚至可以是结构和对象。虽然C++函数不能之间返回数组，但可以将数组作为结构或对象组成部分来返回。 函数如何返回值：函数通过将返回值复制到指定CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。 函数包含多条返回语句： int bigger (int a, int b) { if (a &gt; b) return a; else //else可以省略，程序意图未变 return b; } 7.1.2 函数原型和函数调用1.函数原型必要性原型描述了函数到编译器的接口，即，它将函数返回值的类型以及参数的类型和数量告诉编译器。比如，函数调用： double volume = cube(side); 首先，原型告诉编译器，cube()有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放在执行位置–可能是CPU寄存器，也可能是内存。然后，调用，调用函数将从这个位置取得这个返回值。由于原型指出了cube()的类型为double，因此编译器知道检索多少个自己以及如何解释它们。 编译器需要原型，难道它就不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高。编译器在搜索文件的剩余部分时，必须停止对mian()的编译。一个更严重的问题时，函数甚至可能并不在文件中。C++允许将一个程序放在多个文件中，单独编译这些文件，然后组合起来。这种情况下，编译器在编译mian()时，可能无权访问函数代码。 2. 原型的语法函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是：复制函数定义中的函数头，并添加分号。 double cube(double x); 然而，函数原型不要求提供变量名，有类型列表就足够了。 void cheers(int); 原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。 3. 原型的功能 编译器正确处理函数返回值； 编译器检查使用的参数数目是否正确； 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可以的话）。 cheers(cube(2)); 首先，cube()原型指定了一个doulbe类型参数，因此将2转换为2.0。接下来，cube()返回一个double值0.8，这个值被用作cheers()的参数。编译器再一次检查原型，并发现cheers()要求一个int参数，因此将返回值转换为整数8。 7.2 函数参数和按转传递C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其复制给一个新的变量。如下： double volume = cube(side); 其中，side是一个变量。cube()的函数头如下: double cube(double x); 被调用时，该函数将创建一个新的名为x的double变量，并将其初始化为5。这样，cube()执行的操作将不会影响main()中的数据，因此cube()使用的是side的副本，而不是原来的数据。 用于接收传递值得变量称为形参。传递给函数得值被称为实参。C++标准使用参数来表示实参，使用参量来表示形参，因此参数传递将参数赋给参量。 在函数中声明的变量(包括参数)是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存。这样的变量被称为局部变量。 7.2.1 多个参数函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可： n_chars(&apos;R&apos;, 25); 同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表： void n_chars(char c, int n) 该函数头指出了，函数n_chars()接收一个char参数和一个int参数。传递给函数的值被赋值给参数c和n。如果函数的两个参数的类型相同，必须分别指定每个参数的类型，而不能像声明常规变量那样，将声明组合在一起： void fifi(float a, float b) void fifi(float a, b) //非法的 和其他函数一样，只需添加分号就可以得到该函数的原型： void n_chars(char c, int n); 和一个参数一样，原型中的变量名不必与定义中的变量名相同，而且可以省略： void n_chars(char, int); 然而，提供变量名将使原型更容易理解，尤其是两个参数的类型相同时，这样，变量名可以提醒参量和参数之间的对应关系。 twoarg.cpp #include &lt;iostream&gt; using namespace std; void n_chars(char, int); int main() { int times; char ch; cout &lt;&lt; &quot;Enter a character: &quot;; cin &gt;&gt; ch; while (ch != &apos;q&apos;) { cout &lt;&lt; &quot;Enter an integer: &quot;; cin &gt;&gt; times; n_chars(ch, times); cout &lt;&lt; &quot;\nEnter another character or presss the q to quit: &quot;; cin &gt;&gt; ch; } cout &lt;&lt; &quot;The value of times is &quot; &lt;&lt; times &lt;&lt; &quot;.\n&quot;; return 0; } void n_chars(char c, int n) { while (n-- &gt; 0) cout &lt;&lt; c; } 结果 Enter a character: h Enter an integer: 10 hhhhhhhhhh Enter another character or presss the q to quit: q The value of times is 10. 程序中使用cin&gt;&gt;ch，而不使用cin.get(ch)或ch=cin.get()来读取一个字符，这样因为cin.get()函数读取所有的字符，包括空格和换行符，而cin&gt;&gt;跳过空格和换行符。当用户对程序提示做出响应时，必须在每行的最后按下Enter键，以生成换行符。cin&gt;&gt;ch方法可以轻松跳过这些换行符。 n的自减对main()中的times的值没有影响。 7.2.2 另一个接收两个参数的函数假设从51个数中选取6个，计算不同组合的数量。 totto.cpp #include &lt;iostream&gt; using namespace std; long double probability(unsigned numbers, unsigned picks); int main() { double total, choices; cout &lt;&lt; &quot;Enter the total nember of choices on the game card and the number of picks allowed: \n&quot;; while ((cin &gt;&gt; total &gt;&gt; choices) &amp;&amp; total &gt;= choices) { cout &lt;&lt; &quot;You have one chance in &quot;; cout &lt;&lt; probability(total, choices); cout &lt;&lt; &quot; of wining.\n&quot;; cout &lt;&lt; &quot;Next two numbers (q to quit): &quot;; } return 0; } long double probability(unsigned numbers, unsigned picks) { long double result = 1.0; long double n; unsigned p; for (n = numbers, p = picks; p &gt; 0; p--, n--) result *= n/p; return result; } 结果 Enter the total nember of choices on the game card and the number of picks allowed: 51 6 You have one chance in 1.80095e+07 of wining. Next two numbers (q to quit): 10 2 You have one chance in 45 of wining. Next two numbers (q to quit): q 7.3 函数和数组将一个数组名作为参数传递给函数，为使函数通用，而不限于特定长度的数组，还需要传递数组长度。将一个形参声明为数组名。函数头如下： int sum_arr(int arr[], int n) 方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。实际情况是：arr并不是数组，而是一个指针！在编写函数时，可以将arr看作时数组。 arrfun1.cpp #include &lt;iostream&gt; const int ArSize = 8; int sum_arr(int arr[], int n); using namespace std; int main() { int cookies[ArSize] = {1,2,4,8,16,32,64,128}; int sum = sum_arr(cookies, ArSize); cout &lt;&lt; &quot;Total: &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } int sum_arr(int arr[], int n) { int total = 0; for (int i = 0; i &lt; n; i++) total += arr[i]; return total; } 结果： Total: 255 7.3.1 函数如何使用指针来处理数组在前面介绍过，C++将数组名解释为起第一个元素的地址： cookies = &amp;cookies[0]; 该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度；第三，正如前面指出的，将地址运算符&amp;用于数组名时，将返回整个数组的地址，例如，&amp;cookes将返回一个32字节内存卡的地址。 int sum = sum_arr(cookies, ArSize); 其中，cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素为int，因此cookies的类型必须是int指针，即int*。正确的函数头为： int sum_arr(int *arr, int n) 其中用int * arr替换了int arr[]。这证明这两个函数头都是正确的。这种表示仅在函数头和函数原型中等价，不能在函数体中，使用int arr[]来声明指针。 下面两个等式等价： arr[i] = *(arr+i); &amp;arr[i] = arr + i; 7.3.2 将数组作为参数意味着什么arr_sum()函数将cookies的地址赋给指针变量arr,将ArSize赋给int变量n。这意味着并没将数组内容传递给函数，而是将数组的位置、包含的元素种类以及元素数目提交给函数 传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。实际上，这种区别并不违反C++按值传递的方法，sum()函数传递了一个值，这个值被赋给一个新变量，但这个值是一个地址，而不是数组的内容。 如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。 arrfun2.cpp #include &lt;iostream&gt; const int ArSize = 8; int sum_arr(int arr [], int n); using namespace std; int main() { int cookies[ArSize] = {1,2,4,8,16,32,64,128}; cout &lt;&lt; cookies &lt;&lt; &quot; = array address, &quot; &lt;&lt; sizeof(cookies) &lt;&lt; &quot; = sizeof cookies.\n&quot;; int sum = sum_arr(cookies, ArSize); cout &lt;&lt; &quot;Total cookies eaten: &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies, 3); cout &lt;&lt; &quot;First three eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies+4, 4); cout &lt;&lt; &quot;Last four eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } int sum_arr(int arr[],int n) { int total = 0; cout &lt;&lt; arr &lt;&lt; &quot; = arr, &quot;; cout &lt;&lt; sizeof(arr) &lt;&lt; &quot; = sizeof arr.\n&quot;; //实际得到的地址的长度 for (int i = 0; i &lt; n; i++) total += arr[i]; return total; } 结果 0x7ffff779f8b0 = array address, 32 = sizeof cookies. 0x7ffff779f8b0 = arr, 8 = sizeof arr. Total cookies eaten: 255 0x7ffff779f8b0 = arr, 8 = sizeof arr. First three eaters ate 7 0x7ffff779f8c0 = arr, 8 = sizeof arr. Last four eaters ate 240 注意，地址值和数组的长度随系统而异。 cookies和arr指向同一个地址，但sizeof(cookies)的值为32，而sizeof(arr)为8。这是由于sizeof(cookies)是整个数组的长度，而sizeof(arr)只是指针变量的长度。这是必须现实传递数组长度，而不能在sum_arr()中使用sizeof(arr)的原因；指针本身没有指出数组的长度。 注意： 将数组类型和元素数量告诉数组处理函数，不要试图使用方括号表示法来传递数组长度： void filarray(int arr[size]); //非法的 7.3 更多数组函数示例假设要使用一个数组记录房地产的价值。 1. 填充数组由于接收数组名参数的函数访问的是原始数组，而不是副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组的名称。第二个参数是数组的长度。由于用户输入的元素数目可能少于数组的长度，因此函数返回实际输入的元素数目。 停止循环的方法：使用一个特殊值来指出输入结束。由于所有的属性都不为负数，因此可以使用负数来指出输入结束。 2. 显示数组及使用const保护数组接受数组名的函数将使用原始数据，为防止函数无意中修改数组的内容，可在声明形参时使用关键字const。 void show_array(const double ar[], int n); 该声明表明，指针ar指向的是常量数组。这意味着不能使用ar修改该数据。 3. 修改数组具体见代码 4. 组合arrfun3.cpp #include &lt;iostream&gt; const int Max = 5; int fill_array(double ar[], int n); void show_array(const double ar[], int n); void revalue(double r, double ar[], int n); using namespace std; int main() { double properties[Max]; int size = fill_array(properties,Max); show_array(properties, size); if (size &gt; 0) { cout &lt;&lt; &quot;Enter revaluation factor: &quot;; double factor; while (!(cin &gt;&gt; factor)) { cin.clear(); while (cin.get() != &apos;\n&apos;) continue; cout &lt;&lt; &quot;Bad input; Please enter a number: &quot;; } revalue(factor, properties, size); show_array(properties, size); } return 0; } int fill_array(double ar[], int n) { double temp; int i; for (i = 0; i &lt; n; i++) { cout &lt;&lt; &quot;Enter values #&quot;&lt;&lt; i+1 &lt;&lt; &quot; : &quot; ; cin &gt;&gt; temp; if (!cin) { cin.clear(); while (cin.get() != &apos;\n&apos; ) //读取输入队列中的所有内容 continue; cout &lt;&lt; &quot;Bad input; input process terminated.\n&quot;; break; } else if (temp &lt; 0) break; ar[i] = temp; } return i; } void show_array(const double ar[], int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; &quot;Property #&quot; &lt;&lt; i+1 &lt;&lt; &quot;: $ &quot; &lt;&lt; ar[i] &lt;&lt; endl; } void revalue(double r, double ar[], int n) { for (int i = 0; i &lt; n; i++) ar[i] *= r; } 结果： Enter values #1 : 30000 Enter values #2 : 20000 Enter values #3 : 10000 Enter values #4 : -3 Property #1: $ 30000 Property #2: $ 20000 Property #3: $ 10000 Enter revaluation factor: 0.8 Property #1: $ 24000 Property #2: $ 16000 Property #3: $ 8000 [root@localhost ~]# ./a.out Enter values #1 : oo Bad input; input process terminated. 5. 数组处理函数的常用编写方式如果函数修改数组，其原型可能如下： void f_modify(double ar[], int n); 如果函数不修改数组，其原型可能如下： void f_no_change(const double ar[], int n); 7.3.4 使用数组区间的函数前面，对于处理数组的C++函数，必须将数组中的数据类型、数组的起始位置和数组中元素的数量提交给它。 还有一种给函数提供所需信息的方法，即指定元素区间，这块车通过传递两个指针来完成；一个指针表示数组的开头，另一个指针表示数组的尾部。 double elbuod[20]; 则指针elbuod和elbuod+20定义了区间。首先，数组名elbuod指向第一个元素。表达式elbuod+19指向最后一个元素，因此elbuod+20指向数组结尾后的一个位置。 arrfun4.cpp #include &lt;iostream&gt; const int ArSize = 8; int sum_arr(int * begin, int * end); using namespace std; int main() { int cookies[ArSize] = {1,2,4,8,16,32,64,128}; cout &lt;&lt; cookies &lt;&lt; &quot; = array address, &quot; &lt;&lt; sizeof(cookies) &lt;&lt; &quot; = sizeof cookies.\n&quot;; int sum = sum_arr(cookies, cookies+ArSize); cout &lt;&lt; &quot;Total cookies eaten: &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies, cookies+3); cout &lt;&lt; &quot;First three eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies+4, cookies+8); cout &lt;&lt; &quot;Last four eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } int sum_arr(int * begin, int * end) { const int * pt; int total = 0; for (pt = begin; pt != end; pt++) total += *pt; return total; } 结果 Total cookies eaten: 255 First three eaters ate 7 Last four eaters ate 240 程序中，将pt设置为指向第一个元素的指针，并将*pt加入到total扎。然后，循环通过递增操作来更新pt，使之指向下一个元素。 7.3.5 指针和const可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值；第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。 1. const int *int age = 39; const int * pt = &amp;age; 该声明指出，pt指向一个const int，因此不能使用pt来修改这个值。即，*pt的值为const，不能被修改： *pt += 1; //非法 cin &gt;&gt; *pt; //非法 一个微妙的问题，pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。比如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，但是不能使用pt指针来修改它： *pt = 20; //非法 age = 20; //合理 还有两种可能：第一种，将const变量的地址赋给指向const的指针；第二种，将const的地址赋给常规指针。第一种可行，第二种不可行： cont float g_earth = 9.80; cont float * pe = &amp;g_earth; //合理 const float g_moon = 1.63; float *pm = &amp;g_moon; //非法 对于第一种情况，既不能修改g_earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因：如果将g_moon的地址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const状态很荒诞。 如果将指针指向指针，则情况更复杂。假如涉及的是一级间接关系，则将非const指针赋给const指针是可以的： int age = 39; int *pd = &amp;age; const int * pt = pd; 然而，进入两级间接关系时，与一级间接关系一样，将const和非const混合的指针赋值方式将不再安全。如果允许这样做，则可以编写这样的代码： const int **pp2; int *p1; const int n = 13; pp2 = &amp;p1; //非法，但是假设其成立 *pp2 = &amp;n; //合理 *p1 = 10; //合理 上述代码将非const地址(&amp;p1)赋给了指向const指针(pp2)，因此可以使用p1来修改const数据。因此，仅当只有一层间接关系时，才可以将非const地址或指针赋给const指针。 假设一个由const数据组成的数组： const int monthes[5] = {31, 28, 31, 30, 31}; 则禁止将常量数组的地址赋给非常量指针，这意味着不能将数组名作为参数传递给非常量形参的函数： int sum(int arr[], int n); // 应该写为： const int arr[] int j = sum(months, 12); //不被允许 上述函数调用试图将const指针赋给非const指针，编译器将禁止这种函数调用。 另一个微妙之处，声明： int age = 39; const int * pt = &amp;age; 第二个声明种的const只能防止修改pt指向的值，但不能修改pt的值，即可以将一个新地址赋给pt: int sage = 40; pt = &amp;sage; 但仍然不能使用pt来修改它指向的值。 2. int * const使用const的方式使得无法修改指针的值： int sloth = 3; const int *ps = &amp;sloth; int * const finger = &amp;sloth; 最后一个声明，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但可以将ps指向另一位置。即，finger和$\ast$p都是const，而$\ast$finger和ps不是。 如果愿意还可以声明指向const对象的const指针： double trouble = 2.0E30; const double * const stick = &amp;trouble; 其中，stick只能指向troulbe，而stick不能用来修改trouble的值。即const和$\ast$const都是const。 7.4 函数和二维数组为编写将二维数组作为参数的函数，必须牢记，数组名被视为其地址，因此响应的形参是一个指针。比如： int data[2][4] = {{1,2,3，4},{4,5,6，7}}; int total = sum(data, 3); data是一个数组名，该数组有2个元素。第一个元素本身就是一个数组，有4个int值组成。因此data的类型是指向由4个int组成的数组的指针，正确的原型如下： int sum(int (*ar2)[4], int size); 其中的括号是必不可少的，因为下面声明将声明一个由4个指向int的指针组成的数组，而不是由一个指向由4个int组成的数组的指针；林伟函数不能是数组： int *ar2[4]; //4个指针指针组成的数组 还有另一个种格式，这种格式与上述原型的含义完全相同，但可读性更强: int sum(int ar2[][4], int size); 上述两个原型都指出，ar2是指针而不是数组。指针类型指出，它指向由4个int组成的数组。因此，指针类型指定了列数。 由于指针类型指定了列数，因此sum()函数只能接受由4列组成的数组。但长度变量指定了行数，因此sum()对数组的行数没有限制： int a[100][4]; int b[60][4]; int total1 = sum(a, 100); int total2 = sum(b, 60); 对于参数ar2是指向数组的指针，在函数定义中使用它，最简单的办法是将ar2看作一个二维数组的名称。 同样行数被传递给size参数，当无论是参数ar2的声明或是内部for循环中，列数都是固定的–4列。 ar2[r]是编号为r的元素，由于该元素本身就是一个由4个int组成的数组，因此ar2[r]是由4个int组成的数组的名称。将下标用于数组名将得到一个数组元素，因此ar2[r][c]是由4个int组成的数组中的一个元素，是一个int值。必须对指针ar2执行两次解除引用，才能得到数据。也可以使用运算符*两次： ar2[r][c] = *(*(ar2+r)+c) 7.5 函数和C-风格字符串C-风格自身串由一系列字符组成，以空值字符结尾。 7.5.1 将C-风格字符串作为参数的函数假设要将字符串作为参数传递给函数，则表示字符串的方式有三种： char数组 用引号括起来的字符串常量（字符串字面值） 被设置为字符串的地址的char指针 但上述3中选择的类型都是char指针（准确地说是char$\ast$），因此可以将其作为字符串处理函数的参数： char ghost[15] = &quot;galloping&quot;; char * str = &quot;galumphing&quot;; int n1 = strlen(ghone); int n2 = shrlen(str); 可以说，将字符串作为参数来传递，但实际上传递的是字符串第一个字符的地址。这意味着字符串函数原型将其表示字符串的形参声明为char$\ast$类型。 C-风格字符串与常规数组之间的重要区别是：字符串有内置的结束字符（不以空值字符结尾的char数组只是数组，而不是字符串）。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空字符为止。 strfun.cpp #include &lt;iostream&gt; unsigned int c_in_str(const char * str, char ch); using namespace std; int main() { char mmm[15] = &quot;minimum&quot;; const char *wail = &quot;ululate&quot;; unsigned int ms = c_in_str(mmm, &apos;m&apos;); unsigned int us = c_in_str(wail, &apos;u&apos;); cout &lt;&lt; ms &lt;&lt; &quot; m characters in &quot; &lt;&lt; mmm &lt;&lt; endl; cout &lt;&lt; us &lt;&lt; &quot; u characters in &quot; &lt;&lt; wail &lt;&lt; endl; return 0; } unsigned int c_in_str(const char * str, char ch) { unsigned int count = 0; while(*str) { if (*str == ch) count ++; str++; } return count; } 结果： 3 m characters in minimum 2 u characters in ululate 为了防止c_in_str()函数修改原始字符串，因此在函数声明形参str时使用了限定符const。 str最初指向字符串的第一个字符，因此*str表示的第一个字符。 7.5.2 返回C-风格字符串的函数strgback.cpp #include &lt;iostream&gt; char * buildstr(char c, int n); using namespace std; int main() { int times; char ch; cout &lt;&lt; &quot;Enter a character: &quot;; cin &gt;&gt; ch; cout &lt;&lt; &quot;Enter a integer: &quot;; cin &gt;&gt; times; char * ps = buildstr(ch, times); cout &lt;&lt; ps &lt;&lt; endl; delete [] ps; ps = buildstr(&apos;+&apos;, 20); cout &lt;&lt; ps &lt;&lt; &quot;-DONE-&quot; &lt;&lt; ps &lt;&lt; endl; delete [] ps; return 0; } char * buildstr(char c, int n) { char * pstr = new char [n+1]; pstr[n] = &apos;\0&apos;; while(n--) pstr[n] = c; return pstr; } 结果： Enter a character: V Enter a integer: 46 VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV ++++++++++++++++++++-DONE-++++++++++++++++++++ 要创建包含n个字符的字符串，需要能够存储n+1个字符的空间，以便能够存储空值字符。程序中请求分配了n+1个字节的内存来存储字符串，并将最后一个字节设置为空值字符。 n–表示先在测试条件中比较，然后将其值递减。因此，当n=20时，首先20大于0，然后将其值递减1，于是循环体里面的n=19。 注意pstr的作用为buildstr函数内，因此该函数结束时，pstr使用的内存将被释放。但由于函数返回了pstr的值，因此程序仍可以通过main()中的指针ps来访问新建的字符串。当该字符串不再需要时，使用delete释放该字符串所占用的内存。 7.6 函数和结构使用结构编程时，最直接的方式就像处理基本类型那样来处理结构；即将结构作为参数传递，并在需要时将结构用作返回值使用。在这种情况下，函数将使用原始结构的副本，与处理数组不同。如果结构非常大，则复制结构将增大内存要求，降低系统运行速度。出于这些愿意，许多C程序倾向于传递结构的地址，然后使用指针来访问结构的内容。C++提供了第三种选择—按引用传递（下一章介绍）。 7.6.1 传递和返回结构当结构比较小时，按值传递结构最合理。第一个例子处理行程时间，比如从Falls到Bingo需要3小时50分钟，而Bingo到Gotesquo需要1小时25分钟。对于这种时间，可以使用结构表示–一个成员表示小时值，另一个成员表示分钟值。将两个时间加起来需要一些技巧，因为可能需要将分钟值转换为小时。具体如下： travel.cpp #include &lt;iostream&gt; using namespace std; struct travel_time { int hours; int mins; }; const int Mins_per_hr = 60; travel_time sum(travel_time t1, travel_time t2); void show_time(travel_time t); int main() { travel_time day1 = {5, 45}; travel_time day2 = {4, 55}; travel_time trip = sum(day1, day2); cout &lt;&lt; &quot;Two-day total: &quot;; show_time(trip); return 0; } travel_time sum(travel_time t1, travel_time t2) { travel_time total; total.mins = (t1.mins + t2.mins) % Mins_per_hr; total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr; return total; } void show_time(travel_time t) { cout &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.mins &lt;&lt; &quot; mins.\n&quot;; } 结果 Two-day total: 10 hours, 40 mins. 其中，travel_time就像一个标准类型名，可被用来声明变量、函数的返回类型和函数参数类型。 7.6.2 另一个处理结构的函数示例表示二维坐标中的一个点的方法有两种：一种是指出该点相对远点的水平偏移和垂直便宜（x-y）；另一个种是指出它偏离远点的距离和方向（极坐标）。实现表示两种表示方法，以及之间的相互转换，如下程序： atrctfun.cpp #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; struct rect { double x; double y; }; struct polar { double distance; double angle; }; polar rect_to_polar(rect xypos); void show_polar(polar dapos); int main() { rect rplace; polar pplace; cout &lt;&lt; &quot;Enter the x and y value: &quot;; while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) { pplace = rect_to_polar(rplace); show_polar(pplace); cout &lt;&lt; &quot;Nest two number(q to quit): &quot;; } return 0; } polar rect_to_polar(rect xypos) { polar answer; answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y); answer.angle = atan2(xypos.y, xypos.x); return answer; } void show_polar(polar dapos) { const double Rad_to_deg = 57.29577951; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; dapos.distance; cout &lt;&lt; &quot;, Angle = &quot; &lt;&lt; dapos.angle * Rad_to_deg &lt;&lt; &quot; degrees.\n&quot;; } 结果 Enter the x and y value: 30 40 Distance = 50, Angle = 53.1301 degrees. Nest two number(q to quit): -100 100 Distance = 141.421, Angle = 135 degrees. Nest two number(q to quit): q 7.6.3 传递结构的地址需要修改的滴很： 调用函数时，将结构的地址(&amp;pplace)而不是结构本身(pplace)传递给它； 将形参声明为指向polar的指针，即polar$\ast$类型，由于函数不应该修改结构，因此使用了const修饰符； 由于形参是指针而不是结构，因此应使用间接成员运算符(-&gt;)，而不是成员运算符（句点）。 strctptr.cpp #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; struct rect { double x; double y; }; struct polar { double distance; double angle; }; void rect_to_polar(const rect *xypos, polar *dapos); void show_polar(const polar *dapos); int main() { rect rplace; polar pplace; cout &lt;&lt; &quot;Enter the x and y value: &quot;; while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) { rect_to_polar(&amp;rplace, &amp;pplace); show_polar(&amp;pplace); cout &lt;&lt; &quot;Nest two number(q to quit): &quot;; } return 0; } void rect_to_polar(const rect *xypos, polar *dapos) { dapos-&gt;distance = sqrt(xypos-&gt;x * xypos-&gt;x + xypos-&gt;y * xypos-&gt;y); dapos-&gt;angle = atan2(xypos-&gt;y, xypos-&gt;x); } void show_polar(const polar *dapos) { const double Rad_to_deg = 57.29577951; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; dapos-&gt;distance; cout &lt;&lt; &quot;, Angle = &quot; &lt;&lt; dapos-&gt;angle * Rad_to_deg &lt;&lt; &quot; degrees.\n&quot;; } 结果同上 遇到的问题(待解决)在编写时，发现如果开始将结构初始为结构指针，如下： rect *rplace; polar *pplace; 而这样在输入x,y的之后出现段错误(吐核)。根据网上教程，在./a.out之前，加上strace，即 strace ./a.out，看不懂到底是什么原因。而使用上述程序种的方式不会有问题。 7.7 函数核string对象虽然C-风格字符串和string对象的用途几乎相同，但与数组相比，string对象与结构的更相似。例如：可以将一个结构赋给另一个结构，也可以将一个对象赋给另一个对象。可以将结构作为完整的实体传给函数，也可以将对象作为完整的实体进行传递。如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。 topfive.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; const int SIZE = 5; void display(const string sa[], int n); int main() { string list[SIZE]; cout &lt;&lt; &quot;Enter your &quot; &lt;&lt; SIZE &lt;&lt; &quot; favorite astronomicla sights: \n&quot;; for (int i = 0; i &lt; SIZE; i++) { cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; getline(cin, list[i]); } cout &lt;&lt; &quot;Your list: \n&quot;; display(list, SIZE); return 0; } void display(const string sa[], int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; i + 1&lt;&lt; &quot;: &quot; &lt;&lt; sa[i] &lt;&lt; endl; } 结果 Enter your 5 favorite astronomicla sights: 1: Mon 2: Jupiter 3: Saturn 4: M13 5: Orion Nebula Your list: 1: Mon 2: Jupiter 3: Saturn 4: M13 5: Orion Nebula 7.8 函数和array对象假设要使用一个array对象来存储一年四个季度的开支： std::array&lt;double, 4&gt; expenses; 要使用array类，需要包含头文件array，而名称array位于名称空间std中。如果函数来显示expenses的内容，可按值传递expenses: show(expenses); 但如果函数要修改对象expenses，则需将对象的地址传给函数： fill(&amp;expenses); 声明上述两个函数为array&lt;double, 4&gt;，因此必须在函数原型中指定这种类型： void show(std::array&lt;double, 4&gt; da); void fill(std::array&lt;doulbe, 4&gt; * pa); 首先，使用符号常量替换4： const int Seasons = 4; 使用一个const array对象，该对象包含4个string对象，用于表示几个季度： const std::array&lt;std::string, Season&gt; Sname = {&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;}; arrobj.cpp #include &lt;iostream&gt; #include &lt;array&gt; #include &lt;string&gt; using namespace std; const int Seasons = 4; const array&lt;string, Seasons&gt; Sname = {&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;}; void fill(array&lt;double, Seasons&gt; * pa); void show(array&lt;double, Seasons&gt; da); int main() { array&lt;double, Seasons&gt; expenses; fill(&amp;expenses); show(expenses); return 0; } void fill(array&lt;double, Seasons&gt; *pa) { for (int i = 0; i&lt; Seasons; i++) { cout &lt;&lt; &quot;Enter &quot; &lt;&lt; Sname[i] &lt;&lt; &quot; expenses: &quot;; cin &gt;&gt; (*pa)[i]; } } void show(array&lt;double, Seasons&gt; da) { double total = 0.0; cout &lt;&lt; &quot;EXPENSES\n&quot;; for (int i = 0; i &lt; Seasons; i++) { cout &lt;&lt; Sname[i] &lt;&lt; &quot;: $&quot; &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; } cout &lt;&lt; &quot;Total expenses: $&quot; &lt;&lt; total &lt;&lt; endl; } 结果 Enter Spring expenses: 1000 Enter Summer expenses: 2000 Enter Fall expenses: 2000 Enter Winter expenses: 4000 EXPENSES Spring: $1000 Summer: $2000 Fall: $2000 Winter: $4000 Total expenses: $9000 注意，String是C++11中的内容，在使用Linux编译时，需要告诉编译器使用C++11的编译器，如下： g++ -std = c++ arrobj.cpp 因为在代码最前面添加了编译指令using，因此可以不适用std::来限定array和string。 7.9 递归C++函数有一种有趣的特点–可以自己调用自己，这种功能被称为递归。 7.9.1 包好一个递归调用的递归如果递归函数调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容。通常的方法将递归调用放在if语句中。如下： void recurs(argumentlist) { statements1 if (test) recurs(arguments) statements2 } test为false，调用链断开。只要if语句为true，每个recurs()调用都将执行statements1，然后再调用recurs()，而不会执行statements2。当if语句为false时，当前调用执行statements2。当前调用结束后，程序控制权将返回给调用它的recurs()，而该recurs()将执行其statements2部分，然后结束，并将控制权返回给前一个调用，依次类推。因此，如果recurs()进行了5次递归调用，则第一个statements1部分将按函数调用的顺序执行5次，然后，statements部分将以与函数调用相反的顺序执行5次。进入5层递归后，程序将沿进入的路径返回。 recur.cpp #include &lt;iostream&gt; void countdown(int n); using namespace std; int main() { countdown(4); return 0; } void countdown(int n) { cout &lt;&lt; &quot;Count down ... &quot; &lt;&lt; n &lt;&lt; endl; if (n &gt; 0) countdown(n-1); cout &lt;&lt; n &lt;&lt; &quot;: Kaboom!\n&quot;; } 结果 Count down ... 4 Count down ... 3 Count down ... 2 Count down ... 1 Count down ... 0 0: Kaboom! 1: Kaboom! 2: Kaboom! 3: Kaboom! 4: Kaboom! 注意，每个递归调用都创建自己的一套变量，因此当程序达到第5次调用时，将有5个独立的变量n，其中每个变量的值都不同。为了验证这一点，使之显示n的地址和值： cout &lt;&lt; &quot;Count down ... &quot; &lt;&lt; n &lt;&lt; &quot;(n at&quot; &lt;&lt; &amp;n &lt;&lt; &quot; )&quot; &lt;&lt; endl; if (n &gt; 0) countdown(n-1); cout &lt;&lt; n &lt;&lt; &quot;: Kaboom!&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;(n at&quot; &lt;&lt; &amp;n &lt;&lt; &quot; )&quot; &lt;&lt; endl; 程序输出结果为： Count down ... 4(n at0x7ffc9be6862c ) Count down ... 3(n at0x7ffc9be685fc ) Count down ... 2(n at0x7ffc9be685cc ) Count down ... 1(n at0x7ffc9be6859c ) Count down ... 0(n at0x7ffc9be6856c ) 0: Kaboom! (n at0x7ffc9be6856c ) 1: Kaboom! (n at0x7ffc9be6859c ) 2: Kaboom! (n at0x7ffc9be685cc ) 3: Kaboom! (n at0x7ffc9be685fc ) 4: Kaboom! (n at0x7ffc9be6862c ) 7.9.2 包含多个递归调用的递归在需要将一定工作不断分为两项较小的、类似的工作时，递归非常有用。例如：考虑使用这种方法来绘制绘制标尺的情况。标出两端，找到重点并将其标出。然后，将同样的操作用于标尺的左半部分和右半部分。如果要进一步细分，同将同样的操作用于当前的每一部分。递归方法有时被称为分而治之策略。 下面程序使用subdivide()演示了这种方法，该函数使用一个字符串，该字符串处两端为|字符为，其他都为空格。main函数使用循环调用subdivide()函数6次，每次见递归层编号加1，并打印得到的字符。这样，每行输出表示一层递归。 ruler.cpp #include &lt;iostream&gt; const int len = 66; const int Divs = 6; void subdivide(char ar [], int low, int hight, int level); using namespace std; int main() { char ruler[len]; int i ; for (i = 1; i &lt; len - 2; i++) ruler[i] = &apos; &apos;; ruler[len-1] = &apos;\0&apos;; int max = len - 2; int min = 0; ruler[min] = ruler[max] = &apos;|&apos;; cout &lt;&lt; ruler &lt;&lt; endl; for (i = 1; i &lt;= Divs; i++) { subdivide(ruler, min, max, i); cout &lt;&lt; ruler &lt;&lt; endl; for (int j = 1; j &lt; len -2; j++) ruler[j] = &apos; &apos;; } return 0; } void subdivide(char ar[], int low, int high, int level) { if (level == 0) return ; int mid = (high + low) / 2; ar[mid] = &apos;|&apos;; subdivide(ar, low, mid, level-1); subdivide(ar, mid, high, level-1); } 结果 | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| subdivide()使用变量level来控制递归层。函数调用自身时，将把level减1，当level为0时，该函数将不再调用自己。注意，subdivide()调用自己两次，一次针对左半部分，另一个针对右半部分。最初的中点被用作一次调用的右端点和另一次调用的左端点。调用次数从指数级增长。如果要求的递归层次很多，这种递归方式将是一种糟糕的选择；然而对于递归层次较少，这将是一种精致而简单的选择。 7.10 函数指针与数据项类似，函数也有地址。函数的地址是存储器机器语言代码的内存的地址。通常，这些地址对于用户而言，既不重要，也没有什么用处，但对程序而言，却很重要。可以编写将另一个函数第地址作为参数的函数。这样第一个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同的函数的地址，这意味着可以在不同的时间使用不同的函数。 7.10.1 函数指针的基础知识通过一个例子来阐述这一过程。假设要设计一个名为estimate()函数，估算编写执行函数的代码所需的时间，并且希望不同的程序员都可以使用这个函数。对于所有用户来说，estimate()中一部分代码都是相同的，但该函数允许每个程序员提供自己的算法来估算时间。为实现这个目标，采用的机制是，将程序员使用的算法函数的地址传给estimate()。为此，必须完成如下工作： 获取函数地址 声明一个函数指针 使用函数指针来调用函数 1.获取函数地址获取函数的地址很简单：只要使用函数名(后面不跟参数)即可。即，如果think()是一个函数，则think就是该函数的地址。 要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值： process(think); process(think());//传递的是函数的返回值 2.声明函数指针声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指出函数的返回类型以及函数的特征标(参数列表)。即声明应像函数原型一样指出函数信息。一个函数原型如下： double pam(int); 则正确的指针类型声明如下： double (*pf) (int); 这与pam()声明类似，这是将pam替换为了($\ast$pf)。由于pam是函数，因此($\ast$pf)也是函数。而如果($\ast$pf)是函数，则pf就是函数指针。 括号的优先级比$\ast$的运算符高，因此$\ast$pf(int)意味着pf()是一个返回指针的函数，而($\ast$pf)(int)意味着pf是一个指向函数的指针： double (*pf)(int); double * pf (int); //一个返回指针的函数pf() 正确声明pf后，便可以将相应函数的地址赋给它： pf = pam; 现在，给出estimate()函数的原型： void estimate(int lines, double (*pf)(int)); 使用estiemate()如下： estimate(50, pam); pam为函数pam()的指针。 3.使用指针来调用函数使用指针来调用被指向的函数。($\ast$pf)扮演的角色与函数名相同，因此使用($\ast$pf)时，只需将它看作函数名： double pam(int); double (*pf) (int); double x = pam(3); double y = (*pf)(3); 实际上，C++也允许像使用函数名一样使用pf: double y = pf(3); 7.10.2 函数指针示例下面的程序，两次调用estimate()函数，一次传递betsy()函数的地址，另一次则传递pam()函数地址。 fun_ptr.cpp #include &lt;iostream&gt; double betsy(int); double pam(int); using namespace std; void estimate(int lines, double (*pf)(int)); int main() { int code; cout &lt;&lt; &quot;How many lines of code do you need? &quot;; cin &gt;&gt; code; cout &lt;&lt; &quot;Here&apos;s Betsy&apos;s estimate:\n&quot;; estimate(code, betsy); cout &lt;&lt; &quot;Here&apos;s Pam&apos;s estimate:\n&quot;; estimate(code, pam); return 0; } double betsy(int lns) { return 0.05 * lns; } double pam(int lns) { return 0.03 * lns + 0.0004 * lns * lns; } void estimate(int lines, double (*pf)(int)) { cout &lt;&lt; lines &lt;&lt; &quot; lines will take &quot;; cout &lt;&lt; (*pf)(lines) &lt;&lt; &quot; hour(s)\n&quot;; } 结果 How many lines of code do you need? 30 Here&apos;s Betsy&apos;s estimate: 30 lines will take 1.5 hour(s) Here&apos;s Pam&apos;s estimate: 30 lines will take 1.26 hour(s) 7.10.3 深入探讨函数指针下面一些函数的原型，它们的特征标（参数列表）和返回类型相同： const double * f1(const double ar[], int n); const double * f2(const double [], int); const double * f3(const double *, int); 这些函数特征标看似不同，但实际上相同。前面说过，在函数原型中，参数列表const double ar[]与const double $\ast$ar的含义相同。其次，在函数原型中，可以省略标识符（参数名）。因此，const double ar[]可简化为const double []，而const double $\ast$ar可简化为const double $\ast$。因此，上述的函数特征标的含义都相同。另一方面，函数定义必须通过标识符，因此需要使用const double $\ast$ar或const double ar[]。 接下来，声明一个指针，它可指向这三个函数之一。假设该指针名为pa，则只需要将目标函数原型中的函数名替换为($\ast$pa): const double * (*pa)(cosnt double * , int); 可在声明的同时初始化： const double * (*pa)(cosnt double * , int) = f1; 使用C++的自动类型推断功能时，代码要简单得多： auto p2 = f2; 将于使用三个函数，如果有一个函数指针数组将很方便。这种声明声明类似于单个函数指针的声明，但必须在某个地方加上[3]，以指出一个包含三个函数指针的数组： const double * (*pa[3])(const double *, int) = {f1, f2, f3}; pa是一个包含三个元素的数组，而要声明这样的数组，首先需要使用pa[3]。该声明的其他部分指出了数组包含的元素是什么样的。运算符[]的优先级高于$\ast$，因此$\ast$pa[3]表明pa是一个包含三个指针的数组。在此不能使用auto，自动类型推断只能用于单值初始化，而不能用于初始化列表。但是声明数组pa后，声明同样类型的数组就简单了： auto pb = pa; 使用它们来调用函数：pa[i]和pb[i]表示数组中的指针，因此可将任何一种函数调用表示法用于它们： const double * px = pa[0](av,3); const double * py = (*pb[1])(av,3); 获取指向的double值，可使用运算符$\ast$: double x = *pa[0](av,3); double y = *(*pb[1])(av,3); 可做的另一件事是创建指向整个数组的指针。由于数组名pa是指向函数指针的指针，因此指向数组的指针将是这样的指针，即它指向数组指针的指针。由于可使用单个值对其进行初始化，因此可以使用auto: auto pc = &amp;pa; 如果指针名为pd，则需要指出它是一个指针，而不是数组。这意味着声明的核心部分应为($\ast$pd)[3]，其中的括号让标识符pd与$*$先结合： *pd[3]// 一个数组有三个指针 (*pd)[3] //一个指针指向三个元素 即pd是一个指针，它指向一个包含三个元素的数组。由pa的声明的其他部分描述，如果如下： const double *(*(*pd)[3])(const double *, int) = &amp;pa; 要调用函数，需要认识：pd指向数组，$\ast$pd就是数组，而($*$pd)[i]是数组中的元素，即函数指针。因此，较简单的函数调用是($\ast$pd)i，而$\ast$($\ast$pd)i是返回的指针所指向的值。也可以使用第二种使用指针调用函数语法：使用($\ast$($\ast$pd[i]))(av,3)，而$\ast$($\ast$($\ast$pd))i是指向的double值。 pa和&amp;的区别：pa都是数组第一个元素的地址，即&amp;pa[0]，因此，它是单个指针的地址。但&amp;pa是整个数组的地址（即三个指针块）。从数字上来说，pa和&amp;pa的值相同，但它们的类型不同，一种差别是，pa+1为数组中的下一个元素，而&amp;pa+1为数组pa后面的12字节内存块的地址(假定地址为4字节)。另一个差别是，要得到第一个元素的值，对pa解除一次引用，但需要对&amp;pa解除两次引用： **&amp;pa == *pa == pa[0] arfupt.cpp #include &lt;iostream&gt; using namespace std; const double * f1(const double ar[], int n); const double * f2(const double [], int); const double * f3(const double *, int); int main() { double av[3] = {1112.3, 1542.6, 2227.9}; const double *(*p1)(const double *, int) = f1; auto p2 = f2; cout &lt;&lt; &quot;Using pointers to functions:\n&quot;; cout &lt;&lt; &quot;Address Value\n&quot;; cout &lt;&lt; (*p1)(av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*p1)(av,3) &lt;&lt; endl; cout &lt;&lt; p2(av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *p2(av,3) &lt;&lt; endl; const double *(*pa[3])(const double *, int) = {f1, f2, f3}; auto pb = pa; //const double *(**pb)(const double *, int) = pa; cout &lt;&lt; &quot;\nUsing an array of pointers to functions:\n&quot;; cout &lt;&lt; &quot;Address Value\n&quot;; for (int i = 0; i &lt; 3; i++) cout &lt;&lt; pb[i](av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *pb[i](av,3) &lt;&lt; endl; cout &lt;&lt; &quot;\nUsing pointers to an array pointers:\n&quot;; cout &lt;&lt; &quot;Address Value\n&quot;; auto pc = &amp;pa; cout &lt;&lt; (*pc)[0](av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*pc)[0](av,3) &lt;&lt; endl; const double *(*(*pd)[3])(const double *, int) = &amp;pa; const double * pdb = (*pd)[1](av,3); cout &lt;&lt; pdb &lt;&lt; &quot;: &quot; &lt;&lt; *pdb &lt;&lt; endl; cout &lt;&lt; (*(*pd)[2])(av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*(*pd)[2])(av,3) &lt;&lt; endl; return 0; } const double * f1(const double * ar, int n) { return ar; } const double * f2(const double ar[], int n) { return ar+1; } const double * f3(const double ar[], int n) { return ar+2; } 结果: Using pointers to functions: Address Value 0x7fff5fac4b50: 1112.3 0x7fff5fac4b58: 1542.6 Using an array of pointers to functions: Address Value 0x7fff5fac4b50: 1112.3 0x7fff5fac4b58: 1542.6 0x7fff5fac4b60: 2227.9 Using pointers to an array pointers: Address Value 0x7fff5fac4b50: 1112.3 0x7fff5fac4b58: 1542.6 0x7fff5fac4b60: 2227.9 auto在C++11才有，所以编译时使用： g++ -std=c++11 arfupt.cpp 7.10.4 使用typedef进行简化除auto外，C++还提供了简化声明的工具。关键字typedef能够创建类型别名： typedef double real; //real为double的别名 这里采用的方法是，将别名当作标识符进行声明，并在开头使用关键字typedef。因此，可将p_fun声明为程序中使用的函数指针类型的别名： typedef const double *(*p_fun)(const double *, int); p_fun p1 = f1; 然后使用这个别名来简化代码： p_fun pa[3] = {f1,f2,f3}; p_fun (*pd)[3] = &amp;pa; 7.11 总结函数原型 参数传递和返回值 函数指针]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Public Proof of Cloud Storage from Lattice Assumption∗]]></title>
    <url>%2F2018%2F10%2F03%2FPublic%20Proof%20of%20Cloud%20Storage%20from%20Lattice%20Assumption%2F</url>
    <content type="text"><![CDATA[摘要存储可以提供灵活、可伸缩的数据存储服务。然而，一旦数据上传至云服务器，本地计算机没有拷贝，用户失去了对数据的物理控制。因此，研究一种方法来确保用户数据的完整性是有必要的。避免检索大量存储数或避免由用户检验数据，一种基于格加密的公开审计存储协议证明被提出。用户计算数据块的的标签，并且上传它们至云服务器。云服务器提供联合的块。第三方审计者通过联合的数据和标签来验证所有数据块的完整性。基于小整数解假设，给出的方案可以抵抗来自云服务器的丢失攻击和篡改攻击。基于错误假设的学习，给出的方案可以抵抗来自第三方审计者的好奇攻击。该方案是高效的，仅仅需要几个矩阵向量乘法和离散高斯函数的抽样。 关键词： 云存储 存储证明 格加密 公开审计 一、前言云存储作为云计算的一个基础服务，例如，微软的Azure存储服务和亚马逊的简单存储服务，已经提供给用户使用。在云上，用户可以在任何地方任何时间访问数据，享受更可靠的服务。云存储服务被设想为下一代存储服务。同时，云存储也带来一些新的和具有挑战性的安全问题【1-2】。一旦用户将数据上传至云，数据被云服务提供商控制（CSP）。引用的案例【3】说明了云存储不仅受到外部或外部数据安全威胁，尽管CSP声明了数据的完整性。因此，安全问题成为了影响用户选择云存储服务的主要因素。 在互联网上，数据的丢失或篡改可以有用户执行数据完整性验证来检验。然而，云存储服务有一些特殊的特征首先，存储在云上的数据都是巨大的，由于昂贵的I/O和传输成倍，通过恢复数据来验证数据的完整性是不可行的。其次，云存储服务使用分布式存储系统，于是数据存储在一系列云服务器上。互联网上的数据完整验证方案不再适应于云存储系统。一些针对云的安全方案被研究【4-5】。在云存储系统，存储证明可以可以分为两类：私有审计【6，7】和公开审计【8-10】。对于私有审计，仅仅用户自己检验他们外包的数据的完整性，其引起了巨大的开销。为了避免CSP或数据拥有者任意一方执行审计，公开审计，将审计程序移交给第三方审计者（TPA）,这是一个自然的选择。正如【9，10】所示，同态是公开审计一个有用的工具。 最近，基于格加密已经成为了热点研究课题，因为它在量子攻击（quantum attacks）下是安全的【11】。因为新的格难题的陷门函数(Trapdoor function)被成功的提出在【12】，对于云，许多基于格的方案被提出，其展示了格加密的数学优雅，实现的简单性，可证明的安全性降低，效率显著提高。一个简单有效的签名方叫做GPV签名【12】被提出与一个行的陷门函数。随后，Boneh和Freeman【13】提出了第一个在$F_2$上线性同态签名算法，其的不可伪造性是基于小整数解（SIS）问题。Boneh和Freeman【14】提出了第一个的同态签名方案，该方案能做在Eurocrypt2011上签署数据的多元多项式。其不可伪造性基于理想格上的SIS问题。在【15】中，基于加法的同态的韩系函数，给出了一个效率上的改进。 文献【17】尝试使用基于格的加密方案来验证云存储系统中数据完整性。一个来自格假设的线性同态签名被提出，第一个基于格的存储协议证明基于它被构造。然而，怎么利用$(W_i)_{i=1}^k$和$\sum_i c_i f_i$来计算$\sum_i c_i H(W_i) f_i$没有被解释。$\sum_i c_i f_i$可能泄漏一些关于文件$F=(f_1,\dots,f_k)$的信息给验证者TPA，因此该方案不支持公开审计。 本文旨在提出一种基于格加密的云存储数据的公开审计。本文余下阻止如下：在第二节，本文研究需要的技术知识被给出。系统模型、攻击模型和公开审计的设计目标在第三节给出。第四节，一种云存储数据的公开验证协议被提出，没有文献【17】的缺陷。在第五节，分析了提出方案的安全性和性能。在第六节，给出了结论和未来工作。 二、预备知识1.格对于任何整数$q \geq 2$，设$Z_p$表示模数位$q$的整数环。设$Z_q^{n \times m}$表示元素在$Z_p$中大小为$n \times m$的矩阵集合。 整数格的点的坐标为$Z^m$。对于任何整数$q \geq 2$，$u \in Z_q^n$和矩阵$A \in Z_q^{n \times m}$，定义整数格如下： 对任何$t \in \Lambda_q^u(A)$，$\Lambda_q^u(A) = \Lambda_q^{\bot}(A) + t$ 2. 离散高斯抽样格应用在密码学上是有效的，因为它的自然陷门特征。事实上，所有基于格的加密方案给出了怎么通过一种理论上可靠的方法去使用一个陷门函数。格的一个短基是一个陷门。 定理一 生成一个短基【12】：设$q$是一个整数，$m \geq 5nlogq$。一个概率多项式时间算法$TrapGen(q,n)$，其输出$(A \in Z_q^{n \times m}, T \in Z^{m \times m})$: (1) $A$在$Z_q^{n \times m}$统计地上服从一个一致矩阵。 (2) $T$是$\Lambda_q^{\bot}(A)$的一个基。 (3) $T(||T||)$中所有行的欧几里德范式以$O(nlogn)$为界。 定理二 从离散高斯分布抽样【12】：一个概率多项式时间算法$asmpePre(A,T,\sigma)$，给定一个矩阵$A \in Z_q^{n \times m}$，$\Lambda_q^{\bot}(A)$的一个基$T$，一个系数$\sigma \geq ||\check{T}|| \cdot w(\sqrt{logn})$，一个向量$u \in Z^n$，输出是来自一个分布的抽样，该分布统计地趋近于$D_{\Lambda_q^u(A)},\sigma$。$D_{\Lambda_q^u(A)},\sigma$是$\Lambda_q^u(A)$上系数为$\sigma$的离散高斯分布。 3. 困难假设经典的基于格的困难问题主要包括：最短向量问题、最近向量问题和最小基问题。进一步，为了提出加密方案，小整数解问题$SIS_{q,m,\beta}$被减少，如下： 给定一个整数$q$，一个矩阵$A \in Z_q^{n \times m}$和一个实数$\beta$，找一个非零向量$e \in Z^m $，满足： $A \cdot e = 0 mod q$和$||e|| \leq \beta$。 文献【12】已经证明平均情况问题$SIS_{q,m,\beta}$的难度近似跟最近想问题相等，在最糟的情况，对于任何有边界的特征$m,\beta$和任何素数$q \geq /beta \cdot w(\sqrt{nlogn})$。 错误学习假设【18】$LWE_{q,m,\chi}$以一种适合我们应用的方式被描述。 一个正整数$n$，整数$m \geq n $，$q \geq 2$，一个向量$s \in Z_q^q$，在$Z_q^m$上一个概率分布$\chi$。选择一致矩阵$A \leftarrow Z_q^{n \times m}$，向量$e \leftarrow \chi$，和向量$y \leftarrow Z^m_q$。分布$(A,A^T,s+e)$和分布$(A,y)$是难以区分的。 文献【18】已经证明$LWE_{q,m,\chi}$的难度跟利用量子算法解决几个标准的最糟情况的格问题一样。 三、提出的模型1、系统模型对于公开审计，一个代表性的系统模型见图1。公开审计的系统模型中有三个不同的实体。 用户：拥有大量数据文件需要存储到云上，依赖云来进行数据维护和计算，其可以是个人消费者也可以是组织。 云服务器提供商(CSP)：其是管理云服务器的实体，拥有大量的存储空间和计算资源来维护和计算用户的数据。 第三方审计者(TPA):其拥有用户没有的能力和专业知识，被信任来代表用户评估和揭露云存储服务的危险。 在云系统中，通过将大数据文件上传至云服务器，用户可以释放存储和计算的负担。首先，用户计算数据的标签，并发送数据和标签给云服务器。在云 存储系统中，用户存储他们的数据到一系列云服务器中，它们以一种协作和分布式的方式工作。然后，用户不再本地地处理他们的数据。如果用户想去检验数据是否完整的存在的服务器中，执行审计工作，如图1。 初始化 用户与CSP和TPA协商加密密钥。 挑战 收到来自用户的审计请求后，TPA生成并发送挑战给CSP。 证据 一收到来自TPA的挑战，CSP生成存储数据的证据并发送它给TPA。 验证 使用一些公开参数，TPA验证来自CSP证据的正确性，并返回TRUE/FALSE给用户。 2、攻击模型在云存储系统中，TPA被认为是诚实的和好奇的。在审计过程中，它诚实的执行审计程序，但它对收到的数据好奇。CSP被认为是不诚实的。一些破坏系统的攻击存在： 好奇攻击 TPA通过分析公开参数和来自CSP的证据尝试恢复用户的数据。 丢失攻击 CSP丢失用户的数据，希望通过TPA的审计。 篡改攻击 CSP可能篡改用户的数据为其他非法的数据，并尝试通过TPA的审计。 3、设计目标根据系统模型和攻击模型，公开审计方案的设计目标可以总结如下： 不可伪造性 攻击者无法伪造用户的标签 公开验证 任何人都可以执行审计，不仅仅存在数据到云服务器的用户，有能力去验证存储数据的完整性。 隐私保护 在审计过程中，没有数据块被审计者TPA恢复。 四、提出的方案1. 同态标签方案同态对于云存储证明是一个非常有用的工具。现在描述文献【15】提出的同态标签$(KeyGen,Sign,Combine,Verify)$方案，其包括如下四个多项式时间算法。$H:\lbrace 0,1\rbrace^{\ast} \rightarrow Z^m_q$是一个坑碰撞的哈希函数。 密钥生成 输入一个安全参数$n$。对任何整数$q$，Alice运行定理一中的$TrapGen(q,n)$算法来生成$A \in Z_q^{n \times m}$和陷门基$T \in Z^{m \times m}$分别当作公钥和私钥。 标签 对于给定消息$F=\lbrace u_1,\dots,u_l \rbrace \in Z^m_q$，Alice执行如下操作： 定义消息$F$的表促成为$id \in \lbrace 0,1 \rbrace ^{\ast}$。 计算$n$个向量$\alpha_j = H(id||j) \in Z^m_q$，其中$j \leq n$。 计算内积$h_{ij} = &lt;u_i, \alpha_j&gt;$，并组成向量$\vec{h_i}=(h_{i1},\dots,h_{in})^T$。 对于每个$i \in \lbrace 1,\dots, l \rbrace$，Alice运行定理二中的$SamplePre(A,T,\sigma,\vec{h_i})$生成向量$\vec{h_i}$标签$\vec{e_i}$。 联合 给定公钥$A$，身份标识$id$和一系列$(c_i,e_i)$，输出向量： $e_C = \sum_{i=1}^l c_i e_i$ $u_C = \sum_{i=1}^l c_i u_i$ $e_c$是消息$u_c$的签名。 验证 一收到联合的消息$u_C$和联合的标签，Bob执行如下操作： 计算$\alpha_j = H(id||j) \in Z^m_q$，其j \leq n$$。 计算联合消息$u_c = \sum_{i=1}^l c_i u_i$。 计算内积$h_{C_j} = &lt;u_C,\alpha_j&gt;$，并组成向量$h_C = (h_{C_1},\dots,h_{C_n})^T$。 当且仅当如下的条件满足，则接受联合标签$e_C$: $A_{e_C}=h_C(mod q)$ $||e_C|| \leq l \sigma \sqrt{m}$ 2. 云存储公开审计方案当同态标签被用来公开地检验云存储数据完整性时，一个事实必须被考虑。首先，验证没有标签的文件，并且不知道任何关于文件的任何信息。然后，同态标签方案指出批量验证，为了避免CSP存储联合信息，于是TPA必须根据由自己生成的挑战$chal$来验证。基于系统模型，云存储的公开审计方案如下： 初始化 云存储服务以一种协作和分布式的方式工作。为了存储用户的数据$F$到一系列云服务器上，$f$需要分成$l$个数据块$u_1,\dots,u_l,u_i \in Z^m_q$。 运行密钥$KeyGen$算法来获得用户的公钥$pk=\lbrace A \rbrace$和私钥$sk = \lbrace T \rbrace$。 对于$l$个数据块$u_1,\dots,u_l$，用户运行$Sign$算法，并输出相应的标签$e_1,\dots,e_l$。 用户发送文件$F=\lbrace u_1,\dots, u_l \rbrace$和相应的标签$e_1,\dots,e_l$到CSP，并删除本地数据文件$F=\lbrace u_1,\dots, u_l \rbrace$。 挑战]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NP问题理解]]></title>
    <url>%2F2018%2F10%2F02%2FNP%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[P问题、NP问题、NP难问题、NP完全问题 P问题：一个问题可以在多项式（O(n^k)）的时间复杂度内解决。 时间复杂度如(n^2, n^4, n(log(n)))都是多项式时间的，指数级别的如(2^n，n^n)这些就不是多项式时间了。 NP问题：给定一个解，我们可以在多项式时间内检查他正确与否的决策问题，为NP问题。 之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。 很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。 NP难问题：NP-hard问题：所有的NP问题都可以约化到它。 NP-hard问题是这样的问题，只要其中某个问题可以在P时间内解决，那么所有的NP问题就都可以在P时间内解决了。NP-c问题就是NP-hard问题。但注意NP-hard问题它不一定是NP问题，比如，下围棋就是NP-hard问题，但不是NP问题，我们要在一个残局上找一个必胜下法，告诉我们下一步下在哪里。显然，我们找不到这个解，而且更难的是，就算有人给我了一个解，我们也无法在P时间内判断它是不是正确的。 任意NP问题都可以在多项式时间内归约为该问题，但该问题本身不一定是NP问题。归约的意思是为了解决问题A，先将问题A归约为另一个问题B，解决问题B同时也间接解决了问题A。 归约为了说明NPC问题，引入–约化(规约)概念。 一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。 《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。 “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。 从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。 NP完全问题(NP-C问题)NP-c问题是这样的一类问题，首先他是属于NP的，而且他是NP问题里面最难解决的问题。难到什么程度？只要其中某个问题可以在P时间内解决，那么所有的NP问题就都可以在P时间内解决了。 NP-C问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。 既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P了。因此，给NPC找一个多项式算法太不可思议了。 NP-C问题既是NP问题，也是NP-hard问题。 四者关系 P问题属于NP问题，NP-C问题属于NP问题。 NP-C问题同时属于NP难问题，是NP与NP难问题的交集。 参考： 什么是NP问题，什么是NP hard问题，什么是NP完全问题 https://blog.csdn.net/u013089961/article/details/50069779 P、NP、NPC和NP-Hard相关概念的图形和解释： https://blog.csdn.net/huang1024rui/article/details/49154507]]></content>
      <tags>
        <tag>NP问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格理论与密码学--数学基础（一）]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6--%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍一些基本的数学概念和符号。 1.1 数论基础1.1.1 整除性和最大公因子若$a,b$是整数，则可以分别计算$a+b,a-b,a \cdot b$，且所得结果均是整数，这种性质称为对元素运算的封闭性。 但是对于除法运算并不能总是满足这种 运算封闭性。例如，不能用2去除3，因为3/2并不是整数，由此引出了整除性的基本概念。 定义1.1 设$a,b$是整数，$b \neq 0$。若存在整数$c$，满足$a=bc$，则称$b$整除$a$或$a$被$b$整除，即为$b|a$。 命题1.1 设$a,b,c \in Z$，则有： （1）若$a|b,b|c$，则$a|c$; （2）若$a|b,b|a$，则$a=\pm b$; （3）若$a|b,a|c$，则$a|(b+c)$且$a|(b-c)$。 定义1.2 $a$和$b$的公因子是能够同时整除二者的正整数。即，最大公因子就是满足$d|a,d|b$的最大的正整数$d$，用$gcd(a,b)$来表示。 定义1.7 记整数模$m$同余类环为： $Z/m ,Z={10,1,2,\dots,m-1}$ 注意到在同余类环种所进行的运算，所得结果均需模$m$以保持运算的封闭性。 群群是一种抽象的代数结构。简单地说，一个集合和在集合上满足某种性质的运算就构成了一个群。 定义1.13 群包含一个非空集合$G$和一个运算$\ast$，运算保持封闭性，即对与$a,b \in G$，有$a \ast b \in G$，并且要求运算$\ast$满足下述性质： 单位元：任取$a \in G$，存在$e \in G$，满足$e \ast a=a \ast e=a$。 逆元：任取$a \in G$，存在唯一的$a^{-1} \in G$，满足$a \ast a^{-1}=a^{-1} \ast a=e$。 结合律：任取$a,b,c \in G$，有$a \ast(b \ast c) = (a \ast b) \ast c$。 此外，，若满足交换律：任取$a,b \in G$，有$a \ast b = b \ast a$，则称$G$为交换群或阿贝尔群。 若$G$包含有限个元素，则称$G$为有限群。用$|G|$或$#G$来表示群中元素的数量，称为$G$的阶。 群相关的例子： 当$G=Z$，* = 加法，单位元$e=0$，$a$的逆元是$-a$，则$G$是无限群。 当$G=Z$，* = 乘法，则$G$不是群，因为$Z$的大多数元素在$Z$中并不存在乘法逆元。，比如2的乘法逆元1/2，不属于$Z$。 定义 1.14 设$G$是群，$a \in G$，假设存在正整数$d$满足$a^d = e$，则其中最小的$d$成为元素$a$的阶。若这样的阶不存在，则称$a$的阶位无穷大。 命题1.7 设$G$是一个有限群，则群中元素的阶都有限。此外，设$a \in G$且$a$的阶为$d$，当$a^k = e$，有$d|k$。 定理1.7 (Lagrange定理) 设$G$是有限群，$a \in G$，则$a$的阶能够整除$G$的阶。确切来说，设群$G$的阶位$n$，元素$a$的阶位$d$，则有$a^n = e,d|n$。 循环群 若—个群G的每—个元都是G的某—个固定元a的乘方，则称G为循环群，记作$G=(a)=\lbrace am |m∈Z \rbrace$，a称为G的—个生成元。特别地，如果G的代数运算采用加号表示时，则有 $(a)=\lbrace ma |m∈Z \rbrace$ 环群是在一个集合上定义了一种运算，这种运算可以令两个元素“相乘”并得到第三个元素。而环是在一个集合上定义“加法”和“乘法”两种运算，并存在分配律将他们联系起来。 定义1.15 环$R$就是在一个集合上定义了两种运算，分布用$+,*$来表示，并满足如下运算性质： 加法 单位元：任取$a \in R$，存在加法单元$0 \in R$，满足$0+a=a+0=a$。 负源：任取$a \in R$，存在加法负元$ \in R$，满足$a+b=b+a=0$。 结合律：任取$a,b,c \in R$，有$a+(b+c)=(a+b)+c$。 交换律：任取$a,b \in R$，有$a+b=b+a$。 简而言之，在加法运算的意义下，$R$可视为单位元为0的交换群。 乘法 单位元：任取$a \in R$，存在乘法单位元$1 \in R$，满足$1 \ast a=a \ast 1=a$。 结合律：任取$a,b,c \in R$，有$a \ast (b \ast c) = (a \ast b) \ast c$。 交换律：任取$a,b \in R$，有$a \ast b = b \ast a$。 注意到并没有要求元素具有乘法逆元。此外加法和乘法之间还满足分配律：任取$a,b,c \in R$，有$a \ast (b+c) = a \ast b + a \ast c$。 定义1.16 若环$R$中每个非零元素都要乘法逆元，则称$R$为域。 环和域的例子： R=Q，$\ast$ = 乘法，+ =加法。乘法单位元为1，且每个非零元都有乘法逆元，所以$Q$是一个域。 R=Z, $\ast$ = 乘法，+ =加法。乘法单位元为1，但只有1和-1有乘法逆元，所以Z只是环而不是域。 多项式环：若R是环，则可以构成系数取自R中的多项式环： $R[x] = \lbrace a_0 + a_1 x + a_2 x^2 + \dots + a_n x^n: n \geq 0, a_0, a_1, \dots, a_n \in R \rbrace$]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--分支语句和逻辑运算符（六）]]></title>
    <url>%2F2018%2F10%2F02%2FC%2B%2B%20Primer%20Plus--%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++提供了if和switch语句来进行决策，还有逻辑运算符和条件运算符。 6.1 if语句使用if语句来统计语句中的空格总数，实现如下： if.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int spaces = 0; int total = 0; cin.get(ch); while (ch != &apos;.&apos;) { if (ch == &apos; &apos;) spaces++; total++; cin.get(ch); } cout &lt;&lt; spaces &lt;&lt; &quot; spaces, &quot; &lt;&lt; total ; cout &lt;&lt; &quot; charachers total in sentence.\n&quot;; return 0; } 结果： The balloonist was an airhead with lofty goals. 6 spaces, 46 charachers total in sentence. 只要当ch为空格时，语句spaces++才被执行。因为语句total位于if语句的外面，因此每轮循环中都被执行。 6.1.1 if else语句if (test-condition) statement1 else statement2 如果测试条件为true，则程序将执行statement1，跳过statement2；如果测试条件为false，则程序将跳过statement1，执行statement2。 6.1.2 格式化if else语句如果操作部分需要多条语句，需要使用大括号将它们括起来，组成一个语句块。 if (ch == &apos;z&apos;) { zorro++; cout &lt;&lt; &quot;Another zorro candidate\n&quot;; } else { dull++; cout &lt;&lt; &quot;Not a Zorro candidate\n&quot;; } 6.1.3 if else if else结构实际中，可能需要程序提供两个以上的选择： if (ch == &apos;A&apos;) a_grade++; else if (ch == &apos;B&apos;) b_grade++; else soso++; 可以写成如下形式： if (ch == &apos;A&apos;) a_grade++; else if (ch == &apos;B&apos;) b_grade++; else soso++; 修改后的格式更为清晰。 ifelseif.cpp #include &lt;iostream&gt; using namespace std; const int Fave = 27; int main() { int n; cout &lt;&lt; &quot;Enter a number in the range 1-00 to find my favorite nmber: \n&quot;; do { cin &gt;&gt; n; if (n &gt; Fave) cout &lt;&lt; &quot;Too high -- guess again:&quot;; else if (n &lt; Fave) cout &lt;&lt; &quot;Too low -- guess agin: &quot;; else cout &lt;&lt; Fave &lt;&lt; &quot; is right!\n&quot;; }while (n != Fave); return 0; } 结果： Enter a number in the range 1-00 to find my favorite nmber: 22 Too low – guess agin: 44 Too high – guess again:27 27 is right! 错误防范： 表达式variable == value反转写成value == varibale。这样，可以捕获将相等运算符误写成赋值运算符的错误。 if (3 = var) 将一个变量赋给一个常量，编译器将生成错误信息。 if (var = 3) 这样，将3赋给一个变量，正确的语法，编译不会报错，于是会导致程序出错。 6.2 逻辑表达式C++提供了三种逻辑运算符，分别是：逻辑OR(||)、逻辑AND(&amp;&amp;)和逻辑NOT(!)。 6.2.1 逻辑OR运算符如果表达式中的任意一个或全部都为true，则得到的表达式为true。 5 == 5 || 5 == 9 //true 3 &lt;= 5 || 5 &gt;= 3 //true 1 &gt; 2 || 2 &gt; 3 //False ||运算符的优先级比关系运算符低，因此不需要添加括号。 C++规定，||运算符是个顺序点。即，先修改左侧的值，再对右侧的值进行判定。例如: i++ &lt; 6 || i == j 假设i越来的值为10，则在对i和j进行比较时，i的值将为11。另外，如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只要一个表达式为true，则整个逻辑表达式为true。 6.2.2 逻辑AND运算符仅当两个表达式都为true时，得到的表达式才为true。 5 == 5 &amp;&amp; 4 == 4//true 5 &lt; 3 &amp;&amp; 3 &gt; 2 //false &amp;&amp;运算符的优先级低于关系运算符，因此没必要添加括号。和||运算符一样，&amp;&amp;运算符也是顺序点，因此将先判定左侧，并且在右侧判定之前产生所有的副作用。如果左侧为false，则整个逻辑表达式为false，这种情况下，C++将不会再对右侧进行判定。 6.2.3 用&amp;&amp;来设置取值范围&amp;&amp;运算符还允许建立一系列if else if else语句，其中每种选择都对应一个特定的取值范围。 if (age &gt; 17 &amp;&amp; age &lt; 35) index = 0; else if (age &gt;= 35 &amp;&amp; age &lt; 50) index = 1; else if (age &gt;= 50 &amp;&amp; age &lt; 65) index = 2; else index = 3; 注意，下面语句： if (17 &lt; age &lt; 35) 编译器不会捕获这种错误，因为它仍然是合法的C++语法。&lt;运算符是从左向右结合，因此表达式含义如下： if ((17 &lt; age) &lt; 35) 但（17&lt;age）的结果要么为1，要么为0。不管哪种情况，表达式的值17&lt;age都要小于35，所以整个测试的结果总是true。 6.2.4 逻辑NOT运算符!运算符将它后面的表达式的真值取反。!运算符的优先级高于所有的关系运算符和算术运算符。因此，要对表达式取反，必须使用括号将其括起来，如下： !( x &gt; 5); !x &gt; 5; // 该表达式总是为false，!x为1或0，总是小于5 !运算符对于返回true-false值或可以被解释为true-false值的函数是很有用的。比如： !strcmp(s1,s2); 下面的程序来筛选可赋给int变量的数字输入。 not.cpp #include &lt;iostream&gt; #include &lt;climits&gt; using namespace std; bool is_int(double); int main() { double num; cout &lt;&lt; &quot;Enter an integer value:&quot;; cin &gt;&gt; num; while (! is_int(num)) { cout &lt;&lt; &quot;Out of range -- please try again:&quot;; cin &gt;&gt; num; } int val = int(num); cout &lt;&lt; &quot;You&apos;ve entered the integer &quot; &lt;&lt; val &lt;&lt; endl; return 0; } bool is_int(double x) { if (x &lt;= INT_MAX &amp;&amp; x &gt;= INT_MIN) return true; else return false; } 结果： Enter an integer value:1000000000000000 Out of range -- please try again:-1000000000000 Out of range -- please try again:444 You&apos;ve entered the integer 444 布尔函数is_int()使用了climits文件中定义的两个符号常量INT_MIN和INT_MAX来确定int类型的范围。 6.2.5 逻辑运算符细节AND和OR运算符的优先级都低于关系运算符。 !运算符的优先级都高于所有关系运算符和算符运算符。 逻辑AND运算符的优先级高于逻辑OR运算符，因此: age &gt; 30 &amp;&amp; age &lt; 45 || weight &gt; 300 被解释为： (age &gt; 30 &amp;&amp; age &lt; 45) || weight &gt; 300 当然，还可以使用括号来将所希望的解释告诉程序。例如： (age &gt; 30 || weight &gt; 300) &amp;&amp; donation &gt; 1000 C++确保程序从左向右进行逻辑运算表达式，并在知道了答案立刻停止。 6.2.6 其他表示方式使用标识符and、or和not来表示三种逻辑运算符。 运算符 另一种表示方式 &amp;&amp; and OR ! NOT 6.3 字符函数库cctypeC++继承了一个与字符相关的、非常方便的函数软件包，他可以简化如确定字符是否为大小写字母、数字、标点符号等工作，这些函数的原型在头文件cctype(老式的风格ctype.h)中定义。 下面使用AND和OR来测试字符ch是不是字母字符的代码： if (ch &gt;= &apos;a&apos; and ch &lt;= &apos;z&apos;) || (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) 与使用isalpha()相比： if (isalpha(ch)) isslpha()不仅更容易使用，而且更通用。 下面程序演示cctype库函数。 cctypes.cpp #include &lt;iostream&gt; #include &lt;cctype&gt; using namespace std; int main() { cout &lt;&lt; &quot;Enter text for analysis and type @ to terminate input:&quot;; char ch; int whitespace = 0; int digits = 0; int chars = 0; int punct = 0; int others = 0; cin.get(ch); while (ch != &apos;@&apos;) { if (isalpha(ch)) chars ++; else if (isspace(ch)) whitespace++; else if (isdigit(ch)) digits++; else if (ispunct(ch)) punct++; else others++; cin.get(ch); } cout &lt;&lt; chars &lt;&lt; &quot; letters, &quot; &lt;&lt; whitespace &lt;&lt; &quot; whitespace, &quot; &lt;&lt; digits &lt;&lt; &quot; digits, &quot; &lt;&lt; punct &lt;&lt; &quot; punctuations, &quot; &lt;&lt; others &lt;&lt; &quot; others.\n&quot;; return 0; } 结果： Enter text for analysis and type @ to terminate input: AdrenalVision Internationsl producer Adrienne Vismonger announced production of their new 3-D film, a remake of &quot;My Dinner with Andre,&quot; scheduled for 2013. @ 123 letters, 23 whitespace, 5 digits, 6 punctuations, 0 others. cctype中的字符函数： 函数名称 返回值 isalnum() 如果参数是字母数字，即字母或数字，该函数返回true isalpha() 如果参数是字母，该函数返回true iscntrl() 如果参数是控制字符，该函数返回true isdigit() 如果参数是数字(0~9),该函数返回true isgraph() 如果参数是除空格之外的打印字符，该函数返回true islower() 如果参数是小写字母，该函数返回true isprint() 如果参数打印字符（包括空格），该函数返回true ispunct() 如果参数是标点符号，该函数返回true isspace() 如果参数是标准空白字符，如空格、换行符、回车、制表符，该函数返回true isupper() 如果参数是大写字母，该函数返回true isxdigit() 如果参数是十六进制，该函数返回true tolower() 如果参数是大写字母，则返回小写字母 toupper() 如果参数是小写字母，则返回大写字母 6.4 ?:运算符C++常用?:运算符来代替if else语句，它C++中唯一的3个操作数的运算符。通用格式如下： expression1 ? expression2 : expression3 如果expression1为true，则整个表达式的值为expression2；否则，整个表达式的值为expression3。如下： 5 &gt; 3 ? 10 : 12 //5&gt;3为true，所以该表达式的值为19 3 == 0 ？ 25 : 18 // 3==0为false，所以表达式的值为18 condit.cpp #include &lt;iostream&gt; int main() { using namespace std; int a, b; cout &lt;&lt; &quot;Enter two integers: &quot;; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; &quot;The larger of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b; int c = a &gt; b ? a :b; cout &lt;&lt; &quot; is &quot; &lt;&lt; c &lt;&lt; endl; return 0; } 结果: Enter two integers: 2 3 The larger of 2 and 3 is 3 将条件表达式嵌套在另一个条件表达式中，如下： const char x[2][20] = {&quot;Jason &quot;, &quot;at your serviece\n&quot;}; const char * y = &quot;Quillstone &quot;; for (int i = 0; i &lt; 3; i++) cout &lt;&lt; ((i &lt; 2) ? !i ? x[i]:y : x[i]); 这是一种费解的方式，他按下面的顺序打印3个字符串： Jasn Qullstone at your service 从可读性来说，条件运算符最适合简单关系和简单表达式的值。 6.5 switch语句用户从5个选项中选择一个，虽然可以扩展if else if else来处理，但C++的switch语句能够更容易地从大型列表中进行选择。switch语句的通用格式： switch (integer-expression) { case label1: statement(s); case label2: statement(s); default: statement(s); } switch.cpp #include &lt;iostream&gt; using namespace std; void showmenu(); void report(); void comfort(); int main() { showmenu(); int choice; cin &gt;&gt; choice; while (choice != 5) { switch (choice) { case 1 : cout &lt;&lt; &quot;\a\n&quot;; break; case 2 : report(); break; case 3 : cout &lt;&lt; &quot;The boss was in all day.\n&quot;; break; case 4 : comfort(); break; default : cout &lt;&lt; &quot;That&apos;s not a choce.\n&quot;; } showmenu(); cin &gt;&gt; choice; } cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } void showmenu() { cout &lt;&lt; &quot;Please enter 1,2,3,4,5:\n&quot; &quot;1) alarm 2) report\n&quot; &quot;3) alibi 4) comfort\n&quot; &quot;5) quit\n&quot;; } void report() { cout &lt;&lt; &quot;It&apos;s been an excellent week for business.\n&quot;; } void comfort() { cout &lt;&lt; &quot;Your employees think you are the fines CEO in the induesty.\n&quot;; } 当用户输入5时，while循环结束。输入1到4将执行switch列表中相应的操作，输入6将执行默认语句。 同时，也可以使用字符(而不是整数)作为菜单选项和switch标签，则可以为大写标签和小写标签提供相同的语句： char choice; switch (choice) { case &apos;a&apos; : case &apos;A&apos; : cout &lt;&lt; &quot;\a\n&quot;; break; case &apos;b&apos; : case &apos;B&apos; : report(); break; case &apos;c&apos; : case &apos;C&apos; : cout &lt;&lt; &quot;The boss was in all day.\n&quot;; break; case &apos;d&apos; : case &apos;D&apos; : comfort(); break; default : cout &lt;&lt; &quot;That&apos;s not a choce.\n&quot;; } 由于case ‘a’后面没有break语句，因此程序将执行下一行–case ‘A’后面的语句。 6.5.1 将枚举用作标签使用enum定义了一组相关常量，然后在switch语句中使用这些常量。通常，cin无法识别枚举类型，因此该程序要求用户选择选项时输入一个整数。将switch语句将int值和枚举标签进行对比时，将枚举类型提升为int。 enum.cpp #include &lt;iostream&gt; enum {red, orange, yellow, green, blue, violet, indigo}; using namespace std; int main() { cout &lt;&lt; &quot;Enter color code(0-6):&quot;; int code; cin &gt;&gt; code ; while (code &gt;= red and code &lt;= indigo) { switch(code) { case red : cout &lt;&lt; &quot;Her lips were red.\n&quot;; break; case orange : cout &lt;&lt; &quot;Her hair was orange.\n&quot;; break; case yellow : cout &lt;&lt; &quot;Her sheos were yellow.\n&quot;; break; case green : cout &lt;&lt; &quot;Her nails were green.\n&quot;; break; default : cout &lt;&lt; &quot;Others.\n&quot;; } cout &lt;&lt; &quot;Enter color code (0-6):&quot;; cin &gt;&gt; code; } cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } 结果： Enter color code(0-6):0 Her lips were red. Enter color code (0-6):2 Her sheos were yellow. Enter color code (0-6):6 Others. Enter color code (0-6):7 Bye! 6.5.2 switch和if elseswitch语句和if else语句都允许程序从选项中进行选择。if else更通用，它可以处理取值范围。而switch并不是为处理范围而设计的，switch语句中的每一个case标签都必须时一个单独的值。另外，这个值必须是整数（包括char）,因此switch无法处理浮点测试。另外，case标签值必须是常量。 6.6 break和continuebreak和continue语句都是程序能过跳过部分代码。可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行。continue语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环。如下图： jump.cpp #include &lt;iostream&gt; const int ArSize = 80; int main() { using namespace std; int letter = 0; char line[ArSize]; cout &lt;&lt; &quot;Enter a line of text:\n&quot;; cin.get(line, ArSize); cout &lt;&lt; &quot;Complete line:\n &quot; &lt;&lt; line &lt;&lt; endl; cout &lt;&lt; &quot;Line through first period:\n&quot;; for (int i = 0; line[i] != &apos;\0&apos;; i++) { cout &lt;&lt; line[i]; if (line[i] == &apos;.&apos;)//遇到句号，结束循环 break; if (line[i] == &apos; &apos;) //只统计字母个数，空格跳过，则下面的语句将不会执行 continue; letter++; //统计字母个数 } cout &lt;&lt; endl &lt;&lt; letter &lt;&lt; &quot; letters.\n&quot;; return 0; } 结果： Enter a line of text: Let&apos;s do lunch today. you can pay! Complete line: Let&apos;s do lunch today. you can pay! Line through first period: Let&apos;s do lunch today. 17 letters. 程序说明 虽然continue语句导致该程序跳过循环体的剩余部分，但不会跳过循环的更新表达式。在for循环中,continue语句使程序直接跳到更新表达式，然后跳到测试表达式。然而，对于while循环，continue将使程序直接跳到测试表达式，因此while循环中位于continue之后的更新表达式都被跳过。在某些情况下，这是一个问题。 6.7 读取数字的循环将一系列数字读入数组中，并允许用户在数组填满之前结束输入，利用如下代码： int n; cin &gt;&gt; n; 如果用户输入一个单词，而不是一个数字，发送这种类型匹配情况时，将发生4种情况： n的值保持不变 不匹配的输入将留在输入队列种 cin对象中的一个错误标记被设置 对cin方法的调用将返回false 假设编写一个程序，来计算每天捕获的鱼的重量。这里假设每天最多捕获5条鱼，因此一个包含5个元素的数组将足以存储所以的数据，但也可能没有捕获这么多。如果数组被填满或输入了非数字输入，循环将结束。 cinfish.cpp #include &lt;iostream&gt; using namespace std; const int Max = 5; int main() { double fish[Max]; cout &lt;&lt; &quot;Please enter the weights of your fish.\n&quot;; cout &lt;&lt; &quot;You may enter up to &quot; &lt;&lt; Max &lt;&lt; &quot; fish &lt; q to terminate&gt;.\n&quot;; cout &lt;&lt; &quot;fish #1: &quot;; int i = 0; while (i &lt; Max and cin &gt;&gt; fish[i]) { if (++i &lt; Max) cout &lt;&lt; &quot;fish # &quot; &lt;&lt; i+1 &lt;&lt; &quot;: &quot;; } double total = 0.0; for (int j= 0; j&lt; i; j++) total += fish[j]; if (i == 0) cout &lt;&lt; &quot;No fisht.\n&quot;; else cout &lt;&lt; total / i &lt;&lt; &quot; average weight of &quot; &lt;&lt; i &lt;&lt; &quot; fish.\n&quot;; return 0; } 结果： Please enter the weights of your fish. You may enter up to 5 fish &lt; q to terminate&gt;. fish #1: 10.2 fish # 2: 2.3 fish # 3: 4.5 fish # 4: q 5.66667 average weight of 3 fish. [root@localhost ~]# ./a.out Please enter the weights of your fish. You may enter up to 5 fish &lt; q to terminate&gt;. fish #1: q No fisht. 上述程序中，cin&gt;&gt;fish[i]实际上是一个cin方法函数调用，该函数返回cin。如果cin位于测试条件中，则将被转化为bool类型。如果输入成功，则转换后为true，否则为false。 当用户输入的不是数字时，该程序将不再读取输入。下面再看一个例子，假设程序要求用户提供5个高尔夫得分，以计算平均分。如果用户输入非数字，程序拒绝，并要求用户继续输入数字。可以看到，可以使用cin输入表达式来检测输入是不是数字。程序发现用户输入了错误内容时，应采取3个步骤： 重置cin以接受新的输入 删除错误输入 提示用户重新输入 cingolf.cpp #include &lt;iostream&gt; const int Max = 5; using namespace std; int main() { int golf[Max]; cout &lt;&lt; &quot;Enter your golf scores.\n&quot;; cout &lt;&lt; &quot;You must enter &quot; &lt;&lt; Max &lt;&lt; &quot; rounds.&quot;; for (int i = 0; i &lt; Max; i++) { cout &lt;&lt; &quot;Round# &quot; &lt;&lt; i+1 &lt;&lt; &quot; : &quot; ; while (!(cin &gt;&gt; golf[i])) { cin.clear(); while(cin.get()!=&apos;\n&apos;) continue; cout &lt;&lt; &quot;Please enter a number: &quot;; } } double total = 0.0; for (int i = 0; i&lt; Max; i++) total += golf[i]; cout &lt;&lt; total/Max &lt;&lt; &quot; = average score &quot; &lt;&lt; Max &lt;&lt; &quot; rounds.\n&quot;; return 0; } 结果： Enter your golf scores. You must enter 5 rounds. Round# 1 : 88 Round# 2 : i Please enter a number: k Please enter a number: 4 Round# 3 : 5 Round# 4 : 9 Round# 5 : ? Please enter a number: 44 30 = average score 5 rounds. clear()方法重置输入，如果省略这条语句，程序将拒绝继续读取输入。程序中如下代码的作用是： while(cin.get()!=&apos;\n&apos;) continue; 读取行尾之前的所有输入，从而删除这一行的错误输入。 6.8 简单文件输入/输出C++使得将读取键盘输入和在屏幕上显示输出的技巧用于文件输入/输出(文件I/O)非常简单。 6.81 文本I/O和文本文件使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据–文本数据。然后，cin对象负责将文本转换为其他类型。 char ch; cin &gt;&gt; ch; 输入实例为： 38.5 19.2 输入行中的第一个字符被赋给ch。在这里第一个字符是数字3，其字符编码(二进制)被存储在变量ch中。输入和目标变量都是字符，因此不需要进行转换。注意，这里存储的不是数值3，而是字符3的编码。 int n; cin &gt;&gt; n; 在这种情况下，cin将不断读取，直到遇到非数字符号。也就是说，它读取3和8，这样句点将成为输入队列中的下一个字符。cin通过计算发现，这两个字符对应数字是38，因此将38的二进制编码复制到变量n中。 接下来看double类型： double x; cin &gt;&gt; x; 在这种情况下，cin将不断读取，直到遇到第一个不属于浮点数的字符。即，cin读取3、8、句点和5，使得空格成为输入队列中的下一个字符。cin通过计算发现，这四个字符对应数字38.5，因此将38.5的二进制编码复制到变量x中。 接下来看看char数组的情况： char word[50]; cin &gt;&gt; word; 在这种情况下，cin将不断读取，直到遇到空白字符。即，它读取3、8、句点和5，使得空格成为输入队列中的下一个字符。然后，cin将这4个字符编码存储到输入word中，并在末尾加上一个空字符，这里需要进行任何转换。 最后，看一下另一种使用char数组来存储输入的情况： char word[50]; cin.getline(word,50); 在这种情况下，cin将不断读取，直到遇到换行符。所有字符都将被存储到数组word中，并在末尾添加一个空字符。换行符被丢弃，输入队列中的下一个字符是下一行的第一个字符。这里不进行任何转换。 对于输出，将执行相反的操作。即整数被转换为数字字符序列，浮点数被转换为数字字符和其他字符组成的字符序列。字符数据不需要做任何转换。 这里的要点是：输入一开始都是文本。因此，控制台输入的文件版本是文本文件，即每个字节都存储了一个字符编码的文件。并非所有的文件都是文本文件，比如，数据块和电子表格以数值格式（即二进制整数或浮点格式）存储数值数据。 6.8.2 写入的文本文件中文件输出： 必须包含头文件fstream; 头文件fstream定义了一个用于处理输出的ofstream类； 需要声明一个或多个ofstream变量，并以自己喜欢的方式对其进行命名； 必须指明命名空间std; 需要将ofstream对象与文件关联起来，为此方法之一是使用open()方法； 使用完文件后，应使用方法close()将其关闭； 可结合使用ofstream和运算符&lt;&lt;来输出各种类型的数据。 iostream头文件提供了一个预先定义好的名为cout的ostream对象，但您必须声明自己的ofstream对象，为其命名，并将其同文件关联。声明对象如下： ofstream outFile; 关联文件如下： outFile.open(&quot;fish.txt&quot;); char filename[50]; cin &gt;&gt; filename; outFile.open(filename); open()接受一个c-风格字符串作为输入，可以是字面字符串，也可以是存储在数组中的字符串。 使用文件输出的主要步骤如下： 包含头文件fstream; 创建一个ofstream对象； 将该ofstream对象同一个文件关联起来; 将像使用cout那样使用该ofstream对象。（如：&lt;&lt;,endl和setf()都可用于ofstream对象）。 outfile.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { char automobile[50]; int year; double a_price; double b_price; ofstream outFile; outFile.open(&quot;carinfo.txt&quot;); cout &lt;&lt; &quot;Enter the amke and model of automobile: &quot;; cin.getline(automobile, 50); cout &lt;&lt; &quot;Enter the model year: &quot;; cin &gt;&gt; year; cout &lt;&lt; &quot;Enter the original asing price: &quot;; cin &gt;&gt; a_price; b_price = 0.913 * a_price; cout.precision(5); cout.setf(ios_base::showpoint); cout &lt;&lt; &quot;Make and model: &quot; &lt;&lt; automobile &lt;&lt; endl; cout &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; endl; cout &lt;&lt; &quot;Was asing: $&quot; &lt;&lt; a_price &lt;&lt; endl; cout &lt;&lt; &quot;Now asking: $&quot; &lt;&lt; b_price &lt;&lt; endl; outFile.precision(5); outFile.setf(ios_base::showpoint); outFile &lt;&lt; &quot;Make and model: &quot; &lt;&lt; automobile &lt;&lt; endl; outFile &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; endl; outFile &lt;&lt; &quot;Was asking: $&quot; &lt;&lt; a_price &lt;&lt; endl; outFile &lt;&lt; &quot;Now asking: $&quot; &lt;&lt; b_price &lt;&lt; endl; outFile.close(); return 0; } 结果： 在程序运行之前，并不存在carinfo.txt文件。在这种情况下，open()将新建一个名为carinfo.txt的文件。如果在此程序运行前，该文件已存在。默认情况下，open()将首先截断该文件，即将其长度截断为零—丢弃原有的内容，然后将新的输入加入到该文件中。 6.8.3 读取文本文件文件输入： 必须包含头文件fstream; 头文件fstream定义了一个用于处理输入的ifstream类； 需要声明一个或多个ifstream变量，并以自己喜欢的方式对其进行命名； 必须指明命名空间std; 需要将ifstream对象与文件关联起来，为此方法之一是使用open()方法； 使用完文件后，应使用方法close()将其关闭； 可结合使用ifstream和运算符&gt;&gt;来输出各种类型的数据; 可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符； 可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功； ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将转换为true，否则为false。 ifstream对象的声明： ifstream inFile; 关联文件： inFlie.open(&quot;bowling.txt&quot;); 如果试图打开一个不存的文件用于输入，这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的方法：is_open()。 inFile.open(&quot;bowling.txt&quot;); if (!inFile.is_open()) exit(EXIT_FAILURE); 函数exit()的原型在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数数值EXIT_FAILURE。函数exit()终止程序。 方法is_open()是C++中比较新的内容。可以使用方法good()来代替。 sumafile.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; const int SIZE = 60; int main() { char filename[SIZE]; ifstream inFile; cout &lt;&lt; &quot;Enter name of data file: &quot;; cin.getline(filename,SIZE); inFile.open(filename); if (!inFile.is_open()) { cout &lt;&lt; &quot;Could not open the file &quot; &lt;&lt; filename &lt;&lt; endl; cout &lt;&lt; &quot;Program terminating.\n&quot;; exit(EXIT_FAILURE); } double value; double sum = 0.0; int count = 0; inFile &gt;&gt; value; while (inFile.good()) { ++count ; sum += value; inFile &gt;&gt; value; } if (inFile.eof()) cout &lt;&lt; &quot;End of file reached.\n&quot;; else if (inFile.fail()) cout &lt;&lt; &quot;Input terminatd by data mismatch.\n&quot;; else cout &lt;&lt; &quot;Input terminated for unknown reasion.\n&quot;; if (count == 0) cout &lt;&lt; &quot;No data processed.\n&quot;; else { cout &lt;&lt; &quot;Items read: &quot; &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;Average: &quot; &lt;&lt; sum/count &lt;&lt; endl; } inFile.close(); return 0; } 结果： 文件循环读取设计时，需要注意几点。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof()返回true。其次，程序可能遇到类型不匹配，方法fail()返回true(如果遇到EOF，该方法也返回true)。最后，可能出现意外的问题，如文件损坏或硬件故障。如果最后一次读取文件出现了这样的问题，方法bad()将返回true。不要分布检查这些情况，一种更简单的方式是使用good()方法，该方法在没有发送任何错误时返回true。同时，可以使用其他方法来确定循环终止的原因，如下： if (inFile.eof()) cout &lt;&lt; &quot;End of file reached.\n&quot;; else if (inFile.fail()) cout &lt;&lt; &quot;Input terminatd by data mismatch.\n&quot;; else cout &lt;&lt; &quot;Input terminated for unknown reasion.\n&quot;; 方法god()指出最后一次读取输入的操作成功与否。标准的做法： inFile &gt;&gt; value; while (inFile.good()) { ++count ; sum += value; inFile &gt;&gt; value; } 由于表达式inFile &gt;&gt; value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为inFile().good()，即true或false。于是，两条输入语句用一条用作循环测试的语句代替。因此可以简化上面标准做法，如下： while(inFile &gt;&gt; value) { sum += value; ++count; } 6.9 总结if语句、if else语句和switch语句 逻辑运算符 文件输出和输入]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格-数据基础]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%A0%BC-%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[格密码是一类备受关注的抗量子计算攻击的公钥密码体制。格密码理论的研究设计的密码数学问题很多。 引用：王小云, 刘明洁. 格密码学研究[J]. 密码学报, 2014, 1(1): 13–27. 1.前言格理论的研究源于1611年开普勒提出的如下猜想：在一个容器中堆放等半径的小球所能达到的最大密度是$\pi/ \sqrt(18)$。1840年前，高斯引进了格的概念并证明：在三维空间堆球，如果所有的球心构成一个格，那么堆积密度所能达到的最大值是$\pi/ \sqrt(18)$。 格是$R^m$中一类具有周期性结构离散点的集合。严格地说，格是m维欧式空间$R^m$的$n(m /geq n)$个线性无关向量组$b_1,b_2,\dots,b_n$的所有整系数线性组合，即： 向量组$b_1,b_2,\dots,b_n$称为格的一组基。同一个格可以用不同的格基表示，$m$称为格的维数，$n$称为格的秩。当满足$m=n$的格称为满秩的。通常只考虑满秩的格。下面介绍一些格理论的基本概念和困难问题：]]></content>
      <categories>
        <category>云数据完整性验证</category>
      </categories>
      <tags>
        <tag>云数据完整性验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(三)--数据链路层]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E4%B8%89)--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[数据链路层属于计算机网络的底层，数据链路层使用的信道主要有以下两种类型：(1)点对点信道；(2)广播信道。 3.1 点对点信道的数据链路层3.1.1 数据链路和帧链路：从一个点到相邻节点的一段物理链路，而中间没有任何其他的交换节点。 数据链路：在一条线路上传输数据时，除了一条必须的物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。把实现这些协议的硬件和软件加到链路上，构成了数据链路。 数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据去除并上交给网络层。在因特网中，网络层协议数据单元就是IP数据报（或简称数据报、分组或包）。 点对点信道的数据链路层进行通信时的主要步骤： 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。 结点A把封装好的帧发送给结点B的数据链路层。 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则丢弃这个帧。 3.1.2 三个基本问题数据链路层协议有许多种，但有三个基本问题则是共同的。这三个问题是：封装成帧、透明传输和差错检测。 1、封装成帧封装成帧就是在一段数据的前后分别添加首部和尾部。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。 首部和尾部的一个重要作用就是进行帧界定。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧的首部开始发送。为了提高效率，应当使帧的数据部分长度大于首部和尾部的长度，但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送单元MTU。 当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。ASCII码是7位编码，一个可组成128个不同的ASCII码，其中可打印的有95个，而不可打印的控制字符有33个。如下图，可以说明帧定界的概念，一个控制符SOH放在一个帧的最前面，表示帧的首部开始。另一个控制符EOF表示帧的结束。请注意SOH和EOT都是控制字符的名称。它们的十六进制编码分别为01(二进制00000001)和04(00000100)。 当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。当随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，在接收端知道前面收到的数据是个不完整的帧（只有首部开始符SOH，而没有传输结束符EOT），必须丢弃。 2.透明传输由于帧的开始和结束的标记是使用专门指明的控制字符，因此在所传输的数据中的任何8个比特的组合一定不允许和帧界定的控制字符的比特编码一样，否则就会出现帧定界的错误。 当传送的帧是文本文件组成的时，其数据部分不会出现像SOH或EOT这样的帧定界控制字符。但当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和EOT和SOH这种控制字符一样，如下图，数据链路层就会错误地找到帧的边界。 像上图这样的传输就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”被错误地解释为“传输结束”的控制符，而在其后面的数据应找不到“SOH”被接收端当作无效帧而丢弃。 透明表示：某一个实际存在的事物看起来却是好像不存在一样。在数据链路层透明传送数据，表示无论什么样的比特组合的数据都能够通过这个数据链路层。 为了解决透明传输问题，就必须设法将数据中可能出现的控制字符”SOH“和”EOT“在接收端不被解释未控制字符。具体的方法是： 发送端的数据链路层在数据中出现控制字符”SOH“和”EOT“的前面插入一个转义字符”ESC“（其十六进制编码是1B,二进制是00011011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充或字符填充。 如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此当接收端连续收到两个转义字符时，就删除其中前面的一个。 3.差错检测比特在传输的过程中可能回产生差错：1可能会变成0，而0可能变成1，这就是比特差错。 在一段时间内，传输错误的比特占所所传输比特总数的比率为误码率BER。误码率与信噪比有很大关系，如果设法提高信噪比，就可以使误码率减小。实际的通信链路并非是理想的，不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施，目前在数据链路层广泛采用了循环冗余检验CRC的检错技术。 下面通过一个简单的例子来说明循环冗余检验的原理： 在接收端，先把数据划分为组，假定每组k个比特。现假定带传送的数据$M=101001(k=6)$。CRC运算就是在数据$M$的后面添加供差错检验用的$n$位冗余码，然后构成一个帧发送出去，一共发送$(k+n)$位。在所要发送的数据后面增加n位的冗余码，虽然增加了数据传输的开销，但却可以进行差错检验。 这n位冗余码可用以下方法得出：用二进制的模2运算进行$2^n$乘$M$的运算，这相当于在$M$后面添加$n$个0。得到的$(k+n)$位的数除以收发双方事先设定的长度位$(n+1)$位的除数$P$，得出商是$Q$而余数是$R$(n位，比P少一位)。在下图所示的例子中，M=101001(即k=6)。假定除数P=1101(即n=3)。经模2除法运算后的结果是：商Q=110101(这个商并没有什么用处)，而余数R=001。这个余数R就作为冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码被称为帧检验序列FCS。因此加上FCS后发送的帧是101001001（即$2^nM+FCS$）,共有(k+n)位。 CRC是一种检错方法，而FCS是添加在数据后面的冗余码，在检错方法上可以选用CRC，但也可不是CRC。 在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以相同的除数$P$(模2运算)，然后检验得到的余数R。 如果传输过程中误差错，那么经过CRC检验后得出的余数R肯定是0。但如果出现错码，那么余数R仍等于零的概率是非常非常小的。 总之，在接收端对收到的每一帧经过CRC检验后，有以下两种情况： 若得出的余数R=0，则判定这个帧没有差错，就接收。 若余数$R \seq 0$，则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错）。 在数据链路层，发送端帧检验序列FCS的生成和接收端的CRC检验都是硬件完成的，处理很迅速，因此并不会延误数据的传输。 现在并没有要求数据链路层向网络层提供”可靠传输“的服务，所谓可靠传输就是:数据链路层的发送端发送什么，在接受端就收到什么。 传输差错可分为两大类： 一类是最基本的比特差错； 另一类传输差错更复杂些，帧没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。 在数据链路层使用CRC检验，能过实现无比特差错的传输，但这还不是可靠传输。OSI：必须让数据链路层向上提供可靠传输，因此在CRC检错的基础上，增加了帧编码、确认和重传机制。 3.2 点对点协议PPP在通信线路质量较差的年代，使用能实现可靠传输的高级数据链路控制HDLC就成为当时比较流行的数据链路层协议。但现在HDLC已很少使用了。对于点对点的链路，简单得多得点对点协议PPP(Point-to-Point Protocol)则是目前使用得广泛得数据链路层协议。 3.2.1 PPP协议的特点因特网用户通过要连接到某个ISP才能接入到因特网。PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议。 PPP协议有三个组成部分： 一个将IP数据封装到串行链路的方法。PPP既支持异步链路（无奇偶检验的比特数据），也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元MTU的限制。 一个用来建立、配置和测试数据链路连接的链路控制协议LCP。 一套网络控制协议NCP，其中的每一个协议支持不同的网络层协议。 3.2.2 PPP协议的帧格式1. 各字段的意义PPP的帧格式如下图，PPP帧的首部和尾部分别为四个字段和两个字段。 首部的第一个字段和尾部的第二个字段都是标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是十六进制，十六进制的7E的二进制表示是01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是PPP帧的定界符。 首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011）。最初曾考虑以后再对这两个字段的值进行其他定义，但至今也没有给出。 PPP首部的第四个字段2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021，则信息字段是PPP链路控制协议LCP的数据，而0x8021表示这是网络层的控制数据。 信息字段的长度是可变的，不超过1500字节。 尾部中的第一个字段(2字节)是使用CRC的帧检验序列FCS。 2. 字节填充当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些使用形式上和标志字段一样的比特组合不出现在信息字段中。 当PPP使用异步传输时，它把转义符定义为0x7D（即01111101），并使用字节填充。RFC 1662规定了如下所述的填充方法: 把信息字段中出现的每一个0x7E字节转变成2字节序列（0x7D,0x5E）。 若把信息字段中出现一个0x7D的字节（即出现了和转义字符一样的比特组合），则把0x7D转变成2字节序列(0x7D,0x5D)。 若信息字段中出现ASCII码的控制字符(即数值小于0x20的字符)，则在该字符前面加入一个0x7D字节。例如：出现0x03(在控制字符中式”传输结束“ETX)就要把他转变为2字节序列(0x7D,0x23)。 3. 零比特填充PPP协议用在SONET/SDH链路时，是使用同步传输(一连串的比特连续传送)而不是异步传输(逐个字符地传送)。在这种情况下，PPP协议采用零比特填充方法来实现透明传输。 零比特填充的具体做法是：在发送端，向扫描整个信息字段。只要发现有5个连续1，则立即填入一个0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段F以确定一个帧的边界，紧接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。 这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。 3.3 使用广播信道的数据链路层3.3.1 局域网的数据链路层局域网的数据链路层拆分成两个子层：逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层。与接入到传输媒体有关的内容放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的。 适配器的作用： 计算机与外界局域网的连接是通过通信适配器。适配器本来是在主机箱内插入的一块网络接口板（或者是在笔记本电脑中插入一块PCMCIA卡—个人计算机存储器卡接口适配器）。这种接口板又称为网络接口卡NIC。 在适配器上面装有处理器和存储器(包括：RAM和ROM)。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的I/O总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。 3.3.2 CSMA/CD协议最早的以太网就是将许多计算机连到一个总线上。 总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。这种就是广播通信方式。 但是不总是要在局域网上进行一对多的广播通信，为了在总线上实现一对一的通信，可以使计算机的适配器拥有一个与其他适配器都不同的地址。在发送数据帧时，在帧的首部写明接收站的地址。仅当数据帧中的目的地址与适配器ROM中存放的硬件地址一致时，该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧丢弃。这样，具有广播特性的总线上实现了一对一的通信。 为了通信方便，以太网采用两种措施： 采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编码，也不要求对方发回确认。 以太网发送的数据都使用曼切斯特编码的信号。 CSMA/CM协议的要点： “多点接入”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。 “载波监听”就是用电子技术检测总线上有没有其他计算机也在发送。其实总线上并没有什么“载波”，这里只不过借用“载波”这个名词。因此载波监听就是检测新的。不管在发送前，还是在发送中，每个站都必须不停地检测信道。在发送前检测信道，是为了获得发送权。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。 “碰撞检测”也就是“边发送边监听”，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。如果几个站同时在总线上发送数据，总线上的信号电压幅度会增大（相互叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值，就认为总线上至少有两个站同时发送数据，表明产生了碰撞。所谓“碰撞”就是发送了冲突。因此碰撞检测，也称为“冲突检测”。如果发现总线出现了碰撞，其适配器就要立即停止发送，免得继续进行无效发送，浪费网络资源，然后等待一段随机时间再次发送。 既然每一个站在发送数据之前已经监听到信道为“空闲”，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波在总线上总是以有限的速率传播的。下图说明了这种情况。设图中的局域网两端的站A和B相局1km，用同轴电缆相连。电磁波在1km电缆的传播时延为5$\mu s$。因此，A向B发出的数据，在约5$\mu s$后才能传到B。换言之，B若在A发送的数据到达B之前发送自己的帧（因为这时B的载波监听检测不到A所发送的信息），则必然要在某个时间和A发送的帧发送碰撞。碰撞的结果是两个帧都变得无用。 在局域网的分析中，常把总线上的单程端到端传播时延记为$\tau$。发送数据的站希望尽早知道是否发生了碰撞。从图中可知，最多是两倍的总线端到端的传播时延$(2\tau)$，发送者知道自己的数据和其他站发送的数据有没有发生碰撞。 显然，在使用CSMA/CD协议时，一个站不可能同时进行发送和接受（但必须边发送边监听信道）。因此使用CSMA/CD协议的以太网不可能进行全双工通信，而只能进行双向交替通信(半双工通信)。 从上图可以看出，最先发送数据帧的A站，在发送数据帧后至多经过时间$2\tau$就可知道所发送的数据帧是否遭受了碰撞。这就是$\delta \rightarrow 0$的情况。因此以太网的端到端往返时间$2\tau$称为争用期。争用期又称为碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发送碰撞。这时，就可以放心把这一帧数据顺序发送完毕。 以太网使用截断二进制指数退避算法来确定碰撞后重传的时机。这种算法让发送碰撞的站在停止发送数据后，不是等待信道变为空闲后立即再发送数据，而是推迟一个随机的时间。这点很容易理解，因为如果几个发送碰撞的站都再监听信道，那么都会同时发现信道变为了空闲。如果大家同时再重新发送，那么肯定又发送了碰撞。为了使各站进行重传时再发送冲突的概率减少，具体的退避算法如下： （1）协议规定了基本退避时间为争用期$2\tau$，具体的争用期时间是$51.2\mu s$。对于$10Mb/s$以太网，再争用期内可发送$512bit$，即64字节。也可以说争用期是512比特时间。1比特时间就是发送1比特所需的时间。 （2）从离散的整数集合$[0,1,\dots, (2^k-1)]$中随机取出一个数，即为$r$。重传应推后的时间就是$r$倍的争用期。上面的参数$k$的计算如下： $k = Min[重传次数，10]$ 可见当重传次数不超过10时，参数$k$等于重传次数；但当重传的次数超过10时，$k$就不再增大而一直等于10。 （3）当重传达16次仍不能成功时（这表明同时打算发送数据的站太多，以至连续发送冲突），则丢弃该帧，并向高层报告。 3.4 使用广播信道的以太网3.4.1 使用集线器的星形拓扑传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub)。如下图所示，双绞线以太网总是和集线器配合使用的。每个站需要用两对无屏蔽双绞线（放在一根电缆内），分别用户发送和接受。双绞线的两端使用RJ-45插头。由于集线器使用了大规模集成电路芯片，因此集线器的可靠性就大大提高了。1990年，IEEE指定了星形以太网10BASE-T的标准802.3i。“10”代表10Mb/s的数据率，BASE表示连接线上的信号是基带信号，T代表双绞线。 但10BASE-T以太网的通信距离稍短，每个站到集线器的距离不超过100m。 使双绞线能够传送高速数据的主要措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀减少失真，而且大大减少了电磁波辐射和无线电频率得干扰。 集线器的特点： 使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA\CD协议。 一个集线器有许多接口，例如8至16个，每个接口通过RJ-45插头用两对双绞线于一个工作站上的适配器相连。 集线器工作在物理层，它的每个接口仅仅简单地转发比特–收到1就转发1，收到0转发0，不仅碰撞检测。 集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使转发出去的较强信号不致对该接口收到的较弱信号产生干扰。 3.4.2 以太网的信道利用率3.4.3 以太网的MAC层1.MAC层的硬件地址在局域网中，硬件地址又称为物理地址或MAC地址（因为这种地址用在MAC帧中）。 IEEE802标准为局域网规定了一种48位的全球地址，是指局域网上的每一计算机中固化在适配器的ROM中的地址。 2.MAC帧的格式常用的以太网MAC帧格式有两种格式，一种是DIX Ethernet V2标准（即以太网V2标准），另一种是IEEE的802.3。这里只介绍使用最多的以太网V2的MAC帧格式，如下图。图中，假定网络层使用的是IP协议。 以太网V2的MAC帧比较为简单，由5个字段组成。前两个字段分别为6个字节的目的地址和源地址。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。第四个字段是数据字段，其长度在46到1500字节之间（最小长度64字节减去18字节的首部和尾部就得出数据字段的最小长度）。最后一个字段是4字节的帧检验序列FCS(使用CRC检验)。 MAC帧其首部没有一个帧长度（或数据长度）的字段。曼切斯特编码的每一个码元的正中间一定有一次电压的转换（从高到低或低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方可以很容易地找到以太网帧的结束位置，在这个位置往前数4字节（FCS字段长度是4字节），就能确定数据字段的结束位置。 当数据字段的长度小于46字节，MAC层就会在数据字段的后面加入一个整数字节的填充，以保证以太网的MAC帧长不小于64字节。MAC帧的首部没有指出数据字段的长度是多少。在有填充时，接收端的MAC子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。上层协议具有识别有效的数据字段长度的功能。当上层使用IP协议时，其首部有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于MAC帧数据字段的长度。例如，当IP数据报的总长度为42字节时，填充字段共有4字节。当MAC帧把46字节的数据上交给IP层后，IP层就把其中最后4字节的填充字段丢弃。 从上图可知，在传输媒体上实际传送的要比MAC帧还多8个字节。这是因为当一个站在刚开始接收MAC帧时，由于适配器的时钟尚未与达到的比特流达到同步，因此MAC帧的最前面的若干位无法接受，结果使整个的MAC成为无用帧。为了接收端迅速实现位同步，从MAC子层向下传到物理层时还要在帧的前面插入8个字节，它由两个字段构成。第一个字节是7个字节的前同步码（1和0交替码），它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时针频率，使它和发送端的时针同步，即“实现位同步”。第二个字段是帧开始定界帧，定义为10101011。它的前六位的作用和前同步码一样，最后的两个连续的1就是告诉接收端适配器：“MAC帧的信息马上就来，请适配器注意接收”。 IEEE802.3标准规定如下情况为无效的MAC帧： 帧的长度不是整数个字节 用收到的帧检验序列FCS查出由差错 收到的帧的MAC客户数据字段的长度不在46~1500字节之间。考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间 对于检查无效的帧就简单的丢弃，以太网不负责重传丢弃的帧。 IEEE 802.3规定的MAC帧的第三个字段是“类型和长度”。（1）当这个字段值大于0x0600（十进制1536）时，就表示类型，这样的帧和以太网V2 MAC帧完全一样。（2）只有当这个字段小于0x0x600时才表示“长度”，即MAC帧的数据部分长度。这种情况下，若数据字段的长度于长度字段的值不一致时，则该帧为无效的MAC帧。由于以太网采用曼切斯特编码，长度字段并无实际意义。 当”长度/类型“字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧。 3.5 扩展的以太网以太网的覆盖范围扩展 3.5.1 在物理层扩展以太网以太网的主机之间的距离不能太远（10BASE-T以太网的两个主机之间的距离不超过200米），否则主机发送的信号经过铜线传输衰减到使CSMA/CD协议无法正常工作。 扩展主机和集线器之间的距离的一种简单方法就是使用光纤和一对光纤调制解调器，如下图： 光纤调制解调器的作用就是：进行电信号和光信号的转换。由于光纤带来的实现很小，并且带宽高，因此这种方法可以很容易地使主机和几公里以外的集线器相连。 如果使用多个集线器，就可以连接覆盖更大范围的多级星形结果的以太网。例如，一个学院三个系各有一个10BASE-T的以太网，如下图： 可通过一个主干集线器把各系的以太网连接起来，成为一个更大的以太网： 这样的两个好处：（1）扩大了以太网覆盖的地理范围；（2）使这个学院不同系的以太网的计算机能够进行跨系的通信。 3.5.2 在数据链路层扩展以太网在数据链路层扩展以太网要使用网桥。网桥工作在数据链路层。它根据MAC帧的目的地址对收到的帧进行转发和过滤。当网桥收到一个帧时，并不是所有的接口转发此帧，而是先检查此帧的目的MAC帧，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。 1.网桥的内部结构下图给出了一个网桥的内部结构要点。两个以太网通过网桥连接起来，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可以称为一个网段(segment)。图中接口1和接口2各连到一个网段。 网桥依靠转发表来转发帧。转发表也叫做转发数据库或路由目录。如上图，（1）若网桥从接口1收到A发给E的帧，则在查找转发表后，把这个帧送到接口2转发到另一个网段，使E能够收到这个帧。（2）若网桥从接口1收到A发给B的帧，就丢弃这个帧，因为转发表指出，转发给B的帧应当从接口1转发出去，而现在正是从接口1收到这个帧，这说明A和B处在同一个网段上，B能够之间收到这个帧而不需要借助于网桥来实现。 网桥的好处： 过滤通信量，增大吞吐量 扩大了物理范围 提高了可靠性 可互连不同的物理层、不同MAC子层和不同速率的以太网 缺点： 增加了时延，由于网桥对接收的帧要先存储和查找转发表，然后才转发，而转发之前，还鄙视执行CSMA/CD算法。 没有流量控制，当网络上的负载很重时，网桥中的缓存的存储可能不够而发生溢出，以至产生帧丢失的现象。 广播风暴，网桥只适合于用户不太多和通信量不太大的以太网，否则有时还会音传播过多的广播信息而产生网络拥堵。 2.透明网桥目前使用最多的网桥就是透明网桥。其标准是IEEE 802.1D。”透明“指以太网上的站点不知道所发送的帧将经过哪几个网桥。透明网桥是一个种即插即用设备，意思是就只要把网桥接入局域网，不用人配置转发表网桥就能工作。 当网桥刚刚连接到以太网时，其转发表是空的。这时若网桥收到一个帧，网桥就按照以下自学习算法处理收到的帧（这样就逐步建立起转发表），并且按照转发表把帧转发出去。这种自学习算法比较简单，因为：若从某个站A发出的帧从接口x进入了某网桥，那么从这个接口出发沿着相反方向一定可以把一个帧传送到A。所以网桥只要每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。转发表中没有”源地址“这一栏，而只有”地址“这一栏。在建立转发表时，把帧首部的源地址写在地址这一栏。在转发帧时，则根据收到的帧首部中的目的地址来转发。这时把在”地址“栏下面记下的源地址当作目的地址，而把记下的进入接口当作转发接口。 网桥和集线器的区别 网桥是按存储转发方式工作的，一定是先把帧收下来（但集线器或转发器逐比特转发）再进行处理，而不管其目的地址是什么。此外，网桥丢弃CRC检验有差错的帧以及帧长过短或过长的无效帧。 A向B发送帧：连接在同一个局域网上的站点B和网桥1都能收到A发送的帧。网桥1先按源地址A查找转发表，网桥1的转发表中没有A的地址，于是把地址A和收到此帧的接口1写入转发表。这就表示，以后若收到要发给A的帧，就应当从这个接口1转发出去。接着再按目的地址B查找。转发表中没有B的地址，于是就通过除收到此帧的接口1以外的所有接口（现在就是接口2）转发该帧。网桥2从其接口1收到追个转发过来的帧。 网桥2按同样的方式处理收到的帧。网桥2的转发表中没有A的地址，因此在转发表中写入地址A和接口1.网桥2的转发表中没有B的地址，因此网桥2通过除收到此帧的接口1以外的所有接口转发这个帧。 B本来可以之间收到A发送的帧，让网桥1和网桥2盲目地转发这个帧的原因是：这两个网桥当时并不知道网络拓扑，因此要通过自学习过程才能逐步弄清楚所连接的网络拓扑，建立起自己的转发表。 自学习和转发的一般步骤 网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目。如有，则把原有的项目进行更新。 转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。如没有，则通过所有其他接口进行转发。如有，则按转发表中给出的接口进行转发。但应注意，若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃该帧。 透明网桥还使用了一个生成树算法。即互连在一起的网桥在进行批次通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。 找出一个生成书的目的：为了避免产生转发的帧在网络中不断地兜圈子。 3. 源路由网桥透明网桥的最大优点是容易安装，一接上就能工作。但是，网络资源的利用还不充分。因此，另一种由发送帧的源站负责路由选择的忘记就问世了，这就是源路由网桥。 源路由网桥是在发送帧时，把详细的路由信息放在帧的首部中。 源站选择路由的原理：为了发现合适的路由，源站以广播的方式向欲通信的目的站发送一个发现帧作为探测之用。发现帧将在整个扩展的以太网中沿着所有可能的路由传送。在传送过程中，每个发现帧都记录所经过的路由。当这些帧到达目的站时，就沿着各自的路由返回源站。源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。以后，凡从这个源站向该目的站发送的帧的首部，都必须携带源站所确定的这个路由信息。 发现帧还有另一个作用，就是帮助源站确定整个网络可以通过的帧的最大长度。 源路由网桥对主机不透明，主机必须直到网桥的表示以及连接到哪一个网段上。若在两个以太网之间使用并联的源路由网桥，则可使通信较平均地分配给每一个网桥。 4.多接口网桥–以太网交换机交换式集线器常称为以太网交换机或第二层交换机，表明这种交换机工作在数据链路层。 网桥的接口数很少，一般只有2~4个，而以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，和工作在物理层的转发器、集线器有很大的差别。 以太网交换机和透明网桥一样，也是一种即插即用设备，其内部的帧转发表也是通过自学习算法自动逐渐建立起来的。当两个站通信完成后就断开连接。以太网交换机由于使用了专门的交换结构芯片，其交换速率就教高。 利用以太网交换机可以很方便实现虚拟局域网VLAN。虚拟局域网是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的工作站属于哪一个VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 利用以太网交换机可以很方便地将这10个工作站划分为三个虚拟局域网：$VLAN_1$,$VLAN_2$,$VLAN_3$。在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员发出的广播。例如:当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到广播的信息。B1 发送数据时，工作站 A1, A2 和 C1都不会收到 B1 发出的广播信息。 虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即“广播风暴”)而引起性能恶化。 1988年IEEE批准了802.3ac标准，这个标准定义了以太网的帧格式的扩展，以便支持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入4个字节的标识符，称为VLAN标记（tag）,用来指明发送该帧的工作站属于哪一个虚拟局域网。 VLAN标记字段的长度是4个字节，插入在以太网MAC帧的源地址字段和类型字段中间。VLAN标记的前两个字节总是设置为0像100，称为IEEE 802.1Q标记类型。当数据链路层检测到MAC帧的源地址字段后面的两个字节的值是0x8100，就知道插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。后面两个字节中，前三位是用户优先级字段，接着的一位是规范格式指示符，最后的12位是该虚拟局域网VLAN标识符VID，它唯一地标志了这个以太网帧是属于哪一个VLAN。 3.6 高速以太网速率达到或超过100Mb/s的以太网称为高速以太网。 3.6.1 100BASE-T 以太网在双绞线上传送 100 Mb/s 基带信号的星型拓扑以太网，仍使用 IEEE 802.3 的CSMA/CD 协议。100BASE-T 以太网又称为快速以太网(Fast Ethernet)。 100BASE-T 以太网特定： 可在全双工方式下工作而无冲突发生。因此，不使用 CSMA/CD 协议。 MAC 帧格式仍然是 802.3 标准规定的。 保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。 帧间时间间隔从原来的 9.6$\mu$s 改为现在的 0.96$\mu$s。 3.6.2 吉比特以太网 允许在 1 Gb/s 下全双工和半双工两种方式工作。 使用 802.3 协议规定的帧格式。 在半双工方式下使用 CSMA/CD 协议（全双工方式不需要使用 CSMA/CD 协议）。 与 10BASE-T 和 100BASE-T 技术向后兼容。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典、列表、元组、数组]]></title>
    <url>%2F2018%2F09%2F27%2FPython%E5%AD%97%E5%85%B8%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[介绍Python字典、列表、元组、数组的函数和方法。 一、字典1 、内置函数1、cmp(dict1, dict2) 比较两个字典元素。 2、len(dict) 计算字典元素个数，即键的总数。 3、str(dict) 输出字典可打印的字符串表示。 4、type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 2、内置方法1、dict.clear() 删除字典内所有元素 2、dict.copy() 返回一个字典的浅复制 3、dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4、dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5、dict.has_key(key) 如果键在字典dict里返回true，否则返回false 6、dict.items() 以列表返回可遍历的(键, 值) 元组数组 7、dict.keys() 以列表返回一个字典所有的键 8、dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9、dict.update(dict2) 把字典dict2的键/值对更新到dict里 10、dict.values() 以列表返回字典中的所有值 11、pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12、popitem() 随机返回并删除字典中的一对键和值 数组转换为字典： 1、现在有两个列表，list1 = [‘key1’,’key2’,’key3’]和list2 = [‘1’,’2’,’3’]，把他们转为这样的字典：{‘key1’:’1’,’key2’:’2’,’key3’:’3’} list1 = [&apos;key1&apos;,&apos;key2&apos;,&apos;key3&apos;] list2 = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;] list2 = range(len(list1)) dict(zip(list1,list2)) {&apos;key1&apos;:&apos;1&apos;,&apos;key2&apos;:&apos;2&apos;,&apos;key3&apos;:&apos;3&apos;} 2、将嵌套列表转为字典，有两种方法， new_list= [[&apos;key1&apos;,&apos;value1&apos;],[&apos;key2&apos;,&apos;value2&apos;],[&apos;key3&apos;,&apos;value3&apos;]] dict(list) {&apos;key3&apos;: &apos;value3&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key1&apos;: &apos;value1&apos;} 二、列表列表初始化 1.初始化递增的list： list1 = range(10) print(list1) [0,1,2,...,9] 2.初始化每项为0的一维数组： list2 = [0] * 5 print(list2) [0,0,0,0,0] 3.初始化固定值的一维数组： initVal = 1 listLen = 5 list3 = [ initVal for i in range(5)] print(list3) [1,1,1,1,1] list4 = [initVal] * listLen print(list4) [1,1,1,1,1] 4.初始化一个5x6每项为0（固定值）的数组（推荐使用）： multilist = [[0 for col in range(5)] for row in range(6)] 5.初始化一个5x6每项为0（固定值）的数组 multilist = [[0] * 5 for row in range(3)] 看到了以上的方法，那初始化一个二维数组时，是否可以这样做呢： multi = [[0] * 5] * 3 其实，这样做是不对的，因为[0] * 5是一个一维数组的对象，* 3的话只是把对象的引用复制了3次，比如，我修改multi[0][0]： multi = [[0] * 5] * 3 multi[0][0] = &apos;Hello&apos; print(multi) 输出的结果将是： [[&apos;Hello&apos;, 0, 0, 0, 0], [&apos;Hello&apos;, 0, 0, 0, 0], [&apos;Hello&apos;, 0, 0,0, 0]] 我们修改了multi[0][0]，却把我们的multi[1][0]，multi[2][0]也修改了。这不是我们想要的结果。 但是如下写法是对的： multilist = [[0] * 5 for row in range(3)] multilist[0][0] = &apos;Hello&apos; print(multilist) 我们看输出结果： [[&apos;Hello&apos;, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] 恩，没问题。但是，由于使用 * 的方法比较容易引起混淆导致Bug，所以还是推荐使用上面方法4，即： multilist = [[0 for col in range(5)] for row in range(6)] 三、元组初始化L = 3, 4, 5 或 L = (3,4,5) del(L) //删除元组 (1,2) + (3,4) //得到一个新的元组 元组索引，截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示： 元组： L = (&apos;spam&apos;, &apos;Spam&apos;, &apos;SPAM!&apos;) Python 表达式 结果 描述 L[2] ‘SPAM!’ 读取第三个元素 L[-2] ‘Spam’ 反向读取，读取倒数第二个元素 L[1:] (‘Spam’, ‘SPAM!’) 截取元素 内置函数cmp(tuple1, tuple2) 比较两个元组元素。 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 数组数组创建import numpy as np a = np.array([2,3,4]) b = np.array([2.0,3.0,4.0]) c = np.array([[1.0,2.0],[3.0,4.0]]) d = np.array([[1,2],[3,4]],dtype=complex) # 指定数据类型 print(a) #打印数组 创建数组的常用函数np.arange(0,7,1,dtype=np.int16) # 0为起点，间隔为1时可缺省(引起歧义下不可缺省) np.ones((2,3,4),dtype=np.int16) # 三维数组，2页，3行，4列，全1，指定数据类型 np.zeros((2,3,4)) #三维数组， 2页，3行，4列，全0 np.empty(3) #值取决于内存 np.arange(0,10,2) # 起点为0，不超过10，步长为2 np.linspace(-1,2,5) # 起点为-1，终点为2，取5个点 np.random.randint(0,3,(2,3)) # 大于等于0，小于3，2行3列的随机整数 b = np.ones((2,3,4),dtype=np.int16) print(b.shape) #输出a的形状 print(b.shape[0]) #页数 ， 1行数，2列数 print(b.ravel()) # 输出平坦化后的a（a本身不改变） b.shape = (6,2); print(b)# 改变a的形状 print(a.transpose()) # 输出a的转置]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--循环和关系表达式（五）]]></title>
    <url>%2F2018%2F09%2F27%2FC%2B%2B%20Primer%20Plus--%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++提供三种循环：for循环、while循环和do while循环。 5.1 for循环int i; for (i = 0; i &lt; 5; i++) cout &lt;&lt; &quot;C++ knows loops.\n&quot;; 该循环首先将整数变量i设置为0： i = 0 这是循环的初始化部分，然后，循环测试部分检查i是否小于5： i &lt; 5 如果确实小于5，则程序执行接下来的语句–循环体： cout &lt;&lt; &quot;C++ knows loops.\n&quot;; 然后程序使用循环更新部分将i加1： i++ 接下来，循环开始了新的周期，将新的i值与5比较。 5.1.1 for循环组成部分for循环的组成部分完成步骤： 1、设置初始值；2、执行测试，判断循环是否应当继续进行；3、执行循环操作；4、更新用于测试的值。 1.表达式和语句 for语句的控制部分使用了3个表达式。 maids = (cooks = 4) + 3; 表达式cooks=4的值为4，因此maids的值为7。下面的语句由也是允许的： x = y = z = 0; 这种方法可以快速地将若干个变量设置为相同的值。优先级表表明，赋值运算符是从右向左结合的，因此首先将0赋给z,然后将z=0赋给y，依次类推。 从表达式到语句的转换很容易，只要加上分号即可，因此下面是一个表达式： age = 100 而下面一条语句： age = 100; 更准确地说，这是一条表达式语句。只要加上分号，所有的表达式都可以成为语句，但不一定编程有意义。例如： roents + 6; 编译器允许这样的语句，但它没有完成任何有用的工作。程序仅仅计算和，而没有使用得到的结果。 2.非表达式和语句 下面语句是一个表达式： int toad; 而int toad不是表达式，因为它没有值。因此，下面的代码非法： eggs = int toad * 1000; 同样不能把for循环赋给变量，for循环不是表达式，因此没有值，也不能给它赋值。 3、修改规则 C++对C循环的基础上添加了一项特性，要求对for循环句法做一些微妙的调整： for (int i = 0; i &lt; 5; i++) 也就是说，可以在for循环的初始化部分中声明变量。 5.1.2 回到for循环使用for循环计算并存储前n个阶乘: formore.cpp #include const int ArSize = 16; int main() { using namespace std; long long f[ArSize]; f[0] = f[1] = 1; for (int i = 2; i &lt; ArSize; i++) f[i] = i * f[i-1]; for (int i = 0; i &lt; ArSize; i++) cout &lt;&lt; i &lt;&lt; “! = “ &lt;&lt; f[i] &lt;&lt; endl; return 0; } 结果： 0! = 1 1! = 1 2! = 2 3! = 6 4! = 24 5! = 120 6! = 720 7! = 5040 8! = 40320 9! = 362880 10! = 3628800 11! = 39916800 12! = 479001600 13! = 6227020800 14! = 87178291200 15! = 1307674368000 定义一个const值来表示数组中的元素个数是个好办法。如果要扩展处理20个阶乘，则只需要修改ArSize的值为20，而不需要在程序将16修改为20。 5.1.3 修改步长到现在为止，循环示例每一轮循环计数加1或减1。可以通过修改更新表达式来修改步长： int by = 3; for (int i = 0; i &lt; 9; i = i + by) cout &lt;&lt; i &lt;&lt; endl; 5.1.4 使用for循环访问字符串for循环提供了一种依次访问字符串随的每个字符的方式。 forstr1.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { cout &lt;&lt; &quot;Enter a word:\n&quot;; string word; cin &gt;&gt; word; for (int i = word.size() - 1; i &gt;= 0; i--) cout &lt;&lt; word[i]; cout &lt;&lt; &quot;\nBye.\n&quot;; return 0; } 结果： Enter a word: animal lamina Bye. 在本例子中，可以使用string对象，也可以使用char数组，因为它们都可以使用数组表示法来访问字符串中的字符。 5.1.5 递增运算符(++)和递减运算符(–)两个运算符都要两种变体，前缀版本位于操作数前面，如++x；后缀版本位于操作数后面，如x++，两个版本对操作数的影响是相同的，但是影响的时间不同。 plus_one.cpp #include &lt;iostream&gt; int main() { using namespace std; int a = 20; int b = 20; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;; b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;a++ = &quot; &lt;&lt; a++ &lt;&lt; &quot;; ++b = &quot; &lt;&lt; ++b &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;; b = &quot; &lt;&lt; b &lt;&lt; endl; return 0; } 结果： a = 20; b = 20 a++ = 20; ++b = 21 a = 21; b = 21 a++意味着使用a当前值计算，然后将a的值加一；而b++的意思是先将b的值加1，然后使用新的值来计算表达式。例如： int x = 5; int y = ++x; //y的值为6 int z = 5; int y = z++; //y的值为5 递增和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次。问题在于，规则“使用后修改”和“修改后使用”可能变得模糊不清。下面的语句在不同的系统中将生成不同的结果： x = 2 * x++ * (3 - ++x); 对于这种语句，C++没有定义正确的行为。 5.1.6 副作用和顺序点副作用指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点是程序执行过程中的一个点。在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行所有的修改都必须完成。 完整的表达式：不另一个更大表达式的子表达式。完整的表达式例子有：表达式语句中的表达式部分以及用作while循环中检测条件的表达式。 while (guest++ &lt; 10) cout &lt;&lt; guest &lt;&lt; endl; 在这里，可以认为“使用值，然后递增”，意味着先在cout语句中使用guest的值，再将其值加1。然而，表达式guest++ &lt; 10是一个完整的表达式，因为它是一个while循环的测试条件，因此该表达式的末尾是一个顺序点。所以，C++确保副作用（将guest加1）在程序进入cout之前完成。然而，通过使用后缀格式，可确保将guest同10进行比较后再将其值加1。 现在看如下语句： y = (4 + x++) + (6 + x++); 表达式4 + x++不是一个完整的表达式，因此C++不保证x的值在计算子表达式4+x++后立刻增加1。在这个例子中，整条赋值语句是一个完整表达式，而分号表示了顺序点，因此C++只保证程序执行到下一条语句之前，x的值将被递增两次。 C++中，没有规定是在计算每个子表达式之后将x的值递增，还是整个表达式计算完毕才将x的值递增，鉴于此，应避免使用这样的表达式。 在C++11文档中，不再使用术语”顺序点“，因为这个概念难以用于讨论多线程执行。反而，使用了术语”顺序“，他表示有些事情在其他事件前发生。 5.1.7 前缀格式和后缀格式x++; ++x; 从逻辑上说，上述情形下，使用前缀和后缀表达式没有区别，即当表达式的值未被使用时，因此只存在副作用。 C++允许针对类定义这些运算符，在这种情况下，用户定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加去，然后将复制的副本返回。因此，对于类而言，前缀版本的效率比后缀版本的效率高。 总之，对于内置类型，采用哪种格式都不会有差别；但对于用户定义的类型，如果有用户定义的递增和递减运算符，作为前缀格式的效率高。 5.1.8 递增/递减运算符和指针将递增运算符用户指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于指针递增和递减： double arr[5] = {1.1, 2.2, 3.3, 4.4, 5.5}; double *pt = arr; ++pt; 也可以结合使用这些运算符和*运算符来修改指针所指向的值。 前缀运算符的从右到左结合规则意味着$\ast$++pt的含义如下：现将++应用于pt（因为++位于$\ast$的右边），然后将$\ast$应用于被递增后的pt: double x = *++pt; //指向arr[2],值为23.4 另一方面，++*pt意味着先取pt所指向的值，然后将这个值加1： ++*pt; //指向arr[2],值为24.4 接下来，看看下面的组合： (*pt)++; 圆括号指出，首先对指针解除引用，得到24.4，然后，运算符将这个值递增到25.4，pt仍指向arr[2]。最后，看下面组合： x = *pt++; 后缀用算符的优先级高，这意味着将运算符用户pt，而不是$\ast$pt，因此对指针递增。然而，后缀运算符意味着将对原来的地址（&amp;arr[2]）而不是递增后的新地址解除引用，因此$\ast$pt++的值为arr[2],即25.4，当该语句执行完毕后，pt的值将为arr[3]。 5.1.9 组合赋值运算符C++有一种合并加法和赋值的运算符： i += by; int pa[3] = {1,2,3}; pa[1] += 1; *(pa + 1) += 2; pa += 1; 组合赋值运算符 操作符 作用(L为左操作数，R为右操作数) += L+R赋给L -= L-R赋给L $\ast$= L$\ast$R赋给L /= L/R赋给L %= L%R赋给L 5.1.10 复合语句(语句块)int sum = 0; int number; for (int i =1; i &lt;= 5; i++) { cout &lt;&lt; &quot;Value: &quot; &lt;&lt; i &lt;&lt; &quot;: &quot;; cin &gt;&gt; number; sum += number; } 编译器将忽略缩进，因此需要使用花括号来说明是for中的语句块。如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量存在。执行完该语句块，变量将被释放。 注意，在外部定义的变量，在语句块内部也是被定义了。 5.1.11 逗号运算符语句块允许把两条或更多条语句放到按C++句法只能放到一条语句的地方。逗号运算符对表达式完成同样的任务，允许将两个表达式放到C++句法只允许放一个表达式的地方。例如：假设有一个循环，每轮都将一个变量加1，而另一个变量减1： ++j,--i 逗号并不总是逗号运算符，例如，下面这个声明中的逗号将变量列表中的相邻的名称分开： int i, j; 实现将一个string类对象的内容反转。 forstr2.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { cout &lt;&lt; &quot;Enter a word: &quot;; string word; cin &gt;&gt; word; char temp; int i,j; for(j = 0, i = word.size() - 1; j &lt; i; --i, ++j) { temp = word[i]; word[i] = word[j]; word[j] = temp; } cout &lt;&lt; word &lt;&lt; endl; return 0; } 结果： Enter a word: animal lamina 注意声明i,j的位置在循环之前，因为不能用逗号运算符将两个声明组合起来。这是因为声明已经将逗号用于其他用途–风格列表中的变量。也可以使用一个声明语句表达式来创建并初始化两个变量，但这样看起来有点乱： int j = 0, i = word.size() - 1; 在这种情况下，逗号只是一个分隔符。 如果在for内部声明temp: char temp = word[i]; 这样，temp在每轮循环中都将被分配和释放，这比在循环外声明temp的速度慢一些。另一方面，如果在循环内部声明，则它将在循环结束后释放。 逗号运算符其他用途 i = 20, j = 2 * i //其中i=20,j=40 首先，它确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。其次C++规定，逗号表达式的值是第二部分的值。例如，上面表达式的值为40，因为j=2$\ast$i的值为40。 在所有的运算符中，逗号运算符的优先级最低。例如，下面的语句： cata = 12, 120; 被解释为： (cata = 12), 120; 也就是说cata为12，120不起作用。然而，由于括号的优先级最高，下面的表达式： cats = (12, 120); 将cats设置为120—逗号右侧的表达式值。 5.1.12 关系表达式不等于: !=等于： ==小于等于： &lt;=大于等于： &gt;= 关系运算符的优先级比算术运算符地： x + 2 &gt; y -2 5.1.13 赋值、比较和可能犯的错误观察下面两者的输出： itn A[5] = {20, 20, 10, 20 ,1} for (int i = 0 ; A[i] == 20; i++) //输出前两个20 cout &lt;&lt; i &lt;&lt; endl; for (int i = 0; A[i] = 20; i++) //因为这里使用赋值，所有程序会一直输出20，导致程序崩溃 cout &lt;&lt; i &lt;&lt; endl; 第二个循环，一直输出20，直到程序崩溃，电脑死机。 5.1.14 C-风格字符串比较由于C++将C-风格字符串视为地址，因此如果使用关系运算符来比较它们，将无法得到满意的结果。相反，应使用C-风格字符串库的strcmp()函数来比较。该函数接受两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，则函数返回0；如果第一个字符串按字母排在第二个字符串前面，则函数返回一个负数；如果第一个字符串按字幕顺序排在第二个字符串之后，则函数返回一个正数。 实际上，”按系统排序顺序“比”按字母顺序“更准确，这意味着字符根据字符的系统编码来进行比较。例如：使用ASCII码时，所有大写字母的编码都要小于小写字母，所以按排序顺序，大写字母将位于小写字母前面。因此，字符串”Zoo“在字符串”aviary“之前。根据编码进行比较还意味着大写字母和小写字母是不同的。 虽然不能用关系运算符来比较字符串，但可以用来比较字符，因为字符实际上是整型。 for (ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) cout &lt;&lt;ch; compstr1.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; int main() { using namespace std; char word[5] = &quot;?ate&quot;; for (char ch = &apos;a&apos;; strcmp(word, &quot;mate&quot;); ch++) { cout &lt;&lt; word &lt;&lt; endl; word[0] = ch; } cout &lt;&lt; &quot;After loop ends, word is :&quot; &lt;&lt; word &lt;&lt; endl; return 0; } 结果： ?ateaatebatecatedateeatefategatehateiatejatekatelateAfter loop ends, word is :mate 如果str1和str2相等，作则下面的表达式为true: strcmp(str1,str2) == 0 如果str1和str2不相等，则下面两个表达式都是true: strcmp(str1,str2) != 0 strcmp(str1,str2) 如果str1在str2的前面，则下面表达式为true: strcmp(str1,str2) &lt; 0; 如果str在str2的后面，则下面表达式为true: strcmp(str1,str2) &gt; 0; 5.1.15 比较string类字符串如果使用sting类字符串而不是C-字符串，比较起来简单些。 compstr2.cpp #include &lt;iostream&gt; int main() { using namespace std; string word = &quot;?ate&quot;; for (char ch = &apos;a&apos;; word != &quot;mate&quot;; ch++) { cout &lt;&lt; word &lt;&lt; endl; word[0] = ch; } cout &lt;&lt; &quot;After loop ends, word is :&quot; &lt;&lt; word &lt;&lt; endl; return 0; } string类重载运算符！=的方式可以在下面条件下使用它：至少一个操作数为string对象，另一个操作数可以是string对象，也可以是C-风格字符串。 5.2 while循环while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体： while (test-condition) body 首先，程序计算圆括号内的测试条件表达式，如果该表达式为true，则执行循环体中的语句。如果希望循环最终能够结束，循环体中的代码必须完成某种影响测试条件表达式的操作。 while.cpp #include &lt;iostream&gt; const int ArSize = 20; int main() { using namespace std; char name[ArSize]; cout &lt;&lt; &quot;Your first name: &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;Here is your name, verticalized and ASCIIized:\n&quot;; int i = 0; while(name[i] != &apos;\0&apos;) { cout &lt;&lt; name[i] &lt;&lt; &quot; : &quot; &lt;&lt; int(name[i]) &lt;&lt; endl; i++; } return 0; } 结果： Your first name: zxp Here is your name, verticalized and ASCIIized: z : 122 x : 120 p : 112 如果没有循环体中的i++来更新测试表达式的值，循环会一直停留在第一个数组元素上，导致死循环。测试条件还可以修改为： while(name[i]) 程序的工作方式不变，对于编译器生成代码的速度将更快。由于name[i]是常规字符，其值为该字符的编码–非零值或true，当name[i]为空值时，其编码值为0或false。 打印字符的ASCII码，必须通过强制类型转换将name[i]转换为整型。 5.2.1 for与while在C++中，for和while循环本质上是相同的，例如: for (init-expression; test-expression; update-expression) { statements } 可以改写成: init-expression; while (test-expression) { statements update-expression } 两者区别： for循环中省略测试条件时，将认为条件为true; 在for循环中，可使用初始化语句声明一个局部变量，但在while循环中不能这样做； 如果循环体中包括 continus语句，情况将稍有不同，后续讨论。 通常，使用for循环来循环计数，因为for循环格式允许将所有相关的信息—初始值、终止值和更新计算的方式放在同一个地方。在无法预先直到循环执行次数时，使用while循环。 设计循环时，三条原则： 指定循环终止的条件； 在首次测试之前初始化条件； 在条件被再次测试之前更新条件。 注意分号使用： while (i &lt; 10); { cout &lt;&lt; i; i++; } 这将是一个空循环，分号将结束while循环。 5.2.2 编写延时循环有时候，让程序等待一段时间很有用。while循环可用于这个目的。早期的技术是让计算机进行计数，以等待一段时间： long waite = 0; while (waite &lt; 10000) waite++; 这种方法的问题是，当计算机处理的速度发生变化，必须修改计数限制。更好的办法是让系统时钟来往常这种工作。 C++库中有一个函数有助于完成这项工作，这个函数名叫clock()，返回程序开始执行后所用的系统时间。这有两个复杂的问题：首先，clock()返回时间的单位不一定是秒，其次，该函数的返回类型在某些系统可能是long，在另一些习俗可能是unsigned long或其他类型。 但头文件ctime(早期的time.h)提供了解决这些问题的解决方案。首先，定义一个符号常量—CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数，因此系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCKS_PER_SEC，可以得到系统时间单位为单位的时间。其次，ctime将clock作为clock()返回类型的别名，这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型。 waiting.cpp #include &lt;iostream&gt; #include &lt;ctime&gt; int main() { using namespace std; cout &lt;&lt; &quot;Enter the delay time, in seconde: &quot;; float secs; cin &gt;&gt; secs; clock_t delay = secs * CLOCKS_PER_SEC; cout &lt;&lt; &quot;starting\a\n&quot;; clock_t start = clock(); while (clock() - start &lt; delay); cout &lt;&lt; &quot;done \a\n&quot;; return 0; } 结果： Enter the delay time, in seconde: 5 starting done 该程序以系统时间单位为单位计算延迟时间，避免了在每轮循环中将系统时间转换为秒。 类型别名 C++为类型建立别名的方式有两种。一种是使用预处理器： #define BYTE char //注意没有分号 这样，预处理器将在编译程序时使用char替换所有的BYTE，从而使BYTE成为char的别名。 第二种方式是使用C++（和C）的关键字typedef来创建别名。例如，将byte作为char的别名，可以这样做： typedef char byte; 要让byte_pointer成为char指针的表明，可以将byte_pointer声明为char指针，然后在前面加上关键字typedef: typedef char * byte_pointer; 也可以使用#define，不过声明一系列变量时，这种方法不适用，例如： #define FLOAT_POINTER float *; FLOAT_POINTER pa pb; 预处理器置换该声明为这样： float *pa, pb; typedef方法不会有这样的问题。它能够处理更复杂的类型别名，这使得与使用#define相比，typedef是一种更佳的选择。 注意，typedef不会创建新类型，只是为已有的类型建立一个新名称。 编写程序对比两者： #include &lt;iostream&gt; #define char_point char * typedef char * byte_pointer; int main() { using namespace std; byte_pointer pa, pb; cout &lt;&lt; &quot;typedef: \n&quot;; cout &lt;&lt; sizeof(pa) &lt;&lt; endl; cout &lt;&lt; sizeof(pb) &lt;&lt; endl; char_point pc, pd; cout &lt;&lt; &quot;#define:\n &quot;; cout &lt;&lt; sizeof(pc) &lt;&lt; endl; cout &lt;&lt; sizeof(pd) &lt;&lt; endl; return 0; } 结果： typedef: 8 8 #define: 8 1 5.3 do while循环do while循环不同于介绍过的两种循环，因为它是出口条件循环，即这种循环将首先执行循环体，然后判定测试表达式，决定是否应该继续执行循环。句法如下： do body while (test-expression); 通常，入口条件循环比出口条件循环好，因为入口条件循环在循环开始之前对条件进行检查。但有时do while测试更合理，例如，请求用户输入时，程序必须先获取输入然后对它进行测试。 dowhile.cpp #include &lt;iostream&gt; using namespace std; int main() { int n; cout &lt;&lt; &quot;Enter number: &quot;; do{ cin &gt;&gt; n; } while(n != 7); cout &lt;&lt; &quot;Yes, 7 is my favorite.\n&quot;; return 0; } 结果： Enter number: 3 4 7 Yes, 7 is my favorite. 奇特的for循环 int i = 0; for (;;) { i++; if (30 &gt;= i) break; } 另一种变体： int i = 0; for(;;i++) { if (30 &gt;= i) break; } 上述代码基于这样一个事实：for循环中的空测试条件被视为true。这些例子不易于阅读，也不能用作编写循环的通用模型。第一个例子的功能在do while循环中将表达得更清晰： int i = 0; do{ i++ } while(i &lt;= 30); 第二个例子使用while循环可以表达得更清晰： while(i &lt; 30) { i++; } 5.4 基于范围的for循环（C++11）基于范围的for循环，简化了一种常见的循环任务：对数组或容器类（vector或array）的每个元素执行相同的操作： double prices[5] = {4.99, 10.99, 1.99, 7.99, 8.99}; for (double x: price) cout &lt;&lt; x &lt;&lt; endl; 其中x最初表示数组price的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素。 要修改数组的元素，需要使用不同的循环变量语法： for (double &amp;x : prices) x = x * 0.80; 符号&amp;表明x是一个引用变量。还可以结合使用基于for循环和初始化列表： for (int x : {3, 5, 2, 6}) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; Linux下使用C++11编译程序(rangefor.cpp): g++ -std=c++11 rangefor.cpp 5.5 循环和文本输入cin对象支持3种不同模式的单字符输入，其用户接口各不相同。下面介绍while循环中使用这三种模式： 5.5.1 使用原始的cin进行输入程序通过选择某个特殊的字符–哨兵字符，来作为停止表示，程序知道合适停止读取。例如下面程序遇到#字符时停止输入。 textcin1.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int count = 0; cout &lt;&lt; &quot;Enter characters, enter # to quit: \n&quot;; cin &gt;&gt; ch; while (ch != &apos;#&apos;) { cout &lt;&lt; ch; ++ count; cin &gt;&gt; ch; } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read. \n&quot;; return 0; } 结果： Enter characters, enter # to quit: zxp is handsome # read here zxpishandsome 13 characters read. 程序在输出时省略了空格，原因是cin在读取char值时，与读取其他类型一样，cin将忽略空格和换行。因此输入中的空格没有被回显，也没有被包括在计数内。 只有按下回车键，用户输入的内容才会被发送给程序，这就是在运行程序时，可以在#后输入字符的原因。 5.5.2 使用cin.get(char)补救通常，逐个字符读取时，程序需要检查每个字符，包括空格、制表符和换行符。cin所属的istream类中包括一个能够满足这种要求的成员函数。具体说，成员函数cin.get(char)读取输入中的下一个字符（即使它是空格），并将其赋值给变量ch。 textcin2.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int count = 0; cout &lt;&lt; &quot;Enter characters, enter # to quit: \n&quot;; cin.get(ch); while (ch != &apos;#&apos;) { cout &lt;&lt; ch; ++ count; cin.get(ch); } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read. \n&quot;; return 0; } 结果： Enter characters, enter # to quit: zxp is handosome # read here zxp is handosome 17 characters read. 现在程序回显了每个字符，并将全部字符计算在内，其中包括空格。 cin.get(ch)调用一个值放在ch变量中，这意味着将修改该变量的值。在C语言中，要修改变量的值，必须将变量的地址传递给函数，即cin.get(&amp;ch)。当在C++中，只要函数将参数声明为引用即可。引用是C++在C上新增的一种类型。 5.5.3 使用哪一个cin.get()前面使用过： cin.get(name, ArSize).get(); 相当于两行： cin.get(name., ArSize); cin.get(); 而本节，使用的为： cin.get(ch); 从上面可以看出，cin.get()的参数可以为空，可以是一个char类型的变量，甚至还可以是两个参数：一个整型，一个char型。这是因为C++支持函数重载。函数重载允许创建多个同名函数，条件是它们的参数列表不同。例如：如果在C++中使用cin.get(name, Arsize)，则编译器将找到使用char*和int作为参数的cin.get()版本；如果使用cin.get(ch)，则编译器将使用接受一个char参数的版本。 5.5.4 文件末尾前面的输入程序通过使用#符号来表示输入结束，这样难令人满意，因为这样的符号可能就是合法的输入的组成部分。如果输入来自一个文件，则可以使用一种功能更强大的计数—检测文件末尾(EOF)。C++输入工具和操作系统协同工作，来检测文件末尾并将这种信息告知程序。 检测到EOF后，cin将两位(eofbit和failbit)都设置为1。可以通过成员函数eof()来查看eofbit是否被设置；如果检测到EOF，则cin.eof()将返回true，否则返回false。同样，如果failbit被设置为1，则fail()成员函数返回true，否则返回false。注意：eof和fail方法报告最近读取的结果；即它们事后报告，而不是预先报告，因此应当cin.eof()或cin.fail()测试应放在读取后。一般使用fail()，其可用于更多的实现中。 textcin3.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int count = 0; cout &lt;&lt; &quot;Enter characters, enter # to quit: \n&quot;; cin.get(ch); while (cin.fail() == false) { cout &lt;&lt; ch; ++ count; cin.get(ch); } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read. \n&quot;; return 0; } 结果： Enter characters, enter # to quit: yes yes it is very good yes yes it is very good no no i don&apos;t agree no no i don&apos;t agree //此处使用快捷键ctrl+d(Linux系统)，windows系统使用Ctrl+z 44 characters read. 注意：Windows下面Ctrl+z就相当于EOFLinux下面Ctrl+d相当于EOF。 1. EOF结束输入 cin方法检测到EOF时，将设置cin对象中一个指示EOF条件的标记。设置这个标记后，cin将不读取输入，再次调用cin也不管用。对于文件输入是有道理，因为程序不应读取超出文件末尾的内容。 然而对于键盘输入，有可能使用模拟EOF来结束循环，但稍后要读取其他输入，cin.clear()方法可能清除EOF标记，使输入继续进行。不过在某些系统中（比如：Linux），输入快捷键将结束输入和输出，而cin.clear()将无法恢复输入和输出。 2. 常见的字符输入做法 cin.get(ch); while (cin.fail() == false) { cout &lt;&lt; ch; ++ count; cin.get(ch); } 可以将上述代码使用一些简洁方式。!运算符将true切换为false或将false切换为true。比如: while (!cin.fail()) 方法cin.get(char)的返回值是一个cin对象。然而，istream类提供了一个可以将istreamd对象(cin)转换为bool值得函数；但cin出现在需要是bool值得地方（while循环得测试条件中）时，该转换函数被调用。意味着可以改写为： while (cin) 这比cin.eof()和cin.fail()更通用，因为cin还可以检测到其他失败的原因，比如磁盘故障。 最后，由于cin.get(char)的返回值为cin，因此可以将循环简写为： while (cin.get(ch)) {} 这样，cin.get(char)只被调用一次，而不是两次：循环前一次，循环后一次。为判断循环测试条件，程序必须先调用cin.get(ch)，如果成功，则将值放入ch中，然后，程序获得函数的返回值，即cin。接下来，程序对cin进行bool转换，如果输入成功，则结果为true，否则为false。 5.5.5 另一个cin.ge()版本C语言中字符I/O函数–getchar()和putchar()，它们仍旧适用，只要包含头文件stdio.h(或cstdio)即可。也可以使用istream和iostream中类似的成员。 不接受任何参数的cin.get()成员函数将返回输入中的下一个字符： int ch; ch = cin.get(); 该函数的工作方式与C语言中getchar()相似，将字符编码作为int值返回，而cin.get(ch)返回一个对象，而不是读取的字符。同样，可以使用cout.put()函数来显示字符： cout.put(ch); 该函数的工作方式与C语言中的putchar()类似，只不过其参数类型为char，而不是int。C++实现提供了三种原型：put(char),put(signed char),put(unsigned char)。给put一个int类型将导致错误类型，但可以通过强制类型转换实现：cin.put(char(ch))。 当函数到达EOF时，cin.get()将返回一个符号常量EOF表示的特殊值。该常量是在头文件iostream中定义的。通常，EOF被定义为-1，但没必要知道实际值，而必需在程序中使用EOF即可。 cin.get(ch); while (ch != EOF) { cout &lt;&lt; ch; ++ count; cin.get(ch); } 由于EOF表示的不是有效字符编码，因此可能不与char类型兼容，例如：在有些系统中，char类型是没有符号的，因此char变量不可能为EOF值(-1)。由于这种原因，如果使用cin.get()并测试EOF，则必须将返回值赋给int类型，而不是char类型。但是，如果将ch的类型声明为int，而不是char，则必须在显示ch时强制转换为char类型。 textcin5.cpp #include &lt;iostream&gt; using namespace std; int main() { int ch; int count = 0; while ((ch = cin.get()) != EOF) { cout.put(ch); count++; } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read.\n&quot;; return 0; } 结果: the smalller the smalller good boy good boy //按下快捷键ctrl+d 22 characters read. 循环条件，如果写成如下形式： while ( ch = cin.get() != EOF) 由于！=的优先级高于=，因此程序首先对cin.get()的返回值和EOF进行比较。比较的的结果为false或true，而这些bool值被转换为0或1，并赋值给ch。 ch=cin.get()和cin.get(ch)的区别 属性 cin.get(ch) ch = cin.get() 传递输入字符的方式 赋给参数ch 将函数返回值赋给ch 用于字符输入时函数的返回值 istrem对象(执行bool转换后为true) int类型的字符编码 达到EOF时函数的返回值 istream对象(执行bool转换后为false) EOF cin.get(ch1).get(ch2) 这是可行的，因为函数cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)。 5.6 嵌套循环和二维数组二维数组的声明如下： int maxtemps[4][5]; 该声明意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组成的数组。表达式maxtemps[0]是maxtemps数组e第一个元素，因此maxtemps[0]本身就是一个由5个int组成的数组。maxtemps[0]数组的第一个元素是maxtemps[0][0]，该元素是int元素。可以认为第一个下标表示行，第二个下标表示列。 假设要打数组的所有内容： for (int row = 0; row &lt; 4; row++) { for (int col = 0; col &lt; 5; col++) cout &lt;&lt; maxtemps[row][col] &lt;&lt; &quot;\t&quot;; cout &lt;&lt; endl; } 5.6.1 初始化二维数组创建二维数组时，可以初始化其所有元素： int maxtemps[4][5] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7}, {4,5,6,7,8}, }; 5.6.2 使用二维数组nested.cpp #include &lt;iostream&gt; using namespace std; const int Cities = 5; const int Years = 4; int main() { const char * cities[Cities] = { &quot;Griblle&quot;, &quot;Gribbletown&quot;, &quot;New Gribble&quot;, &quot;San Gribble&quot;, &quot;Gribble Vista&quot; }; int maxtemps[Years][Cities] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7}, {4,5,6,7,8}, }; cout &lt;&lt; &quot;Maximum tempeartures for 2008-2011\n&quot;; for (int city = 0; city &lt; Cities; city++) { cout &lt;&lt; cities[city] &lt;&lt; &quot;: \t&quot;; for (int year = 0; year &lt; Years; year++) cout &lt;&lt; maxtemps[year][city] &lt;&lt; &quot;\t&quot;; cout &lt;&lt; endl; } return 0; } 结果： Maximum tempeartures for 2008-2011 Griblle: 1 2 3 4 Gribbletown: 2 3 4 5 New Gribble: 3 4 5 6 San Gribble: 4 5 6 7 Gribble Vista: 5 6 7 8 5.7 总结C++提供三种循环：for循环、while循环和do while循环。]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(一)--概论]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E4%B8%80)--%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[五层协议体系结构、计算机网络性能 一、计算机网络的性能1.速率比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。bit来源于binary digit,意思是一个“二进制数字”。一个比特就是二进制数字中的一个1或0。速率指的是连接在计算机网络上的主机在数字信道上传输数据的速率。速率的单位b/s(比特每秒)或(bit/s)，有时也写为bps，即bit per second。 2.带宽 带宽本来指某个信号具有的频带宽度。 在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，网络带宽表示单位时间内从网络中的某一点到另一点所能通过的最高数据率。 二、五层协议体系结构OSI的七层协议体系结构的概念清楚，理论完整，但是它既复杂又不实用。TCP/IP体系结构则不同，它现在已经广泛应用。TCP/IP是一个四层的体系结构，包括：应用层、运输层、网际层和网络接口层。但是TCP/IP只有最上面的三层，因为最下面的网络接口层基本和一般的通信链路在功能上没有多大的差别，对于计算机网络，网络接口层并没有声明特别新的具体内容。因此，综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。 (1)应用层 应用层时体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互规则。这里的进程指的是正在运行的程序。对于不同的网络应用需要有不同的应用层协议，比如：支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传输的FTP协议。 (2)运输层 运输层的任务就是负责两个主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。多种应用可以使用同一个运输层服务，由于同一台主机可同时运行多个进程，因此运输层有复用和分用的功能。 运输层主要使用的协议： 传输控制协议TCP–提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段。 用户数据报协议UDP–提供无连接的、尽最大努力的数据传输服务，其数据传输的单位是用户数据报。 (3)网络层 网络层负责为分组交换网上的不同主机通过通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。 网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。 (4)数据链路层 数据链路层简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这需要使用专门的链路层协议。在两个相邻结点之间传送数据时，数据链路层间网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。 在接收数据时，控制捏成使接收端能够知道一个帧从哪个比特开始和到哪个比特阶数。这样，数据链路层收到一个帧后，就可从中提出取数据部分，上交给网络层。 控制信息还使接收端能够检测所接收到的帧中有无差错。如果发现差错，则丢弃差错帧。如果需要改正数据在数据链路层传输时出现的差错，那么需要采用可靠传输协议来纠正差错。 (5)物理层 在物理层上所传数据的单位时比特。 实体，表示任何可发送或接受信息的硬件或软件进程。 协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议，还需要使用下一层所提供的服务。协议是”水平的“，服务是“垂直的”。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(二)--物理层]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E4%BA%8C)--%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层 一、数据通信系统模型通信系统包括：原系统（发送端）、传输系统（传输网络）、目的系统（接收端）。 源系统包括以下两部分： 源点：源点设备产生要传输的数据，例如，从PC键盘输入函数，PC产生输出的数字比特流。 发送器：源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。 目的系统一般包括两个部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器。 终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出。 通信的目的是传送信息。数据是运送信息的实体。 根据信号中代表信息的参数的取值方式不同，信号可分为两类： 模拟信号，或连续信号–代表消息的参数的取值是连续的。 数字信号，或离散信号–代表消息的参数的取值是离散的。，在使用时间域(或简称为时域)的波形表示数字信号时，则代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一种代表1状态。 通信的双方信息交互的方式来看，可以有三种基本方式： 单工通信：即只能有一个方向的通信而没有方向的交互。比如:无线电广播 半双工通信: 通信的双方都可以发送信息，但不能双方同时发送。 全双工通信： 通信的双方可以同时发送和接收信息。 二、信道复用技术2.4.1 频分复用和时分复用频分复用最简单，如下图中左图。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。可见频分复用的所有用户在同样的时间占用不同的带宽资源（这里的带宽是频率带宽而不是数据的发送速率）。 时分复用，则是将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每个一个TDM帧中所占用固定序号的时隙。在下图右图中，只画出了4个用户A、B、C、D。每个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）。因此TDM信号也称等时信号。可见，时分复用的所有用户是在不同的时间所占用同样的频带宽度。 这两种复用方法的优点是技术比较成熟，但缺点 是不够灵活。时分复用则更有利于数字信号的传输。 在进行通信时，复用器和分用器成对使用。在复用器和分用器之间是用户共享的高速信道。分用器的作用和复用器的作用刚好相反，它把高速信道传送过来的数据进行分用，分别送交到相应的用户。 由于时分复用中，每个用户所分配到的时隙长度缩短了。当某些用户暂时无数据发送，在时分复用帧中分配给该用户的时隙只能处于空间状态，其他用户即使一直有数据发送，也不能使用这些空闲的时隙。这就导致复用后的信道利用率不高。 统计时分复用（STDM）是一种改进的时分复用，它能够明显提高信道的利用率。集中器常用这种统计时分复用。下图是统计时分复用的原理图。一个使用统计时分复用的集中器连接4个低速用户，然后将它们的数据集中起来通过高速路线发送到一个远地计算机。 统计时分复用使用STDM帧来传送复用的数据。但每一个STDM帧的时隙数小于连接在集中器上的用户数。个用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中。对没有数据的缓存就跳过。当一个帧放满了，就发送出去。可见，STDM帧不是固定分配时隙，而是按需动态地分配时隙。 在输出线路上，某个用户所占用的时隙并不是周期性地出现，因此统计时分复用又称为异步时分复用，而普通的时分复用称为同步时分复用。 使用统计时分复用的集中器也叫做智能复用器，他能提高对整个报文的存储转发能力，通过排队方式使各用户更合理地共享信道。此外，许多集中器还可能具有路由选择、数据压缩、前向纠错等功能。 2.4.2 波分复用波分复用WDM就是光的频分复用。光纤技术的应用使得数据的传输速率空前提高。使用一根光纤来同时传输多个频率很接近的光载波信号，这样就使光纤的传输能力成倍地提高。由于光载波的频率很高，因此习惯用波长而不是频率来标识所使用的光载波，因此使用波分复用这个名词。 波分复用只能在一根光纤上传输两路光载波信号，现在已经能做到一根光纤上复用几十路或更多的光载波信号，于是称为密集波复用(DWDM)。 ###2.4.3 码分复用 码分复用(CDM)是另一个种共享信道的方法，实际上常用的是码分多址(CDMA)。每一个用户可以在同样的时间使用同样的频带进行通信。 由于各用户使用经过挑选的不同码型，因此各用户之间不会造成干扰。 在CDMA中，每一个比特时间再划分为$m$个短的间隔，称为码片。通常$m$的值为64或128。为了简单，设$m$为8。 使用CMDA的每一个站被指派一个唯一的$m$bit码片序列。一个站如果发送比特1，则发送它自己的$m$bit码片序列。如果发送比特0，则发送该码片序列的二进制反码。例如，指派给S站的8个bit码片00011011，当S发送比特1，他就发送序列00011011，而当S发送比特0时，就发送11100100。为了方便，按惯例将码片中的0写为-1，1写为+1。因此S站的码片序列是（-1-1-1+1+1-1+1+1）。 假设S站要发送信息的数据率为$b$b/s。由于每一个比特要转换成$m$个比特的码片，因此S站实际上发送的数据率提高到$mb$b/s，同时S站所占用的频带宽度也提高到原来数值的$m$倍。这种通信方式是扩频通信中的一种。扩频通信有两大类： 直接序列扩频DSSS,上述使用的码片序列就是这一类； 跳频扩频FHSS。 CDMA系统的一个重要特点就是这种体制给每一个站分配的码片序列不仅必须各不相同，并且还必须相互正交，在实际系统中是使用伪随机码序列。 令向量S表示站S的码片向量，向量T表示其他站的码片向量。两个不同站的码片序列正交，就是向量S和T的规格化内积都是0： $S /cdot T = \frac{1}{m}\sum_{i=1}^mS_iT_i = 0$ 任何一个码片向量和该码片向量自己的规格化内积都是1： $S /cdot S = \frac{1}{m}\sum_{i=1}^mS_iS_i = \frac{1}{m}\sum_{i=1}^mS_i^2 = \frac{1}{m}\sum_{i=1}^m(\pm)^2= 1$ 而一个码片向量和该码片反码的向量的规格化内积值是-1。 下图是码分复用的例子： 当接受站打算收S站发送的信号时，就用S站的码片序列与收到的信号求规格化内积。这相当于分别计算$S \cdot S_x$和$S \cdot T_x$。显然，$S \cdot S_x$就是S站发送的数据比特，因此在计算规格化内积时，相加各项，得到的结果都是+1，或者都是-1；而$S \cdot T_x$一定是零，因为相加的各项中的+1和-1各占一般，因此总和一定是零。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--复合类型（四）]]></title>
    <url>%2F2018%2F09%2F12%2FC%2B%2B%20Primer%20Plus--%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复合类型介绍 4.1 数组数组是一种数据格式，能过存储多个同类型的值。例如，数组可以存储60个int类型的值。 创建数组，可使用声明语句，声明输入应指出以下三点： 存储在每个元素种的值的类型 数组名 数组种的元素数 C++中，可以通过修改简单变量的声明，添加中括号来完成数组声明。例如，下面的声明创建一个名为months的数组，该数组有12个元素，每个元素都可以存储一个short类型的值: short months[12] 事实上，可以将数组中的每个元素看作一个简单变量。声明数组的通用格式如下： typename arrayName[arraySize]; 表达式arraySize指定元素数目，它必须是整型或const值，也可以是常量表达式（如：8*sizeof(int)）,即其中所有的值在编译时都是已知的。具体说，arraySize不能时变量，变量的值时程序运行时设置。稍后，介绍如何使用new运算符来避免这种限制。 数组之所以称之为复合类型，是因为它是可以使用其他类型来创建的。不能仅仅将某种东西声明为数组，它必须是特定类型的数组。没有通用的数组类型，当存在很多特定的数组类型，如char类型或long数组。例如： float loans[20]; loans的类型不是“数组”，而是“float数组”。这强调loans数组是使用float类型创建的。 数组的很多用途都是基于这样一个事实：可以单独访问数组的元素。方法是使用下标或索引来对元素进行编号。C++数组从0开始编号。C++使用带索引的括号表示法来指定数组的元素。例如，months[0]是months数组的第一个元素，months[11]是最后一个元素。注意最后一个元素的索引比数组长度小1。因此，数组声明能过使用一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。 有效下标的重要性：编译器不会检查使用的下标是否有效。但是程序运行后，这种赋值可能引发问题，他可能破坏数据或代码，也可能导致程序异常终止。 数组初始化： int y[3] = {0,1,2}; sizeof运算符返回类型或数据对象的长度（单位为字节）。 sizeof(y); 4.1.1 数组初始化只有定义数组时才能初始化，此后就不能使用了，也不能将一个数组赋给另一个数组： int cards[5] = {3,6,8,10}; int hand[4]; hand[4] = {5,6,7,9}; //错误做法，hand[4] = 5;这样是替换低4个元素的值为5 hand = cards; //错误语法 然而，可以使用下标分别给数组中的元素赋值。 初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化hotelTips的前两个元素： float hotelTips[5] = {5.0, 2.5}; 如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。将数组中所有的元素初始化为0非常简单，只要显式地将第一个元素初始化0。然后编译器将其他元素都初始化为0即可： long totals[500] = {0}; 如果初始化数组方括号内([])为空，C++编译器将计算元素个数，例如，对于下面的声明： short things[] = {1,5,3,8}; 编译器将使things数组包含4个元素。 4.1.2 C++11数组初始化方法初始化时可以省略等号： double earning[3] {100.1, 112.2,133.2}; 可以在花括号中不包括任何内容，这将把所有元素都设置为零： float blances[100] {}; 列表初始化禁止缩窄转换： long plifs[] = {25, 3.0}; //错误语法，3.0为float无法转换为long char slifs[] = {&apos;h&apos;, &apos;i&apos;, 1122011}; //最后一个元素太大，char无法容纳，char变量的长度为8位 char tilfs[4] = {&apos;h&apos;, &apos;i&apos;, 24}; //正确做法 4.2 字符串字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种： 来自C语言，常被称为C-风格字符串 基于string类库的方法 存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。C-风格字符具有一种特殊的性质：以空字符结尾，用字符被写作\0,其ASCII码为0，用来标记字符串的结尾。例如： char dog[4] = {&apos;b&apos;,&apos;e&apos;,&apos;a&apos;,&apos;x&apos;}; //不是一个字符串 char cat[4] = {&apos;f&apos;,&apos;s&apos;,&apos;a&apos;,&apos;\0&apos;}; //是一个字符串 这两个数组都是char数组，但只有第二个数组是字符串。空字符对C-风格字符串而言至关重要。例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数，它们都逐个地字符串中的字符，直到到达一个空字符为止。如果使用cout显式cat这样的字符串，则将前3个字符，发现空字符后停止。如果使用cout显式上面的dog数组（他不是字符串），cout将打印出数组中的4个字符，并接着将内存中随后的各个字节解释为要打印的字符，直到遇到控制符为止。由于空字符（实际上是被设置为0的字节）在内存中是常见的，因此这一过程很快就停止。 一种更好的、将字符数组数组初始化为字符串的方法–只需使用一个引号括起来的字符即可，这种字符串被称为字符串常量或字符串字面值，如下： char bird[11] = &quot;Mr. Cheeps&quot;; char fish[] = &quot;Bubbles&quot;; 用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。 C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上末尾的空字符。当然应确保数组足够大，能过存储字符串中的所有字符—包括空字符。 注意：在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。 字符串常量（使用双引号）不能与字符常量（使用单引号）互换。字符常量（如‘S’）是字符串编码的简写表示。在ASCII系统上，‘S’只是83的另一种写法，因此，下面的语句将83赋给shirt_size: char shirt_size = &apos;S&apos;; 但”S”不是字符常量,它表示的是两个字符（字符S和\0）组成的字符串。更糟糕的是，”S”实际上表示的是字符串所在的内存地址。因此，下面的语句试图将一个内存地址赋给shirt_size: char shirt_size = &quot;S&quot;;//错误的做法 由于地址在C++中是一种独立的类型，因此编译器不允许这种不合理的做法。 4.2.1 拼接字符串常量但字符串很长无法放到一行时，C++允许拼接字符串字面值，即将两个用引号括起来的字符串合并为一个。 事实上，任何两个有空白（空格、制表符、换行符）分割的字符串常量都将自动拼接成一个。下面语句等价： cout &lt;&lt; &quot;I&apos;d give my right arm to ba &quot; &quot;a great violinist.\n&quot;; cout &lt;&lt; &quot;I&apos;d give my right arm to ba a great violinist.\n&quot;; cout &lt;&lt; &quot;I&apos;d give my right ar&quot; &quot;m to ba a great violinist.\n&quot; 注意，拼接时不会再被连接的字符串之间添加空格，第二个字符串的第一个字符将紧接在第一个字符串的最后一个字符（不考虑\0）后面。第一个字符串中的\0会被第二个字符串中的第一个字符取代。 4.2.2 在数组中使用字符串将字符串存段数组中，常用的两种方法： 将数组初始化为字符串常量 将键盘或文件输入读入到数组中 string.cpp #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; int main() { const int Size = 15; char name1[Size]; char name2[Size] = &quot;C++owboy&quot;; cout &lt;&lt; &quot;Howdy! I&apos;m &quot; &lt;&lt; name2; cout &lt;&lt; &quot;! What&apos;s your name? \n&quot;; cin &gt;&gt; name1; cout &lt;&lt; &quot;Well, &quot; &lt;&lt; name1 &lt;&lt; endl; cout &lt;&lt; &quot;Your name has &quot; &lt;&lt; strlen(name1) &lt;&lt; &quot; letters and is stored&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Your name has &quot; &lt;&lt; sizeof(name1) &lt;&lt; &quot; bytes. \n&quot; ; name2[3] = &apos;\0&apos;; //第四个字符设置为空字符，打印字符串时，到此结束 cout &lt;&lt; &quot;First 3 characters of my name: &quot; &lt;&lt; name2 &lt;&lt; endl; return 0; } 结果：Howdy! I’m C++owboy! What’s your name? zxphelloWell, zxphelloYour name has 8 letters and is storedYour name has 15 bytes. First 3 characters of my name: C++ sizeof运算符指出整个数组的长度：15字节；但strlen()函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。另外，strlen()只计算可见的字符，空字符不计算在内。如果存储字符串cosmic,数组的长度不能短于strlen(comisc) + 1。 注意：使用符合常量表示数组长度，当修改程序以使用不同数组长度时，工作变得非常简单。 4.2.3 字符串输入程序inst1.cpp #include &lt;iostream&gt; using namespace std; int main() { const int Size = 20; char name[Size]; char dessert[Size]; cout &lt;&lt; &quot;Enter your name: \n&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;Enter your favorite dessert: \n&quot;; cin &gt;&gt; dessert; cout &lt;&lt; name &lt;&lt; &quot; like &quot;&lt;&lt; dessert &lt;&lt; endl; return 0; } 结果： [root@localhost ~]# ./a.out&lt;/br&gt; Enter your name: &lt;/br&gt; zxp&lt;/br&gt; Enter your favorite dessert:&lt;/br&gt; kk&lt;/br&gt; zxp like kk&lt;/br&gt; [root@localhost ~]# ./a.out&lt;/br&gt; Enter your name: &lt;/br&gt; zxp zxp1&lt;/br&gt; Enter your favorite dessert: &lt;/br&gt; zxp like zxp1&lt;/br&gt; 对于第二种情况，我们还没有对“输入甜点的提示”做出反应，程序便他把显示出来。 由于不能通过键盘输入空字符，因此cin需要用别的方法来字符串的结尾位置。cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。 这个例子的实际结果是，cin把zxp作为第一个字符串，并将它放到name数组中。把zxp1留在队列中，当cin在输入队列中搜索用户喜欢的甜点时，它发现了zxp1,因此cin读取zxp1,并将它放到dessert数组中。 4.2.4 每次读取一行字符串输入当程序要求用户输入城市名，用户输入New York,希望完整的存储城市名，而不仅仅是New。 istream中的类（如cin）提供了面向行的类成员：getline()和get()。这两个函数都读取一行输入，直到到达换行符。然而，随后getline()将丢弃换行符，而get()将换行符保留在输入序列中。 1、getline() 使用cin.getline()调用。该函数有两个参数： 用来存储输入行的数组的名称参数 要读取字符数的参数，getline()成员函数，在读取指定数目的字符或遇到换行符时停止读取。 例如，使用getline()将姓名读取到一个包含20个元素的name数组中： cin.getline(name, 20); 如果一行读入不超过19个字符，将全部读取到name数组中。 将instr1.cpp程序修改为使用cin.getline(),而不是简单的cin。 #include &lt;iostream&gt; using namespace std; int main() { const int Size = 20; char name[Size]; char dessert[Size]; cout &lt;&lt; &quot;Enter your name: \n&quot;; cin.getline(name, Size); cout &lt;&lt; &quot;Enter your favorite dessert: \n&quot;; cin.getline(dessert, Size); cout &lt;&lt; name &lt;&lt; &quot; like &quot;&lt;&lt; dessert &lt;&lt; endl; return 0; } 结果： [root@localhost ~]# ./a.out Enter your name: zxp zxp1 Enter your favorite dessert: kk dd zxp zxp1 like kk dd 该程序可以读取完整的姓名和用户喜欢的甜点。getline()函数每次读取一行，通过换行符来确定行尾，但不保存换行符。 2、get() get()函数的参数跟getline()相同，解释参数的方式也相同，并且都读取到行尾。但get()不丢弃换行符，而是将其留在输入队列中。假设，连续两次调用get(): cin.get(name, Arsize); cin.get(dessert, Arsize); 由于第一次调用后，换行符还在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get()默认已到达行尾，而没有读取到任何内容。 一种方法是通过使用get()的变体，使用不带参数的cin.get()调用可读取下一个字符（即使换行符），因此可以用它来处理换行符： cin.get(name, Arsize); cin.get() cin.get(dessert, Arsize); 另一种使用get()的方式是将两个类成员函数拼接起来（合并）： cin.get(name, Arsize).get(); 这样做，是由于cin.get(name, Arsize)返回一个cin对象，该对象随后调用get()函数。 下面语句跟两次调用getline()效果相同: cin.getline(name1, Arsize).getline(name1,Arsize); 使用get()使输入更仔细。例如，假设用get()将一行读入到数组中，如何直到停止的原因是由于已经读取了整行，而不是由于数组已填满。查看下一个输入字符，如果是换行符，说面已读取了整行，否则，说明该行中还有其他输入。 3、空行和其他问题 当getline()和get()读取空行时，最初的做法，下一条输入语句将在前一条getline()或get()结束读取的位置开始读取。当前做法，当get()（而不是getline()）读取空行后，将设置失效位（failbit）,这意味着接下来的输入被阻断，但可以使用如下命令来恢复输入： cin.clear() 另一个问题是：输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则getline()和get()将把余下的字符保留在队列中，而getline()还会设置失效位，并关闭后面的输入。 4.2.5 混合输入字符串和数字numstr.cpp #include &lt;iostream&gt; using namespace std; int main() { int year; char address[80]; cout &lt;&lt; &quot;Enter year:\n&quot; ; cin &gt;&gt; year; cout &lt;&lt; &quot;Enter address:\n&quot;; // cin &gt;&gt; address; cin.getline(address,80); cout &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt;endl; cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; endl; return 0; } 结果： Enter year:1991Enter address:Year: 1991Address: 用户根本没有输入地址。问题在于cin读取年份，将回车生成的换行符留在的输入队列中。后面的cin.getline()看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。解决的办法是：在读取地址之前先读取并丢弃换行符。具体方法是： cin.get();//调用一个没有参数的get() 或者 cin.get(ch); //调用一个接受参数的get() 或者 (cin &gt;&gt; year).get(); 或者 (cin &gt;&gt; year).get(ch); 4.3 string类简介string类型的变量可以存储字符串，不是使用字符数组的方式存储。string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表达方式。 使用string类，必须在程序中包含头文件string。string类位于命名空间std中，因此必须通告一条using编译指令，或者使用std::string来引用它。string来定义隐藏了字符串的数组特性。 strtype1.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { char ch1[20]; char ch2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; cout &lt;&lt; &quot;Enter a king of feline:\n&quot;; cin &gt;&gt; ch1; cout &lt;&lt; &quot;Enter another king of faline: \n&quot;; cin &gt;&gt; str1; cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; &quot;ch2: &quot; &lt;&lt; ch2 &lt;&lt; endl; cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl; return 0; } 结果：Enter a king of feline:ocelotEnter another king of faline: tigerch1: ocelotch2: jaguarstr1: tigerstr2: panther string类设计让程序能够处理string的大小。例如：str1的声明创建一个长度为0的string对象，当程序将输入读取到str1中时，将自动调整str1的长度。这跟数组相比，使用string更安全方便。 char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。 C++11字符串初始化C++11也允许将列表初始化用于字符串和string对象： char ch1[] = {&quot;aaaa, 11&quot;}; string str1 = {&quot;bbb, 22&quot;} 赋值、拼接和附加使用string类时，一些操作比数组更简单。比如：不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。 char ch1[20]; char ch2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; ch1 = ch2; str1 = str2; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { char ch1[20]; char ch2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; ch1 = ch2;//语法错误 str1 = str2; cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; &quot;ch2: &quot; &lt;&lt; ch2 &lt;&lt; endl; cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl; return 0; } 报错：strtype1.cpp: 在函数‘int main()’中:strtype1.cpp:14:6: 错误：无效的数组赋值 ch1 = ch2; string类简化了字符串的合并操作。可以使用+运算符将两个string对象合并，还可以将字符串附加到string对象的末尾。即： string str3; str3 = str1 + str2; str1 += str2; string类的其他操作C-风格字符串一些常用函数（包含在cstring头文件中）： 字符串赋值到字符数组中：使用strcpy()函数 将字符串附加到字符数组末尾：使用strcat()函数 获取数组字符串长度：strlen(ch1) 获取string类字符串长度： str1.size()，size()是一个类方法，只能通过所属类的对象进行调用。 strtype3.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; int main() { char ch1[20]; char ch2[20] = &quot;jaguar&quot;; int len1 = strlen(ch2); string str1 = &quot;12345&quot;; int len2 = str1.size(); strcpy(ch1, ch2 ); strcat(ch1, &quot;ccc&quot;); cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; &quot;ch2: &quot; &lt;&lt; ch2 &lt;&lt; endl; cout &lt;&lt; &quot;len1: &quot; &lt;&lt; len1 &lt;&lt; endl; cout &lt;&lt; &quot;len2: &quot; &lt;&lt; len2 &lt;&lt; endl; return 0; } 结果： ch1: jaguarccc ch2: jaguar len1: 6 len2: 5 4.3.4 string类I/Ostrtype2.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; int main() { char ch1[20]; string str1; cout &lt;&lt; &quot;ch1&apos;s length before input: &quot; &lt;&lt; strlen(ch1) &lt;&lt; endl; cout &lt;&lt; &quot;str&apos;s length before input: &quot; &lt;&lt; str1.size() &lt;&lt; endl; cout &lt;&lt; &quot;Enter a line of text: \n&quot;; cin.getline(ch1,20); cout &lt;&lt; &quot;Enter another line of text: \n&quot;; getline(cin,str1); cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; &quot; it&apos;s length: &quot; &lt;&lt; strlen(ch1) &lt;&lt; endl; cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; &quot; it&apos;s length: &quot; &lt;&lt; str1.size() &lt;&lt; endl; return 0; } 结果： ch1&apos;s length before input: 6 str&apos;s length before input: 0 Enter a line of text: abc Enter another line of text: kkkk ch1: abc it&apos;s length: 3 str1: kkkk it&apos;s length: 4 用户输入之前，指定了ch1的长度为20，而输出为6，这是因为： 初始化的数组的内容未定义 函数strlen()从数组的第一个元素开始计算字节数，直到遇到空字符 在本例中，在数组中第6个字节遇到空字符。对于未被初始化的数据，第一个空字符出现的位置是随机的，也可能出现数组规定字节外，这样数组的长度大于20。 getline(ch1, 20)是一个istream类的一个类方法，第一个参数为目标数组，第二参数为数组长度。 getline(cin, str1)表明getline（）不是类方法(类方法使用句点表示法),它将cin作为参数，指出从哪里查找输入。另外，没有规定字符串的长度，string对象会根据字符串的长度自动调整大小。 getline()一个是istream的类方法，而另一个不是。在引入string之前，C++就有istream类，因此istrem设计考虑了int、double等数据类型，但没有考虑string类型，所以没有处理string对象的方法。但处理string对象的代码使用string类的一个友元函数。 4.3.5 其他形式的字符串字面值除char类型外，C++还有类型wchar_t，C++新增了char16_t和char32_t。可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分布使用前缀L、u和U来表示，如下： wchar_t a[] = L&quot;aaaa&quot;; char16_t b[] = u&quot;bbbb&quot;; char32_t c[] = U&quot;cccc&quot;; C++11还支持Unicode字符编码方案UTF-8。在这种方案中，根据编码的数字值，字符可能存储为1~4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。 C++11还增加了另一种新类型是原始(raw)字符串。在原始字符串中，字符表示的就是自己。例如：\n不表示换行符，而是两个常规的字符–斜杠和n。还有在字符中使用”,不用\”来表示。原始字符串使用”(和)”来做定界符，并使用前缀R来标识。 cout &lt;&lt; R&quot;(Jim &quot;King&quot; \n instead of endl.)&quot; &lt;&lt; &apos;\n&apos;; 输出为： Jim &quot;King&quot; \n instead of endl. 原始字符串的界定符还可以自己设定，比如：有时候需要在字符串中输入”(或者)”,这是需要自定义界定符。可以在”和(之间添加任意符号，这样在字符串结尾的)和”之间也要添加这些字符。比如：使用R”+#(标识字符串的开头，必须使用)(+#”作为原始字符串的结尾。因此由： cout &lt;&lt; R&quot;+#(Jim Keing&quot;(hello world)&quot;)+=&quot; &lt;&lt; endl; 4.4 结构简介结构是一种比较灵活的数据格式，同一个结构中可以存储多种类型的数据。结构也是C++面向对象(类)的基石。结构是用户自定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。创建一个结构包括两步：定义结构描述；按描述创建结构变量。 结构描述如下： struct inflatable { char name[20]; float volume; double price; } 其中关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称，因此新类型的名称为inflatable。定义结构后，便可以创建这种类型的变量： inflatable hat; inflatable mainframe; C中要求添加struct关键字,如下： struct inflatable hat; 因为hat的类型为inflatable，因此可以是一个.操作符访问各个成员。比如：hat.volume指的是结构得volume成员。 4.4.1 程序中使用结构体structur.cpp #include &lt;iostream&gt; using namespace std; struct inflatable { char name[20]; float volume; double price; }; int main() { inflatable guest = {&quot;gloria&quot;, 1.88, 29.99}; inflatable pal = {&quot;Arthur&quot;, 3.12, 32.99}; cout &lt;&lt; &quot;Guest: &quot; &lt;&lt; guest.name &lt;&lt; &quot; &quot; &lt;&lt; guest.volume &lt;&lt; &quot; &quot; &lt;&lt; guest.price &lt;&lt; endl; cout &lt;&lt; pal.price + guest.price &lt;&lt; endl; return 0; } 结果：Guest: gloria 1.88 29.9962.98 结果声明声明得位置有两种选择，第一，放在main()函数中；第二，放在main()函数的前面，其他函数也可以访问。变量也可以在函数内部和外部定义，外部定义由所有函数共享。 C++结构初始化与数组踹坏，C++也支持列表初始化用于结构，且等号是可选的： inflatable duck {&quot;Daphe&quot;, 0.12, 9,89}; 其次，如果大括号内为空，各个成员初始化为零。如下： inflatable mayor {}; 最后，不允许缩窄转换。 结构可以使用string类o成员struct inflatable { std::string name; float volume; double price; }; 其他结构属性 结构变量之间可以使用赋值运算符; 结构可以作为参数传递给函数，也可以让函数返回一个结构； assgn_st.cpp #include &lt;iostream&gt; using namespace std; struct inflatable { char name[20]; float volume; double price; }; int main() { inflatable bou = {&quot;sun&quot;, 0.2, 12.49}; inflatable choice; choice = bou; cout &lt;&lt; &quot;choice: &quot; &lt;&lt; choice.price &lt;&lt; endl; return 0; } 结果： choice: 12.49 从中可见成员赋值是有效的，choice结构中的成员值与bouquet结构中存储的值相同。 可以同时完成定义结构和创建结果的工作，如下： struct perks { int key_num; char car[12]; }mr_smith, ms_jones; 甚至可以初始化以这种方式创建的变量： struct perks { int key_num; char car[12]; }mr_smith ={7, &quot;Packard&quot;}; 还可以声明没有名称的结构体，这样以后无法创建这种类型的变量，如下： struct { int key_num; char car[12]; }mr_smith; 创建了一个mr_smith变量，可以访问其中的成员。 4.4.5 结构数组可以创建结构数组，比如，创建一个包含100个inflatable结构的数组，如下： inflatable gifts[100]; 这样gifts是一个inflatable数组，其中的每个元素(如gifts[0])都是inflatable对象，可以与成员运算符一起使用： cin &gt;&gt; gifts[0].volume; gifts本身是一个数组，不是一个结构。因此gifts.price是无效的。 初始化结构数组，可以结合使用初始化数组的规则，具体如下： inflatable guests[2] = { {&quot;zzz&quot;, 1.2, 33.4}, {&quot;ddd&quot;, 0.4, 33,2} }; 4.4.6 结构中的位字段C++允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段(bit field)。下面是一个例子： struct torgle_register { unsigned int SN : 4; ussigned int :4 ; bool goodIn : 1; bool goodTorgle : 1; } 可以先通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段： torgle_register tr = {14, true, false}; cout &lt;&lt; tr.goodIn; 位字段一般使用在低级编程中。 4.5 共用体共用体(union)是一种数据格式，它能够存储不同的数据格式，但只能同时存储其中的一种类型。即，结构体可以同时存储int、long和double,共用体只能存储int、long或double。共用体的句法与结构体相似，但含义不同。 union one4all { int int_val; long long_val; double double_val; } 可以使用one4all变量来存储int、long或double，条件是在不同的时间进行： one4all pail; pail.int_val = 15; cout &lt;&lt; pail.int_val; pail.double_val = 2.2; //int_val的值丢失 cout &lt;&lt; pail.double_val; 因此，pail有时可以是int变量，而有时是double类型的变量。通用体每次只能存储一个值，因此必须有足够大的空间来存储最大的成员，所以共用体的长度为其最大成员的长度。 共用体的用处之一是，但数据项使用两种或多种格式时，可节省空间。例如：管理一个小商品目录，其中一些商品的ID为整型，而另一些为字符串。在这种情况可以如下： struct widget { char brand[20]; int tyep; union id { long id_num; char id_char[20]; } id_val; }; widget prize; if (prize.type == 1) cin &gt;&gt; prize.id_val.id_num; else cin &gt;&gt; prize.id_val.id_char; 匿名共用体没有名称，其成员将成为位于相同地址出的变量，显然，每次只有一个成员是当前的成员： struct widget { char brand[20]; int tyep; union { long id_num; char id_char[20]; } ; }; widget prize; if (prize.type == 1) cin &gt;&gt; prize.id_num; else cin &gt;&gt; prize..id_char; 由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。共用体用于节省内存。但C++用于嵌入式编程，如控制烤箱或火星漫步者的处理器，内存非常宝贵。 4.6 枚举C++的enum工具提供了另一种创建符号常量的方式，这种方式可以替代const。它还允许定义新类型，但必须按照严格的限制进行。使用enum句法与使用结构相似。例如: enum spectrum {red, orange, yellow, green, blue, violet, indigo ultraviolet}; 该语句完成了两个工作: 让spectrum成为新类型的名称：spectrum被称为枚举(enumeration) 将red、orange等作为符号常量，它们对应整数值0~7，这些常量叫做枚举量。 利用枚举类型来声明这种类型的变量： spectrrm band; 对于枚举类型，只定义了赋值运算符，具体说，没有为枚举定义算术运算： band = orange; ++band; //非法 band = orange + yellow; //非法 band = 2000; //非法，2000不是一个枚举类型 枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型： int color = bule; band = 3; //非法 color = 3 + red; 如果int值是有效的，则可以通过强制类型转换，将它赋值给枚举变量： band = spectrum(3); 如果试图对一个适当的值进行强制类型转换，结果是不确定的，不会报错： band = spectrum(5000); 如果只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称，如下： enum {red, orange, yellow, green, blue, violet, indigo ultraviolet}; 4.6.1 设置枚举量的值可以使用赋值运算符来显示地设置枚举量的值： enum bits {one = 1, two = 2, four = 4, eight = 8}; 指定的值必须是整数，也可以只显示地定义其中一些枚举量地值： enum bigstep {first, second = 100, third}; 这里，first在默认情况下为0，后面没有被初始化地枚举量地值将比其前面的枚举量大1.因此third的值为101。 最火，可以创建多个值相同的枚举量： enum {zero, null = 0, one, numero_nuo = 1}; 其中，zero,null的值都没零，one和numero_nuo都为1。在早期，只能将int值赋给枚举类型，但这种限制取消了，因此可以使用long甚至long long类型的值。 4.6.2 枚举的取值范围对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都要取值范围，通过强制类型转换，可以将取值范围中的任何整数赋值给枚举变量，即使这个值不是枚举类型，如下: enum bits{one=1, two=2, four=4, eight=8}; bits myflag; 下面的代码合理： myflag = bits(6); 其中6不是枚举类型，但它位于枚举定义的取值范围内。 取值的范围定义如下：首先，找出上限，需要知道枚举的最大值。找出大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。计算下限，需要知道枚举量的最小值，如果它不小于0，则取值范围的下限为0；否则采用与寻找上限方式相同的方式，但加上负号。 例如:前面定义的bigstep的最大枚举值是101。在2的幂中，比这个数大的最小值是128，因此取值范围的上限为127。对于下限，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8，因此下限为-7。 4.7 指针和自由存储空间使用&amp;地址运算符，获取变量的地址。例如，如果home是一个变量，则&amp;home是它的地址。 #include &lt;iostream&gt; int main() { using namespace std; int donuts = 6; double cups = 4.5; cout &lt;&lt; &quot;donuts&apos;s addresss: &quot; &lt;&lt; &amp;donuts &lt;&lt; endl; cout &lt;&lt; &quot;cups&apos;s addresss: &quot; &lt;&lt; &amp;cups &lt;&lt; endl; return 0; } 结果：donuts’s addresss: 0x7ffe74cc89b8cups’s addresss: 0x7ffe74cc89b4 显示地址时，该实现的cout使用十六进制表示法，因为这是常用于描述内存的表示法。两个地址的差为：0x7ffe74cc89b8-0x7ffe74cc89b4（即4）,在实现中，donuts的存储位置比cups低，而这种类型使用4个字节。当然，不同的系统，存储的顺序以及字节大小都不同。 指针与C++基本原理： 面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段进行决策。运行阶段指的是程序正在运行，编译阶段指的是编译器将程序组合起来。运行阶段是做决策，程序应该如何运行，而编译阶段是安全预先设定的程序运行。 运行阶段决策提供了灵活性，可以根据当时的情况进行调整。比如：考虑为数组分配内存的情况。 一种特殊的变量–指针用于存储地址的值。$\ast$运算符被称为间接值或解除引用。 pointer.cpp #include &lt;iostream&gt; int main() { using namespace std; int updates = 6; int *p_updates; p_updates = &amp;updates; cout &lt;&lt; &quot;*p_updates: &quot; &lt;&lt; *p_updates &lt;&lt; endl; cout &lt;&lt; &quot;p_updates: &quot; &lt;&lt; p_updates &lt;&lt; endl; *p_updates = 1 + *p_updates; return 0; } 结果：$\ast$p_updates: 6p_updates: 0x7ffc6c803fa4$\ast$p_updates + 1: 7 从中可知，p_updates表示地址，使用$\ast$号运算符来获得值。$\ast$p_updates和updates完全等价。可以像int变量一样使用$\ast$p_updates。 4.7.1 声明和初始化指针声明指针，计算机需要跟踪指针指向的值的类型。比如：char的地址和double的地址，看上去一样，但char和double使用的字节数不同，它们存储值得内部格式不同。 int * p_updates; 或 int *p_updates; 或 int* p_updates; //int* 是一种类型--指向int的指针。 或 int*p_updates; 这表明，$\ast$updates的类型为int。由于$\ast$运算符被用于指针，因此p_updates变量本身必须是指针。 int* p1, p2; 注意上面的语句是创建一个指针(p1)和一个int变量(p2)。对于每个指针变量名，都需要使用一个$\ast$。 double * tax; char* str; 将tax声明为一个指向double的指针，编译器知道$\ast$tax是一个double类型的值。即$\ast$tax是一个以浮点数格式存储的值，这个值占据8个字节（不同系统可能不同）。指针变量不仅仅是指针，而且是指向特定类型的指针。虽然，tax和str指向两种不同长度的叔叔类型，但这两个变量本身的长度是相同的，即char的地址和double的地址的长度相同。 可以在声明语句中初始化。 int h = 5; int *ph = &amp;h; 被初始化的是指针，而不是它指向的值，即pt的值设为&h;而不是$\ast$pt的值。 4.7.2 指针的危险在C++中创建地址时，计算机分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步是错误的，如下： long * fellow; *fellow = 222; fellow确实是一个指针。上述代码没有将地址赋给fellow,那么222将被存放在哪里？由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储222的地址。 注意：一定要在对指针应用解除引用运算符（$\ast$）之前，将指针初始化为一个确定的、适当的地址。 4.7.3 指针和数字指针不是整型，索然计算机通常把地址当作整数处理。指针没有加减乘除运算，指针描述的是位置。不能简单的对将整数赋给地址： int *pt; pt = 0xB8000000; 在C++中，编译器将显示错误信息，类型不匹配。要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型： int *pt; pt = (int*) 0xB8000000; 这样，赋值语句两边都是整型的地址，因此赋值有效。pt是int值的地址，并不意味着pt本身的类型是int。 4.7.4 使用new来分配内存在C语言中，可以使用库函数malloc()来分配内存；而在C++让可以这样做，但C++提供了更好的方法—new运算符。 在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值： int *pn = new int; new int告诉程序，需要适合存储int的内存。new运算符根据类型确定需要多少字节的内存，然后找到这样的内存，并返回其地址，并将地址赋给pn，pn是被声明为指向int的指针。现在pn是地址，$\ast$pn存储那里的值。将这种方法于将变量的地址赋给指针进行对比: int h = 5; int *ph = &amp;h; 在这两种情况下，都是将一个int变量的地址赋给了指针。在第二种情况，可以通过变量名了访问该int值，而第一种情况只能通过指针进行访问。 为数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式： typeName *pointer_name = new typeName; use_new.cpp #include &lt;iostream&gt; int main() { using namespace std; int nights = 1001; int *pt = new int; *pt = 1001; cout &lt;&lt; &quot;*pt: &quot; &lt;&lt; *pt &lt;&lt; endl; cout &lt;&lt; &quot;pt: &quot; &lt;&lt; pt &lt;&lt; endl; cout &lt;&lt; &quot;&amp;nights: &quot; &lt;&lt; &amp;nights &lt;&lt; endl; return 0; } 结果：*pt: 1001pt: 0x220c010&amp;nights: 0x7ffc241baf94 new为int数据对象分配内存，这是在程序运行时进行的。指针必须声明所指向的类型的原因是：地址本身只指出了对象存储的地址开始，而没有指出其类型(使用的字节数)。 对于指针，new分配的内存块于常规变量声明分配的内存块不同。变量nights的值存储在被称为栈的内存区域中，new从被称为堆或自由存储区的内存区域分配内存。 4.7.5 使用delete释放内存需要内存时，使用new来请求。使用完内存后，使用delete运算符将其归还给内存池。一定要配对使用new和delete，否则会发送内存泄漏，即被分配的内存再也无法使用。如果泄漏严重，则程序将由于不断寻找更多内存而终止。 int *ps = new int; delete ps; 不用使用delete释放已经释放的内存，这样做结果是不确定的。另外，不要使用delete来释放声明变量所获得的内存： int jugs = 5; int *pi = &amp;jugs; delete pi; //不允许，错误的做法 注意：只能用delete释放使用new分配的内存，然后，对空指针使用delete是安全的。 使用delete的关键在于，将它用于new分配的地址，而不意味着要使用用于new的指针，而是用户new的地址： int *ps = new int; int *pq = ps; delete pq; 一般来说，不要创建两个指向同一个内存块的地址，因为这样增加错误地删除同一个内存块两次的可能性。但，对于返回指针的函数，使用另一个指针是有道理的。 4.7.6 使用new来创建动态数组在编程时给数组分配内存被称为静态联编，意味着数组在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它，如果不需要，则不创建。还可以在程序运行时选择数组的长度，这种被称为动态联编，意味着数是在程序运行时创建的。这种数组叫作动态数组。 1、使用new创建动态数组 在C++中创建动态数组：只要将数组元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素的数目： int *psome = new int[10]; delete [] psome; 创建了一个包含10个int元素的数组。并使用delete对分配的内存进行释放。释放内存时，方括号告诉程序，应该释放整个数组，而不仅仅是指针指向的元素。 程序确实跟踪了分配的内存量，以便以后使用delete []正确地释放这些内存，但这种信息是不公用的。例如:不能使用sizeof运算符来确定动态数组分配的数组包含的字节数。 2、使用动态数组 *psome是第1个元素的值,psome[0]同样是第一个元素的值。psome[1]是第2个元素的值，以此类推。 arraynew.cpp #include &lt;iostream&gt; int main() { using namespace std; double *p3 = new double [3]; p3[0] = 0.2; p3[1] = 0.5; p3[3] = 0.8; cout &lt;&lt; &quot;p3[1]: &quot; &lt;&lt; p3[1] &lt;&lt; endl; p3 = p3 + 1; cout &lt;&lt; &quot;p3+1,p3[0]: &quot; &lt;&lt; p3[0] &lt;&lt; endl; p3 = p3 - 1; delete [] p3; return 0; } 结果：p3[1]: 0.5p3+1,p3[0]: 0.5 从中可知，程序将指针p3当作数组名来使用，p3[0]表示第1个元素，依次类推。不过指针和数组名之间有差别的，不能更改数组名的值，但指针是变量，因此可以修改它的值： p3 = p3 + 1; 将p3加1的效果，是将p3[0]指向数组中的第2个元素。将它减1后，指针将指向原来的值，这样程序可以给delete[]提供正确的地址。 4.8 指针、数组和指针算术指针和数组基本等级的原因在于指针运算符和C++内部处理数组的方式。将指针加1后，增加的量等于它所指向的类型的字节数。比如：将double类型的指针加1后，如果系统double使用8个字节存储，则数值将加8。另外，C++将数组名解释为地址。 addpntrs.cpp #include &lt;iostream&gt; int main() { using namespace std; double wages[3] = {1000.0, 2000.0, 3000.0}; short stacks[3] = {3, 2, 1}; double *pw = wages; short *ps = &amp;stacks[0]; cout &lt;&lt; &quot;pw = &quot; &lt;&lt; pw &lt;&lt; &quot;, *pw = &quot; &lt;&lt; *pw &lt;&lt; endl; pw = pw + 1; cout &lt;&lt; &quot;Add 1 to the pw pointer:\n&quot;; cout &lt;&lt; &quot;pw = &quot; &lt;&lt; pw &lt;&lt; &quot;, *pw = &quot; &lt;&lt; *pw &lt;&lt; endl; cout &lt;&lt; &quot;ps = &quot; &lt;&lt; ps &lt;&lt; &quot;, *ps = &quot; &lt;&lt; *ps &lt;&lt; endl; ps = ps + 1; cout &lt;&lt; &quot;Add 1 to the ps pointer:\n&quot;; cout &lt;&lt; &quot;ps = &quot; &lt;&lt; ps &lt;&lt; &quot;, *ps = &quot; &lt;&lt; *ps &lt;&lt; endl; cout &lt;&lt; &quot;stacts[0] = &quot; &lt;&lt; stacks[0] &lt;&lt; endl; cout &lt;&lt; &quot;*(stacks + 1) = &quot; &lt;&lt; *(stacks+1) &lt;&lt; endl; cout &lt;&lt; &quot;Wages array size: &quot; &lt;&lt; sizeof(wages) &lt;&lt; endl; cout &lt;&lt; &quot;pw pointer size: &quot; &lt;&lt; sizeof(pw) &lt;&lt; endl; return 0; } 结果： pw = 0x7ffedfcf9060, *pw = 1000 Add 1 to the pw pointer: pw = 0x7ffedfcf9068, *pw = 2000 ps = 0x7ffedfcf9050, *ps = 3 Add 1 to the ps pointer: ps = 0x7ffedfcf9052, *ps = 2 stacts[0] = 3 *(stacks + 1) = 2 Wages array size: 24 pw pointer size: 8 4.8.1 程序说明在多数情况下，数组名解释为数组的第一个元素的地址。因此，下面语句将pw声明为指向double类型的指针，然后将它初始化为wages—wages数组中第一个元素的地址： double *pw = wages; 和所有数组一样，有： wages = &amp;wages[0]; //第一个元素的地址 程序查看了pw和$\ast$pw的值，前者是地址，后者是存储在该地址的值。pw加1，数字地址值增加8（double类型）这样pw指向数组中第二个元素。而对于ps(short类型)，ps+1,其地址值将增加2。 注意：将指针变量加1后，其增加的值等于指向的类型所占用的字节数。 stacks[1]和$\ast$(stacks+1)等价，$\ast$(stacks+1意味着先计算数组第2个元素的地址，然后找到存储在那里的值。（运算符优先级要求使用括号，如果不使用将给$\ast$stacks的值加1）。 对于数组和指针，c++可以执行下面的转换： arrayname[i]; -&gt; *(arrayname+1); pointername[i]; -&gt; *(pointername+1); 数组和指针的区别在于，数组名是常量，而指针可以修改其值。如下： arrayname = arrayname + 1;//错误 pointername = pointername + 1; 另一个区别，对于数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof运算符得到的指针的长度，即使指针指向一个数组。在上述程序中有体现。 数组的地址数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址： short tell[10]; cout &lt;&lt; tell &lt;&lt; endl; //第一个元素的地址 cout &lt;&lt; &amp;tell &lt;&lt; endl; //整个数组的地址 从数字上说，这两个值是相等的；但概念上，tell(&amp;tell[0])是一个2字节内存块的地址，而&amp;tell是一个20字节的内存块地址。因此表达式tell+1将地址值加1，而表达式&amp;tell+2将地址加20。即：tell是一个short指针($\ast$short),而&amp;tell是一个指向包含20个元素的short数组（short($\ast$)[20]）的指针。 short (*pas)[20] = &amp;tell; pas的类型为short($\ast$)[20]，由于pas被设置为&amp;tell,因此*pas于tell等价，即($\ast$pas)[0]为tell数组的第一个元素。其中括号不能少，否则，pas是一个short指针数组，它包含20个元素。 4.8.2 指针小结1、声明指针 typeName * pointername; double *pn; char *pc; 2、给指针赋值 对变量使用&amp;运算符，来获取被命名的内存的地址，new运算符返回未命名的内存的地址。 double *pn; char * pc; couble * pa; double bud = 2.33; pn = &amp;bud; pc = new char; pa = new double [10]; 3、对指针解除引用 对指针解除引用意味着获取指针指向的值。 cout &lt;&lt; *pn; *pc = &quot;s&quot;; pa[1] = 2.11; 决不要对未被初始化为适当地址的指针解除引用。 4、区分指针和指针指向的值 pt是指向int的指针，则$\ast$pt是指向int类型的变量的值。 int *pt = new int; *pt = 3; 5、数组名 在多数情况下，C++将数组名视为数组第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度。 6、指针算术 C++允许将指针和整数相加。还可以将一个指针减去另一个指针，获得两个指针的差，仅当两个指针指向同一个数组时，运算才有意义。 int tacos[10] = {2,3,4,5,6,8,9,1,0,7}; int *pt = tacos; pt = pt + 1; int *pe = &amp;tacos[9]; pe = pe - 1; int diff = pe - pt; 7、数组的动态联编和静态联编 使用数组声明来创建数组时，采用静态联编，即数组的长度在编译时给定： int tacos[10]; 使用new[] 运算符创建数组时，将采用动态联编，即将在运行时为数组分配空间，其长度也在运行时设置： int size; cin &gt;&gt; size; int *pz = new int [size]; delete [] pz; 8、数组表示法和指针表示法 tacos[0]; 等价于 *tacos; tacos[3]; 等价于 *(tacos+3); 数组名和指针变量都是如此，因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。 4.8.3 指针和字符串cout对象认为char的地址是字符串的地址，因此它打印该地址处的地址，然后继续打印后面的字符，知道遇到空字符(\0)为止。如果要获取字符串数组的地址，需要进行强制转换，如（int*）flower。而且，”are red”字符串常量，为了保持输出一致，这个引号括号起来的字符串也是一个地址。 注意：在cout和多数C++表达式中，char数组名、char指针以及引号括起来的字符串常量都被解释为字符串第一个字符的地址。 ptrstr.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; int main() { using namespace std; char animal[20] = &quot;bear&quot;; const char *bird = &quot;wren&quot;; char *ps; cout &lt;&lt; animal &lt;&lt; &quot; and &quot; &lt;&lt; bird &lt;&lt; endl; //cout &lt;&lt; ps &lt;&lt; endl; cout &lt;&lt; &quot;Enter a kind of animal:&quot;; cin &gt;&gt; animal; ps = animal; cout &lt;&lt; ps &lt;&lt; endl; cout &lt;&lt; &quot;Before using strcpy():\n&quot;; cout &lt;&lt; animal &lt;&lt; &quot; at &quot; &lt;&lt; (int *)animal &lt;&lt; endl; cout &lt;&lt; ps &lt;&lt; &quot; at &quot; &lt;&lt; (int*)ps &lt;&lt; endl; ps = new char[strlen(animal) + 1]; strcpy(ps, animal); cout &lt;&lt; &quot;After using strcpy():\n&quot;; cout &lt;&lt; animal &lt;&lt; &quot; at &quot; &lt;&lt; (int *)animal &lt;&lt; endl; cout &lt;&lt; ps &lt;&lt; &quot; at &quot; &lt;&lt; (int*)ps &lt;&lt; endl; return 0; } 结果： bear and wren Enter a kind of animal:fox fox Before using strcpy(): fox at 0x7ffd1b868460 fox at 0x7ffd1b868460 After using strcpy(): fox at 0x7ffd1b868460 fox at 0xe91010 其中”wren”实际表示的是字符串的地址，因此”const char $\ast$bird = “wren”;”语句是将”wren”的地址赋给了bird指针。程序中将bird指针声明为const，因此编译器将禁止改变bird指向的位置中的内容。 获得字符串副本，首先，需要分配内存来存储该字符串，这可以通过声明一个数组或使用new来完成。后一种方法使得能够根据字符串长度来指定所需的空间： ps = new char[strlen(animal) + 1]; 然后，需要将animal数组中的字符串复制到新分配的空间中。将animal赋给ps是不可行的，因为这样只能修改存储在ps中的地址，从而失去程序访问新分配内存的唯一途径，需要使用库函数strcpy(): strcpy(ps, animal); strcpy()函数接收两个参数，第一个是目标地址，第二个是要赋值的字符串的地址。通过使用new和strcpy()，将获得”fox”两个独立的副本。 fox at 0x7ffd1b868460 fox at 0xe91010 经常需要将字符串放到数组中。初始化数组时，使用”=”运算符；否则使用strcpy()或strncpy()。 char food[20] = &quot;carrots&quot;; strcpy(food, &quot;flan&quot;); strcpy(food, &quot;a picnic basket filled with many goodies&quot;);//导致问题，food数组比字符串小。 对于最后一种情况，函数将字符串剩余的部分复制到数组后面的内存字节中，这可能覆盖程序正在使用的其他内存。要避免这种问题，使用strncpy()。该函数接收第3个参数–要复制的最大字符数。 strncpy(food, &quot;a picnic basket filled with many goodies&quot;, 19); food[19] = &apos;\0&apos;; 这样最多将19个字符复制到数组中，然后最后一个元素设置为空字符。如果该字符串少于19个字符，则strncpy()将在复制完成字符串之后加上空字符，以标记字符串的结尾。 4.8.4 使用new创建动态结构在运行时创建数组优于在编译时创建数组，对于结构也如此。对于new用于结构由两步组成：创建结构和访问其成员。创建结构，需要同时使用结构类型和new。如下： inflatable *ps = new inflatable; 这样把足以存储inflatable结构的一块可用内存的地址赋给ps。这种句法和C++内置类型完全相同。接下来是成员访问，创建动态结构时，不能使用运算符句点用于结构，因为这种结构没有名称，只知道其地址。C++专门提供了箭头成员运算符（-&gt;）。该运算符由连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结构名一样。例如：ps-&gt;price。 另一种访问结构的方法是，如果ps是指向结构的指针，则$\ast$ps就是被指向的值—结构本身。由于$\ast$ps是一个结构，因此($\ast$ps).price是该结果的price成员。C++的运算符优先级规则要求使用括号。 newstrct.cpp #include &lt;iostream&gt; struct inflatable { char name[20]; float volume; double price; }; int main() { using namespace std; inflatable *ps = new inflatable; cout &lt;&lt; &quot;Enter name of infaltable item: &quot;; cin.get(ps-&gt;name, 20); cout &lt;&lt; &quot;Enter volume of inflatable item: &quot;; cin &gt;&gt; (*ps).volume; cout &lt;&lt; &quot;Enter price of inflatable item: &quot;; cin &gt;&gt; ps-&gt;price; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; (*ps).name &lt;&lt; endl; cout &lt;&lt; &quot;Volume: &quot; &lt;&lt; ps-&gt;volume &lt;&lt; endl; cout &lt;&lt; &quot;Price: &quot; &lt;&lt; ps-&gt;price &lt;&lt; endl; return 0; } 结果： Enter name of infaltable item: Frodo Enter volume of inflatable item: 1.4 Enter price of inflatable item: 27.99 Name: Frodo Volume: 1.4 Price: 27.99 1. 一个使用new和delete的示例 delete.cpp定义了一个函数getname()，该函数返回输入字符串的指针。该函数将输入读入到一个大型临时数组中，然后使用new[]来创建一个刚好存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以大大节省内存。 假设程序需要读取100个字符串，其中最大的字符串包含79个字符，而大多数字符串都短得多。如果用char数组来存储这些字符串，则需要100个数组，其中每个数组的长度为80个字符，总共需要8000多个字节，而其中大部分内存没有被使用。 另一种方法，创建一个数组，它包含100个指向char的指针，然后使用new根据字符串的需要分配相应数量的内存。还可以使用new根据需要的指针数量来分配空间。 delete.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; char * getname(void); int main() { char *name; name = getname(); cout &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; (int*)name &lt;&lt; endl; delete [] name; name = getname(); cout &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; (int*)name &lt;&lt; endl; delete [] name; return 0; } char * getname() { char temp[80]; cout &lt;&lt; &quot;Enter last name: &quot;; cin &gt;&gt; temp; char *pn = new char [strlen(temp)+1]; strcpy(pn, temp); return pn; } 结果： Enter last name: Fred Fred at 0x1c76010 Enter last name: Zll Zll at 0x1c76010 2. 程序说明 getname()函数，使用cin将输入的字符串放到temp数组中，然后使用new分配行内存，以存储该字符串。程序需要strlen(temp)+1个字符（包括空字符）来存储该字符串，将这个值提供给new。获得空间后，getname()使用标准库函数strcpy()将temp中的字符串复制到新的内存块中。最后返回pn，这是字符串副本的地址。 在main()中，返回值（地址）被赋值给name。该指针是在main()中定义的，但它指向getname()函数中分配的内存块。接下来，在释放name指向的内存快后，main()再次调用getname()。C++不保证新释放的内存就是下一次使用new时选择的内存，但该例子中刚好是的。 在这个例子中，getname()分配内存，而main()释放内存，将new和delete放在不同的函数通常不是一个好办法，因为这样容易忘记使用delete。不过这样做确实可以。 4.8.5 自动存储、静态存储和动态存储根据用户分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存储时间的长短方面，以这3种方式分配的数据对象各不相同。 1、自动存储 在函数内存定义的常规变量使用自动存储空间，被称为自动变量。即它们在所属的函数被调用时自动产生，在该函数结束时消亡。例如delete.cpp中的temp数组仅当getname()函数活动时存在。当程序控制权回到main()时，temp使用的内存自动释放。 实际上，自动变量是一个局部变量，其作用域为包含它的代码块。自动变量通常存储在栈中，这意味着执行代码块时，其中的变量将依次加入栈中，而在离开代码时，将按照相反的顺序释放这些变量。这被称为后进先出（LIFO）。 2、静态存储 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态存储的方式有两种: 在函数外面定义它 在声明使用关键字static static double fee = 44.3; 自动存储和静态存储的关键在于：这些方法严格限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是特定函数被执行时存在（自动变量）。 3、动态存储 new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++被称为自由存储空间或堆。该内存池同用于静态变量和自动变量的内存是分开的。 数据的生命周期不完全受程序或函数的生存控制。与常规的变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。在栈中，自动添加和删除机制使得占用的内存是连续，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪内存的位置更困难。 内存泄漏 如果使用new运算符在自由存储空间（堆）上创建变量后，没有调用delete，则即使包好指针的内存由于作用域和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间的结构，因为指向这些内存的指针无效。这将导致内存泄漏。泄漏的内存，将在程序整个生命周期内不可使用，这些内存被分配出去，无法回收。极端情况，内存泄漏可能导致程序崩溃。 4.9 类型组合struct antarctica_year_end { int year; }; 可以创建这种类型的变量： antarctica_year_end s01, s02, s03; 然后，使用成员运算符来访问其成员： s01.year = 1998; 可以创建指向这种结构的指针： antarctica_year_end *pa = &amp;s02; 将指针设置为有效地址后，就可以使用间接成员运算符来访问成员： pa-&gt;year = 1999; 可创建结构数组： antarctica_year_end trio[3]; 然后，使用成员运算符来访问元素的成员： trio[0].year = 2003; 由于数组名是一个指针，因此可以使用间接成员运算符： (trio+1)-&gt;year = 2004; 可创建指针数组： const antarctica_year_end *arp[3] = {&amp;s01,&amp;s02,&amp;s03}; arp是一个指针数组，arp[1]就是一个指针，可将间接运算符应用于它： cout &lt;&lt; arp[1]-&gt;year &lt;&lt; endl; 可创建指向上述数组的指针： const antarctica_year_end **ppa = arp; 其中arp是一个数组名，因此它是第一个元素的地址。但其第一元素为指针，因此ppa是一个指针，指向const antarctica_year_end的指针。这样容易出错，比如忘记const，搞错顺序或结构类型，C++11提供了auto，编译器知道arp的类型能过正确地推断出ppb的类型： auto ppb = arp; ppa是一个指向结构指针的指针，因此*ppa是一个结构指针，可间接成员运算符应用于它： cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; endl; cout &lt;&lt; (*(ppa+1))-&gt;year &lt;&lt; endl; mixtype.cpp #include &lt;iostream&gt; struct antarctica_year_end { int year; }; int main() { using namespace std; antarctica_year_end s01, s02, s03; s01.year = 1998; antarctica_year_end *pa = &amp;s02; pa-&gt;year = 1999; antarctica_year_end trio[3]; trio[0].year = 2003; cout &lt;&lt; trio-&gt;year &lt;&lt; endl; const antarctica_year_end *arp[3] = {&amp;s01,&amp;s02,&amp;s03}; cout &lt;&lt; arp[1]-&gt;year &lt;&lt; endl; const antarctica_year_end **ppa = arp; cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; endl; cout &lt;&lt; (*(ppa+1))-&gt;year &lt;&lt; endl; return 0; } 结果： 2003 1999 1998 1999 4.10 数组的替代品4.10.1 模板类vector模板类vector类类似于string类，也是一种动态数组。可以运行阶段设置vector对象的长度，可在末尾附加新数据，还可以在中间插入新数据。实际上，vector使用new和delete来管理内存，但这种工作是自动完成的。 首先，使用vector类，必须包含头文件vector；其次，vector包含在命名空间std中，因此可以使用using编译指令、using声明或std::vector；然后，模板使用不同的语法来指出它存储的数据类型；最后，vector类使用不同的语法来指定元素数。 #include &lt;vector&gt; using namespace std; vector&lt;int&gt; vi; //创建一个int类型空数组 int n; cin &gt;&gt; n; vector&lt;double&gt; vd(n); //创建一个double类型n个元素的数组 其中vi是一个vector对象，vd是一个vector对象。由于vector对象在插入或添加值时自动调整长度，因此可以在将vi的长度初始化为0。但要调整长度，需要使用vector包中的各种方法。 一般而言，创建一个名为vt的vector对象，它可存储n_elem个类型typeName的元素： vector&lt;typeName&gt; vt(n_elem); 4.10.2 模板类array(C++11)vector类的功能比数组强大，但付出的代价是效率低。如果需要的是固定长度的数组，使用数组是更佳的选择，但代价是不那么方便。鉴于此，C++新增了模板类array，它也位于命名空间std中。与数组一样，array对象的长度也是固定，也使用栈（静态内存分配），而不是自由存储区，因此效率与数组相同，但更方便，更安全。需要包含头文件array。创建arry对象的语法： #include &lt;array&gt; using namespace std; array &lt;int,5&gt; ai; array&lt;double,4&gt; ad = {1.2, 1.3, 2.2, 2.3}; 创建一个名为arr的array对象，它包含n_elem个类型为typeName的元素： array &lt;typeName, n_elem&gt; arr; 4.10.3 数组、vector对象、array对象比较choices.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;array&gt; int main() { using namespace std; double a1[4] = {1.2, 1.4, 2.2, 2.3}; vector&lt;double&gt; a2(4); a2[0] = 1.0/3.0; a2[1] = 1.0/5.0; a2[2] = 1.0/7.0; a2[3] = 1.0/9.0; array&lt;double, 4&gt; a3 = {3.14, 2.72, 1.62, 1.41}; array&lt;double, 4&gt; a4; a4 = a3; cout &lt;&lt; &quot;a1[2]:&quot; &lt;&lt; a1[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a1[2] &lt;&lt; endl; cout &lt;&lt; &quot;a2[2]:&quot; &lt;&lt; a2[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a2[2] &lt;&lt; endl; cout &lt;&lt; &quot;a3[2]:&quot; &lt;&lt; a3[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a3[2] &lt;&lt; endl; cout &lt;&lt; &quot;a4[2]:&quot; &lt;&lt; a4[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a4[2] &lt;&lt; endl; a1[-2] = 20.2; cout &lt;&lt; &quot;a1[-2]:&quot; &lt;&lt; a1[-2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a1[-2] &lt;&lt; endl; cout &lt;&lt; &quot;a3[2]:&quot; &lt;&lt; a3[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a3[2] &lt;&lt; endl; cout &lt;&lt; &quot;a4[2]:&quot; &lt;&lt; a4[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a4[2] &lt;&lt; endl; return 0; } Linux下使用C++11版本运行:g++ -std=c++11 choices.cpp 结果： a1[2]:2.2 at 0x7ffdefd049f0 a2[2]:0.142857 at 0x16f2020 a3[2]:1.62 at 0x7ffdefd04a10 a4[2]:1.62 at 0x7ffdefd04a30 a1[-2]:20.2 at 0x7ffdefd049d0 a3[2]:1.62 at 0x7ffdefd04a10 a4[2]:1.62 at 0x7ffdefd04a30 程序说明： 首先，注意到无论数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象，存储在另一个区域（自由存储区域或堆）中。 a1[-2] = 20.2; 索引-2，找出a1指向的地方，向前移两个double元素，并将20.2存储到目的地。即将信息存储到数组的外面，与C语言一样，C++也不检查这种越界错误。vector和array对象仍可以编写这种不安全的代码。 对于vector和array对象还可使用at()成员函数: a2.at(1) = 2.3; 使用at()时，将在运行期间捕获非法索引，而程序默认将终端。这种额外检查的代价是运行的时间更长，这就是C++允许使用任何一种表示法的原因。另外，这些类还能够降低意外超界错误的概率，例如，它们包含成员函数begin()和end()，能够确定边界，以免无意超界。 4.11 总结数组、结构和指针是C++的3种复合类型。 字符串 共用体 枚举 指针 new和delete vector和array对象]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别(二)--K均值聚类]]></title>
    <url>%2F2018%2F09%2F11%2F%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[K均值聚类算法的思想是：首先随机选取K个对象作为初始的聚类中心，然后，计算每个对象距聚类中心的距离，把每个对象归到距离它最近的聚类中心。如果全部对象被分配完，则每个聚类的聚类中心将根据现有的对象重新计算。直到满足某个终止条件。K均值聚类算法是一种无监督学习算法。具体算法实现如下： 代码import numpy as np import random import matplotlib.pyplot as plt #计算样本到中心的距离,采用欧式距离 def distEC(data,center,k): num = np.array(data) hang = num.shape[0] #数据个数 lie = num.shape[1] #指标个数 dist = [[0]*k for row in range(hang)] for i in range(hang): for l in range(k): s = 0 for j in range(lie): s = (center[l][j] - data[i][j])**2 + s dist[i][l] = s**0.5 return dist #根据计算得到的距离对样本分类 def Cluter(dist): num = np.array(dist) hang = num.shape[0] #数据个数 k = num.shape[1] #中心个数 clu = [[] for row in range(k)] #初始化存放样本标号的距离 for i in range(hang): temp = dist[i][:].index(min(dist[i][:]))#求样本距离哪个聚类中心最近 for j in range(k):#判断样本属于哪个距离中心 if temp == j: clu[j].append(i) break return clu #重新计算聚类中心 def clu_center(clu,data,k): for i in range(k): for j in range(2):#(np.array(data).shape[1]): temp = 0 for k in range(len(clu[i])):#len(clu[i])为每个聚类中心样本的个数 temp = data[clu[i][k]][j] + temp center[i][j] = temp / len(clu[i]) #重新计算得到的聚类中心 return center if __name__ == &quot;__main__&quot;: k =3#聚类中心个数 data = [[0,0],[3,8],[2,2],[1,1],[5,3],[4,8],[6,3],[5,4],[6,4],[7,5]] #center = random.sample(data,k)#随机选取初始聚类中心 center = [[0,0],[3,8],[2,2]]#固定初始聚类中心 dist = distEC(data,center,k)#计算样本与聚类中心的距离 clu = Cluter(dist)#聚类 center1 = clu_center(clu,data,k)#重新计算聚类中心 center2 = [] while center1 != center2: #当聚类中心相同时，停止聚类 dist = distEC(data,center1,k) clu = Cluter(dist) center2 = center1 center1 = clu_center(clu,data,k) print(center1,center2) #画图 plt.figure() for j in range(10): plt.plot(data[j][0],data[j][1],&apos;b.&apos;) for i in range(k): plt.plot(center1[i][0],center[i][1],&apos;ro&apos;) plt.xlabel(&apos;x&apos;) plt.ylabel(&apos;y&apos;) plt.show()]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别绪论(一)]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[模式识别 1、模式识别系统组成单元： 信息输入与数据获取 预处理 特征抽取、选择和提取：高维测量空间 $ \rightarrow $ 低维的特征空间 旁边分类（分类决策） 2、 模式识别系统分类 统计模式系统和句法模式识别 统计： 采用概念和统计的方法，采用判别函数，使判识概念最小句法： 模糊模式识别：以隶属度位基础，运用模糊数学的“关系”判别 神经网络模式识别 3、 实现方法分类： 监督： 需要足够的先验知识 无监督]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DAC-MACS Effective Data Access Control for Multiauthority Cloud Storage Systems]]></title>
    <url>%2F2018%2F09%2F06%2FDAC-MACS-Effective%20Data%20Access%20Control%20for%20Multiauthority%20Cloud%20Storage%20Systems%2F</url>
    <content type="text"><![CDATA[论文一 多权威云存储系统的有效数据访问控制摘要数据访问控制是确保云上数据安全的有效方法。然而，由于数据外包和不可信的云服务器，在云存储系统中，数据访问控制成为了一个挑战性问题。现有的访问控制方案不再适合云存储系统，因为它们针对相同的数据生成多个加密副本，并且要求云服务器完全可信。基于密文策略的属性加密（CP-ABE），对于加密数据的访问策略，是个比较好的技术。但是，由于低效的解密和撤销，现有的CP-ABE方案不能直接应用来构造一个适合多权威中心的云存储系统的访问控制方案。在本文，作者提出了针对多权威云存储系统的访问控制（DAC-MACS）,其是一个高效安全的访问控制方案，并且解密和撤销效率高。另外，作者构造了一个新的多权威（CP-ABE）方案，解密效率高，同时设计一个有效的属性撤销方法，可是保证前向安全和后向安全。进一步，作者给出了一个扩展数据访问控制方案（EDAC-MACS）,其在一个弱安全假设下是安全的。 一、介绍（Introduction）云存储是云计算一个重要的服务。它允许数据拥有者上传数据到云服务器，利用云服务器先用户提供数据访问。数据访问控制是保证数据安全的有效方法。然而由于数据外包，云服务器可能无法完全被信任来提供数据访问控制服务，这意味着存在的基于服务的访问控制方法不再适应于云存储。为了实现不可信服务器的数据访问控制，传统方案经常加密数据并只有用户拥有密码来解密。尽管这种方案可以提供安全访问控制，但是当系统用户变多，密钥管理非常复杂。数据拥有者不得不保持在线来发送密钥给新的用户。甚至，对于每一个数据，存在多个密文副本对于拥有不同密钥的用户，这将因此巨大的存储开销。 基于密文策略的属性加密（CP-ABE）[2-6]是一种最适合于云存储系统数据访问控制的技术之一，由于它使数据拥有者可以直接的控制访问策略，并不要求数据拥有者去分发密钥。在CP-ABE方案中，有一个权威机构来负责密钥的分发和属性管理。权威中心可以是一个大学的注册办公室，公司的人力部门等等。根据属性每个用户被分配一个私钥。每个用户仅可以解密其属性满足访问策略的密文。 在云存储系统中，一个用户可能拥有多个权威中心分配的属性，数据拥有者与不同权威机构管理的用户共享数据。例如：在一个电子医疗系统中，医疗数据可能仅分享给被医院分发有“医生”属性的用户，和被医院研究中心分发有“医药研究元”属性的用户。一些CP-ABE方案[7-10]被提出针对多权威系统。然而，由于计算量较大，他们无法直接应用来构造数据访问控制方案。主要，在访问控制中，加密和解密操作要求计算量小。 用户撤销：在云存储系统中，数据访问不是静态的，正如员工的雇佣和解聘，升职和降职，改变用户的属性是非常有必要的。为了保证用户撤销的安全性，满足如下两个要求：1）后向安全：撤销用户（其属性被撤销）不能解密新的密文，解密新的密文需要被撤销的属性。2）前向安全：新加入的拥有足够属性的用户能过解密以前发布的密文。为了实现者两个要求，一个普通的方法市重新加密所有数据。当数据量非常大时，计算开销也是巨大的。这促使我们去研究一种新的方法，可以高效地处理用户的属性撤销。 解密效率：在CP-ABE系统中，用户需要使用自己的私钥去解密数据。不过，现在，用户通常使用移动设备（比如：智能手机、笔记本等等）来获取云数据，移动设备的计算能力不想PC一样强大。这促使我们去外包主要的解密计算量给云服务器，同时保证云服务器无法获取数据。 本文，我们首先构造了一个新的多权威CP-ABE方法，解密效率高，并为其提出了高效的属性撤销方案。然后，我们运用它来为多权威云存储系统设计一个高效的访问控制方法。本文的主要贡献可以总结如下： 1）提出了DAC-MACS（多权威云存储系统的数据访问控制），其是针对多权威中心的云存储系统的，一个高效地，安全地数据访问控制方案。其在预言机模型中是安全的，并且性能优于现有的方案。 2）构造了一个新的多权威CP-ABE方案，解密效率高。尤其，我们通过使用基于令牌的解密方法来外包解密过程的大部分计算量。 3）针对多权威CP-ABE方案，设计了一个高效及时的属性撤销方案，可以实现前向安全和后向安全。甚至，在属性撤销过程的通信开销和计算量大大降低。 与之前的方案[11]相比，我们大大提高了DAC-MACS的安全性，使其更适合于多权威中心的云存储系统。尤其，我们主要研究了由未撤销用户和被破坏用户AA之间共谋引起的安全问题。首先，通过一个安全假设，即未撤销用户不会将其收到的更新密钥发送给撤销用户，来给出一个简单的解决方案。进一步，我们抛弃上面的假设，提出了一种扩展数据访问控制方案（EDAC-MACS），其可以实现同样的安全性能。在EDAC-MACS方案中，即使在任意破坏用户AA帮助下e，撤销用户也无法获取非法的数据访问。没有上面的假设，EDAC-MACS是更符实际的来运用到云存储系统。同时，我们也给出了EDAC-MACS方案的安全分析，证明其在弱安全假设下是安全的。 论文余下部分内容如下：在第二节，我们定义了系统模型，方案架构以及安全模型。在第三节，我们提出了一种新的多权威CP-ABE方案，具有高效的解密和撤销，并被运用来构造DAC-MACS。在第四节，就安全和性能，我们分析了DAC-MACS。第五节，进一步提出了扩展DAC-MACS方案来保证弱假设下的安全性。第六节，给出了相关工作总结。最后，在第七节，给出了结论。详细地安全证明在附录中给出。 二、系统模型和安全模型A. 系统模型考虑到一个云存储系统有多个权威中心，正如图1所示。系统模型包括五部分：全局证书机构（CA）、属性权威中心（AAs）、云服务器（server）、数据拥有着（owners）、数据使用者（users）。 CA.在系统种，CA是一个全局被信任的证书颁发机构。它建立系统，并接受系统种所有用户和AAs的注册。对于每个合法用户，对于每个合法的用户，CA分配一个全局唯一身份标识给他，同时生成一个公私钥对给该用户。然后，CA不参与任何属性管理和任何与属性有关私钥的生成。 AA.每一个AA是一个独立的属性权威中心，负责根据用户的角色和身份来分发、撤销和更新用户的属性。每一个AA负责为每个其管理的属性生成一个公开属性密钥，并为他们属性所对应的每个用户生成一个私钥。 Server.云服务器存储数据拥有着的数据，并向用户提供数据访问控制服务。它也帮助用户进行解密密文，其是通过生成一个解密符合实现。同时，当存在一个属性撤销时，云服务器也帮助用户更新密文。 Owners.在外包数据之前，每个数据拥有者通过对称加密技术使用内容密钥（content keys）来加密数据。然后，数据拥有者针对多个AAs的属性定义一个访问控制策略，并在该策略下加密内容密钥。数据拥有者不信任服务器来做数据访问控制。相反，在系统种，他们假设服务器可能将数据给所有用户。但是，访问控制发现生在加密内部。只有当用户属性满足在密文中定义的访问策略，用户才能解密密文。 Users.每个用户被分配有一个来自CS的全局用户身份，可以自由地查询来自服务器的密文。为了解密密文，每个用户提交有某些AAs一起发布给它的私钥和全部公钥给云服务器，来请求一个解密令牌。然后，用户使用收到的解密令牌和自己的全局公钥来解密密文。仅仅当用户属性满足在密文中定义的访问策略时，服务器才会生成正确的解密令牌。私钥和用户的全部公钥可以存储在服务器中，随后，如果没有更新密钥用于进一步的解密令牌生成，则用户不需要提交任何密钥。 B. 框架定义1（DAC-MACS）:DAC-MACS架构包括如下几个步骤： 步骤一：系统初始化：该阶段包括如下算法： $CASetup(1^\lambda)\rightarrow (MSK, SP, (sk_{CA},vk_{CA}))$. CA初始化算法的输入仅仅为隐式安全参数$\lambda$。输出为主密钥MSK，系统系数SP,以及一对CA的签名和验证密钥$key(sk_{CA},vk_{CA})$。 $UserReg(SP,sk_{CA},Info_u) /rightarrow (uid,GPK_{(uid)},GSK_{(uid)},Cert_{(uid)})$.用户注册算法以系统参数SP，CA的签名密钥$sk_CA$和用户信息$Info_u$（即名字、生日等等）作为输入。它验证用户身份，并分配一个全局唯一用户标识$uid$给该用户。其输出用户的标识$uid$,公私钥对$\lbrace GPK_{uid},GSK_{uid} \lbrace$和一个由CA签发的证书$Cert(uid)$。 $AAReg(Info_{AA}) \rightarrow (aid)$. 属性权威注册算法将属性权威信息作为输入。它验证AA并输出一个全局权威标识$aid$给该AA。 $AASetup(SP, aid) \rightarrow (SK_{aid}, PK_{aid}, VK_{x_{uid}}, PK_{x_{uid}})$.属性权威初始化算法以系统参数SP和全局权威标识$aid$作为输入。输出一私\公权威密钥对$(SK_{aid},PK_{aid})$,每个属性$x$的版本密钥和公权威密钥集合$\lbrace VK_{x_{aid}},PK_{x_{aid}} \lbrace$。 步骤二：密钥生成 -$SKeyGen(SK_{aid},SP,{P_{x_{aid}}},S_{uid,aid},Cert(uid)) \rightarrow SK_{uid,aid}$.私钥生成算法以权威私钥$SK_{aid}$，系统参数$SP$,属性公钥集合%(PK_{x——{aid}})%，描述密钥的属性集合$S_{uid,aid}$和用户的证书$uid$。其输出针对用户$uid$的密钥$SK_{uid,aid}$。 步骤三： 数据加密 $Encrypt(SP, \lbrace PK_{k} \rbrace_{k \in I_{A}} \lbrace, PK_{x_k} \rbrace)^{k \in I_A}_{x_{k} \in S_{A_k}},m, \alpha) \rightarrow CT$.加密算法以系统参数$SP$、来自相关权威集合$I_{A}$的公钥集合$\lbrace PK_{k} \rbrace_{k \in I_{A}}, \lbrace$、属性公钥$\lbrace, PK_{x_k} \rbrace)^{k \in I_A}_{x_{k} \in S_{A_k}}$、数据$m$和一个来自相关AAs中所有的被选属性的访问结构$alpha$。首先，该算法利用内容密钥$\kappa$使用对称加密方案加密数据$m$；然后，在访问结构$alpha$下加密内容密钥，并输出一个密文$CT$。假设密文隐含地包含访问结构。 步骤四：数据解密：数据解密阶段包括云服务器生成解密令牌和用户的数据解密，具体算法如下： $TKGen(CT,GPK_{uid}, \lbrace SK_{uid,k} \rbrace_{k \in I_A}) \rightarrow TK$.解密令牌生成算法以密文CT为输入，密文包括访问结构$alpha$、用户的全局公钥$GPK_{uid}$以及用户私钥集合$\lbrace SK_{uid,k} \rbrace_{k \in I_A}$。如果用户uid拥有足够满足访问结构$alpha$的属性，算法能够为密文CT成功地计算出正确的令牌TK。 $Decrypt(CT,KT,GSK_{uid}) \rightarrow m$. 解密算法的输入为密文CT、解密令牌TK和用户的全局私钥$GSK_{uid}$。其首先解密内容密钥，进一步使用内容密钥来解密数据。输出为数据m。 步骤五：属性撤销：这个阶段包括三步：由AAs更新密钥生成、未撤销用户私钥更新和服务器密文更新。 $UkeyGen(SK_{aid}, \lbrace u_j \rbrace, VK_{x_{aid}}) \rightarrow (KUK_{j,x_{aid}}, CUK_{x_{aid}})$. 更新密钥生成算法的输入是权威密钥$SK_{aid}$、用户私钥集合$\lbrace u_j \rbrace$和撤销属性的以前的密钥$VK_{x_{aid}}$。其输出用户密钥的更新密钥$KUK_{j,x_{aid}}$以及密文更新密钥$ CUK_{x_{aid}}$。 $SKUpdate(SK_{uid,aid}, KUK_{uid,x_{aid}}) \rightarrow SK^{‘}{aid,uid}$. 用户密钥更新算法以当前用户私钥$SK{uid,aid}$和它的密钥更新密钥$KUK_{uid,x_{aid}}$为输入。输出一个新的密钥$SK^{‘}_{aid,uid}$。 $CTUpdate(CT,CUK_{x_{aid}}) \rightarrow CT^{‘}$. 密文更新算法输入为当前的密文$CT$和密文更新密钥$CUK_{x_{aid}}$。输出为一个新密文$CT^{‘}$。 C 每个实体的安全假设在DAC-MACS中，有如下假设： CA是可信的，但其不允许解密任何密文。 每个AA是可信的，但它可以被攻击者破坏。 服务器是半可信的（好奇但诚实）。它将不会拒绝任何授权用户的服务，并正确地执行AA分配的任务。但它对数据内容或收到的数据是好奇的。 用户是不诚实的，可能与共谋来获得未授权的数据访问。 所有未撤销用户不会收到更新密钥发送给撤销用户。（该假设在EDAC-MACS中移除该假设） D 决策q并行Diffie-Hellman指数假设 Decisional q-Parallel Bilinear Diffie-Hellman Exponent Assumption引用文献[5]中关于qDiffie-Hellman指数假设的定义。设$a,s,b_1, \dots b_q \in Z_p$为随机数，$g$为G的一个生成元。如果攻击者被给定： 很难从随机元素R（$G_T$中）区分出一个有效元素$e(g,g^{a^{q+1}}s)$。 一个算法B,其输出为$z \in {0,1}$,如果满足： 则在求解q阶BDHE有优势$\epsilon$。 定义2： 如果没有多项式时间算法在解决q并行BDHE问题方面具有不可忽视的优势，那么决策q并行BDHE假设成立。 E 安全模型现在，通过挑战者和攻击者之间的游戏来描述DAC-MACS的安全模型。安全模型允许攻击者去查询任意不能用来解密挑战的密文私钥和更新密钥。与文献[10]相似，假设攻击者可以静态地破坏权威中心，但是密钥的查询是动态的。设$S_A$表示所有的权威中心集合。安全游戏定义如下： 初始化:通过运行CA初始算法生成系统参数。攻击者指定了一组损坏的属性权威中心$S^{‘}_A \subset S_A$。挑战者通过查询AA初始化预言机生成一个公钥，通过查询私钥生成预言机生成一个私钥。对于正常的权威中心$S_A - S_A^{‘}$，挑战者仅发送公钥给攻击者。对于S^{‘}_A中破坏的权威中心，挑战者发送公钥和私钥给攻击者。 步骤一：攻击者通过提交$(uid, S_{uid})$对给挑战者来发起密钥查询，其中$S_{uid} = \lbrace S_{uid,k} \rbrace _{k \in S_A - S_A^{‘}}$是属于正常AAs的属性集合。挑战者响应对应私钥$\lbrace SK_{uid,k} \rbrace$给挑战者。挑战者通过发送属性集合$S_{aid}^{‘}$来发起更新密钥查询请求。挑战者将对应的更新密钥发送给攻击者。 挑战：攻击者提交两个长度相同的消息$m_0$和$m_1$。另外，攻击者发起一个挑战,获取必须满足以下约束的访问结构$(M^\ast,\rho^\ast)$。设$V$表示由属于破坏AAs属性标记的$M^\ast$行的子集。对于每个$uid$,$V_{uid}$表示由攻击已经查询的属性标记的$M^\ast$的行。对于每个$uid$,要求由$V \cup V_{uid}$组成的子空间不包括$(1,0, \dots ,0)$。即，攻击者不能结合从AA获得的任何密钥，以及请求密钥集合来解密。攻击者生成一个随机数b,并在访问结构$(M^\ast, \rho^\ast)$下加密$m_b$。 步骤二： 攻击者可能查询更多的私钥和更新密钥，只要它们不违反挑战访问结构$(M^\ast,\rho^\ast)$上的约束和如下约束：不存更新密钥（通过查询更新密钥和查询私钥生成）可以解密挑战密文。换句话说，攻击者不能查询一个能更新查询密钥成新密钥的更新密钥，其中的新密钥可以解密挑战密文。 猜测： 攻击者输出b的猜测$b^{‘}$。在游戏中，攻击者$A$的优势定义：$Pr[b^{‘} = b] - (1/2)$ 定义3：如果所有多项式时间对手在上述安全游戏中具有最多可忽略的优势，则DAC-MACS对于权威中心的静态损坏是安全的。 定义4：当单个用户用子集的属性无法解密数据时，如果没有多项式时间攻击者利用不同用户的属性一起来解密数据，则DAC-MACS是共谋弹性。 三、DAC-MACS：针对多权威云存储的数据访问控制本节开始给出了我们方案的回顾，然后，我们描述了DAC-MACS，包括五个阶段。 A 回顾尽管，由Lewko和Waters提出的多权威CP-ABE方案[10]有很高的理解力，并被扩展来支持属性撤销[12],由于解密和撤销的效率低，仍然无法应用来解决多权威云存储的访问控制。这样，主要的挑战是构造一种新的底层多权威CP-ABE方案，其支持高效的解密和撤销。 为了涉及一个对权威CP-ABE方案，主要的挑战是如何将不同私钥联系在一起但仍可以组织共谋攻击。与[7]相似，在DAC-MACS中， 我们将权威分为一个全局整数权威(CA)和多个属性权威中心（AAs）。CA负责初始化系统和分配每个用户一个全局身份标识$uid$,并分配每个属性权威一个全局权威标识$aid$。全局唯一标识$uid$可以结合不同AAs分出的私钥一起进行解密，全局唯一标识$aid$可以区分不同AAs分发的属性。这样，通过使用$uid$和$aid$，可以抵抗共谋攻击。然而，不同于文献[7]，在DAC-MACS中的CA步牵涉任何属性管理，和用户属性对应的私钥生成。DAC-MACS也要求所有的AAs生成它们子集的公钥，其可以结合全局公开参数去加密数据，而不是仅仅使用系统唯一公钥来加密。这解决了[7]中的安全问题，即它能阻止了CA解密密文。 为了实现用户的高效解密，提出了一种令牌解密外包方案。解密外包思路来自文献[12],通过使CA生成一对全局私钥和全局公钥给每个合法用户，来扩展其到多权威系统。在解密期间，用户提交由AAs分发的私钥给服务器来计算密文的解密令牌。用户通过使用解密令牌和全局私钥来解密密文。 为了解决用户撤销的问题，我们为每个属性分配一个版本号，这样对于每个属性的撤销，只需要更新密钥和密文中的被撤销属性相关联的那些组件。当一个属性被从一个用户撤销，相应的AA将针对撤销的属性生成一个新的版本密钥，并计算一个更新密钥，包括：一个密文更新密钥（CUK）和用户密钥更新密钥（KUKs）。对于KUKs，每个未撤销用户可以使用这个私钥更新当前的版本，而撤销用户无法更新自己的私钥，甚至使用其他用户的更新私钥，因为每个KU是与uid相关的（后向安全）。密文也可以使用CUK被更新成当前版本。这样，拥有足够属性的新加入的用户也可以解密以前提交的数据（前向安全）。更为甚者，所有用户仅仅需要拥有最新的私钥，而不要先前的私钥。为了提高效率，使用代理重加密方案将密文更新工作委托给服务器。 B 系统初始化这个阶段包括两个步骤:CA初始化和AA初始化。 1) CA初始化：设$S_A$和S_U分别表示属性权威和系统用户集合。设$G$和$G_T$是两个具有相同阶数q的乘法群。$e:G \times G \rightarrow G_T$是一个线性映射。设$g$是群$G$的生成元。$H: \lbrace 0,1 \rbrace^\ast \rightarrow G$是一个哈希函数，并且在预言机下是安全的。 CA运行CA初始化算法，以一个安全系数作为输入。首先，CA生成一个对签名和验证密钥$(sk){CA},vk{CA})$,然后，其选择一个随机数$a \in Z_p $作为系统的主密钥MSK，并计算系统的参数如下： $SP = (g,g^a,G,G_T,H).$ CA接受用户和AA的注册： 用户注册在系统初始化阶段，每个用户需要向CA注册它自己。CA运行用户注册算法UserReg,其以系统参数和用户信息作为输入。如果用户是合法的，CA分配一个全局用户标识$uid$给用户，并生成全局公钥$GPK_{uid} = g^{u_{uid}}$和全局私钥$GSK_{uid} = z_{uid}$,$u_{uid} \in Z_p$和$z_{uid} \in Z_p$是随机选择的两个元素。同时，CA生成一个证书$Cert(uid)$,其包含了$Sign_{sk_{CA}}（uid,u_{uid},g^{1/z_{uid}}）$。然后，CA将全局公私钥对$(GPK_{uid},GSK_{uid})$和证书$Cert(uid)$发送给用户。 AA注册同样，在系统初始化阶段，AA需要向CA注册自己。CA运行AA注册算法AAReg，以AA的信息作为输入。如果AA是一个合法的权威中心，CA分配器一个全局权威标识$aid$。然后，CA发送它自己的验证密钥$vk_{CA}$和系统参数$SP$给AA。 2）AA初始化 每个$AA_k(k \in S_A)$运行AA初始化算法AASetup。设$S_{A_k}$表示由权威$AA_k$管理的所有属性集合。它选择三个随机数$$\alpha_k \beta_k \Gamma_k$作为私权威密钥$SK_k = (\alpha_k \beta_k \Gamma_k)$。对于每个属性$x_k \in S_{A_k}$，权威生成一个私钥，如下： $PK_{x_k} = (g^{v_{x_k}}H(x_k))^{\Gamma_k}$ 显示地选择一个属性版本密钥$VK_{x_k}=v_{x_k}$。$AA_k$也炯穿公钥如下： $PK_{k} = (e(g,g)^{\alpha_k},g^{1/\beta_k},g^{\Gamma_k/\beta_k})$ 所有的属性公钥和权威公钥都发布在$AA_k$的公布栏中。 C AAs生成私钥对于每个用户$U_j(j \in S_U)$,每个$AA_k(k \in S_A)$首先使用验证密钥通过用户证书来判断用户是否合法。如果是非法用户，将终止。否则，$A_k$将根据用户的在管理系统的角色或身份，分配一个属性集合$S_{j,k}$给该用户。然后，$AA_k$运行私钥生成算法SKeyGen来生成用户的私钥$SK_{j,k}$。 该算法的输入为：权威私钥$SK_{aid}$和系统参数$SP$,属性公钥集合$\lbrace PK_{x_{aid}}\rbrace$,描述私钥的属性集合$S_{uid,aid}$和用户$uid$的证书。如下： 其中$j \in S_U$，$k \in S_A$。 D 拥有者加密数据在外包数据$m$到云上之前，数据拥有通过数据加密算法加密数据。其以系统参数$SP$、来自相应权威集合$I_A$的公钥集合$\lbrace PK_k \rbrace _{k \in I_A}$、属性公钥集合$\lbrace PK_{x+k} \rbrace^{k \in I_A}_{x_k \in S_{A_k}}$、数据$m$以及一个与$AAs$相关的所有被选择属性的访问结构$(M, \rho)$。设矩阵$M$是一个$l \times n$维的矩阵，其中$l$表示所有属性的总数。函数$\rho$与$M$的行对应的属性相关。（不懂） 首先，该算法将根据逻辑粒度数据分为几个块如：$m= \lbrace m_1, \dots , m_n $。例如，个人数据可以分为{name,addres,secutity number, employer, salary}。然后，通过对称加密算法加密数据的块，使用不同对称内容密钥$\lbrace \kappa_1, \dots , \kappa_n \rbrace$，其中$\kappa_i$用户加密$m_i(i=1,\dots,n)$。 然后，数据拥有者定义一个访问结构$M_i$，并在这个结构下加密内容密钥$\kappa_i(i=1,\dots,n)$。显然，本文余下部分仅仅考虑一个数据块$m$和一个内容密钥$\kappa$。加密算法随机选择一个加密指数$s \in Z_p$和一个随机向量$\vec{v} = {s,y-2, \dots, y_n} \in Z_{p}^n$，其中$y-2, \dots, y_n$被使用来分享加密指数$s$。对于，$i=1$至$l$,计算$\lambda_i = \vec{v}\cdot M_i$，其中$M_i$是矩阵$M$对应第$i$行的向量。然后，随机选择$r_1,r_2,\dots,r_l \in Z_p$,并计算密文如下： 在实际系统中，如果数据$m$被分为$n$个数据块，同样，密文$CT$也包括$n$部分$CT = \lbrace CT_1,\dots,CT_n \rbrace$。 E 用户解密数据（在云辅助下）在系统，所有合法的用户可以自由的查询来自云服务器的完整密文。但是，仅仅但用户的属性满足嵌套在密文中的访问结构，他或她才能解密内容密钥，进一步使用它解密数据。这个过程包括两步：云服务器生成令牌和用户解密数据。 1)云服务器生成令牌： 用户$U_j(j \in S_U)$发送他自己的密钥$\lbrace SK_{j,k} \rbrace_{s \in S_A}$给云服务器，请求一个用户解密密文的令牌。仅仅当用户$U_j$拥有的属性满足定义在密文CT中的访问结构，服务器才会成功的计算正确解密令牌TK。 服务器运行令牌生成算法TKGen,其输入为：密文（包括一个访问结构$A$）、用户的全局公钥$GPK_j$和用户私钥集合$\lbrace SK_{j,k} \rbrace_{k \in I_A}$。设$I=\lbrace I_{A_k} \rbrace_{k \in I_A}$是所有包括在密文中的属性的下标集合，其中$I_{A_k} \subset \lbrace 1,\dots,l\rbrace$是来自$AA_k$的属性的下标的子集，定义为：$I_{A_k} = \lbrace i: \rho(i) \in S_{A_k} \rbrace$。设$N_A = |I_A|$是在密文中牵涉到的AAs数量。选择一个常数集合\lbrace \omega_i \in Z_p \rbrace_{i \in I}，如果$\lbrace \lambda_i\rbrace$是M的秘密s的有效份额，则重新构造加密指数：$s= \sum_{i \in I} \omega_i\lambda_i $。 计算解密令牌TK的算法如下： 其输出针对密文CT和用户$U_j$的解密令牌TK。 2）用户解密数据： 一旦收到解密令牌TK，用户$U_j$能够使用其和自己的全局私钥$GSK_j = z_j$解密密文。如下： 然后，用户使用内容密钥密钥$\kappa$来解密数据，如下： F. 有效的属性撤销假设用户$U_{\mu}$的一个属性$\check(x)_k$从$AA_k$被撤销。属性撤销包括三个阶段：AAs更新密钥生成、未撤销用户私钥更新、云服务器更新密文。私钥更新可以阻止撤销用户来解密新的密文（后向安全），新的密文使用新的属性公钥加密。密文更新也能保证新加入的用户仍可以访问先前发布的数据（后向安全），新用户拥有足够的属性。 1）AAs更新密钥生成： 相应的权威$AA_k$运行更新密钥算法UKeyGen来计算更新密钥。算法的输入为：权威私钥$SK_k$，当前属性版本密钥$v_{\check(x)_k}$和用户全局公钥$GPK_j$。它生成一个新的属性版本密钥$VK_{\check(x)k}^{‘}=v{\check(x)k}^{‘}$。首先，其计算属性更新密钥：$AUK{\check(x)_k} = \gamma_k(v_{\check(x)k}^{‘}-v{\check(x)_k})$，然后，运用其来计算用户密钥的更新密钥如下： 密文更新密钥如下: 然后，$AA_k$更新的撤销属性$\check(x)k$的属性公钥:$PK^{‘}{\check(x)k} = PK{\check(x)k} \cdot g{\check(x)_k}^{AUK}$，并向所有用户发布一条信息:属性$\check(x)_k$的公钥被更新。最火，所有用户可以得到新的属性公钥，密钥来自$AA_k的公布$。 2)为撤销用户的密钥更新：对于每个未撤销用户$U_j(j \in S_U, j \neq \mu)$，其拥有已撤销属性$\check(x)_k$，$AA_k$发送相应用户密钥更新密钥$KUK_{j,\check(x)k}$给它。一旦收到$KUK{j,\check(x)_k}$，用户$U_j$运行密钥更新算法SKUpate来更新其私钥，如下： 注意，每个$KUK_{j,\check(x)k}$与$uid$相关联，以至于他们将不同的未撤销用户区分开来。这样，撤销用户$U{\mu}$无法使用任何其他用户的私钥来了更新私钥。 3)云服务密文更新：$AA_k$发送密文更新密钥$CUK_{\check(x)k}$给云服务器。一旦收到$CUK{\check(x)_k}$,服务器运行密文更新算法CTUpdate，来更新与撤销属性$\check(x)k$相关的密文。其的输入为：当前密文CT和$CUK{\check(x)_k}$。仅需要去更新一个密文与属性$\check(x)_k$相关的几个部分。新的密文$CT^{‘]$为： DAC-MACS要求仅仅更新一些部分，这些部分与撤销属性相关联，而其他部分不需要改变。这提高了属性撤销的效率。 密文更新不仅可以保证属性撤销的前向安全，而且还可以减少用户的存储开销（即所有的用户仅仅需要保存最新的私钥，而不许可记录所有先前的密钥）。 四、DAC-MACS分析这节给出了DAC-MACS的综合分析，包括安全和性能分析。 A. 综合分析设$|p|$是阶数为p的群的元素个数。设$t_c$是一个密文中总的属性数量，$t_u$一个用户拥有的属性总数。设$n_u$表示系统中用户的数量。位于撤销属性$x$，设$n_{non,x}$是拥有撤销属性的未撤销用户的数量，$n_{c,x}$是包括撤销属性的密文数量。 表1展示了DAC-MACS和其他两种现有方案的比较，它们都是依靠密文重加密来实现属性撤销。从表中可知，DAC-MACS方案的用户计算量和撤销的通信开销更小。在DAC-MACS中，属性撤销有每个AA独立强制执行，但是密文的更新由半可信的服务器执行，这大大降低了用户的工作量。对于属性撤销的安全性，DAC-MACS可以实现前向安全和后向安全。在系统中，云服务器要求是可信的。即使，在某些场景中，云服务器不可信，云服务器将不会正确的更新密文。在这种情况下，前向安全不能保证，但是系统还可以时间后向安全，即撤销用户不能解密新密文，其要求撤销属性来解密。 B. 安全性分析在第二节定义的安全模型下，证明DAC-MACS具有可证明的安全性和共谋弹性。总结为如下定理： 定理一：判定性q双线性BDHE假设成立，不存在一个多项式时间算法可以选择性的破坏DAC-MACS，使用一个大小为$l^{\ast} \times n^{\ast}$,其中$ n^{\ast} \le q$。 证明： 假设存在一个算法$A$,对于选择性安全游戏来攻击我们的构造有一个不可忽略的优势$\varepsilon = Adv_{A}$,假设其选择一个至少有$q-1$行的挑战矩阵$M^{\ast}$。在安全游戏种，攻击者可以查询任何私钥和更新密钥，但是都不能与其他私钥结合来解密，其他密钥来自破坏的AAs。在这种限制下，多权威系统种的安全游戏可以看作是一个单权威中心的。相似地，可以构建一个模拟$B$，来结局判定性qBDHE问题，其有一个不可忽略的优势。详细的证明在文献[15]给出。 定理二：DAC-MACS可以抵抗用户的共谋攻击。 证明：在DAC-MACS中，系统中的每个用户都分配有一个全局唯一身份$uid$，分发来自不同的AAs，同一个用户的所有私钥是与该用户的$uid$相关。这样，两个或更多用户共谋和解密密文是不可能的。更为甚者，由于每个AA的唯一$aid$，所有属性是不同的，即使一些AAs分发相同的属性。这可以阻止用户利用一个AA分发的私钥来取代另一个AA分发的私钥。 隐私保证： 由于解密外包，服务器可以得到用户的私钥。然而，服务器没有用户的全局私钥，仍然不可以解密密文。更为甚至，密文的更新通过代理重加密的方式执行。这样服务器不需要去解密密文。 性能分析比较DAC-MACS和Ruj的DACC方案的性能，对存储开销、通信开销和计算开销进行分析。 1)存储开销： 在云存储系统中，存储开销是访问控制访问最重要的问题之一。假设系统中有$N_A$个AAs。设$|p|$是$G,G_T,Z_p$的大小。设$n_{a,k}$和$n_{a,k,aid}$分布表示由$AA_k$管理的属性总量和$AA_k$分发给用户$uid$的属性数量。比较系统中每个实体的存储开销，如表2： 在DAC-MACS中，每个$AA_k$的存储开销包括每个属性的版本号和权威性私钥；而DACC包括所有属性的私钥。公开参数由所有者贡献主要的存储开销。另外，DACC需要系统中拥有者持有每个密文的加密私钥，因为拥有者需要去重加密密文。这引发了数据拥有者的巨大存储开销，特别当系统中的密文的数量特别大时。在DAC-MACS中，每个用户的存储开销来自由CA签发的全局私钥和由所有AAs分发的私钥。然后，在DACC中，每个用户的开销包括由所有AAs分发的私钥和与撤销属性相关的密文部分。这是因为当密文被重加密，与撤销撤销属性相关的组件可能被发送给每个未被撤销的用户，这些用户拥有撤销撤销属性。服务器上的存储开销主要是密文存储（不考虑由对称内容密钥加密的数据组件）。 2)通信开销：在DAC-MACS和Ruj的DACC方案中的访问控制的通信开销时基本相同的。这里，仅仅比较属性撤销的通信开销。正如表3所示。显而易见，Ruj的方案属性撤销的通信开销与包含撤销属性的密文数量呈线性关系。由于云系统中密文数量巨大，Ruj的方案，在属性撤销过程中的通信开销巨大。 3)计算开销:对DAC-MACS和Ruj的DACC方法，仿真加密、解密和密文重加密\更新的计算时间。在Linux系统上仿真，采用英特尔酷睿2双核3.16GHz处理器,4.00GB的运行内存。代码使用基于配对的密码库版本0.5.12来模拟访问控制方案。使用对称椭圆曲线-$\alpha$曲线，其中基本字段大小为512比特，嵌入度为2。$\alpha$曲线有一个阶数为160比特的群，这意味着$p$是一个长度为160比特的素数。所有的仿真结果取20次实验的均值。 使用两个标准来比较加密和解密的计算效率：权威的数量和每个权威的属性数量。正如图2所示。图2(a)描述的是拥有者加密时间与AAs数量的关系比较，其中每个AA的属性数量为10。图2(b)给出了拥有者加密时间与每个AA所拥有的属性数量的关系比较，其中AAs的数量为10。图2(c)展示了用户解密时间与AAs数量的关系比较，其中每个用户的属性数量为10。图2(d)描述的是用户的解密时间与每个AA拥有的属性数量之间的关系比较，其中针对该用户的权威的数量为10。图2(e)给出了密文重加密或更新与出现在密文中撤销属性数量的关系比较。仿真结果表明，DAC-MACS方案在拥有者加密数据、用户解密数据、密文重加密时的计算量都比较小。 五、扩展DAC-MACS（EDAC-MACS）在DAC-MACS方案中，有一个安全假设：所有未撤销用户不会将收到的更新私钥发送给撤销用户。然而，这是一个强假设，在实际中，撤销用户可能与其他用户共谋来获得更新私钥。本节首先提出一个扩展的数据访问控制方案（EDAC-MACS），然后给出了安全性分析，证明在没有假设下，EDAC-MACS可以实现同样的安全目标。 A.EDAC-MACS如果移除这个假设，DAC-MACS方案的后向安全无法再保证。即当攻击者$\mu$（撤销用户）破坏任意AA，他或她可能获得所有的用户私钥$\lbrace u_uid \rbrace$，使用它来转换其他用户的私钥更新密钥$KUK_{j,\check(x)_k}$来得到自己的更新私钥： 然后，通过运行私钥更新算法SKUpdate，攻击者可以用其更新自己的私钥的最新的版本。 为了解决这个安全问题，修改私钥生成算法SKeyGen，填加一个新内容到$K_{j,x_k}$。它生产用户私钥如下： 其中$j \ in S_U, k \in S_A$。 加密算法跟DAC-MACS的相同，但是在解密期间，解密令牌TK由新的解密令牌生成算法TKGen生成，如下： 正确性： 观察得到： 对于每个$i \in I$，假设$\rho(i) \in S_k$，计算： 然后，计算： 解密算法跟DAC-MACS相同。 在属性撤销阶段，权威同样需要生成更新私钥。密文更新私钥$CUK_{\check(x)_k}$跟DAC-MACS相同。然而，用户私钥更新密钥生成如下： B. 安全性分析 总结EDAC-MACS的安全性为如下的两个定理： 定理三：在EDAC-MACS中，撤销用户无法更新自己的私钥，即使它可以破坏多个AAs（没有撤销属性队形的AA）和与一些为撤销用户共谋。 证明：在EDAC-MACS中，每个私钥的更新与用户身份标识$uid$相关。并且在私钥中的$(g^{v_{x_k}H(x_k)^{\gamma_k}^2$项可以阻止用户使用其他用户的更新密钥来更新它们的私钥，因为$\gamma_k$是仅仅AA_k知道，所有用户都用户无法获取。 定理四：当判定性qBDHE问题假设成立，不存在一个多项式时间算法可以选择性的破坏EDAC-MACS，使用一个大小为$l^{\ast} \times n^{\ast}$,其中$ n^{\ast} \le q$。 证明： 基于定理三，EDAC-MACS的安全性证明跟DAC-MACS相似，如定理一。主要的不同是在EDAC-MACS中怎么去仿真新的私钥。详细的证明在附录A中给出。 六、相关工作问题：安全模型不是理解，定义3、4的理解 访问结构如何构造 属性在加密和解密中没有体现]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动通信技术]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[介绍第二代至第四代移动通信技术，以及正在研发的第五代移动通信技术 第几代 移动 电信 联通 2G GSM CDMA GSM 3G TD-SCDMA CDMA2000 WCDMA 4G TD-LTE FDD-LTE和TD-LTE FDD-LTE和TD-LTE 第五代移动通信系统，采用高频段，传输距离缩短，所以需要部署比较密集的基站。 5G关键技术 高频传输技术：目前全球使用的3G和4G使用的频段是2GHz左右，频段越低则覆盖率越高，但是低频段谱往往是有限的。为了传输速度更快，高频段需要更宽的带宽与之匹配。 大规模天线传输技术（MIMO） 密集网络技术 5G三大场景 eMBB:3D/超高清视频等大流量移动宽带业务 mMMT：大规模物联网业务 URLLC：如无人驾驶、工业自动化等需要低延时、高可靠连接的业务 5G三种标准(信道编码) LDPC方案：高通牵头 Polar方案：华为牵头 Turbo方案：LG牵头]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 日志系统]]></title>
    <url>%2F2018%2F09%2F05%2FLinux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[日志数据可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。它可以记录下系统产生的所有行为，并按照某种规范表达出来。可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。收集你想要的数据，分析出有价值的信息，可以提高系统、产品的安全性，还可以帮助开发完善代码，优化产品。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。 一、常见的日志日志是一个系统管理员，一个运维人员，甚至开发人员不可或缺的东西，系统永久了偶尔会出现一些错误，需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，需要日志来做问题定位，日志还是过往时间的记录表，可以通过它知道是否被不明用户登陆过等等。 在linux中大部分的发行版都内置使用syslog系统日志，常见的日志一般存放在var/log中，来看看其他有哪些日志： ll /var/log 根据图中所显示的日志，可以根据服务对象粗略的将日志分为两类： 系统日志：主要存放系统内置程序或系统内核之类的日志信息如alternative.log,btmp等等； 应用日志：主要是安装第三方应用所产生的日志，如：tomact7,apache3等等 系统日志具有有哪些，都记录了怎样的信息： 日志名称 记录信息 alternatives.log 系统的一些更新替代信息记录 apport.log 应用程序崩溃信息记录 apt/history.log 使用 apt-get 安装卸载软件的信息记录 apt/term.log 使用 apt-get 时的具体操作，如 package 的下载、打开等 auth.log 登录认证的信息记录 boot.log 系统启动时的程序服务的日志信息 btmp 错误的信息记录 Consolekit/history 控制台的信息记录 dist-upgrade dist-upgrade 这种更新方式的信息记录 dmesg 启动时，显示屏幕上内核缓冲信息,与硬件有关的信息 dpkg.log dpkg 命令管理包的日志。 faillog 用户登录失败详细信息记录 fontconfig.log 与字体配置有关的信息记录 kern.log 内核产生的信息记录，在自己修改内核时有很大帮助 lastlog 用户的最近信息记录 wtmp 登录信息的记录。wtmp可以找出谁正在进入系统，谁使用命令显示这个文件或信息等 syslog 系统信息记录 只闻其名，不见其人，并不能明白这些日志记录的内容。首先我们来看 alternatives.log 中的信息： 从中得到的信息有程序作用，日期，命令，成功与否的返回码 对于Debain系统，使用apt-get安装软件，因在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了哪个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。 其他的日志格式也都类似于之前所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog。 查看的方法是使用 last 与 lastlog 工具来提取其中的信息 二、配置的日志这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。 这样的实现可以通过两种方式： 一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具 rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。 这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd 因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看 sudo apt-get update sudo apt-get install -y rsyslog sudo service rsyslog start ps aux | grep syslog 既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务 首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个， 一个是 /etc/rsyslog.conf：主要是配置的环境，即rsyslog加载什么模块 一个是 /etc/rsyslog.d/50-default.conf：主要是配置的Filter Conditions。 /etc/rsyslog.conf /etc/rsyslog.d/50-default.conf 看看 rsyslog 的结构框架，数据流的走向，如下图： 通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。 Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。 第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages。而Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看。 配置中 rsyslog 支持三种配置语法格式： sysklogdlegacy rsyslogRainerScriptsysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 $ModLoad 还有一些插件和特性只在此语法下支持。而以 $ 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置 老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。 注释有两种语法: 井号 # C-style / .. / 执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。 模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。 legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么 模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement） 如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。 了解了 rsyslog 环境的配置文件之后，再看向 /etc/rsyslog.d/50-default.conf 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 Parser &amp; Filter Engine,它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，facility 与 priority，其配置格式如下: facility.priority log_location 其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 , 分割开,具体可见上图 rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有： | kern | 内核消息 || user | 用户信息 || mail | 邮件系统消息 || daemon | 系统服务消息 || auth | 认证系统 || authpriv | 权限系统 || syslog | 日志系统自身消息 || cron | 计划安排 || news | 新闻信息 || local0~7 | 由自定义程序使用 | 而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有一下几种： 类别 解释 emergency 系统已经无法使用了 alert 必须立即处理的问题 critical 很严重了 error 错误 warning 警告信息 notice 系统正常，但是比较重要 informational 正常 debug debug的调试信息 panic 很严重但是已淘汰不常用 none 没有优先级，不记录任何日志消息 auth,authpriv.* /var/log/auth.log 这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 /var/log/auth.log 日志中 而其中有类似于这样的配置信息意思有细微的差别 kern.* -/var/log/kern.log -代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。 与日志相关的还有一个还有常用的命令 logger,logger 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。 #首先将syslog启动起来 sudo service rsyslog start #向 syslog 写入数据 ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp; #查看是否有数据写入 sudo tail -f /var/log/syslog 从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板 我们可以通过 man 来查看 logger 的其他用法， 参数 内容 -i 在每行都记录进程 ID -t 添加 tag 标签 -p 设置日志的 facility 与 priority 三、转储的日志在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。 logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。 大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。 显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件 cat /etc/logrotate.conf # see &quot;man logrotate&quot; for details //可以查看帮助文档 # rotate log files weekly weekly //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 ) # keep 4 weeks worth of backlogs rotate 4 //最多转储4次 # create new (empty) log files after rotating old ones create //当转储后文件不存在时创建它 # uncomment this if you want your log files compressed compress //通过gzip压缩方式转储（nocompress可以不压缩） # RPM packages drop log rotation information into this directory include /etc/logrotate.d //其他日志文件的转储方式配置文件，包含在该目录下 # no packages own wtmp -- we&apos;ll rotate them here /var/log/wtmp { //设置/var/log/wtmp日志文件的转储参数 monthly //每月转储 create 0664 root utmp //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664 rotate 1 //最多转储一次 } 当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程管理]]></title>
    <url>%2F2018%2F09%2F05%2FLinux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[介绍一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。 一、进程查看 top:实时的查看进程的状态 ps:静态查看当前的进程信息 pstree:查看当前活跃进程的属性结构 1.1 top工具的使用top工具是常用的一个查看工具，能实时的查看系统的一些关键信息： top top是一个在前台执行的程序，所以执行后变进入到这样的一个交互界面，正因交互界面我们才可以实时的获取到系统于进程的信息，在交互界面我们eyi通过一些指令来操作和筛选，在此之前想了解显示的内容： 看到top显示的第一排： 内容 解释 top 表示当前的程序名称 09：12：35 表示当前的系统时间 up 16 days, 1:09 表示当前机器已经启动了多长时间 1 user 表示当前系统中只有一个用户 load average: 0.86,0.14,0.19 分别对应1，5，15分钟内cpu的评价负载 load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。 我们该如何看待这个load average 数据呢？ 假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。 load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务； load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足； load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已； load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了 这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数 #查看物理cpu的个数 cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l #每个cpu的核心数 cat /proc/cpuinfo | grep &quot;physical id&quot; | grep &quot;0&quot; | wc -l 通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了 若是 load &lt; 0.7 并不会去关注他； 若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了； 若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了； 若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了 通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。 top 的第二行数据，基本上第二行是进程的一个情况统计 内容 解释 Tasks: 28 total 进程总数 1 running 1个正在运行的进程数 26 sleeping 25个睡眠的进程数 1 stopped 没有停止的进程数 0 zombie 没有僵尸进程数 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计 | 内容 | 解释 || Cpu(s): 0.6us | 用户空间进程占用CPU百分比（0.6%）|| 0.2 sy | 内核空间运行占用CPU百分比（0.2%） || 0.0 ni | 用户进程空间内改变过优先级的进程占用CPU百分比（0.0%） || 98.6 id | 空闲CPU百分比 || 0.6 wa | 等待输入输出的CPU时间百分比 || 0.0 hi | 硬中断(Hardware IRQ)占用CPU的百分比 || 0.0 si | 软中断(Software IRQ)占用CPU的百分比 || 0.0 st | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 | CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。 top的第四行数据，这一行基本是内存的一个使用情况的统计 内容 解释 8175596 total 物理内存总量 1677840 free 空间的物理内存总量 1806640 used 使用的物理内存总量 4691116 buff/cache 用作内存缓存的内存量 注意：系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计 内容 解释 0 total 交换区总量 0 free 空闲的交换区总量 0 used 使用的交换区总量 60208884 avail Mem 可用交换区总量 再下面就是进程的一个情况： 列名 解释 PID 进程id USER 该进程的所属用户 PR 该进程执行的优先级 priority 值 NI 该进程的 nice 值 VIRT 该进程任务所使用的虚拟内存的总数 RES 该进程所使用的物理内存数，也称之为驻留内存数 SHR 该进程共享内存的大小 S 该进程进程的状态: S=sleep R=running Z=zombie %CPU 该进程CPU的利用率 %MEM 该进程内存的利用率 TIME+ 该进程活跃的总时间 COMMAND 该进程运行的名字 注意 NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低 PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。 其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同 VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数 top是一个前台程序，所以是一个可以交互的： 常用交互命令 解释 q 退出程序 I 切换显示平均负载和启动时间的信息 P 根据CPU使用百分比大小进行排序 M 根据驻留内存大小进行排序 i 忽略闲置和僵死的进程，这是一个开关式命令 k 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 1.2 ps工具的使用ps也是常用查看进程的工具之一，罗列出所有信息如下： ps aux 还可以在查看时，将连同部分的进程呈树状显示出来 ps axjf 内容 解释 F 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员root权限 USER 进程的拥有用户 PID 进程的 ID PPID 其父进程的 PID SID session 的 ID TPGID 前台进程组的 ID %CPU 进程占用的 CPU 百分比 %MEM 占用内存的百分比 NI 进程的 NICE 值 VSZ 进程使用虚拟内存大小 RSS 驻留内存中页的大小 TTY 终端 ID S or STAT 进程状态 WCHAN 正在等待的进程资源 START 启动进程的时间 TIME 进程消耗CPU的时间 COMMAND 命令的名称和参数 TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程 STAT表示进程的状态，而进程的状态有很多，如下表所示 状态 解释 R Running.运行中 S Interruptible Sleep.等待调用 D Uninterruptible Sleep.不可中断睡眠 T Stoped.暂停或者跟踪状态 X Dead.即将被撤销 Z Zombie.僵尸进程 W Paging.内存交换 N 优先级低的进程 &lt; 优先级高的进程 s 进程的领导者 L 锁定状态 l 多线程状态 + 前台进程 使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来 ps -l 若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用 ps aux | grep zsh 当然如果觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示 ps -afxo user,ppid,pid,pgid,command 1.3 pstree工具的使用通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。 pstree pstree -up #参数选择： #-A ：各程序树之间以 ASCII 字元來連接； #-p ：同时列出每个 process 的 PID； #-u ：同时列出每个 process 的所屬账户名称。 二、 进程管理2.1 kill命令当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。 前面使用 kill 命令来管理一些 job，这里将尝试用 kill 来操作下一些不属于 job 范畴的进程 #使用9这个信号强制结束 gedit 进程 kill -9 1608 2.2 进程的控制顺序在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？ 当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了 而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制 #打开一个程序放在后台，或者用图形界面打开 nice -n -5 vim &amp; #用 ps 查看其优先级 ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim 还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试 renice -5 pid]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016百度校招面试题]]></title>
    <url>%2F2018%2F09%2F02%2F2016%E7%99%BE%E5%BA%A6%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[对前面学习命令的一个总结 2016百度校招面试题在linux中，对于文本的处理和分析是极为重要的，现在有一个文件叫做data1，同学们可以在这里下载， wget http://labfile.oss.aliyuncs.com/courses/1/data1 里面记录是一些命令的记录，现在需要你从里面找出出现频率次数前3的命令并保存在/home/shiyanlou/result。 目标 处理文本data 将结果写入result 结果包含次数和命令，如“100 ls” 提示 cut截取(-c 8明白含义吗) uniq -dc去重 sort 的参数选择-k1 -n -r 答案类似于 cat data|....|....|.... &gt; /home/shiyanlou/result cat data1 | cut -c 8- | sort | uniq -dc | sort -n -r &gt; result 解释： 在去重之间，必须先排序，否则，内容为空，具体原因不太清楚，希望清楚的可以留言，谢谢 cut -c 8-： 截取第8个字符之后的字符（包括第8个） sort: 默认排序 uniq -dc: 去重并，-c在输出行前面加上每行在输出文件中出现的次数，-d仅显示重复行 sort -n -r: 按数值从大到小的顺序排列，-r以相反的顺序排序，默认从小到大，-n依照数值的大小排序 head -n -3 显示头三条 附件： sort -t -k: -t后面可以设定间隔符，指定间隔符之后，就可以用-k来指定列数 将如下日期按月份排序 2017-12-092017-01-202017-04-242017-10-23 sort -n -k 2 -t&apos;-&apos;]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程概念]]></title>
    <url>%2F2018%2F09%2F01%2FLinux%20%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。 而在此之前，我们需要对进程的基础知识有一定的了解，才能更好、更有效率的使用Linux 提供的工具。 一、概念理解1.1 程序与进程程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如vim程序。而进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下特点： 动态性： 进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性： 进程可以做到一个时间段内，有多个进程在运行。程序只是静态的实体，所以不存在并发性。 独立性： 进程可以独立分配资源，独立接受调查，独立地运行。 异步性： 进程以不可预知的速度向前推进。 结构性： 进程拥有代码段、数据段、PCB(进程控制块，进程存在的唯一标识)。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都在执行过） 并行：在每一个瞬间，都有多个程序在同时执行，这个必须多个CPU才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 二、进程的属性2.1 进程分类进程的分类，可以从两个角度来分： 以进程的功能与服务的对象来分； 以应用程序的服务类型来分。 第一个角度来看，可以分为用户进程与系统进程： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此来进程可以在用户的控制下运行或关闭。 系统进程： 通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。 第二个角度来看，可以将进程分为交换进程、批处理进程、守护进程 交换进程：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在Linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有进程用的cron（在centos系列为crond）进程，这个进程为crontab的守护进程，可以周期性的执行用户设定的某些任务。 2.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少，感兴趣的同学可以查查为什么。 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 pstree 还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 2.3 进程组于Sessons每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 2.4 工作管理bash（Bourne-Again shell）支持工作控制（job control）,而sh(Bourne shell)不支持。 并且每个终端或者说bash只能管理当前终端中的job，不能管理其他终端中的job，比如我们当前存在两个bash分别为bash1、bash2，bash1只能管理其自己里面的job并不能管理bash2里面的job。 当知道一个进程在前台运行时，可以同用Ctrl+C来终止它，但是若在后台的话，则不行。 可以通过&amp;符号，让命令在后台运行： ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令 #后面不加参数提取预设工作，加参数提取指定工作的编号 #ubuntu 在 zsh 中需要 %，在 bash 中不需要 % fg [%jobnumber] Ctrl+z使得工作停止放置在后台，如果想让其在后台运行，可以使用如下命令： #与fg类似，加参则指定，不加参则取预设 bg [%jobnumber] 既然有办法让放置在后台的工作提至前台或让它从停止变成继续运行在后台，当然也有办法删除一个工作，或者重启等： #kill的使用格式如下 kill -signal %jobnumber #signal从1-64个信号值可以选择，可以这样查看 kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 注意: 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作 若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux数据流重定向]]></title>
    <url>%2F2018%2F09%2F01%2FLinux%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[你可能对重定向这个概念感到些许陌生，但你应该在前面的课程中多次见过&gt;或&gt;&gt;操作了，并知道他们分别是将标准输出导向一个文件或追加到一个文件中。这其实就是重定向，将原本输出到标准输出的数据重定向到一个文件中，因为标准输出(/dev/stdout)本身也是一个文件，我们将命令输出导向另一个文件自然也是没有任何问题的。 常用重定向操作： echo &apos;hello shiyanlou&apos; &gt; redirect echo &apos;www.shiyanlou.com&apos; &gt;&gt; redirect cat redirect 简单的重定向Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。 文件描述符 设备文件 说明 0 /dev/stdin 标准输入 1 /dev/stdout 标准输出 2 /dev/stderr 标准错误 文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。 将cat的连续输出（heredoc方式）重定向到一个文件： cat &gt; test.cpp &lt;&lt; EOF 输入需要存入test.cpp文件的内容，输入EOF结束 将一个文件作为命令的输入，标准输出作为命令的输出： cat test.cpp 将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出： echo &apos;hi&apos; | cat 将echo命令的输出从默认的标准输出重定向到一个普通文件： echo &quot;hello world&quot; &gt; redirect cat redirect 标准错误重定向重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作： #使用cat同时读取两个文件，其中一个存在，一个不存在 cat test.c hello.c #可以看到上述命令，输出第一个文件的内容，还在末尾处出现了一条错误信息 #下面将输出重定向到一个文件 cat test.cpp hello.cpp &gt; somefile 遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了： #将标准错误重定向到标准输出(2&gt;&amp;1)，再将标准输出重定向到文件，注意要将重定向文件写到前面,2表示标准错误，1表示标准输出， cat test.cpp hello.cpp &gt; somefile 2&gt;&amp;1 #或者只用bash提供的特殊的重定向符号`&amp;`将标准错误和标准输出同时重定向到文件 cat test.cpp hello.cpp &amp;&gt;somefilehell 注意你应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中 使用tee命令同时重定向到多个文件除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用tee命令来实现： echo &quot;hello world;&quot; | tee hello 永久重定向前面的重定向操作都只是临时性的，即对当前命令有效，如何做到重定向对所有命令都有效呢？比如在一个脚本中，仅需要某一部分的命令全部进行重定向，难道要在每个命令上面加上临时重定向的操作吗？当然不需要，可以使用exec命令实现“永久”重定向。exec命令的作用是使用指定的命令替换当前的shell，即使用一个进程替换当前进程，或者指定新的重定向。 #先开启一个子shell zsh #使用exec替换当前进程的重定向，将标准输出重定向到一个文件 exec 1&gt;somefile #下面执行的命令的输出都将重定向到文件中，直到你退出当前shell，或取消exec的重定向 ls ll exit cat somefile 创建输出文件描述符在shell中有9个文件描述符，前面介绍和使用了默认提供的0、1、2文件描述符。另外还可以使用3-8的文件描述符，只是它们默认没有打开而已。 使用如下命令查看当前shell进程中打开的文件描述符： cd /dev/fd/; ls -Al 同样，可以使用exec命令创建新的文件描述符： zsh exec 3&gt;somefile #先进入目录，在查看，否则可能不能得到正确的结果，然后再回到上一次的目录 cd /dev/fd/;ls -Al; cd - #注意下面的命令&gt;和&amp;之间不应该有空格，如果有空格则会报错 echo &quot;this a test&quot; &gt;&amp;3 cat somefile exit 关闭文件描述符上面打开了3号文件描述符，可以使用如下操作将其关闭： exec 3&gt;&amp;- cd /dev/fd;ls -Al;cd - 完全屏蔽命令的输出在Linux中有一个被称为“黑洞”的设备文件，所以导入它的数据都将被“吞噬”。 在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。 可以实利用/dev/null屏蔽命令的输出： cat test.cpp hello.cpp 1&gt;/dev/null 2&gt;&amp;1 上面这样的操作将使你得不到任何输出结果。 使用xargs分割参数列表xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题 这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。 cut -d: -f1 &lt; /etc/passwd | sprt | xargs echo 上面这个命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下软件安装]]></title>
    <url>%2F2018%2F09%2F01%2FLinux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在此简单介绍Linux下软件安装，更多可见：Linux不同版本以及程序包安装 注意本文介绍的都是基于ubuntu 体验比如我们想安装一个软件，名字叫做 w3m(w3m是一个命令行的简易网页浏览器)，那么输入如下命令： sudo apt-get install w3m 它就表示将会安装一个软件包名为w3m的软件。 apt包管理工具介绍 APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的多个工具，如 apt-get apt-cache apt-cdrom 等，在Debian系列的发行版中使用。 当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了： 软件源镜像服务器 软件源 我们需要定期从服务器上下载一个软件包列表，使用 sudo apt-get update 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，我举个例子：我们安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 apt-get 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。 apt-getapt-get 是用于处理 apt包的公用程序集，可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具： 工具 说明 install 其后加上软件包名，用于安装一个软件包 update 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表 upgrade 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update dist-upgrade 解决依赖关系并升级(存在一定危险性) remove 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 autoremove 移除之前被其他软件包依赖，但现在不再被使用的软件包 purge 与remove相同，但会完全移除软件包，包含其配置文件 clean 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/ autoclean 移除已安装的软件的旧版本软件包 下面是一些apt-get常用的参数： 参数 说明 -y 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 -s 模拟安装 -q 静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 -f 修复损坏的依赖关系 -d 只下载不安装 –reinstall 重新安装已经安装但可能存在问题的软件包 –install-suggests 同时安装APT给出的建议安装的软件包 重新安装软件包： sudo apt-get --reinstall install w3m 如果不知软件包完整名的时候，通常使用Tat键补全软件包名。 软件升级 #更新软件源 sudo apt-get #升级没有依赖问题的软件包 sudo apt-upgrade #升级并解决依赖关系 sudo apt-get dist-upgrade 卸载软件 sudo apt-get remove w3m #不保留配置文件的移除 sudo apt-get purge w3m #或者 sudo apt-get --purge remove w3m #移除不再需要的被依赖的软件包 sudo apt-get autoremove 软件搜索 当刚知道了一个软件，想先下载，需要确认仓库里面有没有，就需要用到搜索功能，命令如下： sudo apt-cache search softname1 softname2 .... 使用dpkg dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。 dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。 dpkg常用参数介绍： 参数 说明 -i 安装指定deb包 -R 后面加上目录名，用于安装该目录下的所有deb安装包 -r remove，移除某个已安装的软件包 -I 显示deb包文件的信息 -s 显示已安装软件的信息 -S 搜索已安装的软件包 -L 显示已安装软件包的目录信息 #查看已经安装软件包的安装目录 sudo dpkg -L w3m 从二进制包安装二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7设置默认进入图形界面和命令行界面]]></title>
    <url>%2F2018%2F09%2F01%2FCentos%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E8%BF%9B%E5%85%A5%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[相比7之前的版本，在centos7版本中，设置OS启动默认进入图形界面还是文本界面有了点变化。 查看当前默认设置 systemctl get-default graphical.target #默认图形界面 设置开始进入命令行界面： systemctl set-default multi-user.target #返回 Removed symlink /etc/systemd/system/default.target. Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target. 设置开始进入图形界面： systemctl set-default grphical.target 阅读/etc/inittab，也可以发现如下内容 [root@rems2 ~]# cat /etc/inittab # inittab is no longer used when using systemd. # # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM. # # Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target # # systemd uses &apos;targets&apos; instead of runlevels. By default, there are two main targets: # # multi-user.target: analogous to runlevel 3 ---&gt;告诉我们multi-user.target相当于以前的runlevel 3 # graphical.target: analogous to runlevel 5 ---&gt;告诉我们graphical.target相当于以前的runlevel 5 # # To view current default target, run: # systemctl get-default # # To set a default target, run: # systemctl set-default TARGET.target # 转自:https://blog.csdn.net/liglewang/article/details/76222642 命令行输入： init 3 进入命令行界面 init 5 进入图形界面]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍grep，sed，awk这三个命令，而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）。 概念正则表达式，又被正规表示式、正规表示法、针对表达式、规格表达式、常规表达法（Regular Expression,或regex、regexp、RE）。正则表达式使用单个字符来描述、匹配一系列符合某个句法规则的字符串。在很多编辑器里，正则表达式通常用来检索、替换那些符合某个模式的文本。 注意区分正则表达式与通配符的差别。 在文本过滤工具里，都是用正则表达式，比如像awk，sed，等，是针对文件的内容的 而通配符多用在文件名上，比如查找find，ls，cp，等等 具体内容对比，可以参考：https://blog.csdn.net/zgqxiexie/article/details/51184602 例子： 一个文件中，包含“shiyanlou”和“shilouyan”这两个字符，同样一个表达式： shi* 如果上述表达式作为正则表达式，它将只能匹配shi；而如果不是正则表达式，而是作为一个通配符，则将同时匹配两个字符串。 原因：在正则表达式中，*表示匹配前面的子表达式零次或多次，比如它可以匹配”sh”,”shi”,”shii”,”shishi”等等，而作为通配符*表示匹配通配符后面任意多个字符，所以可以匹配文本中的字符串。 基本语法一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。 选择|表示分割，比如： boy | gril可以匹配“boy”或者“girl” 数量限定数量限定出了上面讲过的*，还有+和?,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次： +表示前面的字符必须出现至少一次（一次或多次），例如，”goo+gle”可以匹配‘goooogle’,’gooooogle’等； ?表示前面的字符最多出现一次（零次或一次），例如，“colou?r”可以匹配‘colour’和‘color’； *表示前面的字符可以不出现，也出现一次或者多次，例如，‘0*42’可以匹配42，042，0042，00042等等。 范围和优先级()圆括号可以用来定义模式字符串的范围和优先级，可以简单的理解位是否将括号内的模式串作为一个整体。例如，”gr(a|r)y”等价于gray|grey；”(grand)?father”匹配father和grandfather。 语法部分正则表达式有多种不同的风格，下面举例一下常用的作为PCRE子集的适合于perl和python编程语言及grep或egrep的正则表达式匹配规则。 PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库，比Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。 字符 描述 \ 建一个字符标记为一个特殊字符，或一个原义字符，比如，”n”匹配字符“n”, “/n”匹配一个换行符，序列”\“匹配”\”而“(”匹配”(“。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 {n} n是一个非负整数，匹配确定的n次，例如：”o{2}”不能匹配“Bob”种的“o”,但是能匹配“book”种的两个”o” {n,} n是一个非负整数，至少匹配n次，例如：“o{2,}“不能匹配‘bob’，但可以匹配”foooood“种的所有‘o’, &quot;o{1,}&quot;等价于”o+“,&quot;o{0,}&quot;等价于”o*“ {n,m } m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次，比如“o{1，3}”将匹配“fooooodv”种的前三个o * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除了”\n“之外的任何单个字符，要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。 （pattern） 匹配pattern并获取这一匹配的子字符串。该子字符串用户向后引用。要匹配圆括号字符，请使用“(”或“)”。 x竖线y 匹配x或y。 例如”z竖线food“能匹配”z“或”food”.”(z竖线f)oood”则匹配”zood“或”food“。 [xyz] 字符集合（character class）。匹配所包含的任意一个字符。例如，”[abc]“可以匹配”plain“中的”a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。 [^xyz] 排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意：由于markdown的语法问题，表格中的竖线无法显示，会被编译成表格的一列，所以在表格中使用竖线（’|‘）的地方，写成了中文的“竖线” 优先级优先级为从上到下从左到右，依次降低： 运算符 说明 \ 转义符 (), (?:), (?=), [] 括号和中括号 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$、\任何元字符 定位点和序列 ｜ 选择 grep模式匹配命令基本操作grep命令用户打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定： 参数 说明 -E POSIX扩展正则表达式，ERE -G POSIX基本正则表达式，BRE -P Perl正则表达式，PCRE 在通过grep命令使用正则表达式之前，先介绍一下它的常用参数： 参数 说明 -b 将二进制文件作为文本来进行匹配 -c 统计以模式匹配的数目 -i 忽略大小写 -n 显示匹配文本所在行的行号 -v 反选，输出不匹配行的内容 -r 递归匹配查找 -A n n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行 -B n n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行 –color=auto 将输出中的匹配项设置为自动颜色显示 使用正则表达式使用基本正则表达式：BRE 位置 查找/etc/group文件中以”shiyanlou“为开头的行 grep &apos;shiyanlou&apos; /etc/group grep &apos;^shiyanlou&apos; /etc/group 数量 #匹配以‘z’开头以‘o’结尾的所有字符串 echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.*o&apos; #匹配以‘z’开头以‘o’结尾，中间包含一个任意字符的字符串 echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.o&apos; #匹配以‘z’开头，以任意多个‘o’结尾的字符串 echo &apos;zero\nzo\nzoo&apos; | grep &apos;zo*&apos; 选择 #grep默认区分大小写，这里将匹配所有的小写字母 echo &apos;1234\nabcd&apos; | greap &apos;[a-z]&apos; #将匹配所有的数字 echo &apos;1234\nabcd&apos; | greap &apos;[0-9]&apos; #匹配所有数字 echo &apos;1234\nabcd&apos; | greap &apos;[[:digit]]&apos; #匹配所有小写字母 echo &apos;1234\nabcd&apos; | greap &apos;[[:lower:]]&apos; #匹配所有大写字母 echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:upper:]]&apos; #匹配所有的数字和字母，包括：0-9，a-z,A-Z echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:alnum:]]&apos; #匹配所有的字母 echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:alpha:]]&apos; 下面包含完整的特殊符号及说明： 特殊符号 说明 [:alnum:] 代表英文大小写字母及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字母，亦即 A-Z, a-z [:blank:] 代表空白键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字母，亦即 a-z [:print:] 代表任何可以被列印出来的字符 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字母，亦即 A-Z [:space:] 任何会产生空白的字符，包括空白键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节 # 排除字符 echo &apos;geek\ngood&apos; | grep &apos;[^o]&apos; 使用扩展正则表达式要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。 数量 #只匹配”zo“ echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo{1}&apos; #匹配以&apos;zo&apos;开头的所有单词 echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo{1,}&apos; 注意：推荐掌握{n,m}即可，+,?,*，这几个不太直观，且容易弄混淆。 选择 # 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot; $ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -E &apos;www\.(shiyanlou|google)\.com&apos; # 或者匹配不包含&quot;baidu&quot;的内容 $ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -Ev &apos;www\.baidu\.com&apos; sed流编辑器sed工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text “，意即，用于过滤和转换文本的流编辑器。 在 Linux/UNIX 的世界里敢称为编辑器的工具，大都非等闲之辈，比如前面的”vi/vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”这些个编辑器。sed与上述的最大不同之处在于它是一个非交互式的编辑器。 sed常用参数介绍sed命令基本格式 sed [参数] [执行命令] [输入文件] ... #形如 sed -i &apos;s/ad/happy&apos; test #表示将test文件中的&quot;sad&quot;替换成happy 参数 说明 -n 安静模式，只打印受影响的行，默认打印输入数据的全部内容 -e 用于在脚本中添加多个执行命令一次执行，在命令行中多个命令通过需要加该参数 -f filename 指定执行filename文件中的命令 -r 使用扩展正则表达式，默认为标准正则表达式 -i 直接修改输入文件内容，而不是打印到输出标准设备 sed编译器的执行命令sed 执行格式： [n1][,n2]command [n1][~step]command # 其中一些命令可以在后面加上作用范围，形如： $ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围 $ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串 其中n1,n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令： 命令 说明 s 行内替换 c 整行替换 a 插入到指定行的后面 i 插入到指定行的前面 p 打印指定行，通常与-n参数配合使用 d 删除指定行 sed操作举例打印指定行#打印2-5行 nl passwd | sed -n &apos;2,5p&apos; #打印奇数行 nl passwd | sed -n &apos;1~2p&apos; 注意：nl 可以将输出的文件内容自动的加上行号 行内替换#文本中”shiyanlou“全局替换成’hehe‘，并纸打印替换的那一行，注意这里不能省略最后的”p“命令 sed -n &apos;s/shiyanlou/hehe/gp&apos; passwd 注意： 行内替换可以结合正则表达式使用。 行间替换nl passwd | grep &apos;shiyanlou&apos; #删除第21行 sed -n &apos;21c\www.shiyanlou.com&apos; passwd （这里我们只把要删的行打印出来了，并没有真正的删除，如果要删除的话，请使用-i参数） awk文本处理语言AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。 在大多数linux发行版上面，实际我们使用的是gawk（GNU awk，awk的GNU版本）。 nawk： 在 20 世纪 80 年代中期，对 awk语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得; gawk： 是 GNU Project 的awk解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序，但不断地对其进行了更新，以包含 NAWK 的特性; mawk 也是awk编程语言的一种解释器，mawk遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言，包含了一些没有在AWK 手册中提到的特色，同时 mawk 提供一小部分扩展,另外据说mawk是实现最快的awk。 awk的基础概念awk所有的操作都是基于pattern（模式）—action(动作)对来完成的，如下面的形式： pattern {action} 它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。 awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。 awk命令基本格式awk [-F fs] [-v var=value] [-f prog-file] | &apos;program text&apos;] [file...] 其中-F参数用于预先指定前面提高的字段分隔符（还有其他指定字段的方式），-v用户预先为awk程序指定变量，-f参数用户指定awk命令要执行的程序文件，或者在不加’-f’参数的情况下直接间程序语句放在这里。最后为awk需要处理的文本输入，且可以同时输入多个文本文件。 awk操作体验vim test #输入文本 cat test 使用swk将文本打印到终端awk &apos;{ print }&apos; test #或者写成一行 awk &apos;{print}&apos; test 说明:在这个操作中我是省略了pattern，所以awk会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即print打印所有匹配项，这里是全部文本内容 将test的第一行中的每个字段单独显示为一行$ awk &apos;{ &gt; if(NR==1){ &gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3 &gt; } else { &gt; print} &gt; }&apos; test # 或者 $ awk &apos;{ &gt; if(NR==1){ &gt; OFS=&quot;\n&quot; &gt; print $1, $2, $3 &gt; } else { &gt; print} &gt; }&apos; test 说明:你首先应该注意的是，这里我使用了awk语言的分支选择语句if,它的使用和很多高级语言如C/C++语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是NR与OFS，这两个是awk内建的变量，NR表示当前读入的记录数，你可以简单的理解为当前处理的行数，OFS表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为\n换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是$N其中N为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了$3。除此之外另一个这里没有出现的$0，它表示引用当前记录（当前行）的全部内容。 将test的第行以点为分段的字段换成以空格为风格$ awk -F&apos;.&apos; &apos;{ &gt; if(NR==2){ &gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3 &gt; }}&apos; test # 或者 $ awk &apos; &gt; BEGIN{ &gt; FS=&quot;.&quot; &gt; OFS=&quot;\t&quot; # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开 &gt; }{ &gt; if(NR==2){ &gt; print $1, $2, $3 &gt; }}&apos; test 说明：这里的-F参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的\t，print打印的非变量内容都需要用””一对引号包围起来。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用BEGIN，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是FS赋值了新的”.”点号代替默认的” “空格 awk常用的内置变量 变量名 说明 FILENAME 当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串 $0 当前记录的内容 $N N表示字段号，最大值为NF变量的值 FS 字段分隔符，由正则表达式表示，默认为” “空格 RS 输入记录分隔符，默认为”\n”，即一行为一个记录 NF 当前记录字段数 NR 已经读入的记录数 FNR 当前输入文件的记录数，请注意它与NR的区别 OFS 输出字段分隔符，默认为” “空格 ORS 输出记录分隔符，默认为”\n”]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--开始学习（二）]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C%2B%2B%2F</url>
    <content type="text"><![CDATA[C++基本语法介绍 进入C++C++对大小写敏感，比如：将cout替换成Cout或COUT，都无法通过编译。 C++程序包括的元素： 注释： 由前缀//标识 预处理器编译指令#include 函数头： int main() 编译指令：using namespace 函数体：用{}括起 使用C++的cout工具显示消息的语句 结束main()函数的return语句 main()int main() { statements return 0; } 这几行代码构成了函数的定义。定义由两部分组成： 第一行：int main()叫函数头（functon definition），函数头对函数与程序其他部分之间的接口进行了总结； 花括号中包括的部分叫做函数体，函数体指出函数应该做什么计算机指令。 作为接口的函数头C++函数可以被其他函数调用，函数头描述了函数与调用函数之间的接口。 位于函数名的前部分叫做函数的返回类型，他描述的是从函数返回给调用它的函数的信息。 函数名括号中的部分叫做形参列表，或参数列表，它描述的是从调用函数传递给被调用的函数的信息。 注：main()通常不被程序的其他部分调用，而被启动代码调用，启动代码是由编译器添加到程序中的，是程序和操作系统之间的桥梁。 C++中合法的函数头： int main() int main(void) main（）中如果结尾未遇到返回语句，则默认添加语句结尾：retrun 0;，不适应于其他函数。 注释//表示注释，单行注释 /*注释部分*/ 多行注释 预处理器和iostream文件如果程序中使用到C++的输入或输出工具，必须提供如下两行代码： #include &lt;iostream&gt; using namespace std; 注意：以上代码在C++98标准中实现，如果编译器不接受上述两行代码，说明它没有遵守标准C++98。 #include &lt;iostream&gt;指令导致预处理将iostream文件中的内容添加到程序中。iostream中的io指的是输入和输出。C++的输入/输出方案涉及iostream文件中的多个定义。为了使用cout来显示消息，第一个程序需要这些定义。#include编译指令导致iostream文件的内容随源代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将取代程序中的代码行#include &lt;iostream&gt;。源文件并没有被修改，而是源代码文件和iostream组合成的一个复合文件，编译的下一个阶段将使用到该文件。 头文件名iostream这样的文件叫做包含文件（include file）—由于它被包含在其他文件中，也被叫做头文件（header file）—由于他被包含在文件的起始处。 C++包含了C中的头文件，C中的头文件以h为扩展名，比如：math.h，仍可以使用C中math.h头文件。C++中的头文件没有扩展名。注意，C中的有些头文件被转换为C++头文件，文件被重新命名，去掉扩展名h，并在文件名称前面添加前缀c(表明来自C语言)。例如：C++版本的math.h为cmath。 C++旧式风格，头文件以.h结尾，比如：iostream.h 命名空间如果使用iostream，而不是iostream.h，则应使用下面的命名空间编译指令来使iostream中的定义对程序可用： using namespace std; 这被称之为using编译指令。 命名空间支持是C++的一项特性，旨在让编写大型程序以及将多个厂商现有的代码组合起的程序时更容易，它还有助于组织程序。一个潜在的问题，当使用两个以及封装好的产品，而它们同时使用了wanda()函数。这样当使用wanda()函数的时候，编译器不知道指的哪个版本。 命名空间让厂商将其产品封装在一个叫做命令空间的单元中，这样可以用命名空间来指出想使用哪个厂商的产品。Microflop可以将其定义放到一个名为Microflop的命名空间中。这样，其的wanda（）函数的全称为Microflop::wanda();同样，Piscine公司的wanda()版本表示为：Piscine::wanda()。这样，程序就可以使用命名空间来区分不同的版本。 类、变量和函数是C++编译器的标准组建，它们被放置在命名空间std中。仅当头文件没有扩展h时，情况才是如此。 实际中如上三种方式等级： std:cin&gt;&gt; a; std::cout &lt;&lt;&quot;jjj&quot;; std::cout&lt;&lt;std::endl; using std::cout; using std::endl; using std:cin; using namespace std #偷懒写法 使用cout进行C++输出cout &lt;&lt;&quot;come up&quot; &lt;&lt;表示把字符串发送给cout，该符号指出了信息流动的路径。cout是一个预定义的对象，知道如何显示字符串、数字和单个字符等等。 cout对象表示一个流，其属性是在iostream文件中定义的，cout的对象包括一个插入运算符”&lt;&lt;”,它可以将右侧的信息插入到流中。 上面代码，将字符串插入到输出流中，因此，与其说程序显示了一条消息，不如说它将一个字符串插入到了输出流中。 注意：插入运算符&lt;&lt;跟按位左移运算符&lt;&lt;一样，其实这是一个运算符重载的例子。通过重载，同一个符合将有不同的含义。编译器通过上下文来确定运算符的含义。C本身也有一些运算符重载，比如：&amp;符合既有地址运算符，又表示AND运算符；*既表示乘法，又表示指针解除引用。 控制符endlendl表示重起一行，在输出流中插入endl将导致屏幕光标移到下一行。endl同样也在头文件iostream中定义，且位于命名空间std中。 cout&lt;&lt;&quot;The Good, the&quot;; cout&lt;&lt;&quot;Bad,&quot;; 输出结果：The Good, the Bad, 换行符&#39;/n&#39; cout&lt;&lt;endl; 两者区别：enld确保程序继续运行前刷新输出（即将其立即显示在屏幕上）；而使用’\n’不能提供这样的保证。 C++源代码格式化C++中使用’;’表示语句的结尾。因此在C++中，回车的作用就和空格或制表符相同。也就是几条语句可以放在同一行，用空格或制表符隔开。 C++代码风格： 每条语句占一行 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。 函数中的语句都要相对花括号进行缩进 与函数名相关的圆括号周围没有空白 C++语句C++程序是一组函数，而每个函数又是一组语句。C++有好几种语句：声明语句创建变量，复制语句给变量提供一个值。 声明语句和变量int carrots 这条语句提供了两项信息： 需要的内存以及该内存单元的名称，具体，这条语句指出程序需要足够的存储来存储一个整数。 给存储单元指定名称，该声明语句指出，此后程序将使用名称carrots来标识存储在该单元中的值，carrots被称为变量。 声明变量的重要性： python中，在使用新名称时创建变量，而不用显式地进行声明。看上去比较友好，问题是如果变量名写错，将在不知情的情况下创建一个新的变量。如下： castleDark = 34 castleDank = castleDark + MoreGhosts print(castleDark) 由于castleDank拼写错误，因此所作的修改实践上并没有修改castleDark。这种错误很难发现，因为并没有违反python的任何规则。然后，在C++中，违反了使用变量前必须声明它的规则，因此编译器将捕获这种错误。 C中的变量声明通常位于函数的开头，不过C++的变量声明没有这种限制，C++的通常做法是在首次使用变量前声明它，这样不必再程序中查找，以了解变量的类型。 赋值语句赋值语句将赋值给存储单元，例如： carrots = 25; 将整数25赋给变量carrots表示的内存单元。 符号’=’叫做赋值运算符。C++和C有一项不寻常的特性—可以连续使用赋值运算符。例如： int steinway; int baldwin; int yamaha; yamaha = balwin = steinway = 88; 赋值将从右至左进行。首先，将88被赋值给steinway,然后，steinway的值被赋值给baldwin，继续进行。 赋值之前可以修改变量的值，比如： carrots = carrots - 1; cout的新花样cout前面都是用来打印字符串，而它还可以用来打印变量： cout &lt;&lt; carrots; 程序没有打印carrots，而是打印存储在carrots中的值，即25。实际上，这将两个操作合而为一。首先，cout将carrots替换为其当前值25；然后，把值转换为合适的输出字符。打印之前，cout必须将整数形式转化为字符的形式。 字符串’15‘和整数25有天壤之别： 字符串存储的是书写该该数字时使用的字符，即字符2和5。程序在内部存储的是字符2和字符5的编码。要打印字符串，cout只需要打印字符串中的各个字符即可。 整数25被存储为数值，计算机不是单独存储每个数字，而是将25存储为二进制数。 C语言中，使用特殊代码（%s和%d）来指出打印字符串和整数。如果让printf()打印字符串，但又错误的提供了一个整数，由于printf()不够精密，因此根本发现不了错误，而是输出一串乱码。 printf(&quot;%s&quot;, &quot;25&quot;); printf(&quot;%d&quot;, 25); 而C++中cout比较智能，其智能来自C++的面向对象特性。实际中，C++插入运算符（&lt;&lt;）将根据其后的数据类型相应的调整其行为，这是一个运算符重载的例子。 其他C++语句cincin &gt;&gt; carrots; 从这条语句，可知，信息从cin流向carrots。cin使用&gt;&gt;运算符从输入流中抽取字符，运算符右侧提供一个变量，以接受抽取的信息。”&lt;&lt;”和”&gt;&gt;”用来指示信息流的方向。 cin同样是一个智能对象，它可以将通过键盘输入的一系列字符（即输入）转换为接受信息的变量能过接受的形式。 int carrots; cin &gt;&gt; carrots; 上述例子，程序将carrots声明为一个整性变量，因此输入被转换为计算机用来存储整数的数字形式。 cout进行封装cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots&quot; &lt;&lt; endl; 跟如下代码等价： cout &lt;&lt; &quot;Now you have &quot;; cout &lt;&lt; carrots ; cout &lt;&lt; &quot; carrots&quot;; cout &lt;&lt; endl; 也可写成如下形式： cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots&quot; &lt;&lt; endl; 类简介类是用户定义的一种数据类型。类之于对象就像类型之于变量，即类定义描述的是数据格式及其用法，而对象则是根据数据格式创建的实体。比如：类就好比所有著名演员，则对象就是好比某个著名演员，如，蛙人Kermit。扩展这种类比，表示演员的类中包括该类可执行的操作的定义，如念某句台词，表达悲伤，接受奖励。 int carrotss; 上面的代码创建了一个类型为int的变量（carrots）。也就是说，carrots可以存储整型，可以按特定的方式使用—例如，用户加和减。 又如，cout是一个ostream类对象，ostream类定义描述了ostream对象表示的数据以及可以对它执行的操作。如将数字或字符串插入到输出流中。同样，cin是一个istream类，也定义在iostream中。 注意：类描述了一种数据类型的全部属性，包括可使用它执行的操作，对象是根据这些描述创建的实体。 类描述指定了可对类对象执行的所有操作，要对特定对象执行这些允许的操作，需要给该对象发送一条消息。例如：希望cout对象显示一个字符串，应向它发送一条消息，告诉它，“对象，显示这些内容！”。 C++提供了两种发送消息的方式： 使用类方法（本质上就是函数调用）； 重新定义运算符，cin和cout采用的就是这种方式。 cout &lt;&lt; “I am not a crook”; 上面的语句使用重新定义&lt;&lt;运算符将‘显示的消息’发送给cout。消息带有一个参数—即显示的字符串。 函数C++函数分为两类：有返回值和无返回值。 使用有返回值的函数有返回值的函数将生成一个值，而这个值可赋给变量或在其他表达式中使用。例如，C/C++库中的sqrt()函数，它返回平方根，如下： x = sqrt(6.25); 表达式sqrt(6.25)将调用sqrt()函数，表达式sqrt(6.25)被称为函数调用，被调用的函数被称为被调用函数（called function）,包含函数调用的函数叫做调用函数。 int main() { x = sqrt(6.25) } 其中的main()函数叫做调用函数， sqrt()叫做被调用函数。括号中的值6.25是发送给函数(sqrt())的消息，以这种方式发送给函数的值叫做参数。被调用函数返回的值叫做函数的返回值（return value）。 函数原型之于函数就像变量声明之于变量—指出涉及的类型。例如，C++库将sqrt()函数定义成将一个看（可能）带小数部分的数字（6.25）作为参数，并返回一个相同类型的数字。sqrt()的函数原型如下： double sqrt(double);//函数原型 第一个double意味着sqrt()返回一个double值，括号中的double一位sqrt()需要一个double参数。因此该原型对sqrt()的描述和下面代码中使用的函数相同： double x; x = sqrt(6.25); 原型结尾的分号表明它是一条语句，这使得它是一个原型，而不是函数头。如果省略分号，编译器将把这行代码解释为函数头，并要求提供函数体。 在程序中使用sqrt()是，必须通过原型，可以用两种方式提供来实现： 在源代码文件中输入函数原型 包含头文件cmath（老系统math.h），其中定义了原型 第二种方法更好，因为头文件更有可能使原型正确。对于C++库中的每个函数，都在一个或多个头文件中提供了其原型，可以通过手册或在线帮助查看函数描述来确定应使用哪个头文件。 函数原型和函数定义不要混淆，可以看出： 函数原型只描述函数接口，也就是说，它描述的是发送给函数的信息和返回的信息 而函数定义包含了函数的代码，如计算平方根的代码 C/C++将库函数的这两项特性（原型和定义）分开，库文件中包含了函数的编译代码，而头文件中则包含了原型。 # include &lt;iostream&gt; # include &lt;cmath&gt; int main() { using namespace std; double area; cin &gt;&gt; area; //area = 152 ,cin智能地将其转化为152.0（double类型） double side; side = sqrt(area); //double side = sqrt(area)//初始化 cout &lt;&lt; side; return 0; } 使用函数库C++库函数存储在库文件中，编译器编译程序时，它必须在库文件搜索您使用的函数。至于自动搜索哪个库文件，将因编译器而异。如果运行程序时，得到一条消息，指出_sqrt()是一个没有定义的外部函数，则很可能是由于编译器不能自动搜索math库，（编译器倾向于给函数名添加下划线前缀—提示它们对程序具有最后的发言权）。如果在Linux(Gnu编译器)中遇到该问题，可能需要在命令行末尾添加-lm选项： g++ sqrt.cpp -lm Unix系统，同样添加’-lm’选项。 函数变体有些函数需要多项信息，这些函数使用多个参数，参数间使用都号分开。例如，数据函数pow()接受两个参数，返回值为以第一个参数为底，第二参数为指数的幂，该函数的原型如下： double pow(double,double); double answer = pow(5.0, 8.0); 不接受参数的函数,原型如下： int rand(void) 没有返回值的函数，例如，编写一个函数，它按美元、美分格式蔑视数字，当向它传递参数23.5时，它将在屏幕上显示$23.5。原型如下： void bucks(double) 用户自定义函数#include &lt;iostream&gt; void simon(int); //函数原型 int main() { using namespace std; simon(3)//调用函数simon int count; cin &gt;&gt;count; simon(count); count &lt;&lt; &quot;Done!&quot; &lt;&lt; endl; return 0; } void simon(int n)//定义simon函数 { using namespace std; cout &lt;&lt; &quot;Simon says touch your toes &quot; &lt;&lt; n &lt;&lt; &quot; times.&quot; &lt;&lt;endl; } 函数格式： type functionsname(arguementlist) { statements; } C++中定义的函数一般位于main()之后，不允许将函数定义嵌套在另一个函数定义中，每个函数的定义都是独立的，所有创建的函数的时平等的。 函数头： 上述程序的函数头为： void simon(int n) void表明没有返回值，因此调用simon()不会生成可在main()中将其赋给变量的数字。因此函数调用方式如下： simon(3); 括号中的int n表明，使用simon()时，应提供一个int参数。函数调用时，传递的值将被赋值给n。 int main() 开头的int表明，main()返回一个整数值，空括号表明，main()没有参数。对于有返回值的函数，应使用关键字return来提供返回值，并结束函数。入main()函数末尾： return 0; main()函数的返回值返回给操作系统，并不是返回给程序的其他部分。通常的约定，退出值为0则意味着程序运行成功，为非0则意味着存在问题。如果，C++程序无法打开文件，可以将它设计为返回一个非零值。 关键字 关键字是计算机语言中的词汇，比如：int、void、return和double。因为这心关键字有专用，因此不能用作他用。另外main不是关键字，当最好不要将其用作变量名，不然会引发错误。 用户定义的有返回值的函数# include &lt;iostream&gt; int stonetolb(int); //原型声明 int main() { using namespace std; int stone = 4; int pounds = stonebolb(stont); //接受调用函数的返回值 count &lt;&lt; pounds &lt;&lt; endl; return 0; } int stonetolb(int sts) //函数定义 { return 14 * sts; //函数返回值 } 在多函数程序中使用using编译指令将编译指令放在函数外面，所有函数都可以访问命名空间std: #include &lt;iostream&gt; using neamespace std; void simon(int); int main() { sinmon(3); return 0; } void simon(int n) { cout &lt;&lt; n; } 当前通行的理念是，只让需要访问命名空间std的函数访问它是更好的选择。例如只有mian()函数使用cout，因此没必要让函数stonelb()能过访问命名空间std。因此编译指令放在main()函数中。 总之，让程序能够访问命名空间std的方法有多种，下面是其中的四种： 将using namespace std; 放在函数定义之前，让文件中的所有函数都能够使用命名空间std中的所有的元素。 将using namespace std；放在特定的函数定义中，让该函数能够使用命名空间std中的所有元素。 在特定的函数中使用类似using std::cout;这样的编译指令，而不是using namespace std;，让该函数能过使用指代的元素，如cout。 完全不使用编译指令using，而在需要使用命名空间std中的元素是，使用前缀std::,如下所示：std::cout &lt;&lt; &quot;I am using cout&quot; &lt;&lt; std::endl; 总结C++程序有一个或多个被称为函数的模块组成。程序从main()函数开始执行，因此该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值类型和函数期望通过参数传递给它的信息的类型。 C++语句有多种类型，包括如下6种： 声明语句 赋值语句 消息语句：将消息发送给对象，激发某种行动 函数调用：执行函数 函数原型：声明函数的类型、函数接受的参数数量和类型 返回语句：将一个值从被调用函数那里返回到调用函数 类是用户自定义的数据类型规范，详细描述了如何表示信息以及对数据执行的操作。对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。 C++提过了两个用户处理输入和输出的预定义对象（cin和cout），它们是istream和ostream类的实例，这两个类在iostream文件中定义。]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--数据处理（三）]]></title>
    <url>%2F2018%2F08%2F31%2FC%2B%2B%20Primer%20Plus%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[介绍C++变量的命名规则，以及数据类型 3.1 简单变量int a; a = 5; 上述语句告诉程序，它正在存储整数，并使用名称a来表示该整数的值。实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为a,并将5复制到该内存单元中，然后，可以在程序中使用a来访问该内存单元。可以通过&amp;运算符来检索a的内存地址。 变量名C++提倡使用有一定含义的变量名，如果表示差旅费，应将其命名为cost_of_trip或costOfTrip，而不要命名为a或x等。必须遵循几种简单的C++命名规则： 在名称中只能使用字母字符、数字和下划线(_); 名称的第一个字符不能是数字； 区分大小写 不能将C++关键字用作名称 以两个下划线或下划线和大写字母开头的名称被保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给实现，用作全局标识符； C++对于名称的长度无限制，名称中所有的字符都有意义。 最后两点和前几点不同，因为使用_time_stop或_Donut或__time这样的名称不会导致编译器错误，而会导致不确定性。即，不知道结果将是什么，不出现编译错误的原因是，这样的名称不是非法的，但是要保留给现实使用。全局名称指的是名称被声明的位置。 命名方案 在给变量命名时，可能在变量名中加入其他信息，即描述变量类型或内容的前缀，例如，可以将整型变量命名myWeight命名为intMyWeight或nMyWeight,这样，在阅读代码时，一目了然，每个变量的意义和类型。常以这种方式使用的前缀用：str或sz（表示以空字符结束的字符串）、b（表示布尔值）、p (表示指针)、c（表示单个字符）。 整型整型是没有小数部分的数字，比如：98，-86，0。C++提供了好几种整型来存储整数。使用的内存越大，可以表示的整数值范围也越大。另外，有的类型（符号类型）可以表示正值和负值，而有的类型（无符号类型）不能表示负值。术语宽度用户描述存储整数时使用的内存量，使用的内存越多，则越宽。C++的基本整型（按照宽度递增的顺序排序）： char:该类型有一些特殊属性，常用来表示字符，而不是数字 short int long long long 计算机内存由一些叫做位（bit）的单元组成。C++中short、int、long和long long类型都是通过使用不同数目的位来存储值。 在不同的系统中，每种的类型的宽度都不一样，C++提供了一种灵活的标准，确保了最小长度（从C语言借鉴而来），如下： short至少16位 int至少与short一样长 long至少32位，且至少与int一样长 long long至少64位，且至少与long一样长 实际上short是short int的简称，long是long int的简称。 位与字节 计算机内存的基本单元时位（bit）,字节（byte）通常指的是8位的内存单元。从这个意义上说，字节指的就是描述计算机内存量的度量单位，1KB等于1024字节，1MB等于1024KB。 8位的内存块可以设置出256种不同的组合，因为每一位由两种设置（0和1）,所以8位的总组合位：2^8-256。因此8位单元可以表示0-255或-128到127。每增加一位，组合数变加倍。 C++中对字节的定义与此不同，C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说可能取值的数目必须等于或超过字符数目。在美国，基本字符集通过是ASCII和EBCDIC集，它们都可以用8位来容纳，所以在使用这两种字符集的系统中，C++通常包括8位。然而，国际编程可能需要使用更大的字符集，如Uunicode,因此有些实现可能使用16位甚至32位的字符。 C++中检测类型的长度，sizeof运算符返回类型或变量的长度，单位为字节。 比如：sizeof(int),或者 对一个变量利用sizeof，如：sizeof n_short (short n_short;)。 在头文件climits（旧版本limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种显示的符合名称。比如：INT_MAX 为int的最大值，CHAR_BIT为字节的位数。 SHRT_MAX为short的最大值，LLONG_MAX为long long的最大值，LONG_MAX为long的最大值。INT_MIN为int的最小值。这里只给出了部分，详细的可以查看书籍P41。 符号常量–预处理方式 climits文件中包含于下面类似的语句行： #define INT_MAX 32767 在C++编译过程中，首先将源代码传给预处理器。在这里，#define和#include一样，也是一个预处理编译指令。该编译指令告诉预处理器：在程序中查找INT_MAX，并将所有的INT_MAX替换为32767。 初始化初始化将复制和声明合并在一起。如下： int n_int = INT_MAX; 可以将变量初始化为另一个变量，条件是后者是已经定义过，甚至可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中的所有值都已经定义过： int uncles = 5; int aunts = uncles; int chairs = aunts + uncles + 4; 前面的初始化继承自C语言，C++还有另一个C语言没有的初始化语法： int wrens(432); 注意： 如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值将是它被创建之前，相应内存单元保存的值。 在变量声明时对它进行初始化，可避免以后忘记给它赋值的情况发生。 C++11初始化方式另一种初始化方式，这种方式用户数组和结构，但在C++98中，也可以用于单值变量： int hamburgers = {24}; 将大括号初始化器用于单值变量的情形不多，但在C++标准使得这种情形更多了。首先，采用这种方式时，可以使用等号（=）,也可以不使用： int emus{7}; int rheas = {12} 其次，大括号可以为空，即变量被初始化为零： int rocs = {}; int psychis{}; 无符号类型前面介绍的4种整数都有一种不能存储负数值的无符号变体。其优点是可以增大变量能够存储的最大值。例如：如果short表示的范围为-32768到32767，则无符号版本的表示范围为0-65535。当然，仅当数值不会为负时才应该使用无符号类型，如人口、件数等。创建无符号版本的基本整性，只需要使用关键词unsigned来修改： unsigned short change; unsigned long long lang_lang; 注意：unsigned 本身是 unsigned int 的缩写。 对于一个short变量，取short的最大值（32767），对于符号整型，对最大值加一，则该值将变为-32768。对于无符号整型，对最大值加一，则该值将变为：32768。如果将无符号整数0，减一则该值会变成65535。 可以看出，这些整型变量的行为就像里程表，如果超越了限制，其值将为范围另一端的取值。 选择整型类型int被设置为对目标计算机而言最为“自然”的长度。自然长度指的是计算机处理起来效率最高的长度。如果没有其他要求，则应该使用int。 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用32位。即使系统上int为32位，也应该这样。如果存储的值大于20亿，可使用long long。 如果short比int小，则使用short可以节省内存。通常，仅当有大型整型数组时，才有必要使用short。如果节省内存很重要，则应使用short而不是int，即使它们的长度一样。例如，如果将程序从int为16位的系统移植到int为32的系统，则用户存储int数组的内存量将加倍，但short不会受影响。 如果只需要使用一个字节，可使用char。 整型字面量整型字面量（常量）是显式地书写常量，如212或1776。C++能够以三种不同的计数方式来书写整型：基数为10、8和16。如果第一位为1~9，则基数为10（十进制）；如果第一位为0，第二位1~7，则基数为8（八进制）；如果前两位为0X或0x，则基数为16（十六进制）。具体进制问题：转 在默认情况下，cout以十进制格式显示整数，而不管这些整数在程序中如何书写，如： int waits = 0X42; cout &lt;&lt; waits; //输出结果为66 这些表达方式仅仅是为了表达上的方便。例如：如果CGA视频内存段为十六进制B000，则不必在程序中使用之前将它转换为十进制45056，而只需使用0xB000。但是不管把值书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制。 如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。头文件iostream提供了控制符endl,用于指示cout重起一行。同样，它还提供了控制符dec、hex和oct,分别表示用于指示cout以十进制、十六进制和八进制格式显示整数。 using namespace std; int chest = 42; cout &lt;&lt; hex; cout &lt;&lt; chest; //输出2a cout &lt;&lt; oct; cout &lt;&lt; chest; //输出52 诸如cout&lt;&lt;hex;等代码不会显示在屏幕上显示任何内容，而只是修改cout显示整数的方式。因此，控制符，hex实际上是一条消息，告诉cout采取何种行为。 C++如何确定常量的类型程序的声明中将特定的整型变量的类型告诉了C++编译器，但编译器是如何确定常量的类型呢？假设在程序中使用一个常量表示一个数字： cout &lt;&lt; &quot;Year = &quot; &lt;&lt; 2018 &lt;&lt; endl; 程序将1492存储为int、long还是其他类型呢？答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型存储为int。 关于后缀，后缀是放在常量后面的字母，用于表示类型。具体如下： 后缀 类型 l或L long常量 ul unsigned long常量 ll或LL long long常量 LU或UL ungigned long常量 ull或Ull或uLL或ULL unsigned long long 常量 对于长度，C++中不同进制，采用存储整型的规则不同： 进制 存储类型 十进制 使用后面能过存储该数的最小类型来表示： int、long 、long long 八进制和十六进制 使用后面几种类型中能过存储该数的最小类型来表示： int、unsigned int、long、unsigned long、long long 、unsigned long long 十六进制数0x9C40（40000）将被表示为unsigned int，这是因为十六进制常用来表示内存地址，而内存地址没有符号。 char类型：字符和小整数char类型是专门为存储字符而设计的。编程语言通过使用字母的数值编码来存储字符。因此char类型是另一种整型。它足够长，能过表示计算机系统中的所有字符—字母、数字、标点符号等等。实际上，很多系统支持的字符不操作128个，因此用一个字节就可以表示所有的符号。虽然，char最常用来处理字符，但也可以将它用做比short更小的整型。 在美国，最常用的符号集是ASCII字符集。例如，字符A的编码是65，字母M的编码为77。 char ch; cout &lt;&lt; &quot;Enter a chararcter: &quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; &quot;Thank you for the &quot; &lt;&lt; ch &lt;&lt; &quot; character&quot; &lt;&lt; endl; 输入M,结果输出为 Thank you for the M character.程序打印的是M,而不是77。通过查看内存可知，77是存储在变量ch中的值。这种神奇的力量来自cin和cout,而不是char，这些工具完成了转换工作。输入时，cin将键盘输入的M转换为77；输出是cout将77转换为M。 如果将77存储在int变量中，则cout将把它显示为77(也就是说cout显示两个字符7)。C++中书写字符字面量：将字符用单引号括起来。如’M’。（注意：C++对字符用单引号对字符串使用双引号，这两者差别比较大）。cout引入一项新特性–cout.put()函数，该函数显示一个字符。 char ch = &apos;M&apos;; int i = ch; cout &lt;&lt; i; //结果为77 ch = ch + 1; i = ch; cout &lt;&lt; i //结果为78 cout.put(ch); //结果为N 上面程序中，ch存储的实际上是整数，因此可以对其使用整数操作，如加一。 char ch; cin &gt;&gt; ch; //输入5，实际上ch存储的整数53（5的ASCII编码） 上述代码将读取字符“5”.并将其对应的字符编码存储到ch变量中。 int n; cin &gt;&gt; n; //输入5 上述代码获取字符“5”，并将其转换为对应的数字5，并存储到n变量中。 成员函数cout.put()cout.put()成员函数提供了一种显示字符的方法，可以代替&lt;&lt;运算符。cout.put存在的必要性：在c++的Release2.0之前，cout将字符变量显示为字符，而将字符常量（如‘M’和‘N’）显示为数字。问题是，C++早期版本将字符常量存储为int类型。也就是说，‘M’的编码将被存储在一个16或32为单元中。而char变量一般占8位。下面的语句从常量“M”中赋值左边的8位到变ch中： char ch = &apos;M&apos; 遗憾的是，对于cout来说，‘M’和ch看上去有天壤之别，虽然存储的值一样。下面的语句将打印字符M的ASCII码，而不是字符M: cout &lt;&lt; &apos;M&apos;; 但是下面打印字符M: cout.put(&apos;M&apos;); C++Release2.0之后，将字符常量存储位char类型，而不是int,意味着cout现在可以正确处理字符常量。 char字面值在C++中，书写字符常量的方式有多种，对于常规字符（字母，数字和标点符号），最简单的方法是将字符用单引号括起来。这种表示法代表的是字符的数字编码。例如，ASCII系统中的对应情况如下： ‘A’为65，即字符A的ASCII ‘a’为97 ‘0’为48 ‘ ‘为32 ‘!’为33 这种表示法优于数值编码，更加清晰，而不需要知道编码方。如果系统使用的是EBCDIC,则A的编码值不是65，但’A‘表示的仍然是字符A。 转义字符： 有些字符不能之间通过键盘输入到程序中，比如：回车等。C++提供了一种特殊的表示方法–转义字符。例如：\”将双引号作为常规字符，\t表示水平制表符等等。 将转移字符作为字符常量时，应用单引号括起来；将他放在字符串中不要使用单引号。 基于字符八进制和十六进制编码来使用转义字符。例如，Ctrl+Z的ASCII码为26，对应的八进制编码为032，十六进制编码为0X1a。可以使用下面的转义字符来表示该字符： \032或\x1a。 通用字符名通用字符名的用法类似于转义序列。通用字符名可以以\u或\U开头。\u后面是8个十六进制位，\U后面则是16个八进制位。这些位表示的是字符的ISO 10646码点。（ISO 10646是一种正在制定的国际标准，为大量的字符提供了数字编码）。 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Let them eat g\u00E2teau.\n&quot;; return 0; } 输出为：Let them eat gâteau. Unicode提供了一种表示各种字符集的解决方案—为大量字符和符号提供标准数值编码，并根据类型给他们分类。例如：ASCII码为Unicode的子集，因此在这两种系统中，美国的拉丁字母（如A和Z）表示相同。然后，Unicode还包含其他拉丁字符。 Unicode给每个字符制定一个编号–码点。Unicode码点通常类似于：U-222B。其中U表示这是一个Unicode字符，而222B是该字符的十六进制编码。 国际标准组织（ISO）建立了一个工作组，专门开发ISO 10646—这也是对一个多语言文本进行编码的标准。ISO 10646小组和Unicode小组从1991年开始合租，以确保他们的同步。 signed 和 unsigned char与int不同的是，char默认情况下既不是没有符号，也不是有符号。是否有符号由C++决定。 char fodo //可能为有符号，也可能无符号 unsigned char bar //无符号 signed char snark //有符号 如果char作为数值类型，unsigned char类型表示的范围为0~255，而signed char表示的范围为-128~127。如果使用char变量存储200这样大的值，在某些系统上可以，而在另一些系统上可能不可以。但是使用unsigned char可以在任何系统上达到这种目的。如果使用char存储ASCII字符，则有没有字符都没关系。 wchar_twchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和字符属性相同，对底层系统的选择取决于实现，因此在一个系统中，他可能是unsiged short，而在另一个系统中，则可能是int。 cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t类型。iostream头文件的最新版提供了类似的工具—wcin和wcout,可用于处理wchar_t。另外，可以通过加上前缀L来表示宽字符常量和宽字符串。 wchar_t bob = L&apos;P&apos;; wcout &lt;&lt; L&quot;tall&quot; &lt;&lt; bob &lt;&lt; endl; 本书不使用宽字符类型，但应知道这种类型，尤其是在进行国际编程或使用Unicode或ISO 10646时。 C++11新增类型 char16_t和char32_t随着编程人员的日益熟悉Unicode，类型wchar_t显然不再满足需求。事实上，在计算机系统上惊喜字符和字符串编码时，仅使用Unicode码点并不够。具体说，进行字符串编码时，如果由特定长度和符号特征的类型，将很有帮助，而类型wchar_t的长度和符号特征随实现而已。因此，C++11新增了char16_t和char32_t,两者都无符号，前者长为16为，后者长为32为。使用前缀u表示char16_t字符常量和字符串常量，如u’be goog’；使用前缀U表示char32_t常量，如:U’R’。类型char16_t与/u00F6形式的通用字符名匹配，而类型char32_t与/U0000222B形式的通用字符名匹配。 char16_t ch1 = u&apos;q&apos;; char32_t ch2 = U&apos;\U0000222B&apos;; bool类型在计算中，布尔变量的值可以时true或false。 bool is_ready = true; 字面值true和false都可以通过提升转换为int类型，true被转换为1，false被转换为0。任何非零值可以转换为true,而零被转换为false。 bool start = -100; bool end = 0; 3.2 const限定符使用关键字const来修改变量声明和初始化，例如，假设需要一个表示一年中月份数的符号常量： const int Months =12; 这样，便可以在程序中使用Months,而不是12了。常量（如Months）被初始化后，其值就被固定了，编译器将不允许在修改该常量的值。如果这样做，g++将指出程序视图给一个只读变量赋值。const被叫做限定符，因为它限定了声明的含义。 一种常见的做法是将名称的首字母大写，以提醒Months是一个常量。 const比#define好，首先，它能明确指定类型；其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中；最后，const用户更复杂的类型，后面介绍。 建议使用const而不是#define。 3.3 浮点数对于浮点数，计算机将其分为两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。比如：对于数字34.1245和34124.5，它们处理小数点位置不同外，其他都相同。可以把第一个数表示为0.341245(基准值)和100（缩放因子），而将第二个表表示为0.341245(相同基准值)和100（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过是二进制，因此缩放因子是2的幂，不是10的幂。 3.3.1 书写浮点数C++有两种书写浮点数的方式： 第一种使用常用的标准小数点表示法：12.34 第二种E表示法： 3.45E6指的是3.45与1000000相乘的结果；8.33E-4, 7E5，-8.33E4。 E表示法适合表示非常大和非常小的数。E表示法确保数字以浮点数格式存储，即使没有小数点。注意，既可以使用E也可以使用e,指数可以是正数也可使负数。数字中不能有空格，比如:7.2 E6是非法的。 指数为负数意味着除以10的乘方，而不是乘以10的乘方。因此8.33E-4表示$8.33/10^4$,即0.000833。数值前面的符号用于数值，而指数的符号用户缩放。 3.3.2 浮点类型C++三种浮点类型：float、double和long double.这些类型是按照它们可以表示的有效位数和允许的指数最小范围来描述的。有效位数是数字中有意义的位。例如：14179英尺，使用了5个有效位；13000英尺，使用了2个有效位，其他3位为占位符；1.234，使用了4个有效位。 C++对有效位数的要求是，float至少32位；double至少48位，且不少于float；long double至少跟double一样多。通常，float位32位，double为64位，long double为80、96或128位。另外三种类型的指数范围至少是-37至37。 #include &lt;iostream&gt; using namespace std; int main() { cout.setf(ios_base::fixed, ios_base::floatfield); float tub = 10.0 / 3.0; const float million = 1.0e6; double mint = 10.0 / 3.0; cout &lt;&lt; &quot;tub = &quot; &lt;&lt; tub &lt;&lt;endl; cout &lt;&lt; &quot;tubs = &quot; &lt;&lt; tub * million &lt;&lt; endl; cout &lt;&lt; &quot;mint = &quot; &lt;&lt; mint &lt;&lt; endl; cout &lt;&lt; &quot;mints = &quot; &lt;&lt; mint * million &lt;&lt; endl; return 0; } 结果：tub = 3.333333tubs = 3333333.250000mint = 3.333333mints = 3333333.333333 通常cout会删除结尾的零，例如，将3333333.250000显示为 3333333.25。调用cousetf()将覆盖这种行为。tub和mint都被初始化为10.0/3.0=3.333333333333….,由于cout打印6位小数，因此tub和mint都是精确的。但是当程序将每个数乘以一百万后，tub在第7个3之后就不正确的值有了误差。然后，double类型的变量显示了13个3，因此它至少有13位精确。这是由于float的精度限制。 读取包含文件：程序中的所有文件都存在于计算机中，或位于计算机可以使用的地方。找到使用的包含文件，看看它们包含的内容，很快发现，源文件和头文件都是知识和信息的很好来源。 浮点常量与整型相比，浮点数优点： 可以表示整数之间的值 由于有缩放因子，可以表示的范围大得多 浮点数缺点： 浮点运算的速度通常比整数运算慢 精度将降低 fltadd.cpp程序： #include &lt;iostream&gt; using namespace std; int main() { float a = 2.34e22; float b = a + 1.0; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;a - b = &quot; &lt;&lt; b -a &lt;&lt; endl; return 0; } 结果： a = 2.34e+22a - b = 0 问题在于，2.34e22是一个小数点左边有23位的数字。加上1，就是在第23位加1。但是float类型只能表示数字中的前6或前7位，因此修改第23位对这个值不会有影响。 3.4 C++算术运算符C++中常用的运算符： +运算对操作数执行加法 -运算 *运算 /运算 %运算符求模，生成第一个数除以第二个数后的余数。例如19%6=1。如果其中一个是负数，则结果的符号满足如下规则：（a/b）*b+a%b = a,%的操作数必须是整数。 arith.cpp #include &lt;iostream&gt; using namespace std; int main() { float a = 10.23; float b = 11.22; cout.setf(ios_base::fixed, ios_base::floatfield); cout &lt;&lt; &quot;a = &quot;&lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a + b &lt;&lt; endl; return 0; } 结果：a = 10.230000a + b = 21.450001 这是由于float保证6位有效位。 3.4.1 运算符优先级和结合性先乘除，后加减 *、/和%的优先级相同 float logs = 120 / 4* 5; 对于上式，运算符/和$$的优先级相同，因此优先级本身不能指出程序究竟是先计算120除以4，还是先计算45。两种结果截然不同。 当两个运算符优先级相同时，C++将看操作数的结合性是从左到右还是从右到左。从左到右意味着如果两个优先级相同的运算符被同时用于一个操作数，则首先应用左侧的运算符。查表得，乘除是从左到右结合得，所以上述式子应先计算120/4，得到结果30再除以5。 3.4.2 除法分支除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是整数，则C++将执行整数除法，这意味着小数部分将被丢弃，使得最后的结果是一个整数。如果其中有一个（或两个）操作数是浮点数，则小数部分保留，结果为浮点数。 除法运算符表示了3种不同的运算：int除法、float除法、double除法。C++根据上下文来确定运算符的含义，使用相同的符号进行多种操作叫做运算符重载。 3.4.3 求模运算符求模运算符返回整数除法的余数，它与整数除法先结合，尤其适用于解决要求将一个量分成不同的整数单元的问题，例如：英寸转换为英尺和英寸。 将181镑，转换为英石和镑。一英石等于14磅. #include &lt;iostream&gt; using namespace std; int main() { const int lbs_per_stn = 14; int lbs = 181; int stone = lbs / lbs_per_stn; int pounds = lbs % lbs_per_stn; cout &lt;&lt; lbs &lt;&lt; &quot; pounds are &quot; &lt;&lt; stone &lt;&lt; &quot; stone, &quot; &lt;&lt; pounds &lt;&lt; &quot; pound(s).&quot;&lt;&lt; endl; return 0; } 结果：181 pounds are 12 stone, 13 pound(s). 3.4.4 类型转换C++自动执行类型转换： 将一个算术类型的值赋给另一种算术类型的变量 表达式种包含不同类型 将参数传递给函数 初始化和赋值进行的转换C++允许将一种类型的值赋给另一种类型的变量。值将被转换为接受变量的类型。假设so_long的类型为long,thirty的类型为short,而程序中有： so_long = short 则进行赋值时，程序将thirty的值（short通常为16位）扩展为long值（通常32位）。扩展后将得到一个新值，这个值存储再so_long中，而thirty的内容不变。 将一个值赋给取值范围更大的类型通常不会导致问题。例如，将short值赋给long变量并不会改变值，只是占位符的字节更多而已。 然而，建一个很大的long（如2111222333）值赋给float的变量将降低精度。因为float只有6位有效数字，因此这个值将被四舍五入为2.11122E9。因此，有些转换是不安全的。 潜在的数值转换问题： 将较大的整数转换为较小的整型，如将long转换为short,原来的值可能超出目标类型的取值范围，通常只复制右边的字节； 将浮点数转换为整型，小数部分丢失（不是四舍五入）,原来的值可能超出目标类型的取值范围，在这种情况下，结果可能不确定； 将较大的浮点类型转换位较小的浮点类型，如将double转换为float,精度（有效位位数）降低，,原来的值可能超出目标类型的取值范围，在这种情况下，结果可能不确定； 将0赋值给bool变量，将被转换为false；而非零将被转换为true。 以{}方式初始化时进行的转化（C++11）C++将使用大括号的初始化称为列表初始化，因为这种初始化常用于给复杂的数据类型提供值列表。对类型的转化要求更严格。具体，列表初始化不允许缩窄，即变量的类型可能无法表示赋给它的值。例如，不允许浮点数转换为整型。在不同的整型之间转换或将整型转换为浮点型可能被允许。例如：可见long变量初始化为int类型的值，因为long总是至少与int一样长；相反转换也可能被允许，只要int变量能够存储给它的long常量。 表达式中的转换在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false被转换为0，这些转换称为整型提升。 整型提升还包括：如果short比int短，则unsigned short类型转换为int；如果两种类型的长度相同，则unsigned short类型转换为unsigned int。这种规则保证对unsigned short提升时不会损失数据。 将不同类型进行算术运算时，也会进行一些转换。比如将int和float相加。当运算涉及两种类型时，较小的类型被转换为较大的类型。编译器通过校验表来确定算术表达式中执行的转换，校验表如下： 如果有一个操作数的类型为long double,则将另一个操作数转换为long double; 否则，如果有一个操作数的类型为double,则将另一个操作数转换为double; 否则，如果有一个操作数的类型为float,则将另一个操作数转换为float; 否则，说明操作数都是整型，因此执行整型提升； 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为高级别的类型； 如果一个操作数有符号，另一个操作数无符号，且无符号操作数的级别比有符号操作数的级别高，则将有符号操作数转换为无符号的操作数类型； 否则，如果有符号类型可表示无符号类型的所以可能值，则将无符号类型转换为有符号操作数所属的类型； 否则，将两个操作数都转换为无符号版本。 参数传递的转换传递参数时的类型转换通常由C++函数原型控制。 强制类型转换C++允许通过强制转换机制显示地进行类型转换。强制类型转换格式有两种，例如：为将存储在变量thorn中的int值转换为long类型，如下： (long)thorn//来自C long(thorn)//C++新格式：像函数调用一样 强制转换不会改变thorn本身，而是创建一个新的、指定类型的值。 C++还引入了4个强制类型转换符，对他们的使用要求更严格。后面介绍，在这四种运算符中，static_cast&lt;&gt;可用于将一种数值转换为另一个种数值类型，例如将thorn转换为long类型： static_cast&lt;long&gt; (thorn) 推广之，可以这样做： static_cast&lt;typename&gt; (value) typecast.cpp #include &lt;iostream&gt; using namespace std; int main() { int auks, bats, coots; auks = 11.99 + 19.99; //相加赋值给int变量，被截断为31， bats = int(11.99) + int(19.99);//先截断，在相加 coots = (int) 11.99 + (int) 19.99; cout &lt;&lt; &quot;auks = &quot; &lt;&lt; auks &lt;&lt; &quot;, bats = &quot; &lt;&lt; &quot;bats&quot; &lt;&lt; &quot;, coots = &quot; &lt;&lt; coots&lt;&lt; endl; char ch = &apos;Z&apos;; cout &lt;&lt; &quot;The code for &quot; &lt;&lt; ch &lt;&lt; &quot; is &quot; &lt;&lt; int(ch) &lt;&lt; endl; cout &lt;&lt; &quot;Yes, the code is &quot; &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; endl; return 0; } auks = 31, bats = bats, coots = 30The code for Z is 90Yes, the code is 90 3.4.5 C++11中的auto声明C++新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。auto是C语言的关键子，当很少使用。在初始化声明中，如果使用关键字auto，而不指定变量类型，编译器将把变量的类型设置成与初始值相同： auto n = 100; //n是整型 auto x = 1.5 // x is double auto y = 1.3e12L // y is long double 然而，自动推断类型并非为这种简单情况而设计；事实上，如果将其用于这种简单情形，甚至可能让您误入歧途。例如，假设要将x、y、z都指定为double，并编写了如下代码： auto x = 0.0; //浮点型 double y = 0; //浮点型 auto z = 0; //整型 处理复杂类型，如标准模块库（STL）中的类型，自动类型推断的优势才能显现出来。例如，对于下述C++98代码： std:vector&lt;double&gt; scores; std:vector&lt;double&gt;::iterator pv = scores.begin(); C++允许您将其重写为： std::vector&lt;doble&gt; scores; auto pv = scores.begin() 3.5 总结C++的基本类型分为两组: 由存储为整型的值组成 由存储为浮点格式的值组成 整型通过存储值时的内存量及有无符号来区分。整型从最小到最大依次是： bool \ char \ signed char \ unsigned char \ short \ unsigned short \ int \ unsigned int \ long \ unsigned long \ long long \ unsigned long lon 3种浮点类型： float \ double \ long double]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络与信息安全研究方向]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/zhangvalue/article/details/78056559 1、信息安全算法类：包括密码算法、信息隐藏与检测算法、数字水印嵌入与检测算法、数据挖掘与过滤算法、量子密码算法等。 2、信息安全协议类：包括认证协议、密钥交换与管理协议、电子支付协议、多方安全计算协议以及安全协议的安全性分析理论与方法等。 3、信息系统安全类：包括可信计算、安全体系结构、操作系统安全、数据库安全、服务器安全以及信息系统安全评估理论与方法等。 4、网络安全类：包括信息对抗、网络攻防、入侵检测、网络可生存、网络安全管理、移动网络安全、无线网络安全、物联网安全，以及恶意代码检测、防御与应急处置等。 5、信息安全应用类：包括电子政务、电子商务、信息安全基础设施以及新技术应用带来的安全问题及解决方案等。 6、安全测试与仿真类：网络与信息安全仿真，安全测试理论与模型，安全测试技术等。 7、信息安全技术类：等级保护技术、三网融合与安全管理、信息安全应急响应体系、网络监测与监管技术等。 8、新一代网络技术类：网络体系结构、路由/交换技术、协议工程、网络虚拟化、认知网络、IPv4/IPv6过渡技术、NGN/NGI平台应用等。 9、新一代计算技术：网格计算、并行/分布式计算、适/效用计算、服务计算。 10、安全专用芯片：密码算法与协议实现、安全处理器与协处理器设计、芯片攻击与安全防护、安全芯片应用。 11、数字版权管理安全（DIM）:认证/授权访问控制、安全数据传输、可信管理与可信评估、信息内容安全技术、数字水印、数字权限管理。 12、云计算与物联网安全：云计算/物联网安全模型、云计算/物联网安全需求与策略、云计算/物联网用户隐私保护、云计算/物联网基础设施安全防护]]></content>
      <tags>
        <tag>研究方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--预备知识（一）]]></title>
    <url>%2F2018%2F08%2F29%2F%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[介绍C++的一些基本概念，起源，以及如何编译执行。 C++简介C++融合了3种不同的编程方式： C语言代表的过程性语言 C++在C语言的基础上添加的类代表面向对象语言 C++模板支持的泛型编程 c演员编程原理计算机语言要处理两个概念–算法和数据，数据是程序使用和处理的信息，而算法是程序使用的方法。 C语言强调的是编程的算法方面，C语言的设计是自顶向下的，其理念是将大型程序分解成小型、便于管理的任务。程序员可以开发程序党单元(函数)来表示各个任务的模块，根据执行的操作来构思一个程序。C语言具有使用结构化编程的特性，比如：while、if、for等语句。 面向对象编程(OOP)OOP强调的是数据，OOP不想过程性编程那样，试图使问题满足语言的过程性，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。 C++中，类是一种规范，描述了这种新型数据格式，对象是根据这种规范（类）构造的特定数据结构。比如：类可以描述公司管理人员的基本特征（姓名，工资，职位等），而对象则代表特定的管理人员（zxp, 1000000,董事长）。 类规定了可使用哪些数据表示对象，以及可以对这些数据执行哪些操作（方法，即函数）。比如：绘制矩形的计算机绘图程序种，定义的数据包括：矩形的顶点位置，长，宽，颜色等，定义的操作可以包括：移动，改变大小，改变颜色等等。当使用该程序绘图时，需要根据类创建一个对象，该对象保存了描述矩形的所有数据值，因此可以使用类方法来修改矩阵。 OOP程序设计，首先设计类，它们准确的表达了程序需要处理的内容。然后，设计一个使用这些类的对象程序。从低级组织（如：类）到高级组织（如：程序）的处理过程叫做自下而上（bottom-up）的编程。 OOP编程不仅仅可以将数据和方法合并成类，还可以创建可重用的代码，多态可以让运算符和函数创建多个定义等。 泛型编程泛型指的是创建独立类型的代码。C++中的数据表示类型包括：整数，小数，字符，字符串，用户定义等等。如果对不同类型的数据进行排序，通常需要为每种类型创建一个排序函数。泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，将其用户各种实际类型。C++模板提供了这种任务的机制。 泛型编程（generic programming）与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。OOP是一个管理大型项目的工具，而泛型编程提成了执行常见任务（如对数据排序和合并）的工具。 起源（了解）C和C++都起源于贝尔实验室。Bjarne Sroustrup于20世纪80年代开发了C++。 名称C++来自C语言中的递增运算符++,该运算符将变量加1。名称表明C++是C的扩展版本。 程序创建过程 使用文本编辑器编写程序，将其保存为文件，这个文件就是源代码； 编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言—机器语言。包含了翻译后的程序的文件就是程序的目标代码。 将目标代码与其他代码链接起来。例如：C++程序通常使用库，C++库包含一系列计算机例程（被称为函数）的目标代码，这些函数可以执行诸如在屏幕显示信息或计算平方根等任务。链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本。包含该最终产品的文件被称为可执行代码。 创建源代码文件在unix系统上，可以使用vi等编辑器编辑，其中只能实现编译和链接，执行程序，要求在系统命令行输入命令。在windows系统中，可以edlIn、edit或其他编辑器 给源文件命名时，必须使用正确的后缀，将文件表示为C++文件，不仅可以表示该文件是C++源代码，还将这种信息告知编译器。 Unix中，区分大小写，C程序使用：c(小写)，C++程序使用：C(大写)，还可以使用cc、cxx表示C++源代码。 编译和链接Linuxg编译和链接 编译test.cpp文件，生成a.out可执行文件： g++ test.cpp 运行可执行文件： ./a.out linux安装gcc: yum install gcc-c++]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的文本处理]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文介绍tr（注意不是tar），col，join，paste命令。实际上是管道操作命令的延续，所以我们依然将结合管道来熟悉这些命令的使用。 tr命令tr命令可以用来删除一段文本信息中的某些文字，或者将其进行转换。 使用方式： tr [option] ... SET1 [SET2] 常用的选项有： 选项 说明 -d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 -s 去除set1指定的在输入文本中连续并重复的字符 #删除hello world中所有的&apos;o&apos;,&apos;l&apos;,&apos;d&apos; echo &quot;hello world&quot; | tr -d &apos;old&apos; #将&quot;hello&quot;中的ll,去重为一个l echo &quot;hello&quot; | tr -s &apos;l&apos; #将输入文本，全部转换为大写或小写输出 echo &apos;input some text heRe&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; #上面的&apos;[:lower:]&apos;&apos;&apos;[:upper:]&apos;,也可以简单的写作&apos;[a-z]&apos;&apos;[A-Z]&apos;,当然反过来将大写变小写也是可以的 echo &apos;input some text heRE&apos; |tr &apos;[:upper:]&apos;&apos;[:lower:]&apos; col命令col命令可以将Tab换成对等数量的空格键，或反转这个操作 格式： cal [option] 常用的选项： 选项 说明 -x 将Tab转换为空格 -h 将空格转换为Tab（默认选项） #查看/etc/protocols中的不可见字符，可以看到很多^I，这其实就是Tab转义成可见字符的符号 cat -A /etc/protocols #使用col -x将/etc/protocols中的Tab转换为空格，然后再使用cat查看，会发现^I不见了 cat /etc/protocols | col -x | cat -A join命令该命令就是用于将两个文件中包含相同内容的那一行合并在一起。在数据库中也有该命令，作用基本相同。 使用方式： join [option] ... file1 file2 常用的选项： 选项 说明 -t 指定分隔符，默认为空格 -i 忽略大小的差异 -1 指定第一个文件要用哪个字段来对比，默认对比第一个字段 -2 指定第二个文件要用哪个字段来对比，默认对比第一个字段 #创建两个文件 echo &apos;1 hello&apos; &gt; file1 echo &apos;2 hello&apos; &gt; file2 join file1 file2 # 将/etc/passwd与/etc/shadow两个文件合并，指定以&apos;:&apos;作为分隔符 sudo join -t&apos;:&apos; /etc/passwd /etc/shadow # 将/etc/passwd与/etc/group两个文件合并，指定以&apos;:&apos;作为分隔符, 分别比对第4和第3个字段 sudo join -t&apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group paste命令paste命令有join命令类似，不过它是在不对比数据的情况下，简单地将多个文件合并在一起，以Tab隔开。 使用格式：paste [option] file ... 常用的选项： 选项 说明 -d 指定合并的分隔符，默认是Tab -s 不合并到一行，每个文件为一行 echo hello &gt; file1 echo shiyanlou &gt; file2 echo www.shiyanlou.com &gt; file3 paste -d &apos;:&apos; file1 file2 file3 paste -s file1 file2 file3 问题Windows/dos 与 Linux/UNIX 文本文件一些特殊字符不一致 如断行符 Windows 为 CR+LF(\r\n)，Linux/UNIX 为 LF(\n)。使用cat -A 文本 可以看到文本中包含的不可见特殊字符。Linux 的\n表现出来就是一个$，而 Windows/dos的表现为^M$，可以直接使用dos2unix和unix2dos工具在两种格式之间进行转换，使用file命令可以查看文件的具体类型。 不过现在希望你在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。 tr -d &apos;^M&apos; https://blog.csdn.net/fan_hai_ping/article/details/8352087]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行顺序控制与管道]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等，高效率使用 Linux 的技巧。 命令执行顺序控制通常情况下，我们每次只能在终端输入一条命令，按下回车执行，执行完成后，我们再输入第二条命令，然后再按回车执行……,当有时候我们会一次输入多条命令，这个时候的执行过程又是如何的呢？下面我们将为大家详细讲解下命令的执行顺序的控制问题。 顺序执行多条命令当我们需要使用apt-get安装一软件时，然后安装完成后立即运行安装软件，又凑巧你的主机才更换的软件源还没有更新软件表，那么可能有如下一系列操作： sudo apt-get update #等待更新 sudo apt-get install somen-tool #some-tool是指具体的软件包 #等待安装 some-tool 如上操作，可以使用一条命令执行完成，不需要多次输入，简单的顺序执行可以使用;来完成，以上操作可以如下输入进行： sudo apt-get update;sudo apt-get install some-tool;some-tool 有选择的执行命令顺序执行多条命令时，可能前面的命令执行不成功，而后面的命令依赖上一条命令的结果，那么就会造成，花了很长的时间，却得到了一个错误的结果，而且有时候只管还无法判断结果是否正确，那么需要有选择性的执行命令。比如上一条执行成功才继续执行下一条，或者不成功又该做出什么样的选择。 使用which来查看是否安装某个命令，如果找到命令，则执行该命令，否则什么也不做： which cowsy&gt;/dev/null &amp;&amp; cowsay -f head-in ihch~ 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果。同时||表示当上一条命令执行结果不为0($?≠0)时则执行后面的命令。 which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&apos;&quot; ||和&amp;&amp;结合使用： which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; 管道管道是一种通信机制，通常用户进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。 管道又分为匿名管道和具名管道；在实际中使用一些过滤程序是经常会用到的就是匿名管道，在命令行中由|分割符表示。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。 管道例子ls -al /etc 将/etc下的文件全部打印出来，内容太多，屏幕不能完全显示，可以使用滚动条或快捷键来查看，不太友好，不过可以使用管道，一行一行查看： ls -al /etc | less 通过管道将前一个命令ls的输出作为下一个命令less的输入，然后一行一行查看 cut命令：打印每一行的某一个字段打印/etc/passwd文件中以’:’为分隔符的第1个字段和第6个字段分布表示用户名和其目录： cut /etc/passwd -d &apos;:&apos; -f 1,6 打印/etc/passwd文件中指定的内容： # 前五个（包含第五个） $ cut /etc/passwd -c -5 # 前五个之后的（包含第五个） $ cut /etc/passwd -c 5- # 第五个 $ cut /etc/passwd -c 5 # 2到5之间的（包含第五个） $ cut /etc/passwd -c 2-5 grep: 在文本中或stdin中查找匹配字符串grep命令非常强大，相当常用的一个命令，结合正则表达式可以实现非常复杂却很高效的匹配和查找。 grep命令的一般格式： grep 【命令选项】 ... 用户匹配的表达式 [文件]... 例子：查找/home/shiyanlou目录下的包行“shiyanlou”文本的文件 grep -rnI &quot;shiyanlou&quot; -r参数表示递归搜索子目录中的文件，-n表示打印匹配先行号,’-I’表示忽略二进制文件。 使用正则表达式的例子： export | grep &quot;.*yanlou$&quot; 其中$就表示一行的末尾,*匹配前面的子表达式任意次,.匹配除“\n”和”\r”之外的任何单个字符 wc命令：计数工具wc命令用户统计并输出一个文件中行、单词和字节的数目，比如输出/etcpasswd文件中的统计信息： wc /etc/passwd 输出行数、单词数、字节数： 分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数： # 行数 $ wc -l /etc/passwd # 单词数 $ wc -w /etc/passwd # 字节数 $ wc -c /etc/passwd # 字符数 $ wc -m /etc/passwd # 最长行字节数 $ wc -L /etc/passwd 注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的 结合管道来操作，统计/etc下面所有目录数： ls -dl /etc/*/ | wc -l sort排序命令该命令功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。 默认为字典排序： cat /etc/passwd | sort 反转排序： cat /etc/passwd | sort -r 按特定字段排序： cat /etc/passwd | sort -t&apos;:&apos; -k 3 上面的-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数： cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n uniq去重复命令uniq命令可以用于过滤或者输出重复行。 过滤行 使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令： history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq 然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序： history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq # 或者 history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u 这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。 输出重复行 # 输出重复过的行（重复的只输出一个）及重复次数 $ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc # 输出所有重复的行 $ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux不同版本以及程序包安装]]></title>
    <url>%2F2018%2F08%2F28%2FLinux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux版本介绍，以及程序包安装命令介绍 Linux系统版本 RedHat(红帽)系列： Redhat、Centos、Fedora等 Debian(得比恩)系列： Debian、Ubuantu等 程序包安装RedHat系列 常见的安装包格式rpm包，安装rpm包的命令是”rpm -参数” 包管理工具yum 支持tar包 Debian系列 常见的安装包格式deb包，安装deb包的命令是”dpkg -参数” 包管理工具apt-get 支持tar包 tar 只是一种压缩文件格式，所以，它只是把文件压缩打包而已。 rpm 相当于windows中的安装文件，它会自动处理软件包之间的依赖关系。优缺点来说，rpm一般都是预先编译好的文件，它可能已经绑定到某种CPU或者发行版上面了。 yum安装命令YUM（Yellow dog Updater, Modified ）是Yellow Dog Linux开发的。 Yellow Dog Linux原本是一套完全源于Red Hat但运作于先前使用IBM PPC平台的MAC机器，原本以为这个版本已经消失，没想到最新消息是他们推出了在Sony PS3上面运作的版本。 CentOS及Fedora的基本预设安装中即将YUM列入其内。 使用方法： 编辑/etc/yum.conf档案详细设定请参考： 简易APT/YUM伺服器设定 基本指令： （如果yum在工作过程中需要使用者回应，可加上-y参数直接回答yes ） | yum install softwarename1 [softwarename2…..] | 安装套件 || yum update [softwarename 1 softwarename2…] | 更新套件，不指定套件名则更新所有可更新的套件 || yum list | 列出目前在yum server 上面有的套件 || yum info | 类似rpm -qi || yum clean | 移除下载到本机的packages 或headers || yum remove softwarename1 [softwarename2…..] | 移除已经安装的套件 | 注1：Red Hat近年来致力于将一个设定档切割成很多小设定档。 以yum.conf为例，Red Hat将其分割成xxx.repo档放置在/etc/yum.repos.d这个目录下。 并在yum.conf档里增加一行注解： PUT YOUR REPOS HERE OR IN separate files named file.repo in /etc/yum.repos.d。 个人可视喜好决定。 apt安装命令Debian开发，目前也有porting到其他版本，要在Red Hat系的Fedora或CentOS使用也是可以的。 使用方法： 编辑/etc/apt/sources.list ，设定所选用的版本，如stable，testing，unstable及套件来源站台或装置。 档案详细设定请参考： 了解Debian系统的哲学 基本指令： | apt-setup | 设定/etc/apt/souces.list || apt-get update | 软体资料库同步 || apt-get install softwarename1 [softwarename2…..] | 安装软体 || apt-get remove softwarename 1 [softwarename 2…] | 移除软体(保留设定档） || apt-get –purge remove softwarename 1 [softwarename 2…] | 移除软体(不保留设定档） || apt-cache search softwarename | 列出所有sofrwarename的套件 || apt-upgrade [softwarename 1 softwarename2…] | 更新套件，不指定套件名则更新所有可更新的套件 || apt-get clean(autoclean) | 删除系统暂存的deb(autoclean只会将比目前系统旧版的套件删除) || apt-get dist-upgrade | 转换系统的版本（需在/etc/apt/sources.list指定stable，testing或unstable） | 转自：张飞在线]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux任务计划crontab]]></title>
    <url>%2F2018%2F08%2F27%2FLinux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab%2F</url>
    <content type="text"><![CDATA[时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本文将带你很好的利用 Linux 系统的计划工具 crontab 命令常见于 Unix 和类 Unix 的操作系统之中（Linux 就属于类 Unix 操作系统），用于设置周期性被执行的指令。 Crontab简介Crontab命令从输入设备读取指令，并将其存于crontab文件中，以供之后读取和执行。crontab存储的指令在守护进程激活，crond为其守护进程，每一分钟会检查一次是否预定的作业需要执行。 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。 # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed crontab使用运行如下命令，添加一个集合任务： crontab -e 详细的格式可以使用man命令查看： man crontab 给出一个例子来完成一个任务的添加，该任务是每分钟在/home/zxp目录下创建一个以当前年月日时分秒为名字的空文件： */1 * * * * touch /home/zxp/$(date + /%H/%m/%d/%H/%M/%S) 注意 “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。 查看添加的任务： crontab -l 默认cron是自动启动的，可以通过如下命令查看是否启动: ps aux | grep cron pgrep cron 启动crontab: sudo cron -f &amp; 当不再需要这个任务时，可以使用如下命令： crontab -r crontab深入每个用户使用 crontab -e 添加计划任务，都会在 /var/spool/cron[/crontabs] 中添加一个该用户自己的任务文档，这样目的是为了隔离。 如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 /etc/crontab 文件就可以。 cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。 在/etc下，cron相关的文件和目录有： 每个目录的作用： /etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行； /etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行； /etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行； /etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；系统默认执行时间可以根据需求进行修改。 转自：实验楼]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的帮助命令]]></title>
    <url>%2F2018%2F08%2F25%2FLinux%E4%B8%AD%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[转自：实验楼 实验知识点 内建命令与外部命令之分 help , man , info命令的使用以及区别 内建命令与外部命令 内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。 外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。 简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用 type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的。 #得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中xxx is a shell builtin #得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中xxx is /usr/bin/xxx #若是得到alias的结果，说明该指令为命令别名所设定的名称；xxx is an alias for xx –xxx 帮助命令helpzsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令,首先进入bash: bash 尝试如下命令： help ls 这是因为help命令用户显示shell内建命令的简要帮助信息。帮助信息中显示该命令的简要说明以及一些参数的使用和说明。 外部命令帮助查看： ls --help 其实外部命令都具有一个参数--help。 manman命令得到的内容比help命令更详细，而且man命令没有内建和外部命令区分，因为man工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，包括一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。 man ls man ls (章节数) 在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节 章节数 说明 1 Standard commands （标准命令） 2 System calls （系统调用） 3 Library functions （库函数） 4 Special devices （设备说明） 5 File formats （文件格式） 6 Games and toys （游戏和娱乐） 7 Miscellaneous （杂项） 8 Administrative Commands （管理员命令） 9 其他（Linux特定的）， 用来存放内核例行程序的文档。 打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面 info该命令一般bash中自带 info ls 得到的信息是不是比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多 man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的 GNU 工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。 注释：Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell 。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。bash是大多数Linux系统以及Mac OS X默认的shell，它能运行于大多数类Unix风格的操作系统之上。详细见：Linux之bash介绍]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大数据结构]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[算法+数据结构=编程 转自：大数据文摘公众号 数组（列表） 栈 队列 链表 树 图 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表） 字典 元组 数组数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。 每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。 以下是数组的两种类型： 一维数组（如上所示） 多维数组（数组的数组） 数组的基本操作 Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量 面试中关于数组的常见问题 寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值 栈著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。 可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。 下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除： 栈的基本操作 Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它 面试中关于栈的常见问题 使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡 队列与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。 一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。 下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除： 移除先入队的元素、插入新元素 队列的基本操作 Enqueue() —— 在队列尾部插入元素 Dequeue() ——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top() ——返回队列的第一个元素 面试中关于队列的常见问题 使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数 链表链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。 链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。 链表一般用于实现文件系统、哈希表和邻接表。 这是链表内部结构的展示： 链表包括以下类型： 单链表（单向）双向链表（双向） 链表的基本操作： InsertAtEnd 在链表的末尾插入指定元素 InsertAtHead 在链接列表的开头/头部插入指定元素 Delete 从链接列表中删除指定元素 DeleteAtHead 删除链接列表的第一个元素 Search 从链表中返回指定元素 isEmpty 如果链表为空，则返回true 面试中关于链表的常见问题 反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项 图图是一组以网络形式相互连接的节点。节点也称为顶点。 一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。 图的类型 无向图 有向图 在程序语言中，图可以用两种形式表示： 邻接矩阵 邻接表 常见图遍历算法 广度优先搜索 深度优先搜索 面试中关于图的常见问题 实现广度和深度优先搜索 检查图是否为树 计算图的边数 找到两个顶点之间的最短路径 树树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。 树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。 这是一个简单树的示意图，以及树数据结构中使用的基本术语： Root 根节点 Parent 父节点 Child 子节点 Leaf 叶子节点 Sibling 兄弟节点 以下是树形结构的主要类型： N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树 其中，二叉树和二叉搜索树是最常用的树。 面试中关于树结构的常见问题： 求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点 字典树（Trie）字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。 以下是在字典树中存储三个单词“top”，“so”和“their”的例子： 这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。 面试中关于字典树的常见问题 计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ） 哈希表哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。 哈希表通常使用数组实现。 散列数据结构的性能取决于以下三个因素： 哈希函数 哈希表的大小 碰撞处理方法 下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。 面试中关于哈希结构的常见问题： 在数组中查找对称键值对 追踪遍历的完整路径 查找数组是否是另一个数组的子集 检查给定的数组是否不相交 字典元组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2.7和Python3.6安装以及文件解决]]></title>
    <url>%2F2018%2F08%2F22%2Fpython2.7%E5%92%8Cpython3.6%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[在实际中，可以需要同时安装python2.7和python3.6版本，在此过程中可以遇到一些问题，在此将一一陈述。 Python2.7和Python3.6并存在环境变量中添加Python两个版本的值即可，具体如下： 右键我的电脑，按下图操作： 添加值： 在环境变量中添加： C:\Python27 C:\Python27\Scripts C:\Python36 C:\Python36\Scripts 打开CMD,切换Python2.7和Python3.6 py -2 切换至python2.7 py -3 Ctrl+C或 输入exit()退出Python环境 在具体py文件中，使用 #! python2 # coding: utf-8 可以指定解释器版本，这时只需py test.py，无需带-2或-3这种参数 IDLE打开方式可以尝试在搜索栏中输入IDLE，然后双击，如果找不到，尝试如下方法：找到C:\Python27\Lib\idlelib下的idle.bat文件，双击即可打开IDLE Python2.7的IDLE无法打开问题解决打开运行，输入如下代码： %USERPROFILE%\.idlerc 会自动大量如下文件夹： 删除文件夹中的三个文件 pip安装第三方库pip2.7 install numpy #仅为python2.7安装numpy库 pip3.6 install numpy #仅为python3.6安装numpy库 第三方库安装目录：C:\Python27\Lib\site-packages]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题目]]></title>
    <url>%2F2018%2F08%2F22%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[leetcode是个题库，里面有很编程多面试的题目，可以在线编译运行。难度比较高。如果自己能都做出来，对面大公司很有帮助。 两数之和给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路： 利用python实现，先将列表转化为字典dict1，字典的键为列表元素，字典的值为对应元素的下标。 对于每个元素nums[i]，对于给定的target数，检查字典中是否有键（target-nums[i]）,如果存在则说明，该键对应的值和nums[i]的下标为对应的输出结果。注意该键对应的值不能是i! 代码： class Solution: def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict1 = {} l = len(nums) for i in range(0,l): dict1[nums[i]] = i for i in range(0,l): temp = target - nums[i] if (temp in dict1.keys()) and dict1.get(temp) != i: return [i,dict1.get(temp)] 算法分析: 时间复杂度：O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。 两数相加给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 思路： 考虑到两个链表长度不一，短的列表后面补零。 最开始的创建一个链表（ll），并赋值一个另一个值(lp)（后面链表的指针需要移动，不指向起始），并创建一个变量来存储进位的值（temp）。 首先判读两个链表是否都已到达末尾，如果没有，将两个链表的值分别赋值给两个变量（val1和val2）,如果其中一个到达末尾，则val1或val2赋值为0。然后，对两个数进行相加求余数，利用余数创建链表节点(lq)，并接在最先创建的链表(ll)后面，将节点ll先后指向下一个节点，同时计算val1+val2+temp的进位值。如果两个节点都已达到末尾，而此时还需进位值不为零（可以最后两个相加大于9），还需要创建一个节点来存储进位的值，并接在节点ll后面。 代码： # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; ll = ListNode(0) lp = ll temp = 0 while l1 or l2: if l1 == None: val1 = 0 else: val1 = l1.val l1 = l1.next if l2 == None: val2 = 0 else: val2 = l2.val l2 = l2.next lq = ListNode((val1 + val2 + temp) % 10) ll.next = lq ll = ll.next temp = (val1 + val2 + temp) //10 if l1 == None and l2 == None and temp != 0: lq = ListNode(temp) ll.next = lq return lp.next 算法分析： 时间复杂度：O(n)， 我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。 无重复字符的最长子串给定一个字符串，找出不含有重复字符的最长子串的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 无重复字符的最长子串是 “abc”，其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 无重复字符的最长子串是 “b”，其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 无重复字符的最长子串是 “wke”，其长度为 3。 请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。 方法一：暴力法思路 逐个检查所有的子字符串，看它是否不含有重复的字符。 算法 假设我们有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回true，否则会返回false。 我们可以遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为true，那么我们将会更新无重复字符子串的最大长度的答案。 现在让我们填补缺少的部分： 为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为i和j。那么我们有 0≤i&lt;j≤n （这里的结束索引 j 是按惯例排除的）。因此，使用 i 从0到 n−1 以及 jj 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。 要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。 代码： class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; def allUnique(s, start, end): st = set() for i in range(start,end): if s[i] in st: return 0 st.add(s[i]) return 1 l = len(s) ans = 0 for i in range(0, l): for j in range(i+1, l+1): if(allUnique(s,i,j)): ans = max(ans, j-i) return ans 方法二：滑动窗口代码： class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) ans = i = j = 0 st = set() while i &lt; n and j &lt; n: if s[j] in st: st.remove(s[i]) i = i+1 else: st.add(s[j]) j = j + 1 ans = max(ans, j-i) return ans 方法三：优化的滑动窗口代码： class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) ans = i = j = 0 d = {} #将存放 st = set() while j &lt; n: if s[j] in d.keys(): i = max(i, d.get(s[j])) ans = max(ans, j-i+1) d[s[j]] = j + 1 j = j + 1 return ans 两个排序数组的中位数链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/ 二、数组1.三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 方法一：该方案时间复杂度比方案二高 class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() l = len(nums) a = [] dict1 = {} for i in range(0,l): dict1[nums[i]] = i for i in range(0,l): for j in range(i+1,l): temp = -(nums[i] + nums[j]) if temp in dict1.keys() and dict1[temp] &gt; i and dict1[temp] &gt; j: b = [nums[i], nums[j], temp] if b not in a: a.append(b) return a 方法二：该方案时间复杂度为O(n^2) class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() l = len(nums) a = [] for i in range(0,l-2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l += 1 elif s &gt; 0: r -= 1 else: a.append([nums[i], nums[l], nums[r]]) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 return a 2.最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 代码 class Solution: def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; ll = len(nums) nums.sort() result = nums[0] + nums[1] + nums[2] for i in range(ll-2): l, r = i + 1,ll-1 while l &lt; r: sum1 = nums[i] + nums[l] + nums[r] if sum1 == target: return sum1 if abs(sum1 - target) &lt; abs(result - target): result = sum1 if target &lt; sum1: r -= 1 elif target &gt; sum1: l += 1 return result 3.四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 代码 def fourSum(self, nums, target): def findNsum(nums, target, N, result, results): ll = len(nums) if ll &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: return if N == 2: l,r = 0,ll-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 elif s &lt; target: l += 1 else: r -= 1 else: for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) results = [] nums.sort() findNsum(nums, target, 4, [], results) return results 4.删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 双指针法数组完成排序后，我们可以放置两个指针i和j ，其中i是慢指针，而j是快指针。只要nums[i]=nums[j]，我们就增加j 以跳过重复项。 当我们遇到 nums[j] \n eq nums[i]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到nums[i+1]。然后递增i，接着我们将再次重复相同的过程，直到j 到达数组的末尾为止。 代码： class Solution: def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; i = 0 if len(nums) == 0: return 0 for j in range(1, len(nums)): if nums[i] != nums[j]: i += 1 nums[i] = nums[j] return i + 1 5.移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 双指针法当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 代码： class Solution: def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; n = len(nums) i = 0 while i &lt; n: if nums[i] == val: nums[i] = nums[n-1] n -= 1 else: i += 1 return n 6.下一排序实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 字典排序： 对于数字1、2、3……n的排列，不同排列的先后关系是从左到右逐个比较对应的数字的先后来决定的。例如对于5个数字的排列 12354和12345，排列12345在前，排列12354在后。按照这样的规定，5个数字的所有的排列中最前面的是12345，最后面的是 54321。 一遍扫描 代码： class Solution: def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; i = len(nums) - 2 w hile (i &gt;= 0) and nums[i] &gt;= nums[i+1]: i -= 1 if i &gt;= 0: j = len(nums) - 1 while (j &gt;= 0) and nums[j] &lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] k = len(nums) - 1 i = i + 1 while (i &lt; k): nums[i], nums[k] = nums[k], nums[i] i += 1 k -= 1 7.搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 代码 class Solution: def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; k = range(len(nums)) d = dict(zip(nums,k)) if target in d.keys(): return d.get(target) else: return -1 8.插入搜索位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 代码 class Solution: def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if nums[len(nums)-1] &lt; target: return len(nums) for i in range(len(nums)): if nums[i] == target: return i if target &lt; nums[i]: return i 9.组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 代码 class Solution: def combinationSum(self, candidates, target): “”” :type candidates: List[int] :type target: int :rtype: List[List[int]] “”” if(target &lt; 0): return [] if(target == 0): return [[]] return [[candidates[i]] + left for i in range(len(candidates)) for left in self.combinationSum(candidates[i:], target - candidates[i])] 10. 缺失的第一个正数给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 代码 class Solution: def firstMissingPositive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 0: return 1 dict1 = dict(zip(nums, range(len(nums)))) for i in range(1,max(nums)+1): if i in dict1.keys(): continue return i return max(nums)+1 11. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 代码 class Solution: def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; l = len(height) if l == 0: return 0 total = 0 left_max = [0]*l right_max = [0]*l left_max[0] = height[0] for i in range(1, l): left_max[i] = max(height[i], left_max[i-1]) right_max[l-1] = height[l-1] for i in range(l-2, -1, -1): right_max[i] = max(height[i], right_max[i+1]) for i in range(0,l-1): total += min(left_max[i],right_max[i]) - height[i] return total 12. 跳跃游戏Ⅱ给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明: 假设你总是可以到达数组的最后一个位置。 代码 class Solution: def jump(self, nums): &quot;&quot;&quot; Greedy implementation maximizing the length of each jump. :type nums: List[int] :rtype: int &quot;&quot;&quot; current_index = 0 target_index = len(nums) - 1 total_jumps = 0 while current_index &lt; target_index: total_jumps += 1 jump_range = range(current_index, current_index + nums[current_index] + 1) if target_index in jump_range: break next_index = current_index for next_index_candidate in jump_range: candidate_jump_destination = next_index_candidate + nums[next_index_candidate] next_jump_destination = next_index + nums[next_index] if next_jump_destination &lt; candidate_jump_destination : next_index = next_index_candidate current_index = next_index return total_jumps 13. 图像旋转给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 代码 class Solution: def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix)-1 #交换第i行和第n-i行 for i in range(len(matrix)//2): matrix[i][:], matrix[n-i][:] = matrix[n-i][:], matrix[i][:] #将矩阵进行装置 for i in range(len(matrix)): for j in range(i+1, len(matrix)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 14. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 C++实现 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int *dp = new int[n]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; n; i++) { dp[i] = nums[i] + (dp[i-1] &gt; 0 ? dp[i-1] : 0); max = max &gt; dp[i] ? max : dp[i]; } return max; } };]]></content>
      <tags>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2.x和Python3.x的版本区别]]></title>
    <url>%2F2018%2F08%2F22%2Fpython2.x%E5%92%8Cpython3.x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Python 3.0在设计的时候没有考虑向下相容。许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 pyython3.x和python2.x的版本区别 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。 printpython 3.0 中使用print()函数来输出，而不再使用print语句。 print(&quot;zxp&quot;) #python3.0 print &quot;zxp&quot; #python3.0不再支持 在python2.6和python2.7中，三种形式等价： print(&quot;zxp&quot;)# print不能带任何参数 print (&quot;zxp&quot;) #print后有空格 print &quot;zxp&quot; python2.6实际已经支持print()语法： seq = &apos;hello&apos; print(&apos;zxp&apos;,&apos;panda&apos;,seq) Unicodepython2中有ASCII str()类型，unicode()是单独的，不是byte类型。python3中有Unicode(utf-8)字符串，以及一个字节类：byte和bytearrays。 python3.x源码文件默认使用utf-8: &gt;&gt;&gt;中国 = “china” &gt;&gt;&gt;print(中国) china 而在python2.x中是语法错误 python2.x &gt;&gt;&gt; 中国 = &quot;china&quot; SyntaxError: invalid syntax &gt;&gt;&gt; str = &quot;我是霸王&quot; &gt;&gt;&gt; str &apos;\xce\xd2\xca\xc7\xb0\xd4\xcd\xf5&apos; &gt;&gt;&gt; print str 我是霸王 &gt;&gt;&gt; str = u&apos;我是霸王&apos; &gt;&gt;&gt; str u&apos;\u6211\u662f\u9738\u738b&apos; python3.x &gt;&gt;&gt; str = &quot;我是霸王&quot; &gt;&gt;&gt; str &apos;我是霸王&apos; &gt;&gt;&gt; print(str) 我是霸王 除法运算python中除法包括两个运算符，/和// python2.x中的/除法，跟java、c相同，整数相除结果是一个整数，把小数忽略掉。浮点数的除法会保留小数部分，得到一个浮点数结果。 python3.x中/除法对于整数之间相除，结果也会是浮点数 python2.x &gt;&gt;&gt; 3/2 1 python3.x &gt;&gt;&gt; 3/2 1.5 而对于//除法，被称为floor除法(python3.x中的floor)，会对除法的结果自动进行一个floor操作，在python2.x和python3.x中是一致的 &gt;&gt;&gt; 5//3 1 python3.x中floor操作：向下取整，小数不存在 &gt;&gt;&gt; import math &gt;&gt;&gt; math.floor(2.2) 2 python2.x中floor操作：向下取整，小数存在，仍然是浮点数 &gt;&gt;&gt; math.floor(3.2) 3.0 如果需要取整，需要trunc函数 &gt;&gt;&gt; import math &gt;&gt;&gt; math.trunc(5/3) 1 异常在 Python 3 中我们现在使用 as 作为关键词。捕获异常的语法由 except exc, var 改为 except exc as var。 使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。 1在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代，只有继承自BaseException的对象才可以被抛出。 2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩的写法，直接调用构造函数抛出对象即可。 创建迭代对象在Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。这个表现十分像生成器（比如。”惰性求值”）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。 在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。 python2.x中使用xrange()和range() &gt;&gt;&gt; range(1,10,2) [1, 3, 5, 7, 9] &gt;&gt;&gt; xrange(1,10,2) xrange(1, 11, 2) &gt;&gt;&gt; list(xrange(1,10,2)) [1, 3, 5, 7, 9] python3.x中使用range(),内容包含了xrange() &gt;&gt;&gt; xrange(10) Traceback (most recent call last): File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt; xrange(10) NameError: name &apos;xrange&apos; is not defined &gt;&gt;&gt; range(10) range(0, 10) &gt;&gt;&gt; list(range(1,10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] 八进制字面量表示八进制数必须写成0o777，原来的形式0777不能用了；二进制必须写成0b111。 新增了一个bin()函数用于将一个整数转换成二进制字串。 Python 2.6已经支持这两种语法。 在Python 3.x中，表示八进制字面量的方式只有一种，就是0o1000。 &gt;&gt;&gt; 0777 SyntaxError: invalid token &gt;&gt;&gt; 0o777 511 python2.x &gt;&gt;&gt; 0777 511 &gt;&gt;&gt; 0o777 511 不等于运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt; Python 3.x中去掉了&lt;&gt;, 只有!=一种写法，还好，我从来没有使用&lt;&gt;的习惯 数据类型python3.x中不再有long类型，只有一种整性int,当它的行为跟python2.x的long相同 python3.x中，字符串和bytes类型彻底分开了。字符串是以字符为单位进行处理的，bytes类型是以字节为单位处理的。 bytesbytes数据类型在所有的操作和使用甚至内置方法上和字符串数据类型基本一样，也是不可变的序列对象。 bytes对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等。可以通过调用bytes()生成bytes实例，其值形式为 b’xxxxx’，其中 ‘xxxxx’ 为一至多个转义的十六进制字符串（单个 x 的形式为：\x12，其中\x为小写的十六进制转义字符，12为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围0-255），对于同一个字符串如果采用不同的编码方式生成bytes对象，就会形成不同的值. b = b&apos;&apos; # 创建一个空的bytes b = byte() # 创建一个空的bytes b = b&apos;hello&apos; # 直接指定这个hello是bytes类型 b = bytes(&apos;string&apos;,encoding=&apos;编码类型&apos;) #利用内置bytes方法，将字符串转换为指定编码的bytes b = str.encode(&apos;编码类型&apos;) # 利用字符串的encode方法编码成bytes，默认为utf-8类型 bytes.decode(&apos;编码类型&apos;)：将bytes对象解码成字符串，默认使用utf-8进行解码。 对于bytes，我们只要知道在Python3中某些场合下强制使用，以及它和字符串类型之间的互相转换，其它的基本照抄字符串。 简单的省事模式： string = b&#39;xxxxxx&#39;.decode() 直接以默认的utf-8编码解码bytes成string b = string.encode() 直接以默认的utf-8编码string为bytes 转自：http://www.runoob.com/python/python-2x-3x.htmlhttps://www.cnblogs.com/R-bear/p/7744454.html]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制介绍以及相互转换]]></title>
    <url>%2F2018%2F08%2F22%2F%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[进制也就是进位计数制，是人为定义的带进位的计数方法 对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。 进制 十进制 二进制 四进制 七进制 八进制 十六进制 十进制十进制编码几乎就是数值本身。 二进制它由两个数码0，1组成，二进制数运算规律是逢二进一。 二进制乘法和加法基本运算法则： 0+0=0，0+1=1，1+0=1，1+1=10 0×0=0，0×1=0，1×0=0，1×1=1 四进制四进制是以4为基数的进位制，以 0、1、2 和 3 四个数字表示任何实数。 十进制0-12之间的相互转换： 七进制七进制是以7为基数的计数系统。使用数码0-6。 八进制由于二进制数据的基数R较小，所以二进制数据的书写和阅读不方便，为此，在小型机中引入了八进制。八进制的基数R=8=2^3，有数码0、1、2、3、4、5、6、7，并且每个数码正好对应三位二进制数，所以八进制能很好地反映二进制。八进制用下标8或数据后面加O表示 例如：二进制数据 （ 11 101 010 . 010 110 100 ）2 对应八进制数据 (352.264)8或352.264O。 十六进制由于二进制数在使用中位数太长，不容易记忆，所以又提出了十六进制数。 十六进制数有两个基本特点：它由十六个数码：数字0～9加上字母A-F组成（它们分别表示十进制数10～15），十六进制数运算规律是逢十六进一，即基数R=16=2^4，通常在表示时用尾部标志H或下标16以示区别，在c语言中用添加前缀0x以表示十六进制数。 例如：十六进制数4AC8可写成（4AC8）16，或写成4AC8H。 进制转换对于任何一个数，我们可以用不同的进位制来表示。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，也可以用八进制表示为71(8)、用十六进制表示为39(16)，它们所代表的数值都是一样的。 二进制数、十六进制数转换为十进制数（按权求和）二进制数、十六进制数转换为十进制数的规律是相同的。把二进制数（或十六进制数）按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”. 例如：把（1001.01)2 二进制计算。 解：（1001.01）2&lt;/br&gt; =8*1+4*0+2*0+1*1+0*(1/2)+1*(1/4)&lt;/br&gt; =8+0+0+1+0+0.25&lt;/br&gt; =9.25 把（38A.11)16转换为十进制数解：（38A.11)16=3×16的2次方+8×16的1次方+10×16的0次方+1×16的-1次方+1×16的-2次方=768+128+10+0.0625+0.0039=906.0664 十进制数转换为二进制数，十六进制数（除2/16取余法）整数转换.一个十进制整数转换为二进制整数通常采用除二取余法，即用2连续除十进制数，直到商为0，逆序排列余数即可得到――简称除二取余法． 例：将25转换为二进制数解：25÷2=12 余数112÷2=6 余数06÷2=3 余数03÷2=1 余数11÷2=0 余数1所以25=(11001)2 同理，把十进制数转换为十六进制数时，将基数2转换成16就可以了. 例：将25转换为十六进制数解：25÷16=1 余数91÷16=0 余数1所以25=(19)16 二进制数与十六进制数之间的转换由于4位二进制数恰好有16个组合状态，即1位十六进制数与4位二进制数是一一对应的.所以，十六进制数与二进制数的转换是十分简单的. (1）十六进制数转换成二进制数，只要将每一位十六进制数用对应的4位二进制数替代即可――简称位分四位.例：将（4AF8B)16转换为二进制数.解： 4 A F 8 B0100 1010 1111 1000 1011所以（4AF8B)16=(1001010111110001011)2 (2）二进制数转换为十六进制数，分别向左，向右每四位一组，依次写出每组4位二进制数所对应的十六进制数――简称四位合一位.例：将二进制数（000111010110)2转换为十六进制数.解： 0001 1101 01101 D 6所以（111010110)2=（1D6）16转换时注意最后一组不足4位时必须加0补齐4位 数制转换的一般化1）R进制转换成十进制 任意R进制数据按权展开、相加即可得十进制数据。例如：N = 1101.0101B = 1*2^3+1*2^2+0*2^1+1*2^0+0*2^-1+1*2^-2+0*2^-3+1*2^-4 = 8+4+0+1+0+0.25+0+0.0625 = 13.3125&lt;/br&gt; N = 5A.8H = 5*16^1+A*16^0+8*16^-1 = 80+10+0.5 = 90.5 2）十进制转换R 进制 十进制数转换成R 进制数，须将整数部分和小数部分分别转换. 1.整数转换———除R 取余法 规则：（1）用R 去除给出的十进制数的整数部分，取其余数作为转换后的R 进制数据的整数部分最低位数字； （2）再用R去除所得的商，取其余数作为转换后的R 进制数据的高一位数字； （3）重复执行（2）操作，一直到商为0结束。 2．小数转换—————乘R 取整法 规则：（1）用R 去乘给出的十进制数的小数部分，取乘积的整数部分作为转换后R 进制小数点后第一位数字； （2）再用R 去乘上一步乘积的小数部分，然后取新乘积的整数部分作为转换后R 进制小数的低一位数字； （3）重复（2）操作，一直到乘积为0，或已得到要求精度数位为止。 3.小数转换——整数退位法：举例：0.321d转成二进制，由于321不是5的倍数，用取余法、取整法可能要算很久，这时候我们可以采用整数退位法。原理如下： n为转成的二进制数的小数位数&lt;/br&gt; (x)10=(y)2&lt;/br&gt; (x)10*2^n=(y)2*2^n&lt;/br&gt; D=(x)10*2^n：计算10进制数，取整&lt;/br&gt; D→T转成2进制数&lt;/br&gt; (y)2=T/2^n=T*2^(-n)，T退位，位数不足前端补零&lt;/br&gt; 举例:&lt;/br&gt; 0.321转成二进制数，保留7位&lt;/br&gt; 0.321*2^7=41.088,取整数41&lt;/br&gt; 41=32+8+1即100000+1000+1=101001&lt;/br&gt; 退位，因只有6位而要求保留7位，所以是0.0101001 提炼至：百度百科]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配的KMP算法]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单模式匹配算法的效率不高，原因在于匹配过程中的回溯。KMP匹配算法的时间复杂度是O(m+n)，优于简单算法，原因在于KMP算法到达失配点，串S不需要回溯，串P也不一定要回溯到第1个字符的位置。 模式匹配：设有两个串S和P,称在串中S中找串P的过程为模式匹配。S为主串，P为字串。 KMP算法的关键是$j$回溯到什么位置，实现KMP算法的关键是求出模式串$P$的每个字符的最大$k$值，$k$是失配时$j$需要向前回溯的最少位置。下一趟比较就可以从$S[i]$和$P[k]$开始。设主串为$S=”s_0s_1{\cdots}s_{n-1}”$，模式串为$P=”p_0p_1{\cdots}p_{m-1}”$，并设在$s_i \neq p_j$处失配。考察P串，如果发现： $$p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\tag{1-1} $$ 是失配点前的串$p_0p_1{\cdots}p_{j-1}$中“最长的相同的前缀子串和后缀子串”，其中，$p_0p_1{\cdots}p_{k-1}$是$p_0p_1{\cdots}p_{j-1}$的前缀子串，$p_{j-k}p_{j-k+1}{\cdots}p_{j-1}$是$p_0p_1{\cdots}p_{j-1}$的后缀子串。那么，由于匹配在$s_i \neq p_j$处失败，所以必有： $$p_{j-k}{\cdots}p_{j-2}p_{j-1} = s_{i-k}{\cdots}p_{i-2}p_{i-1}\tag{1-2} $$ 综合式（1-1）和式（1-2）,可得式（1-3）： $$p_0{\cdots}p_{k-2}p_{k-1} = s_{i-k}{\cdots}s_{i-2}s_{i-1}\tag{1-3} $$ 式（1-3）说明，下一趟匹配过程从$s_i$和$p_k$开始，即将模式串中$k$位置的字符和主串中$i$位置的字符对齐后开始下一趟比较。 1.失败函数f设长度为$m$的模式串$P=“p_0p_1{\cdots}p_{m-1}”$，$k$为相同的前、后缀子串长，失败函数定义为： $$f(j) =\begin{cases}-1 &amp; j=0\ |\max \left (k | 0&lt;k&lt;j 且 p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\right )\ |0 &amp; other\\end{cases}\tag{1-4}$$ 从式（1-4）可以看出，失败函数$f(j)$被定义为相同的前、后缀子串长的最大值，其含义为：当匹配在$s_i \neq p_j$处失败，$j$应该回溯的的位置$f(j)$。$f(j) \geq or \ge 0$表示下趟匹配过程从$s_i$和$p_{f(j)}$开始；$f(j)=-1$表示从下趟匹配过程从$s_{i+1}$和$p_0$开始。 j 0 1 2 3 4 5 6 7 8 9 10 P a b c a b c a b b a c $f(j)$ -1 0 0 0 1 2 3 4 5 0 1 $f(j)$的取决于模式串$P$自身的特性。一种特殊的情况，$P$中没有相同的字符出现，或头尾相同，其余不同，则除了$f(0)=-1$外，其他得$f(j)$均为0。也就是说，当到达失配点，$P$均回到第1个字符a_0开始下一趟匹配。 2. KMP算法的C++程序设串P的f值已求得 int FindKMP(int i, String &amp;P) { if (i&lt;0 || i&gt;n-1){ cout &lt;&lt; &quot;Out of bounds!&quot; &lt;&lt;endl; return -1; } int j=0, m=P.n; while(i&lt;n &amp;&amp; j&lt;m) { if( j==-1 || str[i] == P.str[j]) { i++; j++; } else j=P.f[j]; return ( (j==m)?i-m:-1) } }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现：8种排序算法]]></title>
    <url>%2F2018%2F08%2F22%2FPython%E5%AE%9E%E7%8E%B08%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍8中排序算法，包括算法的基本思路和算法的python实现。 选择排序-简单选择排序 选择排序-堆排序 插入排序-直接插入排序 插入排序-希尔排序 交换排序-快速排序 交换排序-冒泡排序 归并排序 桶排序/基数排序 经典文章：好文 选择排序简单选择排序每一趟从待排序的数据元素中选出最小（最大）的元素，顺序放在待排序的数列最前，直到全部待排序的数据元素全部排完。 例子：[4, 2, 3] 找出最小的：2,与第一个元素交换[2, 4, 3] 找出最小的：3，与第二个元素交换[2, 3, 4] 百度百科： 简单选择排序 算法实现 def j_sort(a): l = len(a) temp = 0 for j in range(0,l-1): count = j #记录最小元素下标 #每次找出最小元素 for i in range(j,l-1): if a[count] &gt; a[i+1]: count = i+1 #交换最小元素和待排序元素中最前一个 &apos;&apos;&apos;if count != j: temp = a[j] a[j] = a[count] a[count] = temp &apos;&apos;&apos; a[j], a[count] = a[count], a[j] #实现跟上述代码一样 for i in range(0,l): print(a[i]) if __name__ == &quot;__main__&quot;: a = [10, 2, 5, 1, 3, 7, 3] j_sort(a) 堆排序堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。 堆堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图： 转自：https://www.cnblogs.com/chengxiao/p/6129630.html 百度百科： 堆排序 算法实现 def d_sort(arr): l = len(arr) for i in range(int(l/2-1), -1, -1): adjustHead(arr,i,l) # 交换堆顶和最后一个元素，并调整堆结构 for j in range(l-1, 0, -1): arr[0], arr[j] = arr[j], arr[0] #将堆顶元素和末尾元素进行交换 adjustHead(arr, 0, j) #重新对对进行调整 for k in range(0,l): print(arr[k]) #构造大顶堆 def adjustHead(a, i, l): temp = a[i] #取出当前元素 k = 2*i + 1 #从左子节点开始，即2*i+1 while k &lt; l: if k+1 &lt; l &amp; a[k] &lt; a[k+1]: #若果左子节点小于右子节点，k指向右子节点 k=k+1 if a[k] &gt; temp: #如果子节点大于父节点，将子节点赋值给父节点，并将子节点下标记录下来，后面将父节点值赋值给该子节点 a[i] = a[k] i = k else: break k = 2*k + 1 #把该节点当作父节点，继续操作 a[i] = temp #将父节点值赋值给该子节点 if __name__ == &quot;__main__&quot;: a = [10,2,4,5] d_sort(a) 插入排序插入排序思想：每一趟将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素的适当位置上，直到所有待排序元素元素全部插入为止 直接插入排序直接插入排序是假定前i个构成的子序列是处于已排序的情况下进行排序的，然后将第i个元素与前i个构成的子序列逆序进行比较，如果是要升序排序，则比较第i个元素是否比j=i-1(i-1需要&gt;=0)的元素大，如果是则第i个元素的位置（即j+1的位置上）保持不动，反之则将j=i-1的元素放置到i的位置，再进行第i个元素与j=i-2(i-2需要&gt;=0)的,依次进行，如果第i个元素刚好比j=i-3大，则将第i个元素插入到j=i-2（即j+1的位置）上！ 百度百科： 直接插入排序 算法实现 def zc_sort(a): l = len(a) j=0 for i in range(1,l): temp = a[i] for j in range(i-1, -1, -1): if temp &lt; a[j]: #如果第i个元素大于前i个元素中的第j个 a[j+1] = a[j] #则第j个元素先后移1位 else: #如果第i个元素小于等于前i个元素中的第j个则结束循环 break a[j+1] = temp #将i个元素赋值给空着的位置 for i in range(0,l): print(a[i]) if __name__ == &quot;__main__&quot;: a = [1, 10, 5, 2, 6, 7, 2] zc_sort(a) 希尔排序转自：https://www.cnblogs.com/chengxiao/p/6104371.html 百度百科： 希尔排序 算法实现 def shell_sort(a): l = int(len(a)/2) #生成增量列表 gap_list = [] while l &gt; 0: gap_list.append(l) l = int(l/2) print(gap_list) for gap in gap_list:#增量gap，并逐步缩小增量 #print(gap) for i in range(gap, len(a)):#从第gap个元素，逐个对其所在组进行直接插入排序操作 j = i while j -gap &gt;= 0 and a[j-gap] &gt; a[j]: swap(a, j, j-gap) #交换两个元素 j = j - gap for i in range(0,len(a)): print(a[i]) def swap(arr, a, b): arr[a] = arr[a] + arr[b] arr[b] = arr[a] - arr[b] arr[a] = arr[a] - arr[b] if __name__== &quot;__main__&quot;: a = [1,0,4,-1,2,7,9,8,10, 3,6,5,18] shell_sort(a) 交换排序快速排序任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0];3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 注意：快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 百度百科： 快速排序 算法实现递归 def quick_sort(arr, low, high): #temp = a[0] i = low j = high if i &gt;= j: return arr temp = arr[i] while i &lt; j: while i &lt; j and arr[j] &gt;= temp: j = j-1 arr[i] = arr[j] while i &lt; j and arr[i] &lt;= temp: i = i + 1 arr[j] = arr[i] arr[i] = temp quick_sort(arr, low, i-1) quick_sort(arr, j+1, high) return arr if __name__ == &quot;__main__&quot;: a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8] quick_sort(a, 0, len(a)-1) print(a) 冒泡排序冒泡排序算法的原理如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 百度百科： 冒泡排序 def bubble_sort(arr): length = len(arr) while length &gt; 0: for i in range(length-1): if arr[i] &gt; a[i+1]: arr[i] = arr[i] + arr[i+1] arr[i+1] = arr[i] - arr[i+1] arr[i] = arr[i] - arr[i+1] length -= 1 if __name__ == &quot;__main__&quot;: a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8] bubble_sort(a) print(a) 归并排序（递归）本文中的快速排序就是一种递归排序先递归，在排序首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。 解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？ 可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。 转自：https://www.cnblogs.com/lulushow/p/6820727.html 百度百科： 归并排序 算法实现 def Merge_Sort(lists): if len(lists) &lt;= 1: return lists num = int(len(lists)/2) left = Merge_Sort(lists[:num]) #将列表从中间分为两部分 right = Merge_Sort(lists[num:]) return Merge(left, right) #合并两个列表 def Merge(left,right): r, l=0, 0 result=[] while l&lt;len(left) and r&lt;len(right): if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return result if __name__ == &quot;__main__&quot;: a = [10, 7, 4, 2, 8, 5, 1, 3] a = Merge_Sort(a) print(a) 基数排序基数排序又称为“桶子法”，从低位开始将待排序的数按照这一位的值放到相应的编号为0~9的桶中。等到低位排完得到一个子序列，再将这个序列按照次低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。 转：https://blog.csdn.net/double_happiness/article/details/72452243 百度百科： 基数排序 算法实现 import math def radix_sort(arr): radix = 10 #基数 k = int(math.ceil(math.log(max(arr),radix)))#k可以表示任意整数 #math.log对arr中最大的数取对数，log(max(arr),10),并对其取整得到最大值的位数 bucket =[[] for i in range(radix)] for i in range(1, k+1): for value in arr: bucket[int(value%(radix**i)/(radix**(i-1)))].append(value) #析取整数第k位数字（从低到高）10**2位10的二次方 del arr[:] for each in bucket: arr.extend(each) #桶合并 bucket = [[]for i in range(radix)] if __name__ == &quot;__main__&quot;: a = [10, 2, 13, 44, 22, 33, 100, 612, 333, 262] radix_sort(a) print(a)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件系统概念]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[文件系统和硬盘分区基本概念介绍文件系统：是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。 硬盘分区：实质上是对硬盘的一种格式化。当我们创建分区时，就已经设置好了硬盘的各项物理参数，指定了硬盘主引导记录(即Master Boot Record，一般简称为MBR)和引导记录备份的存放位置。而对于文件系统以及其他操作系统管理硬盘所需要的信息则是通过之后的高级格式化，即Format命令来实现。 簇：是指可分配的用来保存文件的最小磁盘空间，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。所以,簇越小，保存信息的效率就越高。 主引导记录：（MBR，Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。 硬盘大小： 实际中，给硬盘分区时，按照1G=1024M来设置，但是显示的结果都不是整数。比如：将分区设置为10G,显示的确实9.XXG。原因是：正确计算公式 (N-1)*4+1024*N 式中N为想要的大小，单位为GB。最终计算出来的结果为MB. 例如：想要设置分区为2G,则（2-1）4+10242=2052M设置分区时应该为2052M 分区状态三种：主分区、扩展分区和逻辑分区 主分区：是一个比较单纯的分区，通常位于硬盘的最前面一块区域中，构成逻辑C磁盘。其中的主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区，负责把引导权移交给活动分区的DOS或其他操作系统。此段程序损坏将无法从硬盘引导，但从软驱或光驱引导之后可对硬盘进行读写。 扩展分区：仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区(实际上也就是下一个逻辑磁盘)的起始位置，以此起始位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘。 三者解释：主分区能够激活，通常用来引导系统。扩展分区本身并不能直接用来存放数据，逻辑分区是扩展分区进一步分割出来的区块，通常用来存储数据。如果将逻辑分区比作房间，那么扩展分区就好比客房区(包括若干个房间) 主分区和活动分区：主分区也被称为主磁盘分区，是磁盘分区的一中类型，其主要作用是用来安装操作系统。一个硬盘最多可创建4个主分区。活动分区是基于主分区的，磁盘分区中的任意主分区都可以设置为活动分区。如果电脑上4个主分区都安装了不同的系统，那被标记为活动分区的主分区将用于初始引导，即启动活动分区内安装的系统。 逻辑分区和扩展分区：因为主分区最多可以创建4个，我们需要使用扩展分区打破4的限制。在磁盘上可以创建多个逻辑分区而创建的这些逻辑分区都被称为扩展分区，您可以用主分区和逻辑分区中储存数据，但是不能用扩展分区储存，因为扩展分区是我们对逻辑分区的总称，只是一中称呼。 例子：通常我们会先在硬盘上划分一个主分区，就是我们常说的C分区，用于安装操作系统，然后将其他的空间全部作为扩展分区，并根据需要，将扩展分区分成几个逻辑分区，即D、E等分区。 分区格式windows:FAT16、FAT32、NTFS、exFATLinux: ext2、ext3、Linux swap、VFAT、ext4、 FAT和NNTFS区别FAT32：随着大容量硬盘的出现，从Windows 98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。其实白话说就是FAT格式的分区单个文件夹文件不支持大于4G的文件，NTFS可以支持无限大的，不过相对FAT格式不稳定是真的，xp一般系统是FAT格式的，现在的分区一般都选测NTFS格式的了，文件存储大了 分区表类型GPT分区: GUID磁盘分区表（GUIDPartition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。至少可以划分128个主分区。gtp不在有分区的概念。 MBR分区：只能划分四个分区，最多支持2T的磁盘 两者区别： 内存支持：mbr最多支持2T，而gpt理论上是无限制的。 在MBR硬盘中，分区信息直接存储于主引导记录（MBR）中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。 分区：mbr最多支持四个主分区，gpt没有限制。如果你想跑多系统，mbr最多4个而gpt没有限制。 系统：win7只能用mbr分区（也可以但是很麻烦，不建议），从Win8开始微软建议你使用gpt。 其它：gpt是由uefi启动的，而uefi是后来才提出的概念，兼容性和稳定性不如bios+mbr。 对于总容量大于2TB的硬盘，必须选择GPT分区表，才能识别所有的硬盘容量。MBR分区表由于自身设计的局限性，最大只能支持2TB的地址空间。对于超过2TB的大硬盘，如果使用MBR分区表，将无法识别和使用2TB后的空间。 BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。用于加载电脑最基本的程序代码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。只支持MBR分区。 UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS（基本输入/输出系统），UEFI旨在提高软件互操作性和解决BIOS的局限性。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而达到开机程序化繁为简节省时间的目的。只支持GPT分区。]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>硬盘分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock模拟数据生成接口]]></title>
    <url>%2F2018%2F08%2F17%2FMock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Easy Mock是一个可视化，并且能快速生成模拟数据的服务。 Mock解决的问题开发时，后端还没完成数据输出，前端只好写静态模拟数据。数据太长了，将数据写在js文件里，完成后挨个改url。某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。特殊的格式，例如IP,随机数，图片，地址，需要去收集。 教程官方地址：https://easy-mock.com/login 直接输入账号，密码，如果未注册，会直接注册。进入如下页面，按图操作 文档中给出了基本教程]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Mock数据模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境变量与文件查找]]></title>
    <url>%2F2018%2F08%2F16%2F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[介绍环境变量的作用与用法，及几种搜索文件的方法。学会这些技巧可以高效地使用 Linux 。 环境变量变量要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。 shell创建变量 declare tmp shell变量复制 temp=zxp 输出变量 echo $temp 注意：并不是任何形式的变量名都是可用的，变量名只能是英文字母、数字或者下划线，且不能以数字作为开头 环境变量环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。 通常我们会涉及到的变量类型有三种： 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表： 命 令 说 明 set 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 环境变量永久生效按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。查看每个用户的永久生效的环境变量： cd /home/用户名 ls -a 命令查找路径与顺序Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。 查看PATH环境变量路径： echo $PATH 其中给出的路径存放可执行文件，当在shell中执行命令时，系统就会安装PATH中设定的路径依次到目录中查找，如果找到同名文件，则执行先找到的文件。 创建Shell脚本创建脚本文件，并打开 gedit hello_world.sh 在打开的文本中输入： #！ /bin/bash //该行不是注释，不能少 for((i=0; i&lt;10; i++));do echo &quot;hello world&quot; done exit 0 为文件添加可执行权限 chmod 755 hello_shell.sh 执行脚本 ./hello_shell.sh 创建C语言程序创建并打开一个文件 gidit hello_world.c 在文本中输入 #include &lt;stdio.h&gt; int main(void) { printf(&quot;hello world&quot;); return 0; } 保存后，使用gcc生成可执行文件： gcc -o hello_world hello_world.c gcc生成二进制文件默认具有可执行文件，不需修改 在/当前目录修创建一个目录mybin,并将上述文件移动到其中 mkdir mybin mv hello_shell.sh hello_world mybin/ 并进入mybin目录，运行上述两个程序： cd mybin ./hello_shell.sh ./hello_world 回到上一级目录，再运行程序，则发现提示命令找不到，除非加上命令的完整路径，但比较麻烦，可以进该路径添加到PATH环境变量。 添加自定义路径到“PATH”环境变量PATH=$PATH:/home/shiyanlou/mybin =之前之后不能添加空格，否则会提示变量不存在注意：路径必须是绝对路径 这样在任意目录中，都可以执行上述两个文件，直接输入文件名即可执行。到此，如果退出终端，再打开则会发现失效，可以添加一种自动执行的方式：在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 .zshrc，相应 Bash 的配置文件为.bashrc。它们在 etc 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。 echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc 上述命令中 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 &gt; 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。 变量修改和删除变量的修改有以下几种方式： 变量设置方式 说明 ${变量名#匹配字串} 从头向后开始匹配，删除符合匹配字串的最短数据 ${变量名##匹配字串} 从头向后开始匹配，删除符合匹配字串的最长数据 ${变量名%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最短数据 ${变量名%%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最长数据 ${变量名/旧的字串/新的字串} 将符合旧字串的第一个字串替换为新的字串 ${变量名//旧的字串/新的字串} 将符合旧字串的全部字串替换为新的字串 变量删除unset temp 环境变量立即 生效在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如： source .zshrcc source命令还有一个别名就是 .，注意与表示当前路径的那个点区分开，虽然形式不一样，但作用和使用方式一样，上面的命令如果替换成.的方式就该是: . ./.zshrc 注意第一个点之后必须有个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 搜索文件与搜索相关的命令常用的有 whereis，which，find 和 locate 。 whereis简单快捷whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。 locate快而全通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。 locate 文件名 安装软件包：yum install mlocate which小而精which本身是 Shell 内建的一个命令，通常使用 which来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令： which man find精而细find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。 find / -name 文件名 //w文件名查找 find /etc/ -name interfaces //表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path] [option] [action] 。 与时间相关的命令参数： 参数 说明 -atime 最后访问时间 -ctime 最后修改文件内容的时间 -mtime 最后修改文件属性的时间 下面以 -mtime 参数举例： -mtime n：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件 -mtime +n：列出在 n 天之前（不包含 n 天本身）被修改过的文件 -mtime -n：列出在 n 天之内（包含 n 天本身）被修改过的文件 -newer file：file 为一个已存在的文件，列出比 file 还要新的文件名 find ~ -mtime 0 //查找当天(24小时之内)右改动的文件 find ~ -newer /home/shiyanlou/Code //列出目录下比 Code 文件夹新的文件 以上内容来自:实验楼]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django安装（二）]]></title>
    <url>%2F2018%2F08%2F16%2FDjango%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python之Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现：用位运算符实现加法，不允许使用 “+”]]></title>
    <url>%2F2018%2F08%2F16%2FPython%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20%E2%80%9C%2B%E2%80%9D%2F</url>
    <content type="text"><![CDATA[计算两个整数a、b的和，但是不能使用“+”操作符。即：给定a=1,b=2，返回结果3 位运算基础1、位运算符利用位运算实现加法，即计算机利用二进制进行运算，当然离不开位运算 2、异或运算相同为0，不同为1 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 1 = 1 0 ^ 0 = 0 要实现加法，先考虑1位数的加法，不考虑进位，如下： 1 + 1 = 0 1 + 0 = 1 0 + 1 = 1 0 + 0 = 0可知，上面的表达式可以用位运算符”^”代替，接下来考虑进位 3、与运算都为1,则为1 上面的加法可以表示为： 0 &amp; 0 = 不进位 1 &amp; 0 = 不进位 0 &amp; 1 = 不进位 1 &amp; 1 = 进位 从上推到，可得： 位运算中，用“&lt;&lt;”表示向左移动一位，即“进位”，我么可以用以下表达式实现进位： （x&amp;y&lt;&lt;1 于是可以得到如下两个表达式： x^y //执行加法 （x&amp;y&lt;&lt;1 //进位操作 两位数的加法： 11+01=100 //实际的二进制算法 //推算表达式 11^01=10 11&amp;01&lt;&lt;1 = 10 由于不能使用加法，接着按上述算法计算： 10^10 =00 (10&amp;10)&lt;&lt;1=100 到此，就可以得出结论，总结如下定理： 定理一：设a，b位两个二进制数，则a+b=a^b+(a&amp;b)&lt;&lt;1 证明： a^b是不考虑进位的加法结果，当二进制位同时为1时，才有进位，因此(a&amp;b)&lt;&lt;1 是进位产生的值，称为进位补偿，将两者相加便是完整加法结果。定理二：利用定理一可以实现只用位运算进行加法运算。证明： 利用定理一中的等式不停对自身进行迭代，每迭代一次，进位补仓右边就多一位0，因此最多需要加数二进制位数长度次迭代，进为补偿就变为0，这时运算结束。 4、Python实现#不使用“+”来求两个数的和 def newadd(a, b): ta = a&amp;b tb = a^b while(ta): t_a = tb t_b = ta&lt;&lt;1 ta = t_a &amp; t_b tb = t_a ^ t_b print(&apos;a+b=&apos;, tb) if __name__ == &quot;__main__&quot;: newadd(4,5) &apos;&apos;&apos; 计算过程： a = 100 //4 b = 101 //5 ta = 100 //4 tb = 001 //1 进入循环循环 t_a = 001 t_b = 1000 //8 ta = 0000 //0 tb = 1001 //9 退出循环&apos;&apos;&apos; 转自：http://t.pae.baidu.com/s?s=bai-paallr]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介（一）]]></title>
    <url>%2F2018%2F08%2F16%2FDjango%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django是使用Python开发的开源Web开发框架。使用Django，你能以最小的代价构建和维护高质量的Web应用。 使用Django的原因： Django诞生于新闻网站的环境中，它所提供的特性非常适合开发内容类的网站（例如：博客，交流社区，图片分享站等等……）。因为Django是在快节奏的新闻编辑环境中开发的，它的设计目的是使常见的Web开发任务变得快速而简单。 Django是开源的，不是商业项目或者科研项目，它集中力量解决Web开发中所遇到的一系列问题。因此，Django每天都在现有的基础上进步，以适应不断更迭的开发需求。这样即节省了开发时间，也提高了后期维护的效率。 Django概览在Django建立网站的过程中，我分为3个Python文件（models.py, urls.py, views.py） 和HTML模板文件（template.html）来讲解。 设计模型ModelDjango无需数据库就可以使用，通过对象关系映射器（Object-relational mapping）,仅使用python代码就可以描述数据结构。 from django import models class book(models.Model): name = models.CharField(max_length=100) pud_date = models.DateField() models.py 文件主要用一个Python类来描述数据表。称为模型（model）。运用这个类，你可以通过简单的Python代码来创建、检索、更新、删除数据库中的记录而无需写一条由一条的SQL语句。在这里我们创建了一个book模型，并定义了name和pub_date属性。 设计视图views在模型定义之后，我们便可以在视图中引用模型，通常，根据视图参数检索数据，加载一个模板，并使用检索到的数据呈现模板。 form django.shortcuts import render from .models import Person def book_archive(request, year): book_list = Person.objects.filter(birth_year = year) content = {% raw %}{'year': year, 'book_list': book_list}{% endraw %} return render(request, &apos;books/year_archive.html&apos;, context) views.py文件包含了页面的业务逻辑。 book_archive()函数叫做视图。 这里还用到了year_archive.html模板。 设计链接URLs优雅简洁的Url解析式是衡量高品质网站的重要标准。Django鼓励使用漂亮的URL设计。使用这些优美的URL,只需要建立URL和Python回调函数简单的映射关系。 from django.urls import path from . import views ulrpatterns = [ path(&apos;book/&lt;int:year&gt;&apos;, views.year_archive) ] urls.py指出了什么样的 URL 调用什么视图。 在这个例子中books/xxxxx将会调用 year_archive()这个函数。也就是说，在进入这个链接时，会返回视图函数的结果。 设计模板Django拥有强大的模板功能，使用该模板能设计处强大的web页面 {% raw %} {%block title%}Books for {{year}}{%endblock%} {{%block content}} Articles for {{years}} {% for book in book_list %} {{book.name}} Published{{book.put_date | date: "F j, Y"}} {% endfor %} {% end block %} {% endraw %} year_archive.html是 html 模板。 使用带基本逻辑声明的模板语言，如{% for book in book_list %}，它试图将函数返回的结果显示在网页上。 Django的这种结构我们称之为MTV模式：M代表模型(Model)，T代表模板(Template)，V代表视图(View)。这三个分别代表了三种不同功能的Web应用，各司其职，又彼此合作。 转自：https://www.shiyanlou.com/courses/1127]]></content>
      <categories>
        <category>Python之Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开发工具调试]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[小程序开发过程中，调试是让程序跑起来的关键。第一步：点击调试器 第二步：点击sources 第三步：在目录中找到需要调试的js文件，打开图中文件，注意不是后缀为js的文件，而是js？[sm]的文件 第四步： 在文件中设置断点将鼠标移到文件最左侧，点击即可设置断点 快捷键ctrl+b进入调试第五步：点击红色箭头按钮，继续执行到下一个断点点击蓝色按钮，继续执行&lt;/r.点击黄色按钮，单步调试 第六步：查看变量值方法一： 鼠标放在变量上，即可显示变量值 方法二：在调试器窗口，点开Scope标签，然后再点开相应变量 方法三：使用console.log(options);打印出来，在console窗口可以查看]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git + TortoiseGit安装教程和环境部署]]></title>
    <url>%2F2018%2F08%2F15%2FGit%20%2B%20TortoiseGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对于程序员而言，版本管理是不可缺少的一部分，利用Gitlab或Github对代码进行管理大大提高的效率，本文介绍如何搭建环境。 工作模式： 生成公私钥对，将公钥部署到github上，然后利用保存在本地的私钥去连接github 第一步: 下载Git: https://git-scm.com/downloads 第二步： 下载TortoiseGit: https://tortoisegit.org/download/ 第三步： 安装以上两个软件，如果英语不ok的，可以安装tortoisegit语言包（简体中文语言包） 在安装TortoiseGit后，第一次配置时，选择语言 或者在TortoiseGit的设置进行设置，如下：首先鼠标右键，移到TortoiseGit上，点击Setting,进入如下页面，即可进行设置 第三步： 密钥生成及部署 在电脑搜索栏输入PuTTygen，打开软件 点击Generate 在红色方框内不停移动鼠标，10秒左右，进入如下页面： 点击Save private key,将私钥保存到本地： 点击是，并输入私钥文件名 接着将公钥填到Github或Gitlab中，这里以github为例，gitLab相同： 首页点击右上角的头像，并选择点击setting 然后点击 SSH Keys 接着点击创建一个ssh Key, 并将复制的公钥填入Key一栏中： 第四步： 利用本地的私钥去连接Github，并克隆（clone）代码包到本地 在需要存放代码的目录下，点击右键，并点击 git clone（git 克隆），进入如下页面： 根据图中指示填好，然后点击ok，即可将代码克隆到本地 其中的URL在Github上保存的代码包顶部地址 提交代码第一步： 右键点击 git commit 第二步： 右键点击 TortoiseGit,并点击push（推送）： 点击ok即可]]></content>
      <tags>
        <tag>Git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发前言]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[在这里，将介绍开发小程序的前期准备，和开发框架的了解 第一步 注册微信小程序账号：https://mp.weixin.qq.com/wxopen/waregister?action=step1 第二步 开发环境安装： https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18081317 第三步 小程序开发架构的了解，将是本文的重点 目录结构进入开发工具，可见如下图的目文件： utils中的文件处理全局配置pages下还有文件夹，每个文件夹对应一个页面，每个文件加下的文件管理对应的页面 app.json: 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等 project.config.json: 在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发 者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。 page.json: 可以独立定义每个页面的一些属性，例如顶部颜色、是否允许下拉刷新等等 wxml：相当于web开发中的html文件，用来描叙页面的结构 wxss: 相当于web开发中的css文件,兼容大部分css的特性 Js: 负责用户交互,响应用户的点击、获取用户的位置等等 分层 逻辑层：逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。 开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。视图层：框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示；将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim教程]]></title>
    <url>%2F2018%2F08%2F13%2FVim%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文介绍linux中的编辑器vim操作,以及基本命令操作 Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式： 普通模式(Normal mode) 在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。 Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。 插入模式(Insert mode) 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。 在插入模式中，可以按ESC键回到普通模式。 可视模式(Visual mode)这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。 选择模式(Select mode)这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。 命令行模式(Command line mode)在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 Ex模式(Ex mode)这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。 这其中我们常用到就是普通模式、插入模式和命令 vim 文件名 //如果文件名不存在，会自动创建文件并打开 vim nginx.conf //进入普通模式 a 或 i //进入插入模式 Esc //退出插入模式，进入普通模式 ： //退出普通模式，进入命令行模式 命令行模式下： wq保存退出 游标移动按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右（小写L） j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 从普通模式进入插入模式按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右（小写L） j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 保存文件:w 文件名 //可以将文档另存为其他文件名或存到其它路径下 :w //保存文件 :w test //另存为test文件 退出vim命令行模式下退出vim从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑 以下为其它几种退出方式： 命令 说明 :q! 强制退出，不保存 :q 退出 :wq! 强制保存并退出 :w &lt;文件路径&gt; 另存为 :saveas 文件路径 另存为 :x 保存并退出 :wq 保存并退出 普通模式下退出vim普通模式下输入Shift+zz即可保存退出vim 普通模式下删除vim文本信息进入普通模式，使用下列命令可以进行文本快速删除： 命令 说明 x 删除游标所在的字符 X 删除游标所在前一个字符 Delete 同x dd 删除整行 dw 删除一个单词（不适用中文） d$或D 删除至行尾 d^ 删除至行首 dG 删除到文档结尾处 d1G 删至文档首部 vim重复命令（普通模式下）. 表示重复执行上次命令 //向输入x删除第一个字符，再输入.接着删除一个字符 10x 表示删除10连续个字符 3dd 表示删除3行文本 dw或daw 删除一个单词 dNw 删除N个单词 #游标快速跳转 行间跳转. 命令 说明 nG(n Shift+g) 游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号) gg 游标移动到到第一行 G(Shift+g) 到最后一行 行内跳转 命令 说明 w 到下一个单词的开头 e 到当前单词的结尾 b 到前一个单词的开头 ge 到前一个单词的结尾 0或^ 到行头 $ 到行尾 f&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用) F&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配的位置 t&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用) T&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用) 复制粘贴和剪切复制及粘贴普通模式中使用y复制 普通模式中，yy复制游标所在的整行（3yy表示复制3行） 普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。 普通模式中，y$ 复制至行尾。含光标所在处字符。 普通模式中，yw 复制一个单词。 普通模式中，y2w 复制两个单词。 普通模式中，yG 复制至文本末。 普通模式中，y1G 复制至文本开头。 普通模式中使用 p 粘贴 普通模式中，p(小写)代表粘贴至光标后（下）普通模式中，P(大写)代表粘贴至光标前（上） 剪切及粘贴dd删除命令其实是剪切，每次dd删除文档内容后，使用p来粘贴，这样可以实现—-交换上下行 查找替换字符的替换及撤销操作 命令 说明 r+&lt;待替换字母&gt; 将游标所在字母替换为指定字母 R 连续替换，直到按下Esc cc 替换整行，即删除游标所在行，并进入插入模式 cw 替换一个单词，即删除一个单词，并进入插入模式 C(大写) 替换游标以后至行末 ~ 反转游标所在字母大小写 u{n} 撤销一次或n次操作 U(大写) 撤销当前行的所有修改 Ctrl+r redo，即撤销undo的操作 快速缩进普通模式下操作 &gt;&gt; 整行向右缩进 &lt;&lt; 整行向左回退 普通模式下，对shftwidth值进行设置，可以控制缩进和回退e字符数 :set shiftwidth? //查看当前缩进字符数 :set shiftwidth=10 //设置缩进字符数为10 shiftwidthn可以简写为sw 调整文本位置命令行模式下，操作光标所在的行 :ce //本行内容剧中 :ri //本行内容靠右 :le //本行内容靠左 查找普通模式下，输入 /, 然后输入需要查找的字符串，按回车即可进行查找。 ? 功能与 / 功能相同，只不过 ?向下查找。进入查找之后，在字符串之后输入n和N 可以继续查找，n表示继续查找，N表示方向查找 高级查找普通模式下输入*寻找游标所在处的单词普通模式下输入#同上，但 # 是向前（上）找，*则是向后（下）找普通模式下输入g*同* ，但部分符合该单词即可普通模式下输入g#同# ，但部分符合该单词即可 高级功能多文件编辑vim编辑多个文件vim 1.txt 2.txt 默认进入1.txt文件的编辑界面 命令行模式下输入 :n 编辑 2.txt 文件，可以加 ! 即 :n! 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件 命令行模式下输入 :N 编辑 1.txt 文件，可以加! 即 :N! 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件 进入vim后打开新文件 命令行模式下输入:e 3.txt 打开新文件3.txt 命令行模式下输入:e#回到前一个文件 命令行模式下输入:ls可以列出以前编辑过的文档 命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑 命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目 命令行模式下输入:e! 4.txt，新打开文件4.txt，放弃正在编辑的文件 命令行模式下输入:f 显示正在编辑的文件名 命令行模式下输入:f new.txt，改变正在编辑的文件名字为new.txt 恢复文件如果因为断电等原因造成文档没有保存，可以采用恢复方式，vim -r进入文档后，输入:ewcover 1.txt来恢复 vim -r 1.txt 可视模式可视模式命令简介 在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。 在普通模式下输入 Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取。 在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取。 在可视模式下输入 d 删除选取区域内容在可视模式下输入y复制选取区域内容可视模式命令练习 在普通模式下9G跳转到第9行,输入Shift+v（小写V），进入可视模式进行行选择，选中5行，按下&gt;&gt;缩进，将5行整体缩进一个shiftwidth 在普通模式下输入 Ctrl+v（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后x删除整列 视窗操作vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入 :new 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 Ctrl+w也可以），除了 :new 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗： 注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。 命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt 命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt 普通模式下Ctrl+w s 将当前窗口分割成两个水平的窗口 普通模式下Ctrl+w v 将当前窗口分割成两个垂直的窗口 普通模式下Ctrl+w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q! 普通模式下Ctrl+w o 打开一个视窗并且隐藏之前的所有视窗 普通模式下Ctrl+w j 移至下面视窗 普通模式下Ctrl+w k 移至上面视窗 普通模式下Ctrl+w h 移至左边视窗 普通模式下Ctrl+w l 移至右边视窗 普通模式下Ctrl+w J 将当前视窗移至下面 普通模式下Ctrl+w K 将当前视窗移至上面 普通模式下Ctrl+w H 将当前视窗移至左边 普通模式下Ctrl+w L 将当前视窗移至右边 普通模式下Ctrl+w 减小视窗的高度 普通模式下Ctrl+w + 增加视窗的高度 创建加密文档vim -x nginx.conf 根据提示输入密码，下次打开文件时，需要输入密码 vim执行外部命令在命令行模式中输入!可以执行外部的shell命令 :!ls 用于显示当前目录的内容 :!rm FILENAME用于删除名为 FILENAME 的文件 :w FILENAME可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件 vim中查看帮助 普通模式下按F1打开vim自己预设的帮助文档 命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件 命令行模式下输入:ver 显示版本及参数 功能设定vim的功能设定可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用 获取目前的设定 命令行模式下输入:set或者:se显示所有修改过的配置 命令行模式下输入:set all 显示所有的设定值 命令行模式下输入:set option? 显示option的设定值 命令行模式下输入:set nooption 取消当前设定值set功能的说明 命令行模式下输入:set autoindent(ai) 设置自动缩进 命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开 命令行模式下输入:set background=dark或light，设置背景风格 命令行模式下输入:set backup(bk) 设置自动备份，默认未打开 命令行模式下输入: set cindent(cin) 设置C语言风格缩进-以上内容来自https://www.shiyanlou.com/courses/2，为作者边学习，边摘抄和总计的内容]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机抓包软件：charles安装及教程]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%EF%BC%9Acharles%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[手机app或微信小程序开发过程中，解决数据传输过程中的问题，抓包软件必不可少 0、准备：电脑关闭防火墙、其他代理或者翻墙软件 1、安装最新版地址：charles 本教程使用v4.2.6 安装一路next即可 2、配置第一步： 查看本机IP 方法一：运行-&gt;输入cmd-&gt;在命令行中输入：ipconfig 方法二：在charles中点击Help-&gt;Local IP Adress 第一行为本地IP,后面两行为虚拟IP 第二步： 查看端口 第三步：手机上设置代理 安装证书 复制http://charlesproxy.com/getssl或http://www.charlesproxy.com/ssl.zip 到手机浏览器打开，点击 here 下载，安装，信任； 手机和电脑连接到同一局域网，在wifi中设置代理，ios如下： 电脑端弹出connction from “IP”,点击allow 第四步： 电脑端安装证书 点击help-&gt;SSL Proxying-&gt; install Charles root certificate 一路next即可安装 第五步：设置SSL代理 点击proxying-&gt;ssl proxying settings 点击Add 在host中填入：*通配符在port中填入：443 字段说明 Structure：树状结构显示，将网络请求按访问的域名分类； Sequence：水平结构显示，将网络请求按访问的时间排序 垃圾桶图标 ： 功能是clear，清理掉所有请求显示信息 Filter ： 过滤，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求 Overview ： 查看这次请求的详细内容，例如耗时详细列车了请求开始时间、结束时间，响应开始时间、结束时间，总耗时、DNS耗时、网络延时等。 对于Size也详细列出了请求头大小、响应头大小、压缩比例等内容。 URL：进行网络请求的链接； Status：当前状态，complete表示请求完成； Responce Code：返回码。不同的接口，不同的请求结果，返回码都不同； Protocol：使用的协议； Method：请求方式，如GET请求，POST请求等； Kept Alive：判断当前是否正在链接（活跃）； Content-Type:发送的内容类型，如这里用的是XML文本，以UTF8的方式发送； Client Address：客户端的IP地址； Remote Address：远程服务器的IP； Timing: Request Start Time：请求开始的时间； Request End Time：请求结束的时间； Response Start Time：返回开始的时间； Response End Time : 返回结束的时间； Duration : 总时间； Size: Request Header ：请求的头部大小； Response Header：返回的头部大小； Request : 请求发送的大小； Response：返回数据的大小； Total：所有数据大小； Request Compression : 请求压缩； Response Compression : 返回压缩； Request ： 查看请求内容（底下的Headers，Query String， Cookies，Raw。） Headers：发送请求的头部信息； Query String : 发送参数列表； Cookies： 浏览器缓存； Raw：发送的原生数据，包括了头部和参数； Reponse : 查看响应内容 Headers：是返回的头部信息； Text：返回信息（除去头部）后的文本； Hex：返回信息的16进制表示； XML：我返回的数据是XML。如果你返回的是JSON，这里就会显示JSON； XML Text：如果你返回JSON，这里会显示JSON Text； Raw：返回的所有原生数据，包括头部； Summary: 查看发送数据的一些简要信息（主机，状态码，数据的类型，header和body大下，加载时间，总时间） Chart: Summary中简要信息以图表形式展示 Notes: 其他信息 问题解决问题一You may need to configure your browser or application to trust the Charles Root Certificate由于手机虽然安装了证书，但是未信任 解决方案：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 转自：更多详细内容见此]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>手机抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN资源]]></title>
    <url>%2F2018%2F08%2F13%2FVPN%E8%B5%84%E6%BA%90md%2F</url>
    <content type="text"><![CDATA[VPN资源：赛风和兰灯 赛风：https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct 兰灯：http://pan.bcoderss.com/?dir=lan (包括安卓、windows、mac和linux端资源)]]></content>
      <tags>
        <tag>VPN</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN安装后无法连接到互联网]]></title>
    <url>%2F2018%2F08%2F13%2FVPN%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[VPN安装后无法连接到互联网问题解决方案赛风（psiphon）下载地址https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct 使用vpn时，出现浏览器无法连接到互联网问题解决： 原因是浏览器开启了局域网代理：]]></content>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown教程]]></title>
    <url>%2F2018%2F08%2F12%2FMarkdown%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Markdown安装，升级，以及语法介绍 升级Pro版本邮箱地址：Soar360@live.com 授权秘钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVp bP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vV y4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/ QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnx t1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 作者：hecatonchires链接：https://www.jianshu.com/p/8a1bd4892291來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 来自：https://www.jianshu.com/p/8a1bd4892291 语法标题支持六级标题 # 一级标题 ## 二级标题 ### 三级标题 注意：#之后必须加一个空格，当然有些编辑器不用，但最后还是添加 字体设置&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;内容填写在这里&lt;/font&gt; 效果：内容填写在这里 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考[Github][2]. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如： 12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见[math.stackexchange.com][1]. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 [这儿][3]. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 [这儿][4], 关于 流程图 语法，参考 [这儿][5]. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入 数学公式语法转：https://www.jianshu.com/p/a0aa94ef8ab2 https://blog.csdn.net/yzr1183739890/article/details/64130912:花括号 https://blog.csdn.net/smstong/article/details/44340637#3-csdn-markdown%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%BE%93%E5%85%A5%E6%95%99%E7%A8%8B https://blog.csdn.net/huanhuan_Coder/article/details/79325071 其他语法转自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux介绍]]></title>
    <url>%2F2018%2F08%2F11%2FLinux%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Liunx支持多用户登陆，共享一些主机的资源,但他们也分别有自己的用户空间,用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但是由于 Linux 的 用户管理 和 权限机制，不同用户不可以轻易地查看、修改彼此的文件。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建属于自己的博客]]></title>
    <url>%2F2018%2F08%2F11%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文将介绍利用Hexo搭建博客的教程，包括其中遇到问题的解决方案，包括：添加域名等等内容，本人亲自实践过，希望对您有所帮助，如果遇到其他问题，可联系本人。 准备：Git：https://git-scm.com/downloads Nodejs:https://nodejs.org/en/ Github账号，并创建新仓库 新建仓库如下： 安装Nodejs：一路next即可 安装git安装一路next，重点在配置 首先将安装目录添加进环境变量 然后设置用户名和邮箱 $ git config --global user.name &quot;John Doe&quot; $ git config --global user.email johndoe@example.com 安装hexo在所要存放博客文件的文件夹下右键，点击git bash 输入如下命令： npm install -g hexo-cli 创建hexo文件夹hexo init 安装依赖依赖包npm install 站点配置在博客目录下找到_config.yml,修改如下内容在修改配置文件时，建议使用Notepad++进行编辑，原因是缩进和空格会影响代码能否成功提交 # Site title: 平步青云win subtitle: description: 建站 Linux Python C++ 编程语言 keywords: 建站 Linux Python C++ 编程语言 author: zxp language: zh-Hans timezone: deploy: type: git repository: https://github.com/zxpgo/blog.git# 博客仓库地址 #repository: https://github.com/xxx/xxx.github.io.git 博客仓库地址见本文开头第二张图片内的地址 注意：：之后必须添加一个空格再添加内容 否则会有如下错误： 发布博客hexo new &quot;文章名字&quot; 本地站点生成生成文件hexo g 显示如下信息，表示成功 启动服务hexo s 显示如下信息，表示成功： 到此本地的配置结束 打开浏览器，输入localhost:4000查看 部署Githubhexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。（个人习惯，非必需） hexo g #生成静态文件，每次改动之后都需要执行以下这个命令。 hexo d #这个才是真正的部署命令，这里用的都是简写形式 问题一运行时出错，由于还没有添加sshkey，具体教程如下：打开Git Bash 设置Git的user name和email：（前面以及设置） git config --global user.name &quot;aqiongbei&quot; #改成你的注册Github的用户名 git config --global user.email &quot;aqiongbei@gmail.com&quot; #改成你的注册Github的邮箱 生成SSH密钥：生存密钥： ssh-keygen -t rsa -C &quot;aqiongbei@gmail.com&quot; #改成你注册Github的邮箱 返回提示如下： 然后会提示，不用理，直接按回车，一共三次。在C:\Users\Neckpain.ssh得到 id_rsa 和 id_rsa.pub 文件，说明生成成功 添加密钥到 Github打开 Github，登录自己的账号后点击自己的头像-&gt;settings-&gt;SSH Keys-&gt;Add SSH key将本地 id_rsa.pub 中的内容粘贴到 Key 文本框中，随意输入一个 title，点击 Add Key 即可。 测试Git里面继续输入 ssh -T git@github.com 返回 则说明验证成功。 问题一ERROR Deployer not found: git 解决方案如下： npm install --save hexo-deployer-git 添加域名首先购买域名，博主在阿里云购买，记得实名认证 首先在域名控制台添加记录， 记录一般添加两条，具体如下: 其中的ip通过ping命令获取github服务器ip,其中仓库的URL为： github&apos;用户名&apos;.github.io 具体可见下图： 然后在github的博客代码处添加一个CNMAE文件，不要后缀，或者在本地的source文件（所有提交的文件都放在该目录下）中添加该文件，并提交， 内容为申请的域名 www.zxpblog.cn zxpblog.cn 最后还得在setting中的Custom domain处添加域名，必须加www, 如下 主题修改在本地博客目录下打开git bash git clone https://github.com/iissnan/hexo-theme-next themes/next 在_config.yml中找到theme修改为下载的主题名 重新部署到github即可 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 底部添加访问量统计部分主题自带访问量统计，不用配置打开\themes\主题名字\layout_partials\footer.swig文件,不同具体footer文件的后缀可能不同，在顶部添加如下代码： &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 接着在合适的地方添加需要显示的统计数字代码（同上文件）： &lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; 两种统计方式： 同一用户连续点击n篇文章，记录n次访问量 本站总访问量次 同一用户连续点击n篇文章，记录1次访问量 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次 添加RSS首先安装 hexo-generator-feed包 npm install hexo-generator-feed 在配置文件中添加如下代码： #RSS配置 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: content_limit_delim: &apos; &apos; 主题不同，添加方式可能不同，NEXT主题 _CONFIG.YML文件中有个 RSS的配置，直接设置为 TRUE就可以了 Yelee主题http://moxfive.coding.me/yelee/ Hexo中的Yelee主题，首页不显示文章摘要转自：https://blog.csdn.net/youshaoduo/article/details/78709160 首页显示文章摘要方法一：在需要显示的摘要之后添加如下代码： &lt;!--more--&gt; 方法二： 自动截取方法转自：https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/ 添加文章访问量统计themes\yelee\layout_partial\footer.ejs中添加如下代码： &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 在article.ejs中&lt;%- partial(‘post/tag’) %&gt;后添加如下代码： &lt;span id=&quot;busuanzi_container_page_pv&quot; style =&quot;display:block&quot;&gt; |阅读量(&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;) &lt;/span&gt; 在theme/source/css/style.styl文件中设置格式 #busuanzi_container_page_pv {display:block !important; padding-top:4px; color: #bebebe; //margin-left:200px; } 问题系列：出现Template render error：（unknown path）问题描述在使用hexo g生成文章的时候，报错如下: ATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) unexpected end of file 问题原因当文章中有}}时,且这两个括号未被代码块包含，解析会出问题 解决方法{% raw %} 含有双大括号的内容 {% endraw %} 转自：https://www.jianshu.com/p/738ebe02029b]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件系统操作与磁盘管理]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[df,du,mount命令的使用，以及磁盘相关知识学习。 查看磁盘和目录的容量df dev/sda1：是对应这主力硬盘的分区，后面的数字表示分区号，数字前面的字母a表示第几块硬盘（也可能是可移动磁盘）。如果主机上有多快磁盘，可能会出现/dev/sdb,/dev/sdc，这些磁盘设备都会放在/dev目录下以文件的存在形式。 1k.块：表示磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用容量和可用容量。 接下来的命令，显示结果一目了然： df -h du查看目录容量du //默认以块的大小展示 du -h //以更易读的方式展示 -d参数指定查看目录的深度 du -h -d 0 ~ //只查看1级目录的深度 du -h -d 1 ~ //查看2级 常用参数： du -h //以k,M,G为单位，提高信息的可读性 du -a //同-aall,显示目录中所有文件的大小 du s //同–summarize 仅仅显示终极，只列出最后加总的值 下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作 创建虚拟磁盘dd命令简介 dd命令用于转换和复制文件，不过它的复制不同于cp。Linux中，一切即文件，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，主持在各自的驱动程序中实现了对应的功能，dd也可以读取文件或写入这些文件。于是dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在ASCII与EBCDIC编码间互换。 dd命令行语句与其他的Linux程序不同，因为它的命令选项格式为选项=值，而不是标准的--选项 值或-选项=值。dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file输入文件）和of(output file输出文件)改变。 //输出到文件 dd of=test bs=10 count=1 dd if=/dev/stdin of=test bs=10 count=1 //输出到标准输出 dd if=/dev/stdin of=/dev/stdout bs=10 count=1 //在打完这个命令后，继续在终端打字，作为你的输入 上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。 dd在拷贝的同时可以实现数据转换，例子：将输出的英文字符转换为大写在输入文件： dd if=/dev/stdin of=test bs=10 count=1 conv=ucase dd命令创建虚拟镜像文件 dd完成创建虚拟磁盘的步骤第一步:从/dev/zero设置创建一个容量为265M的空文件 dd if=/dev/zero of=virtual.img bs=1M count=256 du -h virtual.img 第二步：将上述创建文件格式化（写入文件系统） 使用mkfs命令格式化磁盘 可以在命令行输入sudo mkfs 然后按下tab键，可以看到多个以mkfs为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。 sudo mkfs.ext4 virtual.img ext4：EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。 第三步： 使用count命令挂载磁盘到目录树 用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。 Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。 查看主机已经挂载的文件系统： sudo mount 输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。 挂在磁盘到目录树,mount命令的一般格式为: mount 【optons】 [source] [directory] 以下常用操作： mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro[文件系统源]]] [挂载点] 将创建的磁盘镜像挂载到/mnt目录： mount -o loop -t ext4 virtual.img /mnt //也可以省略挂载类型，很多时候 mount 会自动识别 /以只读方式挂载 mount -o loop --ro virtual.img /mnt //或者mount -o loop,ro virtual.img /mnt 使用umount命令卸载已挂载磁盘 命令格式 sudo umount 已挂载设备名或者挂载点，如： sudo umount /mnt fdisk为磁盘分区 查看磁盘分区表信息 sudo fdisk -l sudo fdisk virtual.img m：为帮助手册 n: 创建新分区，接着输入分区号，分区起始和结尾，两个相减为分区大小 w: 写入新建分区 p: 查看现有分区]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用的压缩/解压工具：zip和tar]]></title>
    <url>%2F2018%2F08%2F11%2FLinux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7zip%E5%92%8Ctar%2F</url>
    <content type="text"><![CDATA[知识点：zip命令、tar命令、压缩与解压常用组合 常用压缩包格式 文件后缀名 说明 *.zip zip 程序打包压缩的文件 *.rar rar 程序压缩的文件 *.7z 7zip 程序压缩的文件 *.tar tar 程序打包，未压缩的文件 *.gz gzip 程序（GNU zip）压缩的文件 *.xz xz 程序压缩的文件 *.bz2 bzip2 程序压缩的文件 *.tar.gz tar 打包，gzip 程序压缩的文件 *.tar.xz tar 打包，xz 程序压缩的文件 *tar.bz2 tar 打包，bzip2 程序压缩的文件 *.tar.7z tar 打包，7z 程序压缩的文件 zip压缩zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop 将Desktop目录下的子文件打包成shiyanlou.zip压缩文件，-r表示递归打包包含子目录的全部内容，-q表示安静模式，不向屏幕显示内容，-o表示输出文件，须在其后紧跟打包输出文件名（shiyanlou.zip）。 du -h shiyanlou.zip du命令查看打包文件的大小。-h表示文件大小可读，-d表示查看所查文件的深度，打印在屏幕上。 加密创建zip包：使用-e参数 zip -r -e -o shiyanlou_e.zip /home/shiyanlou/Desktop 跟着屏幕提示输入密码 注意：： 关于zip命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改： zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop unzip解压zip文件unzip shiyanlou.zip u使用安静模式,将文件解压到指定目录： unzip -q shiyanlou.zip -d ziptest 上述目录不存在，将会自动创建，如果不想解压只想查看压缩包的内容，可以使用-l参数： unzip -l shiyanlou.zip 注意：中文的兼容性问题，windows系统创建的压缩文件，如果有中文文档或文件名为中文，默认采用GBK或其他编码，而Linux上默认使用的是UTF-8编码。 使用-o参数指定编码类型： unzip -o GBK 中文压缩文件.zip tar打包工具tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。 创建一个tar包： tar -cf shiyanlou.tar home/shiyanlou/Desktop 不能使用相对路径，不然会提示图中问题 上面命令中，-c表示创建一个tar包文件，-f用户指定创建的文件，注意文件名必须紧跟在-f参数之后，比如不能写出tar -fc shiiyanlou.tar,可以写成tar -f shiyanlou.tar -c。-v参数以可视的方式输出打包的文件， 解压一个tar包：解压参数：-x指定已存在的目录： -C tar -xf shiyanlou.tar -C tardir 只查看不解包文件：参数： -t tar -tf shiyanlou.tar 保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（-p 参数）和备份链接指向的源文件而不是链接本身（-h 参数）： tar -cphf etc.tar /etc 使用gzip来压缩文件 添加-z参数 tar -czf shiyanlou.tar.gz home/shiyanlou/Desktop 解压*.tar.gz文件 tar -xzf shiyanlou.tar.gz 要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可： 压缩文件格式 参数 *.tar.gz -z *.tar.xz -J *tar.bz2 -j tar 命令的参数很多，不过常用的就是上述这些，需要了解更多你可以查看 man 手册获取帮助。 总结常用命令： zip： 打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数 tar： 打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
