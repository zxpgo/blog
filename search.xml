<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell编程-输出命令echo和printf(三)]]></title>
    <url>%2F2019%2F03%2F27%2FShell%E7%BC%96%E7%A8%8B-echo%E5%91%BD%E4%BB%A4(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Shell的echo指令与PHP的echo指令类似，都是用于字符串的输出，命令格式： echo string 您可以使用echo实现复杂的输出格式控制。 echo显示普通字符串echo &quot;It is a test&quot; 这里的双引号完全可以省略，以下命令与上面实例效果一致： echo It is a test 显示转义字符echo &quot;\&quot;It is a test\&quot;&quot; 通常，双引号也可以省略 echo &quot;\It is a test\&quot; 显示变量read命令从标准输入中读取一行，并把输入行的每个字段的值都指定给shell变量： #! /bin/bash echo It is a test echo &quot;\It is a test\&quot; read name echo $name It is a test 结果： It is a text &quot;It is a test&quot; OK #输入内容 OK It is a text 显示换行-e 开启转义 echo -e &quot;OK! \n It is a test&quot; 输出： OK! It is a test 显示不换行#！ /bin/bash echo -e &quot;OK! \c&quot; echo &quot;It is a test&quot; 输出： OK! It is a test 显示结果定向至文件echo &quot;It is a test&quot; &gt; profile 原样输出字符串，不进行转义或区变量(用单引号)echo &apos;$name\&quot;&apos; 输出： $name\” 显示命令执行时间echo `date` 注意，这里的是反引号`，而不是单引号’ 输出： 2019年 03月 27日 星期三 20:29:13 CST printfprintf 命令模仿 C 程序库（library）里的 printf() 程序。 printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。 printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。 printf 命令的语法： printf format-string [arguments...] 参数说明： format-string： 为格式控制字符串 arguments：为参数列表 实例如下： #! /bin/bash printf &quot;%-10s %-8s %-4s\n&quot; name sex weight/kg printf &quot;%-10s %-8s %-4s\n&quot; Alice Male 66.124 printf &quot;%-10s %-8s %-4s\n&quot; Bob Female 48.555 输出： name sex weight/kg Alice Male 66.124 Bob Female 48.555 %s %c %d %f都是格式替代符 %-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。 %-4.2f 指格式化为小数，其中.2指保留2位小数。 更多实例： printf &quot;%d %s \n&quot; 1 &quot;abc&quot; printf &apos;%d %s \n&apos; 1 &quot;abc&quot; printf %s abcdef printf %s abc def printf &quot;%s \n&quot; abc def printf &quot;%s %s %s\n&quot; a b c d e f printf &quot;%s and %d\n&quot; 输出： 1 abc 1 abc abcdefabcdefabc def a b c d e f and 0 printf的转义序列]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程-test命令和流程控制(五)]]></title>
    <url>%2F2019%2F03%2F27%2FShell%E7%BC%96%E7%A8%8B-test%E5%91%BD%E4%BB%A4%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 test命令数值测试 参数 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 实例演示： #!/bin/bash num1=100 num2=100 if test $[num1] -eq $[num2] then echo &quot;two number are equal&quot; else echo &quot;two number are nequal&quot; fi 输出： two number are equal 代码中的[]执行基本的算数运算符，如： a=5 b=6 result=$[a+b] echo &quot;result is: $result&quot; 输出： result is: 11 字符串测试 参数 说明 = 等于则为真 != 不相等则为真 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 实例演示： num1=&quot;zxp&quot; num2=&quot;zxp2&quot; if test $num1 = $num2 then echo &quot;two string are equal&quot; else echo &quot;two string are nequal&quot; fi 输出： two string are nequal 文件测试 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 实例演示： cd /bin if test -e ./bash then echo &quot;file is existing!&quot; else echo &quot;fiel is not existing!&quot; fi 输出： file is existing! 流程控制和Java、PHP等语言不一样，sh的流程控制不可为空，如PHP流程控制写法： &lt;?php if (isset($_GET[&quot;q&quot;])){ search(q); } else //不做任何事 &gt; 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 if elseif语句语法格式： if condition then command1 command2 ... fi 写成一行（适用于终端命令提示符）： if [$(ps -ef | grep -c &quot;ssh&quot;) -gt 1]; then echo &quot;true&quot;; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的。 if else语法格式： if condition then command1 command2 ... else command fi if else-if else语法格式： if condition1 then command1 elif condition2 then command2 else commandN fi 以下示例判断两个变量是否相等： a=10 b=20 if [ $a == $b ] then echo &quot;a = b&quot; elif [ $a -gt $b ] then echo &quot;a &gt; b&quot; elif [ $a -lt $b ] then echo &quot;a &lt; b&quot; else echo &quot;no&quot; fi 输出： a &lt; b if else语句经常与test命令结合使用，如下所示： num1=$[2*3] num2=$[1+5] if test $[num1] -eq $[num2] then echo &quot;two number are equal&quot; else echo &quot;two number are nequal&quot; fi 输出： two number are equal for循环语法： for var in item1 item2 ... itemN do command1 done 写成一行： for var in item1 item2 ... itemN; do command1; command2 done; 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 例如，顺序输出当前列表中的数字： for loop in 1 2 3 4 5 do echo &quot;The value is $loop&quot; done 输出： The value is 1 The value is 2 The value is 3 The value is 4 The value is 5 顺序输出字符串： for str in &apos;This is a string&apos; do echo $str done 输出： This is a string while语句语法： while condition do command done 以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，int加1.运行上述脚本，返回数字1到5，然后终止： #! /bin/bash int=1 while(($int&lt;=5)) do echo $int let &quot;int++&quot; done 输出 1 2 3 4 5 使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量 while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按结束循环。 echo ‘input to quit:’echo -n ‘input your favorite websiet: ‘while read FILMdo echo “Yes, $FILM is good website”done 输出： input to quit:input your favorite websiet: www.zxpblog.cnYes, www.zxpblog.cn is good website 无限循环until循环case跳出循环esac]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程-shell传递参数(二)]]></title>
    <url>%2F2019%2F03%2F27%2FShell%E7%BC%96%E7%A8%8B-shell%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[我们可以在执行Shell脚本时，向脚本传递参数，脚本内获取参数的格式为： $n， n代表一个数字，1为执行脚本的第一个参数，2为执行脚本的第二个参数，以此类推… 实例以下实例我们向脚本传递三个参数，并分别输出，其中$0为可执行的文件名： #! /bin/bash #author:zxp #url: www.zxpblog.cn echo &quot;example of shell passing parameter&quot;; echo &quot;name of file: $0&quot;; echo &quot;First parameter: $1&quot;; echo &quot;Second parameter: $2&quot;; echo &quot;Third parameter: $3&quot;; 输出： example of shell passing parameter name of file: ./test.sh First parameter: 1 Second parameter: 2 Third parameter: 3 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符显式所有向脚本传递的参数 $$ 脚本运行的当前进程ID $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。以”$1” “$2” … “$n” 的形式输出所有参数。 $- 显示shell使用的当前选项，与set命令功能相同 $? 显示最后命令的退出状态，0表示没有错误，其他任何表明有错误 echo &quot;Number of parameter: $#&quot; echo &quot;The first charater is passing parameter: $*&quot; echo &quot;$$&quot; 输出： ./test.sh 1 2 3 Number of parameter: 3 The first charater is passing parameter: 1 2 3 25790]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程-变量(二)]]></title>
    <url>%2F2019%2F03%2F27%2FShell%E7%BC%96%E7%A8%8B-%E5%8F%98%E9%87%8F(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[在Linux部分介绍了变量的概念，以及初略的介绍了shell变量和环境变量，这里将深入讨论。 定义变量时，变量名不加美元符号$(PHP语言中变量需要)，如： your_name=&quot;zxp&quot;; 注意，变量名和等号之间不能有空格，这可能和熟悉的所有编程语言都不一样。同时，变量名的命名虚遵循如下规则： 命名只能使用英文字面、数字和下划线，首个字符不能以数字开头； 中间不能有空格，可以使用下划线； 不能使用标点符号； 不能使用bash里的关键字。 有效的shell变量名示例如下： zxp _zxp var1 _var2 无效的变量名： 3var zxp= user*name 除了显式地直接赋值外，还可以用语句给变量赋值，如： for file in &apos;ls /etc&apos; for file in $(ls /etc) 以上语句将/etc下目录的文件名循环出来 使用变量使用一个定义过的变量，只要在变量名前面加上美元符号即可，如： your_name=&quot;zxp&quot; echo $your_name echo ${your_name} 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种操作: for skill in Ada Coffe Action Java; do echo &quot;I am good at $(skill)Script&quot; done 如果不给变量加花括号，写成了echo &quot;I am good at $skillScript&quot;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。 推荐给所有变量加上花括号，这是个好的编程习惯。 已定义的变量，可以被重新定义，如： your_name=&quot;tom&quot; echo $your_name your_name=&quot;alibaba&quot; echo $your_name 这样的写法是合法的，但注意，第二次赋值的时候不能写$your_name=&quot;alibaba&quot;，使用变量的时候才加美元符 只读变量使用readonle命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错： #! /bin/bash myUrl=&quot;https://www.zxpblog.cn&quot; readonly myUrl myUrl=&quot;https://zxpblog.cn&quot; 运行脚本，结果如下： ./test.sh:行4: myUrl: 只读变量 删除变量使用unset命令可以删除变量，语法： unset variable_name 变量被删除后不能再次使用，unset命令不能删除只读变量。 实例 #! /bin/bash myUrl=&quot;https://www.zxpblog.cn&quot; unset myUrl echo $myUrl 以上实例执行将没有任何输出。 变量类型运行shell时，会同时存在三种变量： 局部变量： 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量： 所有程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量： shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分局部变量，这些变量保证了shell的正常运行。 shell字符串字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没有啥其他类型好用了），字符串可以用单引号，也可以使用双引号，也可以不用引号，单双引号的区别跟PHP类似。 单引号str=&apos;this is a string&apos; 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字符串中不能出现单独一个的单引号（对单引号使用转义字符也不行），但可成对出现，作为字符串拼接使用。 双引号your_name=&quot;zxp&quot; str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot; echo -e $str 输出结果 Hello, I know you are &quot;zxp&quot;! 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串your_name=&quot;zxp&quot; #使用双引号拼接 greeting=&quot;hello, &quot;$your_name&quot;!&quot; greeting_1=&quot;hello, ${your_name}!&quot; echo $greeting $greeting_1 #使用单引号拼接 greeting_2=&apos;hello, &apos;$your_name&apos; !&apos; greeting_3=&apos;hello, ${your_name} !&apos; echo $greeting_2 $greeting_3 输出： hello, zxp! hello, zxp! hello, zxp ! hello, ${your_name} ! 获取字符串长度string=&quot;abcd&quot; echo ${#string} #输出4 提出子字符串以下实例从字符串第2个字符开始截取4个字符： #extract substring string=&quot;zxpblog is a gread site&quot; echo ${string:1:4} #输出xebl 查找子字符串查找字符i或o的位置（哪个字符先出现就计算哪个）： #find substring string=&quot;zxpblog is a gread siet&quot; echo `expr index &quot;$string&quot; io` #输出6 注意：以上脚本中的`是反引号，而不是单引号’，不要看错了 shell数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 类似于C语言，数组元素的下表由0开始编号，获取数组中的元素利用下表，下表可以是整数或算术表达式，其值应大于或等于0。 定义数组在shell中，用括号来表示数组，数组元素用空格符号隔开。定义数组的一般形式如下： 数组名=(值1 值2 ... 值n) 例如， array_name=(value0 value1 value2 value3) 或者 array_name=( value0 value1 value2 value3 ) 还可以单独数组的各个分量： array_name[0]=value0 array_name[1]=value1 可是不使用连续的下标，而且下标的范围没有限制。 读取数组读取数组元素值得一般格式是： ${数组名[下标]} 例如： value=${array_name[n]} 使用@符号可以获取数组中得所有元素，例如： echo ${array_name[@]} 获取数组得长度获取数组长度得方法与获取字符串长度得方法相同，例如： array_name=(1 2 3 4) echo ${array_name[@]} ${array_name[1]} #取得数组元素的个数 length=${#array_name[@]} echo $length #取得数组元素的个数 length=${#array_name[*]} echo $length #获取数组单个元素的长度 lengthn=${array_name[n]} echo $lengthn 输出： 1 2 3 4 2 4 4 1 shell注释以#开头的行就是注释，会被解释器忽略 通过每一行加上一个#设置多行注释，如下： #-------------------------------------------- # 这是一个注释 # author：zxpblog # site：www.zxpblog.cn # slogan：学的不仅是技术，更是梦想！ #-------------------------------------------- ##### 用户配置区 开始 ##### # # # 这里可以添加脚本描述信息 # # ##### 用户配置区 结束 ##### 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。 多行注释多行注释还可以使用以下格式： :&lt;&lt;EOF 注释内容... 注释内容... 注释内容... EOF EOF也可以使用其他符号： :&lt;&lt;&apos; 注释内容... 注释内容... 注释内容... &apos; :&lt;&lt;! 注释内容... 注释内容... 注释内容... !]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程-概述(一)]]></title>
    <url>%2F2019%2F03%2F27%2FShell%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[本系列教程来自：菜鸟教程和鸟哥的Linux私房菜基础学习篇。 Shell是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。 Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Shell在线工具 硬件、内核和Shell三者关系 Shell脚本Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。 由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） …… 本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。 第一个shell脚本打开文编编译器（可以使用vi/vim命令来创建文件），新建一个文件test.sh，扩展名为.sh(sh代表shell)，扩展名并不影响脚本执行，见名知意就好，如果你用php写shell脚本，扩展名就用php就好。 test.sh #！ /bin/bash echo &quot;Hello world!&quot; 1. 作为可执行程序 执行hello_world.sh之前，需要使脚本具有执行的权限： chmod +x ./test.sh 然后执行脚本： ./test.sh 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 2. 作为解释器参数 这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： /bin/sh test.sh /bin/php test.php]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--探讨C++新标准（十八）]]></title>
    <url>%2F2019%2F03%2F15%2FC%2B%2B%20Primer%20Plus--%E6%8E%A2%E8%AE%A8C%2B%2B%E6%96%B0%E6%A0%87%E5%87%86%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍前面提高过的C++11新功能，并详细介绍其他一些功能。最后，简要地探讨BOOST库。 18.1 复习前面介绍过的C++11功能本书前面介绍很多C++11功能，但您现在可能忘了，本节简要地复习这些改进。 18.1.1 新类型C++新增了类型long long和unsigned long long，以支持64位（或更宽）的整型；新增了类型char16_ t和char32_ t，以支持16位或32位的字符表示；还新增了“原始”字符串。第三章讨论了这些新增的类型。 18.1.2 统一的初始化C++扩大了用大括号括起来的列表（初始化列表）的使用范围，使其可用于所有内置类型和用户定义的类型（即类对象）。使用初始化列表时，可添加等号（=），也可不添加： int x = {5}; double y {8.5}; short quar[5] {4, 5, 2, 76, 1}; 另外，列表初始化语法也可用于new表达式中： int * ar = new int[4] {2. 4, 5, 6}; 创建对象时，也可使用大括号（而不是圆括号）括起的列表来调用构造函数： class Stemp { private: int roots; double weight; public: Stump(int r, double w) : roots(r), weight(w) {} }; Stemp s1(3, 1.34); //旧版本 Stemp s2{3, 1.34}; //C++11 Stemp s3 = {1, 1.34}; //C++11 然而，如果类有将模板std::initializer_list作为参数的构造函数，则只有构造函数可以使用列表初始化形式。第3、4、9、10、16章讨论了列表初始化的各个方面。 1. 缩窄初始化列表语法可防止缩窄，即禁止将数值赋给无法存储它的数值变量。常规初始化允许程序员执行可能没有意义的操作： char c1 = 1.57e27; //double到char的转换 char c2 = 4589598978; //int到char的转换 然后，如果使用列表初始化语法，编译器将禁止进行这样的类型转换，即将值存储到比它“窄”的变量中： char c1 {1.57e27}; //编译器错误 char c2 {459526685}; //编译器错误 但允许转换位更宽的类型。另外，只要值在较窄类型的取值范围内，将其转换位较窄类型也是允许的： char c1 {65}; double c2 = {55}; 2. std::initializer_listC++11提供了模板类initializer_ list，可将其用作构造函数的参数，这在第16章讨论过。如果类有接受initializer_ list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。列表中的元素必须是同一种类型或可转换位同一种类型。STL容器提供了将initializer_ list作为参数的构造函数： vector&lt;int&gt; a1(10); //未初始化的是个元素 vector&lt;int&gt; a2{10}; //初始化为10的a2 vector&lt;int&gt; a3{4,6,1}; //3个元素被初始化为4，6，1 头文件initializer_ list提供了对模板类initializer_ list的支持。这个类包含成员函数begin()和end()，可用于获悉列表的范围。除用于构造函数外，还可将initializer_ list用作常规函数的参数： #include &lt;initializer_list&gt; double sum (std::initializer_list&lt;double&gt; il); int main() { double total = sum({2.5, 3.1, 4}); ... } double sum(std::initializer_list&lt;double&gt; il) { double tot = 0; for (auto p = il.begin(); p != il.end(); p++) tot += p; return tot; } 18.1.3 声明C++提供了多种简化声明的功能，尤其在使用模板时。 1. auto以前，关键字auto是一个存储类型说明符（见第9章），C++11将其用于实现自动类型推断（见第3章）。这要求进行显式初始化，让编译器能够将变量的类型设置为初始值的类型： auto maton = 112; //maton是in类型 auto pt = &amp;maton; //pt是一个int *类型 double fm(double, int); auto pf = fm; //pf是一个类型double(*)(double, int) 关键字auto还可简化模板声明。例如，如果il是一个std::initializer_ list对象，则可将下述代码： for(std::initializer_list&lt;double&gt;::iterator p = begin(); p != il.end(); p++) 替换为如下代码： for(auto p = il.begin(); p ！= il.end(); p++) 2. decltype关键字decltype将变量的类型声明为表达式指定的类型。下面的语句的含义是，让y的类型与x相同，其中x是一个表达式： decltype(x) y; 下面是几个示例： double x; int n; decltype(x*n) q; //q是double类型 decltype(&amp;x) pd; //pd是一个double指针 这在定义模板时特别有用，因为只有等到模板被实例化时才能确定类型： template&lt;typename T, typename U&gt; void ef(T t, U u) { decltype(T*U) tu; ... } 其中，tu将表示为表达式T$\ast$U的类型，这里假定定义了运算T$\ast$U。例如，如果T为char，U为short，则tu将为int，这是由整型算术自动执行整型提升导致的。 decltype的工作原理比auto复杂，根据使用的表达式，指定的类型可以为引用和const。下面是几个示例： int j = 3; int &amp;k = j; const int &amp;n = j; decltype(n) i1; //i1类型为const int &amp; decltype(k + 1) i4; //i4类型为int decltype(j) i2; //i2类型为int decltype((j)) i3; //i3类型为int &amp; 有关导致上述结果的规则的详细信息，请参阅第8章。 最后两个对decltype的调用，返回结果有所不同。这是因为，带括号的表达式(j)既非“标识符表达式”，亦非类访问表达式，因而未指向一个命名对象，而是一个左值，于是推导类型便为“指向表达式类型的引用”，亦即int &amp;。 C++语言中可以放在等号左边的变量，即具有对应的可以由用户访问的存储单元，并且能够由用户去改变其值的量。 或者说左值是代表一个内存地址值，通过这个内存地址，就可以对内存进行读写操作；这也就是为什么左值可以被赋值的原因了。 相对应的还有右值：当一个符号或者常量放在操作符右边的时候，计算机就读取他们的“右值”，也就是其代表的真实值。 3. 返回类型后置C++11新增了一种函数声明语法：在函数名和参数列表后（而不是前面）指定返回类型： double f1(double, int); auto f2(double, int) -&gt; double; //C++11 就常规函数的可读性而言，这种语法好像是倒退，但让您能够使用decltype来指定模板函数的返回类型： template &lt;typename T, typename U&gt; auto eff(T t, U u) -&gt; decltype(T*U) {...} 这里解决的问题是，在编译器遇到eff的参数列表前，T和U还不在作用域内，因此必须在参数列表后使用decltype。这种新语法使得能够这样做。 4. 模板别名： using=对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前，C++为此提供了typedef: typedef std::vector&lt;std::string&gt;::iterator itType; C++11提供了另一种创建别名的语法，这在第14章讨论过： using itType = std::vector&lt;std::string&gt;::iterator; 差别在于，新语法也可用于模板部分具体化，但typedef不能： template&lt;typename T&gt; using arr12 = std::array&lt;T, 12&gt;; 上述语句具体化模板array&lt;T, int&gt;（将参数int设置为12）。例如，对于下述声明： std::array&lt;double, 12&gt; a1; std::array&lt;std::string, 12&gt; a2; 可将它们替换为如下声明： arr12&lt;double&gt; a1; arr12(std::string) a2; 5. nullptr空指针是不会指向有效数据的指针。以前，C++在源代码中使用0表示这种指针，但内部表示可能不同。这带来了一些问题，因为这使得0即可表示指针常量，又可表示整型常量。正如第12章讨论的，C++11新增了关键字nullptr，用于表示空指针；它是指针类型，不能转换为整型类型。为先后兼容，C++11仍允许使用0来表示控制，因此表达式nullptr == 0为true，但使用nullptr而不是0提供了更高的类型安全。例如，可将0传递给接受int参数的函数，但如果您试图将nullptr传递给这样的函数，编译器将此视为错误，因此，由于清晰和安全考虑，请使用nullptr。 18.1.4 智能指针如果在程序中使用new从堆（自由存储区）分配内存，等到不再需要时，应使用delete将其释放。C++引入了指针指针auto_ ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL时）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ ptr，并新增了三种智能指针：unique_ ptr、shared_ ptr和weak_ ptr，第16章讨论了前两种。 18.1.6 作用域内枚举传统的C++枚举提供了一种创建名称常量的方式，但其类型检查相当低级。另外，枚举名的作用域为枚举定义所属的作用域，这意味如果在同一个作用域内定义两个枚举，它们的枚举成员不能同名。最后，枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。为解决这些问题，C++11新增了一种枚举。这种枚举使用class或struct定义： enum Olda {yes, no, maybe}; //旧版本 enum class New1 {never, sometimes, often, always}; //C++11 enum struct Nuew {never, lever, sever}; //C++11 新枚举要求进行显式限定，以免发生名称冲突。因此，引用特定枚举时，需要使用New1::never和New2::never等。更详细的信息请参见第10章。 18.1.7 对类的修改为简化和扩展类设计，C++11做了多项改进。这包括允许构造函数被继承和彼此调用、更佳的方法访问控制方式以及移动构造函数和移动复制运算符，这些都将在本章介绍。下面先来复习本书前面介绍过的改进。 1. 显式转换运算符有趣的是，C++很早就支持对象自动转换。但随着编程经验的积累，程序员逐渐认识到，自动类型转换可能导致意外转换的问题。为解决这种问题，C++引入了关键字explicit，以禁止单参数构造函数导致的自动转换： class Plebe { Plebe(int); //int到Plebe自动类型转换 explicit Plebe(double); //要求显式使用 }; ... Plebe a, b; a = 5; //隐式转换 b = 0.5; //错误 b = Plebe(0.5); //显式转换 C++扩展了explicit的这种用法，使得可对转换函数做类似的处理（参见第11章）： class Plebe { operator int() const; explicit operator double() const; ... }; ... Plebe a, b; int n = a; //自动类型转换 double x = b; //不被允许 x = double(b); //显式转换 2. 类内成员初始化很多首次使用C++的用户都会问，为何不能在类定义中初始化成员？现在可以这样做了，其语法类似于下面这样： class Session { int mem1 = 10; double mem2 {19964.55}; short mem3; public: Session(){} #1 Session(short s) : mem3(s) {} #2 Session(int n, double d, short s) : mem1(n), mem2(d),mem3(s) {} #3 ... }; 可使用等号或大括号版本的初始化，但不能使用圆括号版本的初始化。其结果与给前两个构造函数提供成员初始化列表，并指定mem1和mem2的值相同： Session() : mem1(10), mem2(19964.55) {} Session(short s): mem1(10), mem2(19964.55) {} 通过使用类内初始化，可避免在构造函数中编写重复的代码，从而降低了程序员的工作量。 如果构造函数在成员初始化列表中提供了相应的值，这些默认值将被覆盖，因此第三个构造函数覆盖了类内成员初始化。 18.1.8 模板和STL方面的修改为改善模板和标准模板库的可用性，C++做了多个改进；有些是库本身，有些与易用性相关。本章前面提供了模板别名和使用于STL的智能指针。 1. 基于范围的for循环对于内置数组以及包含方法begin()和end()的类（如std::string）和STL容器，基于范围的for循环（第5章和第16章讨论过）可简化为它们编写循环的工作。这种循环对数组或容器中的每个元素执行执行的操作： double prices[5] = {4.99， 1.99， 6.87， 7.99， 8.49}； for (double x: price) std::cout &lt;&lt; x &lt;&lt; std::endl; 其中，x将依次为prices中每个元素的值。x的类型应与数组元素的类型匹配。一种更容易、更安全的方式是，使用auto来声明x，这样编译器将根据prices声明中的信息来推断x的类型： for (auto x : price) std::cout &lt;&lt; x &lt;&lt; std::endl; 如果要在循环中修改数组或容器的每个元素，可使用引用类型： std:vector&lt;int&gt; vi(6); for (auto &amp; x : vi) x = std::rand(); 2. 新的STL容器C++11新增了STL容器forward_ list、unordered_ map、unordered_ multimap、 unordered_ set和unordered_ multiset（参见第16章）。forward_ list是一种单向链表，只能沿着一个方向遍历；与双向链表的list容器相比，它更简单，在占用内容空间方面更经济。其他四种容器都是使用哈希表实现的。 C++11还新增了模板array（这在第4和16章讨论过）。要实例化这种模板，可指定元素类型和固定的元素数： std::array&lt;int, 360&gt; ar; 这个模板类没有满足所有的常规模板需求。例如，由于长度固定，您不能使用任何修改容器大小的方法，如put_ back()。但array确实有begin()和end()，这让您能够对array对象使用众多基于范围的STL算法。 3. 新的STL方法C++11新增了STL方法cbegin()和cend()。与begin()和end()一样，这些新方法也返回一个迭代器，指向容器的第一个元素和最后一个元素的后面，因此可用于指定包含全部元素的区间.另外，这些新方法将元素视为const，与此类似，crbegin()和crend()是rbegin()和rend()的const版本。 更重要的是，除传统的复制构造函数和常规复制运算符外，STL容器现在还有移动构造函数和移动赋值运算符。移动语义在本章后面介绍。 4. valarray升级模板valarray独立于STL开发，其最初的设计导致无法将基于范围的STL算法用于valarray对象。C++11添加了两个函数（begin()和end()），它们都接受valarray作为参数，并返回迭代器，这些迭代器分别指向valarray对象的第一个元素和最后一个元素后面。这让您能够基于范围的STL算法用于valarray（参见第16章）。 5. 摒弃exportC++98增加了关键字export，旨在提供一种途径，让程序员能够将模板定义放在接口文件和实现文件中，其中前者包含原型和模板声明，而后者包含模板函数和方法的定义。实践证明这不现实，因此C++11终止了这种用法，但仍保留了关键字export，供以后使用。 6. 尖括号为避免与运算符混淆，C++要求在声明嵌套模板时使用空格将尖括号分开： std::vector&lt;std::list&lt;int&gt; &gt; vl; C++11不再这样要求： std::vector&lt;std::list&lt;int&gt;&gt; vl; 18.1.9 右值引用传统的C++引用（现在称为左值引用）使得标识符关联到左值。_左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获得其地址。最初，左值可出现在赋值语句的左边，但修饰符const的出现使得可以声明这样的标识符，即不能给他赋值，但可获获取其地址： int n; int * pt = new int; const int b = 101; int &amp; rn = n; int &amp; rt = *pt; const int &amp; rb = b; int const&amp;表示此引用所代表的int类型变量无法使用此引用修改。const int&amp;表示此引用所代表的是const int类型变量,同样也无法用此引用修改。 两者的区别是: int const&amp;所代表的变量可以是int 和 const int . const int&amp;所代表的变量仅可以是 const int . C++11新增了右值引用（这在第8章讨论过），这是使用&amp;&amp;表示的。右值引用可关联到右值，即可出现在赋值表达式右边，但不能对其引用地址运算符的值。右值包括字面常量（C-风格字符串除外，它表示地址）、诸如x+y等表达式以及返回值的函数（条件是该函数返回的不是引用）： int x = 10; int y = 23; int &amp;&amp; r1 = 13; int &amp;&amp; r2 = x + y; double &amp;&amp; r3 = std::sqrt(2.0); 注意，r2关联到的是当时计算x+y得到的结果。也就是说，r2关联到的是33，即使以后修改了x或y也不会影响到r2。 有趣的是，将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。也就说说，虽然不能将运算符&amp;用于13，但可将其用于r1。通常，将数据特定义的地址关联，使得可以通过右值引用来访问该数据。 程序18.1是一个简短的示例，演示了上述有关右值引用的要点。 程序18.1 rvref.cpp #include &lt;iostream&gt; inline double f(double tf) { return 5.0*(tf-32.0)/9.0; } int main() { using namespace std; double tc = 21.5; double &amp;&amp; rd1 = 7.07; double &amp;&amp; rd2 = 1.8 * tc + 32.0; double &amp;&amp; rd3 = f(rd2); cout &lt;&lt; &quot; tc value and address: &quot; &lt;&lt; tc &lt;&lt; &quot;, &quot; &lt;&lt; &amp;tc &lt;&lt; endl; cout &lt;&lt; &quot;rd1 value and address: &quot; &lt;&lt; rd1 &lt;&lt; &quot;, &quot; &lt;&lt; &amp;rd1 &lt;&lt; endl; cout &lt;&lt; &quot;rd2 value and address: &quot; &lt;&lt; rd2 &lt;&lt; &quot;, &quot; &lt;&lt; &amp;rd2 &lt;&lt; endl; cout &lt;&lt; &quot;rd3 value and address: &quot; &lt;&lt; rd3 &lt;&lt; &quot;, &quot; &lt;&lt; &amp;rd3 &lt;&lt; endl; cin.get(); return 0; } 输出： tc value and address: 21.5, 0x7fff1af4a9a8 rd1 value and address: 7.07, 0x7fff1af4a9b0 rd2 value and address: 70.7, 0x7fff1af4a9b8 rd3 value and address: 21.5, 0x7fff1af4a9c0 引入右值的主要目的之一是实现移动语义，这是本章将讨论的下一个主题。 18.2 移动语义和右值引用现在介绍本书前面为讨论的主题。C++11支持移动语义，这就提出了一些问题：什么是移动语义？C++11如何支持它？为何需要移动语义？下面首先讨论第一个问题。 18.2.1 为何需要移动语义先来看C++11之前的复制过程。假设有如下代码： vector&lt;string&gt; vstr; //创建一个20000个字符串的向量，每个字符串1000个字符 ... vector&lt;string&gt; vstr_copy1(vstr); //vstr_ copy1复制vstr vector和string类都使用动态内存分配，因此它们必须定义使用某种new版本的复制构造函数。为初始化对象vstr_ copy1，复制构造函数vector使用new给20000个string对象分配内存，而每个string对象又将调用string的复制构造函数，该构造函数使用new为1000个字符分配内存。接下来，全部200000000个字符都从vstr控制的内存中复制到vstr_ copy1控制的内存中。这里的工作量很大，但只要妥当处理就行。 但这确实妥当吗？有时候答案是否定的。例如，假设有一个函数，它返回一个vector对象： vector&lt;string&gt; allcaps(const vector&lt;string&gt; &amp; s) { vector&lt;string&gt; temp; //在temp中存储vs的全大写版本的代码 return temp; } 接下来，假设有以下面这种方式使用它： vector&lt;string&gt; vstr; //创建一个20000个字符串的向量，每个字符串1000个字符 vector&lt;string&gt; vstr_copy1(vstr); #1 vector&lt;string&gt; vstr_copy2(allcaps(vstr)); #2 从表面上看，语句#1和#2类似，它们都是用一个现有的对象初始化一个vector对象。如果深入探索这些代码，将发现allcaps()创建了对象temp，该对象管理着20000000个字符；vector和string的复制构造函数创建这20000000个字符的副本，然后程序删除allcaps()返回的临时对象（迟钝的编译器甚至可能将temp复制给一个临时返回对象，删除temp，在删除临时返回对象）。这里的要点是，做了大量的无用功。考虑到临时对象被删除了，如果编译器将对数据的所有权直接转让给vstr_ copy2，不是更好吗？也就是说，不将20000000个字符复制到新地方，再删除原来的字符，而将字符留在原来的地方，并将vstr_ copy2与之相关联。这类似于在计算机中移动文件的情形：实际文件还留在原来地方，而只是修改记录。这种方法被称为移动语义（move semantics）。有点悖论的是，移动语义实际上避免了移动原始数据，而只是修改了记录。 要实现移动语义，需要采用某种方式，让编译器知道什么时候需要复制，什么时候不需要。这就是右值引用发挥作用的地方。可以定义两个构造函数。其中一个常规复制构造函数，它实用const左值引用作为参数，这个引用关联到左值实参，如语句#1中的vstr。另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句#2中的allcaps(vstr)的返回值。复制构造函数可执行深复制，而移动构造函数只调整记录。在将所有权转移给新对象的过程中，移动构造函数可能修改其实参，这意味着右值引用参数不应是const。 18.2.2 一个移动示例下面通过一个示例演示移动语义和右值引用的工作原理。程序18.2定义并使用了Useless类，这个类动态分配内存，并包含常规复制构造函数和移动构造函数，其中移动构造函数使用了移动语义和右值引用。为演示流程，构造函数和析构函数都比较哆嗦，同时Useless类还使用了静态变量来跟踪对象数据数量。另外，省略了一些重要的方法，如复制运算符。 程序18.2 useless.cpp #include &lt;iostream&gt; using namespace std; class Useless { private: int n; char *pc; static int ct; void ShowObject() const; public: Useless(); explicit Useless(int k); Useless(int k, char ch); Useless(const Useless &amp; f); Useless(Useless &amp;&amp; f); ~Useless(); Useless operator+(const Useless &amp; f) const; void ShowData() const; }; int Useless::ct = 0; Useless::Useless() { ++ct; n = 0; pc = nullptr; cout &lt;&lt; &quot;default constructor called; number of objects: &quot; &lt;&lt; ct &lt;&lt; endl; ShowObject(); } Useless::Useless(int k) : n(k) { ++ct; cout &lt;&lt; &quot;int constructor called; number of objects: &quot; &lt;&lt; ct &lt;&lt; endl; pc = new char[n]; ShowObject(); } Useless::Useless(int k, char ch) : n(k) { ++ct; cout &lt;&lt; &quot;int, char constructor called; number of objects: &quot; &lt;&lt; ct &lt;&lt; endl; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = ch; ShowObject(); } Useless::Useless(const Useless &amp; f) : n(f.n) { ++ct; cout &lt;&lt; &quot;copy const called; number of objects: &quot; &lt;&lt; ct &lt;&lt; endl; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = f.pc[i]; ShowObject(); } Useless::Useless(Useless &amp;&amp; f) : n(f.n) { ++ct; cout &lt;&lt; &quot;move constructor called; number of objects: &quot; &lt;&lt; ct &lt;&lt; endl; pc = f.pc; f.pc = nullptr; f.n = 0; ShowObject(); } Useless::~Useless() { cout &lt;&lt; &quot;destructor called; objects left: &quot; &lt;&lt; --ct &lt;&lt; endl; cout &lt;&lt; &quot;deleted object:\n&quot;; ShowObject(); delete [] pc; } Useless Useless::operator+(const Useless &amp; f)const { cout &lt;&lt; &quot;Entering operator+()\n&quot;; Useless temp = Useless(n + f.n); for (int i = 0; i &lt; n; i++) temp.pc[i] = pc[i]; for (int i = n; i &lt; temp.n; i++) temp.pc[i] = f.pc[i - n]; cout &lt;&lt; &quot;temp object:\n&quot;; cout &lt;&lt; &quot;Leaving operator+()\n&quot;; return temp; } void Useless::ShowObject() const { cout &lt;&lt; &quot;Number of elements: &quot; &lt;&lt; n; cout &lt;&lt; &quot; Data address: &quot; &lt;&lt; (void *) pc &lt;&lt; endl; } void Useless::ShowData() const { if (n == 0) cout &lt;&lt; &quot;(object empty)&quot;; else for (int i = 0; i &lt; n; i++) cout &lt;&lt; pc[i]; cout &lt;&lt; endl; } int main() { { Useless one(10, &apos;x&apos;); Useless two = one; Useless three(20, &apos;o&apos;); Useless four(one + three); cout &lt;&lt; &quot;object one: &quot;; one.ShowData(); cout &lt;&lt; &quot;object two: &quot;; two.ShowData(); cout &lt;&lt; &quot;object three: &quot;; three.ShowData(); cout &lt;&lt; &quot;object four: &quot;; four.ShowData(); } return 0; } 其中最重要的是复制构造函数和移动构造函数的定义。首先来看复制构造函数（删除了输出语句）： Useless::Useless(const Useless &amp; f) : n(f.n) { ++ct; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = f.pc[i]; ShowObject(); } 它执行深复制，是下面的语句将使用的构造函数： Useless two = one; 引用f将指向左值对象one。 接下来看移动构造函数，这里也删除了输出语句； Useless::Useless(Useless &amp;&amp; f) : n(f.n) { ++ct; pc = f.pc; f.pc = nullptr; f.n = 0; ShowObject(); } 它让pc指向现有的数据，以获取这些数据的所有权。此时，pc和f.pc指向相同的数据，调用析构函数时这将带来麻烦，因为程序不能对同一地址调用delete[]两次。为避免这种问题，该析构函数随后将原来的指针设置为空指针，因为对空指针执行delete []没有问题。这种夺取所有权的方式常被称为窃取。上述代码还将原始对象的元素设置为零，这并非必不可少的，但让这个示例的输出更一致。注意，由于修改了f对象，这要求不能再参数声明中使用const。 在下面的语句中，将使用这个构造函数： Useless four (one + three); 表达式one + three调用Useless::operator+()，而右值引用f将关联到该方法返回的临时对象。 如果使用g++4.5.0和表示-std=c++11编译该程序，输出将不同，输出： int, char constructor called; number of objects: 1 Number of elements: 10 Data address: 0x1e31010 copy const called; number of objects: 2 Number of elements: 10 Data address: 0x1e31030 int, char constructor called; number of objects: 3 Number of elements: 20 Data address: 0x1e31050 Entering operator+() int constructor called; number of objects: 4 Number of elements: 30 Data address: 0x1e31070 temp object: Leaving operator+() object one: xxxxxxxxxx object two: xxxxxxxxxx object three: oooooooooooooooooooo object four: xxxxxxxxxxoooooooooooooooooooo destructor called; objects left: 3 deleted object: Number of elements: 30 Data address: 0x1e31070 destructor called; objects left: 2 deleted object: Number of elements: 20 Data address: 0x1e31050 destructor called; objects left: 1 deleted object: Number of elements: 10 Data address: 0x1e31030 destructor called; objects left: 0 deleted object: Number of elements: 10 Data address: 0x1e31010 注意到没有调用移动构造函数，且只创建了4个对象。创建对象four时，该编译器没有调用任何构造函数；相反，它推断出对象four是operator+()所作工作的收益人，因此将operator+()创建的对象转到four的名下。一般而言，编译器完全可以进行优化，只要结果与未优化时相同。即使您省略该程序中的移动构造函数，并使用g++进行编译，结果也将相同。 如果使用VSC++ 2010中编译，该程序输出不一样，其会调用移动构造函数，并创建一个临时对象。 18.2.3 移动构造函数解析虽然使用右值引用可支持移动语义，但这并不会神奇地发生。要让移动语义发生，需要两个步骤。首先，右值引用让编译器知道如何使用移动语义： Useless two = one; Useless four (one + three); 对象one是左值，与左值引用匹配，而表达式one + three是右值，与右值引用匹配。因此，右值引用让编译器使用移动构造函数来初始化对象four。实现移动语义的第二步是，编写移动构造函数，使其提供所需的行为。 总之，通过提供一个使用左值引用的构造函数和一个使用右值引用的构造函数，将初始化分成了两组。使用左值对象初始化对象时，使用复制构造行是，而是用右值对象初始化对象时，将使用移动构造函数。程序员可根据需要赋予这些构造函数不同的行为。 这就带来了一个问题：在引入右值引用前，情况是什么样的呢？如果没有移动构造函数，且编译器未能通过优化消除对复制构造函数的需求，结果将如何呢？在C++98中，下面的语句将调用复制构造函数： Useless four(one + three); 但左值引用不能指向右值。结果将如何呢？第8章介绍过，如果实参为右值，const引用形参将指向一个临时变量： int twice(const &amp; rx) { return 2 * rx; } ... int main() { int m = 6; //rx指向m int n = twice(m); //rx指向一个临时变量，被初始化为21 int k = twice(21); } ... 就Useless而言，形参f被初始化一个临时对象，而该临时对象被初始化为operator+()返回的值。下面是使用老式编译器进行编译时，程序18.2所示程序（删除了移动构造函数）的部分输出： 首先，在方法Useless::operator+()内，调用构造函数创建了temp，并在01C337C4出给它分配了存储30个元素的空间。然后，调用复制构造函数创建了一个临时复制信息（其地址为01C337E8），f指向该副本。接下来，删除了地址为01C337C4的对象temp。然后，新建了对象fout，它使用了01C337C4出刚释放的内存。接下来，删除了01C337E8处的临时对象参数。这表明，总共创建了三个对象，但其中的两个被删除。这些就是移动语义旨在消除的额外工作。 正如g++示例表明的，机制的编译器可能自动消除额外的复制工作，但通过使用右值引用，程序员可指出何时该使用移动语义。 18.2.4 赋值适用于构造函数的移动语义考虑也适用于赋值运算符。例如，下面演示了如何给Useless类编写复制赋值运算符和移动赋值运算符： Useless &amp; Useless::operator=(const Useless &amp; f) { if (this == &amp;f) return * this; delete [] pc; n = f.n; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = f.pc[i]; return *this; } Useless &amp; Useless::operator=(Useless &amp;&amp; f) { if (this == &amp;f) return * this; delete [] pc; n = f.n; pc = f.pc; f.n = 0; f.pc = nullptr; return * this; } 上述复制赋值运算符采用了第12章介绍的常规模式，而移动赋值运算符删除目标对象中的原始数据，并将源对象的所有权转让给目标。不能让多个指针指向相同的数据，这很重要，因此上述代码将源代码中的指针设置为空指针。 与移动构造函数一样，移动赋值运算符的参数也不能为const引用，因为这个方法修改源对象。 18.2.5 强制移动移动构造函数和移动赋值运算符使用右值。如果要让它们使用左值，该如何办呢？例如，程序可能分析一个包含候选对象的数组，选择其中一个对象供以后使用，并丢弃数组。如果可以使用移动构造函数或移动赋值运算符来保留选定的对象，那该多好。然而，假设您试图像下面这样做： Useless choices[10]; Useless best; int pick; ... best = choices[pick]; 由于choice[pick]是左值，因此上述赋值语句将使用复制赋值运算符，而不是移动赋值运算符。但如果能让choices[pick]看起来像右值，便将使用移动赋值运算符。为此，可使用运算符static_ cast&lt;&gt;将对象的类型强制转换为Useless &amp;&amp;，但C++11提供了一种简单的方式——使用头文件utility中声明的函数std::move()。程序18.3演示了这种技术，它在Useless类添加了啰嗦的赋值运算符，并让以前啰嗦的构造函数和析构函数保持沉默。 程序18.3 stdmove.cpp #include &lt;iostream&gt; #include &lt;utility&gt; using namespace std; class Useless { private: int n; char *pc; static int ct; void ShowObject() const; public: Useless(); explicit Useless(int k); Useless(int k, char ch); Useless(const Useless &amp; f); Useless(Useless &amp;&amp; f); ~Useless(); Useless operator+(const Useless &amp; f) const; Useless &amp; operator=(const Useless &amp; f); Useless &amp; operator=(Useless &amp;&amp; f); void ShowData() const; }; int Useless::ct = 0; Useless::Useless() { ++ct; n = 0; pc = nullptr; } Useless::Useless(int k) : n(k) { ++ct; pc = new char[n]; } Useless::Useless(int k, char ch) : n(k) { ++ct; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = ch; } Useless::Useless(const Useless &amp; f) : n(f.n) { ++ct; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = f.pc[i]; } Useless::Useless(Useless &amp;&amp; f) : n(f.n) { ++ct; pc = f.pc; f.pc = nullptr; f.n = 0; } Useless::~Useless() { delete [] pc; } Useless Useless::operator+(const Useless &amp; f)const { Useless temp = Useless(n + f.n); for (int i = 0; i &lt; n; i++) temp.pc[i] = pc[i]; for (int i = n; i &lt; temp.n; i++) temp.pc[i] = f.pc[i - n]; return temp; } Useless &amp; Useless::operator=(const Useless &amp; f) { if (this == &amp;f) return * this; delete [] pc; n = f.n; pc = new char[n]; for (int i = 0; i &lt; n; i++) pc[i] = f.pc[i]; return * this; } Useless &amp; Useless::operator=(Useless &amp;&amp; f) { if (this == &amp;f) return * this; delete [] pc; n = f.n; pc = f.pc; f.n = 0; f.pc = nullptr; return *this; } void Useless::ShowObject() const { cout &lt;&lt; &quot;Number of elements: &quot; &lt;&lt; n; cout &lt;&lt; &quot; Data address: &quot; &lt;&lt; (void *) pc &lt;&lt; endl; } void Useless::ShowData() const { if (n == 0) cout &lt;&lt; &quot;(object empty)&quot;; else for (int i = 0; i &lt; n; i++) cout &lt;&lt; pc[i]; cout &lt;&lt; endl; } int main() { { Useless one(10, &apos;x&apos;); Useless two = one + one; cout &lt;&lt; &quot;object one: &quot;; one.ShowData(); cout &lt;&lt; &quot;object two: &quot;; two.ShowData(); Useless three, four; cout &lt;&lt; &quot;three = one\n&quot;; three = one; cout &lt;&lt; &quot;now object three: &quot;; three.ShowData(); cout &lt;&lt; &quot;and object one: &quot;; one.ShowData(); cout &lt;&lt; &quot;four = one + two\n&quot;; four = one + two; cout &lt;&lt; &quot;now object four: &quot;; four.ShowData(); cout &lt;&lt; &quot;four = move(one)\n&quot;; four = move(one); cout &lt;&lt; &quot;now object four: &quot;; four.ShowData(); cout &lt;&lt; &quot;and object one: &quot;; one.ShowData(); } return 0; } 输出： object one: xxxxxxxxxx object two: xxxxxxxxxxxxxxxxxxxx three = one now object three: xxxxxxxxxx and object one: xxxxxxxxxx four = one + two now object four: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx four = move(one) now object four: xxxxxxxxxx and object one: (object empty) 正如您看到的，将one赋给three调用了复制赋值运算符，将将move(one)赋给four调用的是移动赋值运算符。 需要知道的是，函数std::move()并非一定会导致移动操作。例如，假设Chunk是一个保护私有数据类，而您编写了如下代码： Chunk one; ... Chunk two; two = std::move(one); 表达式std::move(one)是右值，因此上述赋值语句将调用Chunk的移动赋值运算符——如果定义了这种的运算符。但如果Chunk没有定义移动赋值运算符，编译器将使用复制赋值运算符。如果也没有定义复制赋值运算符，将根本不允许上述赋值。 对大多数程序员来说，右值引用带来的主要好处并非让他们能够编写使用右值引用的代码，而是能够使用利用右值引用实现移动语义的库代码。例如，STL类现在都有复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符。 18.3 新的类功能除本章前面提供的显式转换运算符和类内成员初始化外，C++11还新增了其他几个功能。 18.3.1 特殊的成员函数在原有4个特殊成员函数（默认构造函数、复制构造函数、复制赋值运算符和析构函数）的基础上，C++11新增了两个：移动构造函数和移动赋值运算符。这些成员函数是编译器在各种情况下自动提供的。 前面说过，在没有提供任何参数的情况下，将调用默认构造函数。如果您没有给类定义任何构造函数，编译器将提供一个默认构造函数。这种版本的默认构造函数被称为默认的默认构造函数。对于使用内置类型的成员，默认的默认构造函数不对其进行初始化；对于属于类对象的成员，则调用器默认构造函数。 另外，如果您没有提供复制构造函数，而代码又需要使用它，编译器将提供一个默认的复制构造函数；如果您没有提供移动构造函数，而代码又需要使用它，编译器将提供一个默认的移动构造函数。假定类名为Someclass，这两个默认的构造函数的原型如下： Someclass::Someclass(const Someclass &amp;); Someclass::Someclass(Someclass &amp;&amp;); 在类似的情况下，编译器将提供默认的复制运算符和默认的移动运算符，它们的原型如下： Someclass &amp; Someclass::operator(const Someclass &amp;); Someclass &amp; Someclass::operator(Someclass &amp;&amp;); 最后，如果您没有提供析构函数，编译器将提供一个。 对于前面描述的情况，有一些例外。如果您提供了析构函数、复制构造函数和复制赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符；如果您提供了移动构造函数或移动赋值运算符，编译器将不会自动提供复制构造函数和复制赋值运算符。 另外，默认的移动构造函数和移动赋值运算符的工作方式与复制版本类似：执行逐成员有初始化并复制内置类型。如果成员是类对，将使用相应类的构造函数和赋值运算符，就像参数为右值一样。如果定义了移动构造函数和移动赋值运算符，这将调用它们；否则将调用复制构造函数和复制赋值运算符。 18.3.2 默认的方法和禁用的方法C++11让您能够更好地控制要使用的方法。假定您要使用某个默认的函数，而这个函数由于某种原因不会自动创建。例如，您提供了移动构造函数，因此编译器不会自动创建默认的构造函数、复制构造函数和复制赋值运算符。在这些情况下，您可使用关键字default显式地声明这些方法的默认版本： class Someclass { public: Someclass(Someclass &amp;&amp;); Someclass() = default; Someclass(const Someclass &amp;) = default; Someclass &amp; operator(const Someclass &amp;) = default; ... }; 编译器将创建在您没有提供移动构造函数的情况下将自动提供的构造函数。 另一方面，关键字delete可用于禁止编译器使用特定方法。例如，要禁止复制对象，可禁用复制构造函数和复制赋值运算符： class Someclass { public: Someclass() = default; Someclass(const Someclass &amp;) = delete; Someclass &amp; operator=(const Someclass &amp;) = delete; Someclass(Someclass &amp;&amp;) = default; Someclass &amp; operator=(Someclass &amp;&amp;) = default; Someclass &amp; operator+(const Someclass &amp;) const; ... }; 第12章说过，要禁止赋值，可将赋值构造函数和赋值运算符放到类定义的private部分，但使用delete也能达到这个目的，且更不容易犯错、更容易理解。 如果在启动移动方法的同时禁用复制方法，结果将如何呢？前面说过，移动操作使用的右值引用只能关联到右值表达式，这意味着： Someclass one; Someclass two; Someclass three(one); //不被允许，one是一个左值 Someclass four(one + two);//允许，two是一个左值 关键字default只能用于6个特殊成员函数，但delete可用于任何成员函数。delete的一种可能用法是禁止特定的转换。例如，假设Someclass类有一个接受doubl参数的方法： class Someclass { public: void redo(double); ... }; 再假设有如下代码： Someclass sc; sc.redo(5); int值5被提升为5.0，进而执行方法redo()。 现在假设将Someclass类的定义改成了下面这样： class Someclass { public: ... void redo(double); void redo(int) = delete. ... }; 在这种情况下，方法调用sc.redo(5)与原型redo(int)匹配。编译器检测到这一点以及redo(int)被禁用后，将这种调用视为编译错误。着说明了禁用函数的重要一点：它们只用于查找匹配函数，使用它们将导致编译错误。 18。3.3 委托构造函数如果给类提供了多个构造函数，您可能重复编写相同的代码。也就是说，有些构造函数可能需要包含其他构造中已有的代码。为让编码工作更简单、更可靠，C++11允许您在一个构造函数的定义中使用另一个构造函数。这被称为委托，因为构造函数暂时将创建对象的工作委托给另一个构造函数。委托使用成员初始化列表语法的变种： class Notes { int k; double x; std::string st; public: Notes(); Notes(int); Notes(int, double); Noetes(int, double, std::string); }; Notes::Notes(int kk, double xx, std::string stt) : k(kk), x(xx), st(stt) {...} Notes::Notes() : Notes(0, 0.01, &quot;Oh&quot;) {...} Notes::Notes(int kk) : Notes(kk, 0.01, &quot;Oh&quot;) {...} Notes::Notes(int kk, double xx) : Notes(kk, xx, &quot;Oh&quot;) {...} 例如，上述默认构造函数使用第一个构造函数初始化数据成员并执行其函数体，然后再执行自己的函数体。 18.3.4 继承构造函数为进一步简化编码工作，C++11提供了一种让派生类能够继承基类构造函数的机制。C++98提供了一种让名称空间中函数可用的语法： namespace Box { int fn(int) {...} int fn(double) {...} int fn(const char *) {...} } using Box::fn; 这让fn的所有重载版本都可用。也可使用这种方法让基类的所有非特殊成员函数对派生类可用。 请看下面的代码： class C1 { ... public: int fn(int j) {...} double fn(double w) {...} void fn(const char * s) {...} ... }; class C2 : public C1 { ... public: using C1::fn; double fn(double) {...} ... }; C2 c2; int k = c2.fn(3); //使用C1::fn(int) double z = c2.fn(2.4); //使用C2::fn(double) C2中的using声明让C2对象可使用C1的三个fn()方法，但见选择C2而不是C1定义的方法fn(double)。 C++11将这种方法用于构造函数。让派生类继承基类的所有构造行（默认构造函数、复制构造函数和移动构造函数除外)，但不会使用与派生类构造函数的特征标匹配的构造函数： class BS { int q; double w; public: BS() : q(0), w(0) {} BS(int k) : q(k), w(100) {} BS(double x) : q(-1), w(x) {} BS(int k, double x) : q(k), w(x) {} void Show() const { std::cout &lt;&lt; q &lt;&lt; &quot;, &quot; &lt;&lt; w &lt;&lt; &apos;\n&apos;; } }; class DR : public BS { short j; public: using BS::BS; DR() : j(-100) {} DR(double x) : BS(2 * x), j(int(x)) {} DR(int i) : j(-2), BS(i, 0.5 * i) {} void Show() const { std::cout &lt;&lt; j &lt;&lt; &quot;, &quot; ; BS::Show(); } }; int main() { DR o1; //使用DR() DR o2(18.81); //使用DR(double) DR o3(10, 1.8); //使用BS(int, double); ... } 由于没有构造函数DR(int, double)，因此创建DR对象o3时，将使用继承而来的BS(int, double)。请注意，继承的基类构造函数只初始化基类成员；如果还要初始化派生类成员，则应使用成员列表初始化语法： DR(int i, int k, double x) : j(i), BS(k, x) {} 18.3.5 管理虚方法： overrid和final虚方法对实现多态类层次结构很重要，让基类引用或指针能够指向的对象类型相应的方法，但虚方法也带来了一些编译陷阱。例如，假设基类声明了一个虚方法，而您决定在派生类中提供不同的版本，这将覆盖就版本。但正如第13章讨论的，如果特征标不匹配，将隐藏而不是覆盖旧版本： class Action { int a; public: Action(int i = 0) : a(i) {} int val() const { return a; } virtual void f(char ch) const { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; endl; } }; class Bingo : public Action { public: Bingo(int i = 0) : Action(i) {} virtual void f(char * ch) const { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; &quot;!\n&quot;; } }; 由于类Bingo定义的f(char * ch)而不是f(char ch)，将对Bingo对象隐藏f(char ch)，这导致程序不能使用类似下面的代码： Bingo b(10); b.f(&apos;G&apos;); //Action对象可用，Bingo对象不可用 在C++11中，可使用虚说明符override指出您要覆盖一个虚函数：将其放在参数列表后面。如果声明与基类方法不匹配，编译器将视为错误。因此，下面的Bingo::f()版本生成一条编译错误信息： virtual void f(char * ch) const override { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; &quot;！\n&quot;; } 例如，在VS2010中，出现的错误消息如下： 说明符final解决了另一个问题。您可能想禁止派生类覆盖特定的虚方法，为此可在参数列表后面加上final。例如，下面的代码禁止Action的派生类重新定义函数f(): virtual void f(char ch) const final { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; &quot;!\n&quot;; } 说明符override和final并非关键字，而是具有特殊函数的标识符。这意味着编译将根据上下文确定它们是否有特殊含义；在其他上下文中，可将它们用作常规标识符，如变量名或枚举。 18.4 Lambda函数见到术语lambda函数（也叫lambda表达式，常简称为lambda）时，您可能怀疑C++11添加这项新功能旨在帮助编程新手。看到下面的lambda函数示例后，您可能鉴定了自己的怀疑： [&amp;count] (int x) { count += (x % 13 == 0);} 但lambda函数并不像看起来那么晦涩难懂，它们提供了一种有用的服务，对使用函数谓词的STL算法来说尤其如此。 18.4.1 比较函数指针、函数符和Lambda函数来看一个示例，它使用三种方法给STL算法传递信息：函数指针、函数符和lambda。出于方便的考虑，将这三种形式统称为函数对象，以免不断地重复“函数指针、函数符或lambda”。假设您要生成一个随机一个随机整数列表，并判断其中多少个整数可被3整除，多少个整数可被13整除。 生成这样的列表很简单。一种方法是，使用vector存储数字，并使用STL算法generate()在其中填充随机数： #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; ... std::vector&lt;int&gt; numbers(1000); std::generate(vector.begin(), vector.end(), std::rand); 函数generate()接受一个区间（由前两个参数指定），并将每个元素设置尾第三个参数返回的值，而第三个参数是是一个不接受任何参数的函数对象。再上述示例中，该函数对象是一个指向标准行rand()的指针。 通过使用算法count_ if()，很容易计算出有多少个元素可被3整除。与函数generate()一样，前两个参数应制定区间，而第三个参数应是一个返回true或false的函数对象。函数count_ if()计算这样的元素数，即它使得指定的函数对象返回true。为判断元素能否被3整除，可使用下面的函数定义： bool f3(int x) { return x % 3 == 0;} 同样，为判断元素能够被13整除，可使用下面的函数定义： bool f3(int x) { return x % 13 == 0; } 定义上述函数后，便可计算符合条件的元素数了，如下所示： int count3 = std::cout_if(numbers.begin(), numbers.end(), f3); cout &lt;&lt; &quot;Count of numbers divisible by 3: &quot; &lt;&lt; count3 &lt;&lt; endl; int count13 = std::cout_if(numbers.begin(), numbers.end(), f13); cout &lt;&lt; &quot;Count of numbers divisible by 13: &quot; &lt;&lt; count13 &lt;&lt; endl; 下面复习以下符合使用函数符来完成这个任务。第16章介绍过，函数符是一个类对象，并非只能像函数名那样使用它，这要归功于类方法operator()()。就这个示例而言，函数符的优点之一是，可使用同一函数符来完成这两项计数任务。下面是一种可能的定义： class f_mod { private: int dv; public: f_mod(int d = 1) : dv(d) {} bool operator()(int x) { return x % dv == 0; } }; 这为何可行呢？因为可使用构造函数创建存储特定整数值f_mod对象： f_mod obj(3); 而这个对象可使用operator()来返回一个bool值： bool is_div_by_3 = obj(7); 构造函数本身可用作诸如count_if()等函数的参数： count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3)); 参数f_ mode(3)创建一个对象，它存储了值3；而count_ if()使用该对象来调用operator()()，并将参数x设置为numbers的一个元素。要计算有多少个数字可被13（而不是3）整除，只需将第三个参数设置为f_ mod(13)。 最后，来看看使用lambda的情况。名称labda来自lambda calculus——一种定义和应用函数的数学系统。这个系统让您能够使用匿名函数——即无需给函数命名。在C++11中，对于接受函数指针或函数的函数，可使用匿名函数定义（lambda）作为其参数。与前述函数f3()对象的lambda如下： [] (int x) {return x % 3 == 0; } 这与f3()的函数定义很像： bool f3(int x) { return x % 3 == 0; } 差别有两个：使用[]替代了函数名（这就是匿名的由来）；没有声明返回类型。返回类型相当于使用decltype根据返回值推断得到的，这里为bool。如果lambda不包含返回语句，推断出的返回类型将为void。就这个示例而言，您将以如下方式使用lambda: count = std::count_if(numbers.begin(), numbers.end(), [](int x) {return x % 3 == 0; }); 也就是说，使用整个lambda表达式替换函数指针或函数符构造函数。 仅当lambda表达式完全由一条返回语句组成时，自动类型推断才管用；否则，需要使用新增的返回类型后置语法： [](double x) -&gt;double{int y = x; return x - y; } 程序18.4 lambda0.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;ctime&gt; const long Size1 = 39L; const long Size2 = 100 * Size1; const long Size3 = 100 * Size2; bool f3(int x) { return x % 3 == 0; } bool f13(int x) { return x % 13 == 0; } int main() { using namespace std; srand(time(0)); vector&lt;int&gt; numbers(Size1); generate(numbers.begin(), numbers.end(),rand); cout &lt;&lt; &quot;Sample size = &quot; &lt;&lt; Size1 &lt;&lt; endl; int count3 = count_if(numbers.begin(), numbers.end(), f3); cout &lt;&lt; &quot;Count of numbers divisible by 3: &quot; &lt;&lt; count3 &lt;&lt; endl; int count13 = count_if(numbers.begin(), numbers.end(), f13); cout &lt;&lt; &quot;Count of numbers divisible by 13: &quot; &lt;&lt; count13 &lt;&lt; endl &lt;&lt; endl; numbers.resize(Size2); generate(numbers.begin(), numbers.end(), rand); cout &lt;&lt; &quot;Sample size = &quot; &lt;&lt; Size2 &lt;&lt; endl; class f_mod { int dv; public: f_mod(int d = 1) : dv(d) {} bool operator()(int x) { return x % dv == 0; } }; count3 = count_if(numbers.begin(), numbers.end(), f_mod(3)); cout &lt;&lt; &quot;Count of numbers divisible by 3: &quot; &lt;&lt; count3 &lt;&lt; endl; count13 = count_if(numbers.begin(), numbers.end(), f_mod(13)); cout &lt;&lt; &quot;Count of numbers divisible by 13: &quot; &lt;&lt; count13 &lt;&lt; endl &lt;&lt; endl; numbers.resize(Size3); generate(numbers.begin(), numbers.end(), rand); cout &lt;&lt; &quot;Sample size = &quot; &lt;&lt; Size3 &lt;&lt; endl; count3 = count_if(numbers.begin(), numbers.end(), [](int x) { return x % 3 == 0; }); cout &lt;&lt; &quot;Count of numbers divisible by 3: &quot; &lt;&lt; count3 &lt;&lt; endl; count13 = count_if(numbers.begin(), numbers.end(), [](int x) { return x % 13 == 0;}); cout &lt;&lt; &quot;Count of numbers divisible by 13: &quot; &lt;&lt; count13 &lt;&lt; endl; return 0; } 输出： Sample size = 39 Count of numbers divisible by 3: 14 Count of numbers divisible by 13: 4 Sample size = 3900 Count of numbers divisible by 3: 1288 Count of numbers divisible by 13: 322 Sample size = 390000 Count of numbers divisible by 3: 129771 Count of numbers divisible by 13: 29687 输出表明，样本很小时，得到的统计数据并不可靠。 18.4.2 为何使用lambda您可能会问，除那些表达式狂热爱好者，谁会使用lambda呢？下面从4个方面探讨这个问题：距离、效率、简洁和功能。 很多程序员认为，让定义位于使用的地方附近很有用。这样，就无需翻阅很多页的源代码，以了解函数调用count_ if()的第三个参数了。另外，如果需要修改代码，涉及的内容都在附近；而剪切并粘贴代码以便在其他地方使用时，涉及的内容也在一起。从这种角度看，lambda是理想的选择，因为其定义和使用是在同一地方进行的；而函数是最糟糕的选择，因为受能在函数内部定义其他函数，因此函数的定义可能离使用它的地方很远。函数符是不错的选择，因为可在函数内部定义类（包含函数符类），因此定义离使用地点可以很近。 从简洁的角度看，函数符代码比函数和lambda代码更繁琐。函数和lambda的简洁程度相当，一个显而易见的例外是，需要使用一个lambda两次： count1 = std::count_if(n1.begin(), n1.end(), [](int x){ return x % 3 == 0; }); count2 = std::count_if(n2.begin(), n2.end(), [](int x){ return x % 3 == 0; }); 但并非必须编写lambda两次，而可给lambda指定一个名称，并使用该名称两次： auto mod3 = [](int x) { return x % 3 == 0; } count1 = std::count_if(n1.begin(), n1.end(), mod3); count2 = std::count_if(n2.begin(), n2.end(), mod3); 您甚至可以像使用常规函数那样使用有名称的lambda： bool result = mod3(z); 然而，不同于常规函数，可在函数内部定义有名称的lambda。mod3的实际类型随实现而异，它取决于编译器使用什么类型来跟踪lambda。 这三种方法的相对效率取决于编译器内联那些东西。函数指针方法组织了内联，因为编译器传统上不会内联其地址被获取的函数，因为函数地址的概念意味着非内联函数。而函数符和lambda通常不会阻止内联。 最后，lambda有一些额外的功能。具体来说，lambda可访问作用域内的任何动态变量；要捕获要使用的变量，可将其名称放在中括号中。如果只指定了变量名，如[z]，将按值访问变量；如果在名称前加上&amp;，如[&amp;count]，将按应用访问变量。[&amp;]让您能够按引用访问所有动态变量，而[=]让您能够按值访问所有动态变量。还可混合使用这两种方式，例如，[ted, &amp;ed]让您能够按值访问ted以及按引用访问ed，[&amp;, ted]让您能够按值访问ted，以及按引用访问其他所有动态变量，[=, &amp;ed]让您能够按引用访问ed以及按值访问其他所有动态变量。在程序18.4中，可将下述代码： int count13; ... count13 = std::count_if(numbers.begin(), numbers.end(), [](int x) {return x % 13 == 0; }); 替换为如下代码： int count13 = 0; std::for_each(numbers.begin(), numbers.end(), [&amp;count13](int x) { count13 += x % 13 == 0; }); [&amp;count13]让lambda能够在其代码中使用count13。由于count13是按引用捕获的，因此在lambda对count13所做的任何修改都将影响原始count13。如果x能被13整除，则表达式x % 13 == 0将为true，添加到count13中时，true将被转换为1。同样，false将被转换为0。因此，for_ each()将lambda应用于numbers的每个元素后，count13将为能被13整除的元素数。 通过利用这种计数，可使用一个lambda表达式计算可被3整除的元素和可被13整除的元素数： int count3 = 0; int count13 = 0; std::for_each(numbers.begin(), numbers.end(), [&amp;](int x) { count3 += x % 3 == 0; count13 += x % 13 == 0; }); 在这里，[&amp;]让您能够在lambda表达式中使用所有的自动变量，包括count3和count13。 在程序18.5中演示了如何使用这些技术。 程序 18.5 lambda1.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;ctime&gt; const long Size = 390000L; int main() { using std::cout; std::vector&lt;int&gt; numbers(Size); std::srand(std::time(0)); std::generate(numbers.begin(), numbers.end(), rand); cout &lt;&lt; &quot;Sample Size = &quot; &lt;&lt; Size &lt;&lt; std::endl; int count3 = std::count_if(numbers.begin(), numbers.end(), [](int x) { return x % 3 == 0; } ); cout &lt;&lt; &quot;Count of numbers divisible by 3: &quot; &lt;&lt; count3 &lt;&lt; std::endl; int count13 = 0; std::for_each(numbers.begin(), numbers.end(), [&amp;count13] (int x) { count13 += x % 13 == 0;}); cout &lt;&lt; &quot;Count of numbers divisible by 13: &quot; &lt;&lt; count13 &lt;&lt; std::endl; count3 = count13 = 0; std::for_each(numbers.begin(), numbers.end(), [&amp;] (int x) { count3 += x % 3 == 0; count13 += x % 13 == 0; }); cout &lt;&lt; &quot;Count of numbers divisible by 3: &quot; &lt;&lt; count3 &lt;&lt; std::endl; cout &lt;&lt; &quot;Count fo numbers divisible by 13: &quot; &lt;&lt; count13 &lt;&lt; std::endl; return 0; } 输出： Sample Size = 390000 Count of numbers divisible by 3: 130148 Count of numbers divisible by 13: 30035 Count of numbers divisible by 3: 130148 Count fo numbers divisible by 13: 30035 输出表明，该程序使用的两种方法（两个独立的lambda和单个lambda）的结果相同。 在C++中引入lambda的主要目的是，让您能够将类似于函数的表达式用作接受函数指针或函数符的函数的参数。因此，典型的lambda是测试表达式或比较表达式，可编写为一条返回语句。这使得lambda简洁易于理解，且可自动推断返回类型。然而，有创意的C++程序员可能开发出其他用法。 18.5 包装器C++提供了多个包装器（wrapper，也叫适配器[adapter]）。这些对象用于给其他编程接口提供更一致或更合适的接口。例如，第16章讨论了bind1st和bind2ed，它们让接受两个参数的函数能够与这样的STK算法匹配，即它要求将接受一个参数的函数作为参数。C++11提供了其他的包装器，包括模板bind、men_ fn和reference_ wrapper以及包装器function。其中模板bind可替代bind1st和bind2ed，但更灵活；模板mem_ fn让您能够将成员函数作为常规函数进行传递；模板reference_ wrapper让您能够创建行为像应用但可被复制的对象；而包装器function让您能够以统一的方式处理多种类似于函数的形式。 下面更详细地介绍包装器function及其解决的问题。 18.5.1 包装器function及模板的低效性请看下面的代码行： answer = ef(q); ef是什么呢？它可以是函数名、函数指针、函数对象或有名称的lambda表达式。所有这些都是可调用的类型（callable type）。鉴于可调用的类型如此丰富，这可能导致模板的效率极低。为明白这一点，来看一个简单的案例。 首先，在头文件中定义一些模板，如程序18.6所示。 程序18.6 somedefs.h #include &lt;iostream&gt; template&lt;class T, class F&gt; T use_f(T v, F f) { static int count = 0; count++; std::cout &lt;&lt; &quot; use_f count = &quot; &lt;&lt; count &lt;&lt; &quot;, &amp;count = &quot; &lt;&lt; &amp;count &lt;&lt; std::endl; return f(v); } class Fp { private: double z_; public: Fp(double z = 1.0) : z_(z) {} double operator() (double p) { return z_ * p;} }; class Fq { private: double z_; public: Fq(double z = 1.0) : z_(z) {} double operator() (double q) { return z_ + q; } }; 模板use_f使用参数f表示调用类型： return f(v); 接下来，程序18.7所示的程序调用模板函数use_f()6次。 程序18.7 callable.cpp #include &lt;iostream&gt; #include &quot;somedefs.h&quot; double dub(double x) { return 2.0 * x; } double square(double x) { return x * x; } int main() { using std::cout; using std::endl; double y = 1.21; cout &lt;&lt; &quot;Function pointer dub:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, dub) &lt;&lt; endl; cout &lt;&lt; &quot;Function pointer square:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, square) &lt;&lt; endl; cout &lt;&lt; &quot;Function object Fp:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, Fp(5.0)) &lt;&lt; endl; cout &lt;&lt; &quot;Function ojbect Fq:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, Fq(5.0)) &lt;&lt; endl; cout &lt;&lt; &quot;Lambda expression 1:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, [](double u) {return u * u;}) &lt;&lt; endl; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, [](double u) {return u + u/2.0;}) &lt;&lt; endl; return 0; } 输出： Function pointer dub: use_f count = 1, &amp;count = 0x6021a0 2.42 Function pointer square: use_f count = 2, &amp;count = 0x6021a0 1.4641 Function object Fp: use_f count = 1, &amp;count = 0x6021a4 6.05 Function ojbect Fq: use_f count = 1, &amp;count = 0x6021a8 6.21 Lambda expression 1: use_f count = 1, &amp;count = 0x602198 1.4641 use_f count = 1, &amp;count = 0x60219c 1.815 在每次调用中，模板参数T都被设置为类型double。模板参数F呢？每次调用时，F都接受一个double值并返回一个double值，因此在6次use_f()调用中，好像F的类型都相同，因此指挥实例化模板依次。但根据上面的输出表明，这种想法太天真了。 模板函数use_ f()有一个静态成员count，可根据它的地址确定模板实例化了多少次。有5个不同的地址，这表明模板use_ f()有5个不同的实例化。 为了解其中的原因，请考虑编译器如何判断模板参数F的类型。首先，来看下面的调用： use_ f(y, dub); 其中dub是一个函数名称，该函数接受一个double参数并返回一个double值。函数名是指针，因此参数F的类型为double($\ast$)(double)：一个指向这样的函数的指针，即它接受一个double参数并返回一个double值。 第二个参数的类型也是double($\ast$)(double)，因此该调用使用的use_ f()实例化与第一个调用相同。 在接下来的两个use_ f()调用中，第二个参数为对象，F的类型分别为Fp和Fq，因为将为这些F值实例化use_ f()模板两次。最后，最后两个调用将F的类型设置编译器为lambda表达式使用的类型。 18.5.2 修复问题包装器function让您能够重写上述程序，使其只使用use_ f()的一个实例化而不是5个。注意到程序18.7中的函数指针、函数对象和lambda表达式有一个相同的地方，它们都接受一个double参数并返回一个double值。可以说它们的调用特征标（call signature）相同。调用特征标是返回类型以及用括号括起来并用逗号分隔的参数类型列表定义的，因此这6个实例的调用特征标都是double(double)。 模板function是在头文件functional中声明的，它从调用特征标的角度定义了一个对象，可用于包装调用特征标相同的函数指针、函数对象或lambda表达式。例如，下面的声明创建一个名为fdci的function对象，它接受一个char参数和一个int参数，并返回一个double值： std::functional&lt;double(char, int)&gt; fdci; 然后，可以将接受一个char参数和一个int参数，并返回一个车double值得任何函数指针、函数对象或lambda表达式赋给它。 在程序18.7中，所有调用参数的调用特征标都相同：double(double)。要修复程序18.7以减少实例化次数。可使用function&lt;double(double)&gt; 创建六个包装器，用于表示6个函数、函数符和lambda。这样，在对use_ f()的全部6次调用中，让F的类型都相同（function&lt;double(double)&gt;），因此只实例化一次。据此修改后的程序如程序18.8所示。 程序18.8 wrapped.cpp #include &lt;iostream&gt; #include &lt;functional&gt; #include &quot;somedefs.h&quot; double dub(double x) { return 2.0 * x; } double square(double x) { return x * x; } int main() { using std::cout; using std::endl; using std::function; double y = 1.21; function&lt;double(double)&gt; ef1 = dub; function&lt;double(double)&gt; ef2 = square; function&lt;double(double)&gt; ef3 = Fp(10.1); function&lt;double(double)&gt; ef4 = Fq(10.0); function&lt;double(double)&gt; ef5 = [](double u) { return u * u; }; function&lt;double(double)&gt; ef6 = [](double u) { return u * u / 2.0; }; cout &lt;&lt; &quot;Function pointer dub:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, ef1) &lt;&lt; endl; cout &lt;&lt; &quot;Function pointer square:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, ef2) &lt;&lt; endl; cout &lt;&lt; &quot;Function object Fp:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, ef3) &lt;&lt; endl; cout &lt;&lt; &quot;Function ojbect Fq:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, ef4) &lt;&lt; endl; cout &lt;&lt; &quot;Lambda expression 1:\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, ef5) &lt;&lt; endl; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f(y, ef6) &lt;&lt; endl; return 0; } 输出： Function pointer dub: use_f count = 1, &amp;count = 0x6042ac 2.42 Function pointer square: use_f count = 2, &amp;count = 0x6042ac 1.4641 Function object Fp: use_f count = 3, &amp;count = 0x6042ac 12.221 Function ojbect Fq: use_f count = 4, &amp;count = 0x6042ac 11.21 Lambda expression 1: use_f count = 5, &amp;count = 0x6042ac 1.4641 use_f count = 6, &amp;count = 0x6042ac 0.73205 从上述输出可知，count的地址都相同，而count的值表明，use_ f()被调用了6次。这表明只有一个实例，并调用了该实例6次，这缩小了可执行代码的规模。 18.5.3 其他方式下面介绍使用function可完成的其他两项任务。首先，在程序18.8中，不用声明6个function&lt;double(double)&gt;对象，而只是使用一个临时function&lt;double(double)&gt;对象，将其用作函数use_f()的参数： typedef function&lt;doubel(double)&gt; fdd; cout &lt;&lt; use_f(y, fdd(dub)) &lt;&lt; endl; cout &lt;&lt; use_f(y, fdd(square)) &lt;&lt; endl; ... 其次，程序18.8让use_ f()的第二个参数与形参f匹配，但另一个方法是让形参f的类型与原始实参匹配。为此，可在模板use_ f()的定义中，将第二个参数声明为function包装器对象，如下所示： #include &lt;functional&gt; template&lt;class T&gt; T use_f(T v, std::function《T(T)&gt; f) { static int count = 0; count++; std::cout &lt;&lt; &quot; use_f count = &quot; &lt;&lt; count &lt;&lt; &quot;, &amp;count = &quot; &lt;&lt; &amp;count &lt;&lt; std::endl; return f(v); } 这样调用函数将如下： cout &lt;&lt; &quot; &quot; &lt;&lt; use_f&lt;double&gt;(y, dob) &lt;&lt; endl; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f&lt;double&gt;(y, Fq(5.0)) &lt;&lt; endl; cout &lt;&lt; &quot; &quot; &lt;&lt; use_f&lt;double&gt;(y, [](doubel u) {return u*u;}) &lt;&lt; endl; 参数dub、Fq(5.0)等本身的类型并不是function&lt;double(double)&gt;，因此在use_ f后面使用了来指出所需的具体化。这样，T被设置为double，而std::function&lt;T(T)&gt;变成了std::function&lt;double(double)&gt;。 18.6 可变参数模板可变参数模板（variadic template）让您能够创建这样的模板函数和模板类，即可接收可变数量的参数。这里介绍可变参数模板函数。例如，假设要编写一个函数，它可接收任意数量的参数，参数的类型只需是cout能够显式的即可，并将参数显式为逗号分隔的列表。请看下面的代码： int n = 14; double x = 2.71829; std::string mr = &quot;Mr, string object!&quot;; show_list(n, x); show_list(x*x, &apos;!&apos;, 7, mr); 这里的目标是，定义show_ list()，让代码能够通过编译并生成如下输出： 14， 2.71829 7.38905， ！， 7， Mr, string object! 要创建可变参数模板，需要理解几个要点： 模板参数包（parameter pack）; 函数参数包； 展开（unpack）参数包； 递归。 18.6.1 模板和函数参数包为理解参数包的工作原理，首先来看一个简单的模板函数，它显示一个只有一项的列表： template&lt;typename T&gt; void show_list0(T value) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } 在上述定义中，有两个参数列表。模板参数列表只包含T，而函数参数列表只包含value。下面的函数调用将模板参数列表中的T设置为double，将函数参数列表中的value设置为2.15: show_list0(2.15); C++11提供了一个用省略号表示的元运算符（meta-operator），让您能够声明表示模板参数包的标识符，模板参数包基本上是一个类型列表。同样，它还让您能够表示函数参数包的标识符，而函数参数包基本上是一个值列表。其语法如下： template &lt;typename...Args&gt; void show_list(Args... args) { ... } 其中，Arg是一个模板参数包，而args是一个函数参数包。与其他参数名一样，可将这些参数包的名称指定为任何符合C++标识符规则的名称。Args和T的差别在于，T与一种类型匹配，而Args与任意数量（包括零）的类型匹配。请看下面的函数调用： show_list1(&apos;S&apos;, S0, &quot;Sweet&quot;, 4.5); 在这种情况下，参数包Args包含与函数调用中的参数匹配的类型： char、int、const char$\ast$和double。 下面的代码指出value的类型为T: void show_list0(T value) 同样，下面的代码指出args的类型为Args: void show_list1(Args...args) //args是一个函数参数包 更准确地说，这意味着函数参数包args包含的值列表与模板参数包Args包含的类型列表匹配——无论是类型还是数量。在上面的示例中，args包含’S’, 80, “sweet”和4.5。 这样，可变参数模板show_ list1()与下面的函数调用都匹配： show_list1(); show_list1(99); show_list1(88.5, &quot;cat&quot;); show_list1(2, 4, 6, 8, &quot;who do we&quot;, std::string(&quot;appreciate&quot;)); 就最后一个函数调用而言，模板参数包Args包含类型int、int、int、int、const char$\ast$和std::string，而函数参数包args包含值2、4、6、8、”who do we”和std::string(“appreciate”)。 18.6.2 展开参数包但函数如何访问这些包的内容呢？索引功能在这里不适用，即您不能使用Args[2]来访问包中的第三个元素类型。相反，可将省略号放在函数参数包的右边，将参数包展开。例如，请看下述有缺陷的代码： template&lt;typename... Args&gt; void show_list1(Args... args) { show_list1(args...); } 这是什么意思呢？为何说存在缺陷？假设有如下函数调用： show_list1(5, &apos;L&apos;, 0.5); 这将把5、’L’和0.5封装到args中。在该函数内部，下面的调用： show_list1(args...); 将展开成如下所示： show_list1(6, &apos;L&apos;, 0.5); 也就说说，args被替换为三个存储在args中的值。因此，表示法args…展开为一个函数参数列表。不幸的是，该函数调用与原始函数调用相同，因此它将使用相同的参数不断调用自己，导致无限递归（这存在缺陷）。 18.6.3 在可变参数模板函数中使用递归虽然前面递归让show_ list1()成为有用函数的希望破灭，但正确使用递归为访问参数包的内容提供了解决方案。这里的核心理念是，将函数参数包展开，对列表中的第一项进行处理，再将余下的内容传递给递归调用，依此类推，直到列表为空。为常规递归一样，确保递归将终止很重要。这里的技巧是将模板头改为如下所示： tempalte&lt;typename T, typename... Args&gt; void show_list3(T value, Args... args) 对于上述定义，show_list3()的第一个参数决定了T和value的值，而其他实参决定了Args和args的值。这让函数能够对value进行处理，如显示它。然后，可递归调用show _list3()，并让args…的方式将它实参传递给它。每次递归调用都将显式一个值，并传递缩短了的列表，直到列表为空为止。程序18.9提供了一种实现，它虽然不完美，但演示了这种技巧。 程序18.9 variadic1.cpp #include #include void show_list3() {} template void show_list3(T value, Args… args){ std::cout &lt;&lt; value &lt;&lt; “, “; show_list3(args…);} int main(){ int n = 14; double x = 2.71828; std::string mr = “Mr. String objects!”; show_list3(n, x); std::cout &lt;&lt; std::endl; show_list3(x*x, ‘!’, 7, mr); std::cout &lt;&lt; std::endl; return 0;} 输出： 14, 2.71828, 7.38905, !, 7, Mr. String objects!, 1. 程序说明请看下面的函数调用： show_list3(x*x, &apos;!&apos;, 7, mr); 第一个实参导致T为double，value为x$\ast$x。其他三种类型（char、int和std::string）将放入Args包中，而其他三个值(‘!’、7和mr)将放入args包中。 接下来，函数show_ list3()使用cout显式value(大约为7.38905)和字符串‘“，”。这完成了显式列表中第一项的工作。 接下来是下面的调用： show_list3(args...); 考虑到args…的展开作用，这与如下代码等价： show_list3(&apos;!&apos;,7,mr); 前面说过，列表将每次减少一项。这次T和value分别为char和‘！’，而余下的两种类型和两个值分别被包装到Args和args中，下次递归调用将处理这些搜小了的包。最后，当args为空时，将调用不接受任何参数的show_ lsit3()，导致处理结束。 2. 改进可对show_ list3()做两方面的改进。当前，该函数在列表的每项后面显式一个逗号，但如果能省去最后一项后面的头号就好了。为此，可添加一个处理一项的模板，并让其行为与通用模板稍有不同： template&lt;typename T&gt; void show_list3(T value) { std::cout &lt;&lt; value &lt;&lt; &apos;\n&apos;; } 这样，当args包缩短到只有一项时，将调用这个版本，而它打印换行符而不是逗号。另外，由于没有递归调用show_list3()，它也将终止递归。 另一个改进的地方是，当前的版本按值传递一切。对于这里使用的简单类型来说，这没问题，但对于cout可打印的大型类来说，这样做效率很低。在可变参数模板中，可指定展开模式（pattern）。为此，可将下述代码： show_list3(Args... args); 替换为如下代码： show_list3(const Args&amp;... args); 这将对每个参数应用模式const &amp;。这样，最后分析的参数将不是std::string mr，而是const std::string &amp; mr。 程序 18.10 variadic2.cpp #include &lt;iostream&gt; #include &lt;string&gt; void show_list3() {} template &lt;typename T&gt; void show_list3(const T &amp; value) { std::cout &lt;&lt; value &lt;&lt; std::endl; } template &lt;typename T, typename... Args&gt; void show_list3(const T &amp; value, const Args&amp;... args) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; show_list3(args...); } int main() { int n = 14; double x = 2.71828; std::string mr = &quot;Mr. String objects!&quot;; show_list3(n, x); std::cout &lt;&lt; std::endl; show_list3(x*x, &apos;!&apos;, 7, mr); std::cout &lt;&lt; std::endl; return 0; } 输出： 14, 2.71828 7.38905, !, 7, Mr. String objects! 18.7 C++11新增的其他功能C++11增加了很多功能，本书无法全面介绍；另外，本书编写期间，其中很多功能还未得到广泛实现。然而，有些功能有必要简要地介绍一下。 18.7.1 并行编程当前，为提高计算机性能，增加处理器数量比提供处理器速度更容器。因此，装备了双核、四核处理器甚至多个多核处理起的计算机很常见，这让计算机能够同时执行多个线程，其中一个处理起可能处理视频下载，而另一个处理器处理电子表格。 有些操作能受益于多线程，但有些不能。考虑单项链表的搜索：程序必须从链表开头开始，沿链接依次向下搜索，直到到达链表末尾；在这种情况下，多线程的帮助不大。再来看未经排序的数组。考虑到数组的随机存储特征，可让一个线程从数组开头开始搜索，并让另一个线程从数组中间开始搜索，这将让搜索时间减半。 多线程确实带来了很多问题。如果以线程挂起或两个线程试图同时访问同一项数据，结果如何呢？为解决并行性问题，C++定义了一个支持线程化执行的内存模型，添加了关键字thread_ local，提供了相关的库支持。关键字thread_ local将变量声明为静态存储，其持续性与特定线程相关；即定义这种变量的线程过期时，变量也将过期。 库支持由原子操作（atomic operation）库和线程支持库组成，其中原子操作库提供了头文件atomic，而线程支持库提供了头文件threa、mutex、condition_ variable和future。 18.7.2 新增的库C++添加了多个专用库。头文件random支持的可扩展随机数库提供了大量比rand()复杂的随机数工具。例如，您可以选择随机数生成器和分布状态，分布状态包括均匀分布（类似于rand()）、二项分布和正态分布。 头文件chrono提供了处理时间间隔的途径。 头文件tuple支持模板tuple。tuple对象是广义的pair对象。pari对象可存储两个类型不同的值，而tuple对象可存储任意多个类型不同的值。 头文件ratio支持编译器阶段有理数算术库让您能够准确地表示任何有理数，其分子和分母可用最宽的整型表示。它还支持对这些有理数进行算术运算。 在新增的库中，最有趣的一个是头文件regex支持的正则表达式库。正则表达式指定了一种模式，可用于与文本字符串的内容匹配。例如，方括号表达式与方括号中的任何单个字符匹配，因此[cCkk]与c、C、k和K都匹配，而[cCKk]at与单词cat、Cat、kat和Kat都匹配。其他模式包括一位数字匹配的\d、与一个单词匹配的\w、与制表符匹配的\t等。在C++中，斜杠具有特殊含义，因此对于模式\d\t\w\d（即依次为一位数字、制表符、单词和意味数字），必须写成字符字面量“\d\t\w\d”，即使用\表示\。这是引入原始字符串的原因之一（参见第4章），它让您能够将该模式写成R”\d\t\w\d”。 ed、grep和awk等UNIX工具都是用正则表达式，而解释型语言Perl扩展了正则表达式的功能。C++正则表达式库让您能够选择多种形式的正则表达式。 18.7.3 低级编程低级编程中的“低级”指的是抽象编程，而不是编程质量。低级意味着接近于计算机硬件和机器语言使用的比特和字节。对于嵌入式编程和该少操作的效率而言，低级编程很重要。C++11给低级编程任意提供了以下帮助。 变化之一是放松了POD(Plain Old Data)的要求。在C++98中，POD是标量类型（单值类型，如int或double）或没有构造函数、基类、私有数据、虚函数等的老式结构。以前的理念是，POD是可安全地逐字节复制的东西。这种理念没变，但C++11认识到，在满足C++98的某些约束的情况下，仍可以是合法的POD。这有助于低级编程，因为有些低级操作（如使用C语言函数进行逐字节复制或二进制I/O）要求处理对象为POD。 另一项修改是，允许共用体的成员有构造函数和析构函数，这让共用体更灵活；但保留了其他一些限制，如成员不能有虚函数。在需要最大程度地减少占用的内存时，通常使用共用体；上述新规则在这些情况下给程序员有更大的灵活性和功能。 C++11解决了内存对齐问题。计算机系统可能对数据在内存中的存储方式有一定的限制。例如，一个系统eng要求double值的内存地址为偶数，而另一个系统可能要求其起始位置为8的整数倍。要获悉有关类型或对象的对齐要求，可使用运算符alignof()(参见附录E)。要控制对齐方式，可使用说明符alignas。 constexpr机制让编译器能够在编译阶段计算结果为常量的表达式，让const常量可存储在只读内存中，这对嵌入式编程来说很有用（在运行阶段初始化的变量存储在随机访问内存中）。 18.7.4 杂项C99引入了依赖于实现的扩展整型，C++11继承了这种传统。在使用128位整数的系统中，可使用这样的类型。在C语言中，扩展类型由头文件stdint.d。 C++11提供了一种创建用户自定义字面量的机制：字面量运算符（literal operator）。使用这种机制可定义二进制字面量，如1001001b，相应的字面量运算符将把它转换为整数值。 C++提供了调试工具assert。这是一个宏，它在运行阶段对断言进行检查，如果为true，则显示一条消息，否则调用abort()。断言通常是程序员认为在程序的某个阶段应为true的东西。C++新增了关键字static_ assert，可用于在编译阶段对断言进行测试。这样做的主要目的在于，对于在编译阶段（而不是运行阶段）实例化的模板，调试起来将更简单。 C++11加强了对元编程（metaprogramming）的支持。元编程指的是编写这样的程序，它创建或修改其他程序，甚至修改自身。在C++中，可使用模板在编译阶段完成这种工作。 18.8 语言变化计算机语言是如何成长和发展的呢？C++的使用范围足够广后，显然需要国际标准，并将其控制权交给标准委员会：最初是ANSI委员会，随后是ISO/ANSI联合委员会，当前是ISO/IEC JTC1/SC22/WG21(C++标准委员会)。ISO是国际标准组织，IEC是国安吃电子基数委员会，JEC1是前两家组织组建的联合技术委员会1，SC22是JTC1下属的编程语言委员会，而WG21是SC22下属的C++工作小组。 委员会考虑缺陷报告和有关语言修改和扩展的提议，并试图达成一致。这个过程既繁琐又漫长，《The Dsign and Evoluation of C++》（Stroustrup, Addison-Wesley, 1994）介绍了这方面的一些情况。寻求一致的委员会沉闷而争议不断，可能不是鼓励创新的好方式，这也不是标准委员会应扮演的角色。 但就C++而言，还有另一种变更的途径，那就是充满创意的C++编程社区的直接行动。程序员无法不受羁绊地改进语言，但可创建有用的库。设计良好的库可改善语言的用途和功能，提高可靠性，让编程跟容易、更有乐趣。库是在现有语言功能的基础上创建的，不需要额外的编译器支持。如果库是通过模板实现的，则可以头文件（文本文件）的方式分发。 一项这样的变革是STL，它主要是Alexander Stepanov创建的，Hewlett-Packard免费提供它。STL在编程社区获得了巨大成功，成为了第一个ANSI/ISO标准的候选内容。事实上，其设计影响新标准的其他方面。 18.8.1 Boost项目最近，Booset库成了C++编程的重要部分，给C++11带来了深远影响。Boost项目发起于1998年，当时的C++库工作小组主席Beman Dawes召集其他几位小组成员指定了一项计划，准备在标准委员会的框架外创建新库。该计划的基本理念是，创建一个充当开放论坛的网站，让人发布免费的C++库。这个项目提供有关许可和编程实践的指南，并要求对提议的库进行同行审阅。其最终的成果是，一系列得到高度赞扬和广泛使用的库。这个项目提供了一个环境，让编程社区能够检验和评估编程理念以及提供反馈。 18.8.2 TR1TR1（Technical Report 1）是C++标准委员会的部分成员发起的一个项目，它是一个库扩展选集，这些扩展于C++98标准兼容，但不是必不可少的。这些扩展是下一个C++准备的候选内容。TR1库让C++社区能够检验其组成部分的价值。当标准委员会将RT1的大部分内容融入C++11时，面对的是众所周知且经过实践检验的库。 在TR1中，Boost库占了很大一部分。这包括模板类tuple和array、模板bind和function、智能指针（对名称和实现做了一定修改）、static_ assert、regex库和random库。另外，Boost社区和TR1用户的经验也导致了实际的语言变更，如异常规范的摒弃和可变参数模板的添加，其中可变参数模板让tuple模板类和function模板的实现更好了。 18.8.3 使用Boost虽然在C++11中，可访问Boost开发的众多库，但还有很多其他的Boost库。例如，Conversion库中的lexical_ cast让您能够在数值和字符串类型之间进行简单地转换，其语法类似于dynamic_ cast：将模板参数指定为目标类型。程序18.11是一个简单的示例。 程序18.11 lexcast.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;boost/lexical_cast.hpp&quot; int main() { using namespace std; cout &lt;&lt; &quot;Enter your weight: &quot;; float weight; cin &gt;&gt; weight; string gain = &quot;A 10% increase raises &quot;; string wt = boost::lexical_cast&lt;string&gt;(weight); gain = gain + wt + &quot;to&quot;; weight = 1.1 * weight; gain = gain + boost::lexical_cast&lt;string&gt;(weight); cout &lt;&lt; gain &lt;&lt; endl; return 0; } 输出： 由于本地没有安装boost，所以程序无法运行！！ 第二次运行的结果凸显了lexical_ cast的局限性：它未能很好地控制符点数的格式。为控制浮点数的格式，需要使用更精致的内核格式化工具，这在第17章讨论过。 还可以使用lexical_ cast将字符串转换为数值。 显然，Boost提供的功能比这里介绍的要多得多。例如，Any库让您能够在STL容器中存储一系列不同类型的值和对象，方法是将Any模板用作各种值的包装器。Math库在标准math库的基础上增加了数字函数。Filesystem库让您编写的代码可在使用不同文件系统的平台之间移植。有关这个库以及如何将其加入到各种平台的更详细信息，请参阅Boost网站（www.boost.org）。另外，有些C++编程器（如Cygwin编译器）还自带了Boost库。 18.9 接下来的任务如果仔细阅读了本书，则应很好地掌握了C++的规则。然而，这仅仅是学习这种语言的开始，接下来需要学习如何高效地使用该语言，这样的路还很长。最好的情况是，工作或学习环境您能够接触有些的C++代码和程序员。另外，了解C++后，便可以阅读一些介绍高级主题和面向对象编程的书籍，附录H列出了一些这样的资源。 OOP有助于开发大型的项目，并提高其可靠性。OOP方法的基本活动之一是发明能够表示正在模拟的情形（被称为问题域（problem domain））的类。由于实际问题通常很复杂，因此找到适当的类富有挑战性。创建复杂的系统时，从空白开始通常不可行，最好采用逐步迭代的方式。为此，该领域的实践者开发了多种技术和策略。具体地说，重要的是在分析和设计阶段完成尽可能多的迭代工作，而不要不断地修改实际代码 常用的技术有两种：用例分析（use-case analysis）和CRC卡（CRC card）。在用例分析中，开发小组列出了常见的使用方法和最终系统将用于的场景；找出元素、操作和职责，以确定可能要使用的类和类特性。CRC（Class/Responsibilities/Collaborators的简称）卡片是一种分析场景的简单方法。开发小组为每个类创建索引卡片，卡片上列出了类名、类责任（如表示的数据和执行的操作）以及类的协作者（如必须与之交互的其他类）。然后，小组使用CRC卡片提供的接口模拟场景。这可能提供新的类、转换责任等。 在更大的规模上，是用于整个项目的系统方法。在这方面，最新的工具是统一建模语言（Unified Modeling Language, UML），它不是一种编程语言，而是一种用于编程项目的分析和设计语言，是由Grady Booch、Jim Rumbaugh和Ivar Jacobson开发的，他们分别是更早的3中建模语言（Booch Method、OMT（对象建模技术，Object Modeling Technique）和OOSE（面对对象的软件工程, Object-Oriented Software Engineering））的主要开发人员。UML是从这3中语言演化而来的，于2005年倍ISO/IEC批准为标准。 除加深对C++的总体理解外，还可能需要学习特定的类库。例如，Microsoft和Embarcadero提供了大量简化Windows编程的类库，而Apple Xode提供了简化Apple平台（如iPhone）编程的类库。 18.10 总结C++新增的功能： 大括号括起来的统一列表初始化 智能指针： auto_ptr, unique_ptr, shared_ptr 自动推断类型： auto 基于范围的for循环 设置默认和禁用的方法、委托构造函数、继承构造函数 虚函数设计中使用的说明符 override 、 final lambda 模板function decltype]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--输入、输出和文件（十七）]]></title>
    <url>%2F2019%2F03%2F08%2FC%2B%2B%20Primer%20Plus--%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对C++输入和输出（简称I/O）的讨论提出了一个问题。一方面，几乎每个程序都要使用输入和输出，因此了解如何使用它们是每个学习计算机语言的人面临的首要任务；另一个方面，C++使用了很多较为高级的语言特性来实现输入和输出，其中包括：类、派生类、函数重载、模板和多重继承。 17.1 C++输入和输出概述多数计算机语言的输入和输出是以语言本身为基础实现的。例如，从诸如BASIC和Pascl等语言的关键字列表中可知，PRINT语言、WriteIn语言以及其他类似的语言都是语言词汇表的组成部分，但C和C++都没有输入和输出建立在语言中。这两种语言的关键字包括for和if，但不包括与I/O有关的内容。C语言最初把I/O留给了编译器实现人员。这样做的一个原因是为了让实现人员能够自由的设计I/O函数，使之最适合于目标计算机的硬件要求。实际上，多数实现人员都把I/O建立在最初的UNIX环境开发的库函数的基础之上。ANSI C正式承认这个I/O软件包时，将其称为标准输入/输出包，并将其作为标准C库不可或缺的组成部分。C++也认可这个软件包，因此如果熟悉stdio.h文件中声明的C函数系列，则可以在C++中使用它们（较新的实现使用头文件cstdio来支持这些函数）。 然而，C++依赖于C++的I/O解决方案，而不是C语言的I/O解决方案，前者是在头文件iostream和fstream中定义组类。这个类库不是正式语言定义的组成部分（cin和istream不是关键字）：毕竟计算机语言定义了如何工作的规则，但没有定义应按照这些规则创建哪些东西。然而，正如C实现自带了一个标准函数库一样，C++也自带了一个标准类库。首先，标准类库是一个非正式的标准，只是由头文件iostream和fstream中定义的类组成的。ANSI/ISO C++委员会决定把这个类正式作为一个标准类库，并添加其他一些标准类，如第16章讨论的那些类。本章将讨论标准C++ I/O。但首先看一看C++ I/O的概念框架。 17.1.1 流和缓存区C++程序把输入和输出看作字节流。输入时，程序从流中抽取字节；输出时，程序将字节插入到输出流中。对于面向文本的程序，每个字节代表一个字符，更通俗地讲，字节可以构造字符或数值数据的二进制表示。输入流中的字节可能来自键盘，也可能来自存储设备或其他程序。同样，输出流中的字节可以流向屏幕、打印机、存储设备或其他程序。流充当了程序和流源或流目标之间的桥梁。这使得C++程序可以以相同的方式对待来自键盘的输入和来自文件的输入。C++程序只检查字节流，而不需要知道字节来自何方。同理，通过使用流，C++程序处理输出的方式将独立于其去向。因此管理输入包含两步： 将流与输入去向的程序关联起来。 将流域文件关联起来。 换句话说，输入流需要两个连接，每端各一个。文件端连接提供流的来源，程序端连接将流的流出部分转储到程序中（文件端连接可以是文件，也可以是设备，如键盘）。 同样，对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来。这就像将字节（而不是水）引入到水管中。（参见图17.1） 通常，通过使用缓冲区可以更高效地处理输入和输出。缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输到设备的临时存储工具。通常，像磁盘驱动器这样的设备以512字节（或更多）的块为单位来传输信息，而程序通常每次只能处理一个字节的信息。缓存区帮助匹配这两种不同的信息传输速率。例如，假设程序要计算记录在硬盘文件中的金额。程序可以从文件中读取一个字符，处理它，再从文件中读取下一个字符，再处理，依次类推。从磁盘文件中每次读取一个字符需要大量的硬件活动，速度非常慢。缓冲方法则从磁盘上读取大量信息，将这些信息存储在缓冲区中，然后每次从缓冲区里读取一个字节。因此从内存中读取单个字节的速度比从硬盘上读取块很多，所以这种方法更快，也更方便。当然，到达缓冲区尾部后，程序将从磁盘上读取另一块数据。这种原理与水库在暴风雨中收集几兆加仑流量的水，然后以比较文明的速度给您家里供水是一样的（见图17.2）。输出时，程序首先填满缓冲区，然后把整块数据传输给硬盘，并清空缓冲区，以备下一批输出使用。这被称为刷新缓冲区。 键盘输入每次提供一个字符，因此在这种情况下，程序无需缓存区来帮助匹配不同的数据传输速率。然而，对键盘输入进行缓冲可以让用户将输入传输给程序之前返回并更正。C++程序通常在用户按下回车键时刷新输入缓冲区。这是为什么本书的例子没有一开始就处理输入，而是等到用户按下回车键后再处理的原因。对于屏幕输出，C++程序通常再用户发送换行符时刷新输出缓冲区。程序也可能会在其他情况下刷新输入，例如输入即将到来时，这取决于实现。也就是说，当程序到达输入语句时，它将刷新输出缓冲区中当前所有的输出。与ANSI C一致的C++实现是这样工作的。 17.1.2 流、缓冲区和iostream文件管理流和缓冲区的工作有点复杂，但iostream文件中包含一些专门设计用来实现、管理流和缓冲区的类。C++98 版本C++ I/O定义了一些类模板，以支持char和wchar _t数据；C++11添加了char16 _t和char32 _t具体化。通过使用typedef工具，C++使得这些模板char具体化能够模仿传统的非模板I/O实现。下面是其中的一些类（见图17.3）： streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法； ios_base类表示流的一般特征，如是否可读取、是二进制流还是文本流等； ios类基于ios_base，其中包括了一个指向streambuf对象的指针成员； ostream类是从ios类派生而来的，提供了输出方法； istream类是从ios类派生而来的，提供了输入方法； iostream类是基于istream和ostream类的，因此继承了输入方法和输出方法。 要使用这些工具，必须使用适当的类对象。例如，使用ostream对象（如cout）来处理输出。创建这样的对象将打开一个流，自动创建缓冲区，并将其与流关联起来，同时使得能够使用类成员函数。 重定义I/O ISO/ANSI标准C++98对I/O作了两方面的修订。首先是从ostream.h到ostream的变化，用ostream将类放到std名称空间中。其次，I/O类被重新编写。为成为国际语言，C++必须能够处理需要16位的国际字符集或更宽的字符类型。因此，该语言再传统的8位char(“窄”)类型的基础上添加了wchar_ t(“宽”)字符类型；而C++11添加了类型char16_ t和char32_ t。每种类型都需要自己的I/O工具。标准委员会并没有开发两套（现在为4套）独立的类，而是开发了一套I/O类模板，其中包括basic_ istream&lt;cahrT, traits&gt;和basic_ ostream&lt;charT, traits&gt;。traits模板是一个模板类，为字符类型定义了具体特性，如如何比较字符是否相等以及字符的EOF值等。该C++11标准提供了I/O的char和wchar_ t具体化。例如，istream和ostream都是char具体化的typedef。同样，wistream和wostream都是wchar_ t具体化。例如wcout对象用于输出宽字符流。头文件ostream中包含了这些定义。 ios基类中的一些独立于类型的信息被移动到新的ios_ base类中，这包括各种格式化常量。例如ios::fixed（现在为ios_ base::fixed）。另外，ios_base还包含了一些老式ios中没有的选项。 C++的iostream类库管理很多细节。例如，再程序中包含iostream文件将自动创建8个流对象（4个用于窄字符流，4个用户宽字符流）。 cin对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备（通常为键盘）。wcin对象与此类似，但处理的是wchar_t类型。 cout对象与标准输出流相对应。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。wcout对象与此类似，但处理的是wchar_t类型。 cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。这个流没有被缓冲，这意味着信息被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。wcerr对象与此类似，但处理的是wchar_t类型。 clog对象也对应标准错误流。在默认情况下，这个流被关联单标准输出设备（通常为显示器）。这个流被缓冲。wclog对象与此类似，但处理的是wchar_t类型。 对象代表流——这意味着什么呢？当iostream文件为程序声明一个cout对象时，该对象包含存储了与输出有关的信息的数据成员，如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法以及描述用来处理输出流的缓冲区的streambuf对象的地址。下面的语句通过指向的streambuf对象将字符串“Bjarna free”中的字符放到cout管理的缓冲区中： cout &lt;&lt; “Bjarne free”; ostream类定义了上述语句中使用的operator&lt;&lt;()函数，ostream类还支持cout数据成员以及其他大量的类方法（如本章稍后将讨论的那些方法）。另外，C++注意到，来自缓冲区的输出被导引到标准输出（通常是显示器，有操作系统提供）。总之，流的一端是程序相连，另一端与标准输出相连，cout对象凭借streambuf对象的帮助，管理着流中的字节流。 17.1.3 重定向标准输入和输出流通常连接着键盘和屏幕。但很多操作系统（包括UNIX、Linux和Windows）都支持重定向，这个工具使得能够改变标准输入和标准输出。例如，假设有一个名为counter.exe的、可执行的Windows命令提供符C++程序，它能够计算输入中的字符数，并报告结果（在大多数Windows系统中，可以选择“开始”&gt;“程序”，再单击“命令提示符”来打开命令提示符窗口）。该程序的运行情况如下： C&gt;counter Hello and goodbye! Control -z &lt;&lt;simulated end-of-file Input contained 19 characters 其中的输入来自键盘，输出的被显示在屏幕上。 通过输入重定向（&lt;）和输出重定向（&gt;），可以使用上述程序计算文件oklahoma中的字符数，并将结果放到cow_cnt文件中： cow_cnt file: C&gt;counter &lt;oklahoma &gt;cow_cnt C&gt; 命令行中的的&lt;oklamoma将标准输入与oklahoma文件关联起来，使cin从该文件（而不是键盘）读取输入。换句话说，操作系统改变了输入流的流入端连接，而流出端仍然与程序向量。命令行中的&gt;cow_cnt将标准输出与cow _cnt文件关联起来，导致cout将输出发送给文件（而不是屏幕）。也就是说，操作系统改变了输出流的流出端连接，而流入端仍与程序相连。DOS、Windows命令提示符模式、Linux和UNIX能自动识别这种重定向语法（除早期的DOS外，其中操作系统都允许重定向运算符与文件之间加上可选的空格）。 cout代表代表的标准输出流是程序输出的常用通道。标准错误流（由cerr和clog代表）用于程序的错误消息。默认情况下，这3个对象都被发送给显示器。但对标准输出重定向不会影响cerr和clog，因此，如果使用其中一个对象来打印错误消息，程序将在屏幕上显示错误信息，即使常规的cout输出被重定向到其他地方。例如，请看下面的代码片段： if(suceess) std::cout &lt;&lt; &quot;Here come the goodies!\n&quot;; else { std::cer &lt;&lt; &quot;Something horrible has happened.\n&quot;; exit(1); } 如果重定向没有起作用，则选定的消息都将被显示在屏幕上。然而，如果程序输出被重定向到一个文件，则第一条消息（如果被选定）将被发送到文件中，而第二条消息（如果被选定）将被发送到屏幕。顺便说一句，有些操作系统也允许对标准错误进行重定向。例如，在UNIX和Linux中，运算符2&gt;重定向标准错误。 17.2 使用cout进行输出正如前面指出的，C++将输出看作字节流（根据实现和平台的不同，可能是8位、16位或32位的字节，但都是字节），但在程序中，很多数据被组织成比字节更大的单位。例如，int类型由16位或32位的二进制值表示；double值由64位的二进制数据表示。但在将字节流发送给屏幕时，希望每个字节表示一个字符值。也就是说，要在屏幕上显示数字-2.34，需要将5个字符（-、2.、3和4）,而不是这个值的64位内部浮点表示发送到屏幕上。因此，ostream类最重要的任务之一是将数值类型（如int或float）转换为以文本形式表示的字符流。也就是说，ostream类将数据内部表示（二进制位模式）转换为由字符字节组成的输出流（以后会有仿生移植物，使得能够直接翻译二进制数据。我们把这种开发作为一个练习，留给您）。为执行这些转换任务，ostream类提供了多个类方法。现在就来看看它们，总结本书使用的方法，并介绍能够更紧密地控制输出外观的其他方法。 17.2.1 重载的&lt;&lt;运算符本书常结合使用cout和&lt;&lt;运算符（插入insertion运算符）： int clients = 22; cout &lt;&lt; clients; 在C++中，与C一样，&lt;&lt;运算符的默认含义是按位左移运算符（参见附录E）。表达式x&lt;&lt;3的意思，将x的二进制表示中所有的位向左移动3位。显然，这与输出的关系不大。但ostream类重新定义了&lt;&lt;运算符，方法是将其重载位输出。在这种情况下，&lt;&lt;叫作插入运算符，而不是左移运算符（左移运算符由于其外观（像向左流动的信息流）而获得这种角色）。插入运算符被重载，使之能够识别C++中所有的基本类型： unsigned char signed char char short unsigned short int unsigned int long unsigned long long long(C++11) unsigned long long(C++11) float double long double 对于上述每种数据类型，ostream类都提供了operator&lt;&lt;()函数的定义（第11章讨论过，名称中包含运算符的函数用于重载该运算符）。因此，如果使用下面这样一条语句，而value是前面列出的类型之一，则C++程序将其对应于有相应的特征标的运算符函数： cout &lt;&lt; value; 例如，表达式cout&lt;&lt;88对应于下面的方法原型： ostream &amp; operator&lt;&lt;(int); 该原型表示，operator&lt;&lt;()接受一个int参数，这与上述语句中的88匹配。该原型还表明，函数返回一个指向ostream对象的引用，这使得可以将输出连接起来，如下所示： cout &lt;&lt; &quot;I&apos;m feeling sedimental over &quot; &lt;&lt; boundary &lt;&lt; &quot;\n&quot;; 如果您是C语言程序员，深受%类型说明符过多、说明符类型与值不匹配时发生问题等痛苦，则使用cout非常简单（当然，由于有cin，C++输入也非常简单）。 1. 输出和指针ostream类还未下面的指针类型定义了插入运算符函数： const signed char *; const unsigned char *; const char *; void *; 不要忘了，C++用指向字符串存储位置的指针来表示字符串。指针的形式可以是char数组名、显式的char指针或用引号括起来的字符串。因此，下面所有的cout语句都显式字符串： char name[20] = &quot;Dudly Diddlemore&quot;; char *pn = &quot;Violet D&apos;Amore&quot;; cout &lt;&lt; &quot;Hello!&quot;; cout &lt;&lt; name; cout &lt;&lt; pn; 方法使用字符串中的终止空字符来确定何时停止显式字符。 对于其他类型的指针，C++将其对应于void $\ast$，并打印地址的数值表示。如果要获得字符串的地址，则必须将其强制转换为其他类型，如下面的代码片段所示： int eggs = 12; char * amount = &quot;dozen&quot;; cout &lt;&lt; &amp;eggs; //打印eggs变量的地址 cout &lt;&lt; amont; //打印字符串 cout &lt;&lt; (void *) amount; //打印字符串的地址 2.拼接输出插入运算符的所有化身的返回类型都是ostream &amp;。即，原型的格式如下： ostream &amp; operator&lt;&lt;(type); (其中，type是要显式的数据类型)返回类型ostream &amp;意味着使用该运算符将返回一个指向ostream对象的引用。哪个对象呢？函数定义指出，引用将指向用于调用该运算符的对象。换句话说，运算符函数的返回值为调用运算符的对象。例如，cout&lt;&lt;”putluck”返回的是cout对象。这种特性使得能够通过插入来连接输出。例如，请看下面的语句： cout &lt;&lt; &quot;We have &quot; &lt;&lt; count &lt;&lt; &quot; unhatched chickens.\n&quot;; 表达式cout&lt;&lt; “We have”将显示字符串，并返回cout对象。至此，上述语句将变为： cout &lt;&lt; count &lt;&lt; &quot; unhatched chickens.\n&quot;; 表达式cout&lt;&lt;count将显示count变量的值，并返回cout。然后cout将处理语句中的最后一个参数（参见图17.4）。这种设计计数确实是一项很好的特性，这也是前几章中重载&lt;&lt;运算符的示例模仿了这种计数的原型所在。 17.2.2 其他ostream方法除了各种operator&lt;&lt;()函数外，ostream类还提供了put()方法和write()方法，前者用于显示字符，后者用于显示字符串。 最初，put()方法的原型如下： ostream &amp; put(char); 当前标准与此相同，但被模板化，以适用于wchar_t。可以用类方法表示法来调用它： cout.put(&apos;W&apos;); 其中，cout是调用方法的对象，put()是类成员函数。和&lt;&lt;运算符函数一样，该函数也返回一个指向调用对象的引用，因此可以用它将拼接输出： cout.put(&apos;I&apos;).put(&apos;t&apos;); 函数调用cout.put(‘I’)返回cout，cout然后被用作put(‘t’)调用的调用对象。 在原型合适的情况下，可以将数值型参数（如int）用于put()，让函数原型；自动将参数转换为正确char值。例如，可以这样做： cout.put(65); //显示A字符 cout.put(66.3); //显示B字符 第一条语句将int值65转换为一个char值，然而现实ASCII码为65的字符。同样，第二条语句将delete值66.3转换为66，并显示对应的字符。 这种行为在C++2.0之前可派上用场。在这些版本中，C++语言用int值表示字符常量。因此，下面的语句将‘W’解释为一个int值，因此将其作为整数87（即该字符的ASCII值）显示出来： cout &lt;&lt; &apos;W&apos;; 然而，下面这条语句能够正常工作： cout.put(&apos;W&apos;); 因为当前的C++将char常量表示为char类型，因此现在可以使用上述任何一种方法。 一些老式编译器错误地为char、unsigned char和signed char3种参数类型重载了put()。这使得将int参数用于put()时具有二义性，因为int可被转换为这3种类型中的任何一种。 write()方法显示整个字符串，其模板原型如下： baisc_ostream&lt;charT, traits&gt; &amp; write(const char_type* s, streamsize n); write()的第一个参数提供了要显示的字符串的地址，第二个参数指出了要显示多少个字符。使用cout调用write()时，将调用char具体化，因此返回类型为ostream。程序17.1演示了write()方法是如何工作的。 程序17.1 write.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; int main() { using std::cout; using std::endl; const char * state1 = &quot;Florida&quot;; const char * state2 = &quot;Kansas&quot;; const char * state3 = &quot;Euphoria&quot;; int len = std::strlen(state2); cout &lt;&lt; &quot;Increasing loop index:\n&quot;; int i; for (i = 1; i &lt;= len; i++) { cout.write(state2, i); cout &lt;&lt; endl; } cout &lt;&lt; &quot;Decreasing loop index:\n&quot;; for (i = len; i &gt; 0; i--) cout.write(state2, i) &lt;&lt; endl; cout &lt;&lt; &quot;Exceeding string length:\n&quot;; cout.write(state2, len+5) &lt;&lt; endl; return 0; } 输出： Increasing loop index: K Ka Kan Kans Kansa Kansas Decreasing loop index: Kansas Kansa Kans Kan Ka K Exceeding string length: KansasEuph 有些编译器可能指出程序定义了数组state1和state3但没有使用它们。这不是问题，因为这两个数组只是用于提供数组state2前面和后面的数据，以便您知道程序错误地存取state2时发生的情况。 注意，cout,write()调用返回cout对象。这是因为write()方法返回一个指向调用它的对象的引用，这里调用它的对象是cout。 这使得可以将输出拼接起来，因为cout.write()将被其返回值cout替换： cout.write(state2, i) &lt;&lt; endl; 还需要注意的是，write()方法并不会遇到空字符时自动停止打印字符，而只是打印指定数目的字符，即使超出了字符串的边界！在这个例子中，在字符串“kansas”的前后声明了另外两个字符串，以便相邻的内存包含数据。编译器在内存中存储数据的顺序以及调整内存的方式各不相同。例如，“Kansas”占用6个字节，而该编译器使用4个字节的倍数调整字符串，因此“Kansas”被填充成占用8个字节。由于编译器之间的差别，因此输出的最后一行可能不同。 write()方法也可用于数值数据，您可以将数字的地址强制转换为char$\ast$，然后传递给它： long val = 560031841; cout.write( (char *) &amp;val, sizeof(long)); 这不会将数字转换为相应的字符，而是传输内存中存储的位表示。例如，4字节的long值（如5600311841）将作为4个独立的字节被传输。输出设备（如显示器）将把每个字节作为ASCII码进行解释。因此在屏幕上，560031841将被显示为4个字符的组合，这很可能是乱码。然而，write()确实为将数值数据存储到文件提供了一种简洁、准确的方式，这将在本章后面进行介绍。 17.2.3 刷新输出缓冲区如果程序使用cout将字节发送给标准输出，情况将如何？由于ostream类对cout对象处理的输出进行缓冲，所以输出不会立即发送到目标地址，而是被存储在缓冲区中，直到填满缓冲区。然而，程序将刷新（flush）缓冲区，把内容发送出去，并清空缓冲区，以存储新的数据。通常，缓冲区512字节或其整数倍。当标准输出连接的是硬盘上的文件，缓冲可以节省大量的实践。毕竟，不希望程序为发送512个字节，而存取磁盘512次。将512个字节收集到缓冲区中，然后一次性将它们写入硬盘的效率要高得多。 然而，对于屏幕输出来说，首先填充缓冲区的重要性要低得多。如果必须重述消息“Press any key to continue”以便使用512个字节来填充缓冲区，实在是太不方便了，所幸的是，在屏幕输出时，程序不必等到缓冲区被填满。例如，将换行符发送到缓冲区后，将刷新缓冲区。另外，正如前面指出的，多数C++实现会在输入即将发生时刷新缓冲区。也就是说，假设有下面的代码： cout &lt;&lt; &quot;Enter a number: &quot;; float num; cin &gt;&gt; num; 程序期待输入这一事实，将导致它立刻显示cout消息（即刷新“Enter a number: ”消息），即使输出字符中没有换行符。如果没有这种特性，程序将等待输入，而无法通过cout消息来提示用户。 如果实现不能再所希望时刷新输出，可以使用两个控制符中的一个来强行进行刷新。控制符flush刷新缓冲区，而控制符endl刷新缓冲区，并插入一个换行符。这两个控制符的使用方式与变量相同。 cout &lt;&lt; &quot;Hello, good-looking! &quot; &lt;&lt; flush; cout &lt;&lt; &quot;Wait just a moment, please.&quot; &lt;&lt; endl; 事实上，控制符也是函数。例如，可以直接调用flush()来刷新cout缓冲区： flush(cout); 然而，ostream类对&lt;&lt;插入运算符进行了重载，使得下述表达式将被替换为函数调用flush(cout): cout &lt;&lt; flush; 因此，可以用更为方便的插入表示法来成功地进行刷新。 17.2.4 用cout进行格式化ostream插入运算符将值转为文本格式。在默认情况下，格式化值的方式如下。 对于char值，如果它代表的是可打印字符，则将被作为一个字符显示在宽度为一个字符的字段中。 对于数值类型，将以十进制方式显示在一个刚好容纳该数字及负号（如果有的话）的字段中。 字符串被显示在宽度等于该字符串长度的字段中。 浮点数的默认行为有变化。下面详细地说明了老式实现和新实现之间的区别。 新式：浮点类型被显示为6位，末尾的0不显示（注意，显示的数字位数与数字被存储时精度没有任何关系）。数字以定点表示法显示还是以科学计数法表示（参见第3章），取决于它的值。具体来说，当指数大于等于6或小于等于-5时，将使用科学计数法表示。另外，字段宽度恰好容纳数字和负号（如果有的话）。默认的行为对应于带%g说明符的标准C库函数fprintf()。 老式：浮点类型显示为带6为小数，末尾的0不显示（注意，显示的数字位数与数字被存储时的精度没有任何关系）。数字以定点表示法显示还是以科学计数法表示（参见第3章），取决于它的值。另外，字段宽度恰好容器数字和负号（如果有的话）。 因为每个值的显示宽度都等于它的长度，因此必须显式地在值之间提供空格；否则，相邻的值将不会被分开。 程序17.2演示默认的输出情况，他在每个值后面都显示一个冒号（:），以便可以直到每种情况下的字段宽度。该程序使用表达式1.0/9.0来生成一个无穷小数，以便能够知道打印了多少位。 注意：并非所有的编译器都能生成符合当前C++标准格式的输出。另外，当前标准允许区域性变化。例如，欧洲实现可能遵循欧洲人的风格：使用逗号而不是句点来表示小数点。也就是说，2.54将被写成2，54。区域库（头文件locale）提供了用特定的风格影响（imbuing）输入或输出流机制，所以同一个编译器能够提供多个区域选项。本章使用美国格式。 程序17.2 defaults.cpp #include &lt;iostream&gt; int main() { using namespace std; cout &lt;&lt; &quot;12345678901234567890\n&quot;; char ch = &apos;K&apos;; int t = 273; cout &lt;&lt; ch &lt;&lt; &quot;:\n&quot;; cout &lt;&lt; t &lt;&lt; &quot;:\n&quot;; cout &lt;&lt; -t &lt;&lt; &quot;:\n&quot;; double f1 = 1.200; cout &lt;&lt; f1 &lt;&lt; &quot;:\n&quot;; cout &lt;&lt; (f1 + 1.0 / 9.0) &lt;&lt; &quot;:\n&quot;; double f2 = 1.67E2; cout &lt;&lt; f2 &lt;&lt; &quot;:\n&quot;; f2 += 1.0 / 9.0; cout &lt;&lt; f2 &lt;&lt; &quot;:\n&quot;; cout &lt;&lt; (f2 * 1.0e4) &lt;&lt; &quot;:\n&quot;; double f3 = 2.3e-4; cout &lt;&lt; f3 &lt;&lt; &quot;:\n&quot;; cout &lt;&lt; f3 / 10 &lt;&lt; &quot;:\n&quot;; return 0; } 输出： 12345678901234567890 K: 273: -273: 1.2: 1.31111: 167: 167.111: 1.67111e+06: 0.00023: 2.3e-05: 每个值都填充自己的字段。注意，1.200末尾的0没有显示出来，但末尾不带0的浮点值后面将有6个空格。另外，该实现将指数显示为3位，而其他实现可能为两位。 1. 修改显示时使用的计数系统ostream类是从ios类派生而来的，而后者是从ios_ base类派生而来的。ios_ base类存储了描述格式状态的信息。例如，一个类成员中某些位决定了使用的计数系统，而另一个成员则决定了字段宽度。通过使用控制符（manipulater），可以控制显示整数时使用的计数系统。通过使用ios_ base的成员函数，可以控制字段宽度和小数位数。由于ios _base类是ostream的间接基类，因此可以将其方法用于ostream对象（或子代），如cout。 注意：ios_ base类中的成员和方法以前位于ios类中。现在，ios_ base是ios的基类。在新系统中，ios是包含char和wchar_ t具体化的模板，而ios_ base包含了非模板特性。 来看如何设置显示整数时使用的计数系统。要控制整数以十进制、十六进制还是八进制显示，可以使用dec、hex和oct控制符。例如，下面的函数调用将cout对象的计数系统格式状态设置为十六进制： hex(cout); 完成上述设置后，程序将以十六进制形式打印整数值，直到将格式状态设置为其他选项为止。注意，控制符不是成员函数，因此不必通过对象来调用。 虽然控制符实际上是函数，但它们通常的使用方式为： cout &lt;&lt; hex; ostream类重载了&lt;&lt;运算符，这使得上述用法与函数调用hex(cout)等价。控制符位于名称空间std中。程序17.3演示了这些控制符的用法，它以3种不同的计数系统显示了一个整数的值及其平方。注意，可以单独使用控制符，也可将其作为一系列插入的组成部分。 程序17.3 manip.cpp #include &lt;iostream&gt; int main() { using namespace std; cout &lt;&lt; &quot;Enter an integer: &quot;; int n; cin &gt;&gt; n; cout &lt;&lt; &quot;n n*n\n&quot;; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; n * n &lt;&lt; &quot; (decimal)\n&quot;; cout &lt;&lt; hex; cout &lt;&lt; n &lt;&lt; &quot; &quot;; cout &lt;&lt; n * n &lt;&lt; &quot; (hexadecimal)\n&quot;; cout &lt;&lt; oct &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; n * n &lt;&lt; &quot; (octal)\n&quot;; dec(cout); cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; n * n &lt;&lt; &quot; (decimal)\n&quot;; return 0; } 输出： Enter an integer: 13 n n*n 13 169 (decimal) d a9 (hexadecimal) 15 251 (octal) 13 169 (decimal) 2. 调整字段宽度您可能已经注意到，在程序17.3的输出中各列并没有对齐，这是因为数字的字段宽度不相同。可以使用width成员函数将长度不同的数字放到宽度相同的字段中，该方法的原型为： int width(); int width(int i); 第一种格式返回字段宽度的当前设置；第二种格式将字段宽度设置为i个空格，并返回以前的字段宽度值。这使得能够保存以前的值，以便以后恢复宽度时使用。 width()方法只影响将显示的一个项目，然后字段宽度将恢复为默认值。例如，请看下面的语句： cout &lt;&lt; &apos;#&apos;; cout.width(12); cout &lt;&lt; 12 &lt;&lt; &apos;#&apos; &lt;&lt; 24 &lt;&lt; &quot;#\n&quot;; 由于width()是成员函数是，因此必须使用对象（这里是cout）来调用它。输出语句生成的输出如下： # 12#24# 12被放到宽度为12个字符的字段的最右边，这被称为右对齐。然后，字段宽度恢复为默认值，并将两个#符号以及24放在宽与它们的长度相等的字段中。 警告：width()方法只影响接下来显示的一个项目，然后字段宽度将恢复为默认值。 C++永远不会截断数据，因此如果试图在宽度为2的字段中打印一个7位值，C++将增宽字段，以容纳数据（在有些语言中，如果数据长度与字段长度不匹配，将用星号填充。C/C++的原则是：显示所有的数据比标尺列的整洁更重要。C++视内容重于形式）。程序17.4演示了width()成员函数是如何工作的。 程序17.4 width.cpp #include &lt;iostream&gt; int main() { using std::cout; int w = cout.width(30); cout &lt;&lt; &quot;default field width = &quot; &lt;&lt; w &lt;&lt; &quot;:\n&quot;; cout.width(5); cout &lt;&lt; &quot;N&quot; &lt;&lt; &quot;:&quot;; cout.width(8); cout &lt;&lt; &quot;N * N&quot; &lt;&lt; &quot;:\n&quot;; for(long i = 1; i &lt;= 100; i *= 10) { cout.width(5); cout &lt;&lt; i &lt;&lt; &quot;: &quot;; cout.width(8); cout &lt;&lt; i * i &lt;&lt; &quot;:\n&quot;; } return 0; } 输出： default field width = 0: N: N * N: 1: 1: 10: 100: 100: 10000: 在上述输出中，值在字段中右对齐。输出中包含空格，也就是说，cout通过加入空格来填满整个字段。右对齐时，空格被插入到值的左侧。用来填充的字符叫做填充字符（fill characher）。右对齐是默认的。 注意，程序17.4中，第一条cout语句显示字符串时，字段宽度被设置为30，但在显示w的值时，字段宽度不是30。这是由于width()方法只影响接下来被现实的一个项目。另外，w的值为0。这是由于cout.width(30)返回的是以前的字段宽度，而不是刚设置的值。w为0表明，默认的字段宽度为0。由于C++总会增长字段，以容纳数据，因此这种值适用于所有的数据。最后，程序使用width()来对齐列标题和数据，方法是将第1列宽度设置为5个字符，将第2列的宽度设置为8个字符。 3. 填充字符在默认情况下，cout用空格填充字段中未被使用的部分，可以用fill()成员函数来改变填充字符。例如，下面的函数调用将填充字符改为星号： cout.fill(&apos;*&apos;); 这对于检查打印结果，防止接收方添加数字很有用。程序17.5演示了该成员函数的用法。 程序17.5 fill.cpp #include &lt;iostream&gt; int main() { using std::cout; cout.fill(&apos;*&apos;); const char * staff[2] = {&quot;Waldo Whipsnade&quot;, &quot;Wilmarie Wooper&quot;}; long bonus[2] = {900, 1350}; for (int i = 0; i &lt; 2; i++) { cout &lt;&lt; staff[i] &lt;&lt; &quot;: $&quot;; cout.width(7); cout &lt;&lt; bonus[i] &lt;&lt; &quot;\n&quot;; } return 0; } 输出： Waldo Whipsnade: $****900 Wilmarie Wooper: $***1350 注意，与字段宽度不同的是，新的填充字符将一直有效，直到更改它为止。 4. 设置浮点数的显示精度浮点数精度的含义取决于输出模式。在默认情况下，它指的是显示的总位数。在定点模式和科学模式下（稍后将讨论），精度指的是小数点后面的位数。已经知道，C++的默认精度为6位（但末尾的0将不显示）。precision()成员函数使得能够选择其他值。例如，下面语句将cout的精度设置为2： cout.precision(2); 和width()的情况不同，但与fill()类似，新的精度设置将一直有效，直到被重新被设置。程序17.6准备地说明了这一点。 程序17.6 precise.cpp #include &lt;iostream&gt; int main() { using std::cout; float price1 = 20.40; float price2 = 1.9 + 8.0 / 9.0; cout &lt;&lt; &quot;\&quot;Furry Friends\&quot; is $&quot; &lt;&lt; price1 &lt;&lt; &quot;!\n&quot;; cout &lt;&lt; &quot;\&quot;Fiery Friends\&quot; is $&quot; &lt;&lt; price2 &lt;&lt; &quot;!\n&quot;; cout.precision(2); cout &lt;&lt; &quot;\&quot;Furry Friends\&quot; is $&quot; &lt;&lt; price1 &lt;&lt; &quot;!\n&quot;; cout &lt;&lt; &quot;\&quot;Fiery Friends\&quot; is $&quot; &lt;&lt; price2 &lt;&lt; &quot;!\n&quot;; return 0; } 输出： &quot;Furry Friends&quot; is $20.4! &quot;Fiery Friends&quot; is $2.78889! &quot;Furry Friends&quot; is $20! &quot;Fiery Friends&quot; is $2.8! 注意，第3行没有打印小数点及其后面的内容。另外，第四行显示的总数为2位。 5. 打印末尾的0和小数点对于有些输出（如价格或栏中的数字），保留末尾的0将更为美观。例如，对于程序17.6的输出，$20.40将比$20.4更美观。iostream系列没有提供专门用于完成这些任务的函数，但ios_ base类提供了一个setf()函数（用于set标记），能够控制多种格式化特征。这个类还定义了多个常量，可用作该函数的参数。例如，下面的函数调用使cout显示末尾小数点： cout.setf(ios_base::showpoint); 使用默认的浮点格式时，上述语句还将导致末尾的0被现实出来。也就是说，如果使用默认精度（6位）时，cout不会将2.00显示位2，而是将它显示位2.000000。程序17.7在程序17.6中添加了这条语句。 您可能对表示法ios_ base::showpoint有疑问，showpoint是ios_ base类声明中定义的类级静态常量。类级意味着如果在成员函数定义的外面使用它，则必须在常量面前加上作用域运算符(::)。因此，ios_ base::showpoint指的是ios_base类中定义的一个常量。 程序17.7 showpt.cpp #include &lt;iostream&gt; int main() { using std::cout; using std::ios_base; float price1 = 20.40; float price2 = 1.9 + 8.0 / 9.0; cout.setf(ios_base::showpoint); cout &lt;&lt; &quot;\&quot;Furry Friends\&quot; is $&quot; &lt;&lt; price1 &lt;&lt; &quot;!\n&quot;; cout &lt;&lt; &quot;\&quot;Fiery Friends\&quot; is $&quot; &lt;&lt; price2 &lt;&lt; &quot;!\n&quot;; cout.precision(2); cout &lt;&lt; &quot;\&quot;Furry Friends\&quot; is $&quot; &lt;&lt; price1 &lt;&lt; &quot;!\n&quot;; cout &lt;&lt; &quot;\&quot;Fiery Friends\&quot; is $&quot; &lt;&lt; price2 &lt;&lt; &quot;!\n&quot;; return 0; } 输出： “Furry Friends” is $20.4000!“Fiery Friends” is $2.78889!“Furry Friends” is $20.!“Fiery Friends” is $2.8! 在上述输出中，第一行显示了零；第三行显示了小双面，但没有显示末尾的0，这是因为精度被设置位2，而小数点前面已经包含两位。 6. 再谈setf()setf()方法控制了小数点被显示时其他几个格式选项，因此来仔细研究一下它。ios_ base类有一个受保护的数据成员，其中的各位（这里叫作标记）分别控制着格式化的各个方面，例如计数系统、是否显示末尾的0等。打开一个标记称为设置标记（或位），并意味着相应的位被设置位1。位标记是编程开关，相当于设置DIP开关以配置计算机硬件。例如，hex、dec和oct控制符调整控制计数系统的3个标记位。setf()函数提供了另一种调整标记位的途径。 setf()函数有两个原型，第一个为： fmtflags setf(fmtflags); 其中，fmtflags是bitmask类型（参见后面的“注意”）的typedef名，用于存储格式标记。该名称是在ios_ base类中定义的。这个版本的setf()用来设置单个位控制的格式信息。参数是一个fmtflags值，指出要设置哪一位。返回值是类型为fmtflags的数字，指出所有标记以前的设置。如果打算以后恢复原始设置，则可以保存这个值。应给setf()传递什么呢？如果要第11位设置为1，则可以传递一个第11位为1的数字。返回值的第11为被设置为1。对位进行跟踪好像单调乏味（实际上也是这样的）。然而，您不必做这项工作，ios_ base类定义了代表位值的常量，表17.1列出了其中的一些定义。 注意：bitmask类型是一种用来存储各个位值的类型。它可以是整数、枚举，也可以是STL bitset容器。这里的主要思想是，每一位都是可以单独访问的，都有自己的含义。iostream软件包使用bitmask来存储状态信息。 由于这些格式常量都是在ios_ base类中定义的，因此使用它们时，必须加上作用域解析运算符。也就是说，应使用ios_ base::upercase，而不是uppercase。如果不想使用using编译指令或using声明，可以使用作用域运算符来指定这些名称位于名称空间std中。修改将一直有效，直到被覆盖为止。程序17.8演示了如何使用其中一些常量。 程序17.8 setf.cpp #include &lt;iostream&gt; int main() { using std::cout; using std::endl; using std::ios_base; int temperature = 63; cout &lt;&lt; &quot;Today&apos;s water temperature: &quot;; cout.setf(ios_base::showpos); cout &lt;&lt; temperature &lt;&lt; endl; cout &lt;&lt; &quot;For our programming friends, that&apos;s\n&quot;; cout &lt;&lt; std::hex &lt;&lt; temperature &lt;&lt; endl; cout.setf(ios_base::uppercase); cout.setf(ios_base::showbase); cout &lt;&lt; &quot;or\n&quot;; cout &lt;&lt; temperature &lt;&lt; endl; cout &lt;&lt; &quot;How &quot; &lt;&lt; true &lt;&lt; &quot;! oops -- How &quot;; cout.setf(ios_base::boolalpha); cout &lt;&lt; true &lt;&lt; &quot;!\n&quot;; return 0; } 输出： Today&apos;s water temperature: +63 For our programming friends, that&apos;s 3f or 0X3F How 0X1! oops -- How true! 注意，仅当基数位10时才使用加号。C++将十六进制和八进制都视为无符号的，因为对它们，无需使用符号（然而，有些C++实现可能仍然会显示加号）。 第二个setf()原型接收两个参数，并返回以前的设置： fmtflags setf(fmtflags, fmtflags); 函数的这种重载格式用于设置多位控制的格式选项。第一个参数和以前一样，也是一个包含了所需设置的fmtflags值。第二个参数指出要清除第一个参数中的哪些位。例如，将第3位设置1表示以10为基数，将第4位设置为1表示以8为基数，将第5位设置为1表示以16为基数。假设输出是以10为基数的，而要将它设置为以16为基数，则不仅需要将第5位设置为1，还需要将第3位设置位0——这叫作清除位（clearing the bit）。聪明的十六进制控制符可自动完成这两项任务。使用函数setf()时，要做的工作多些，因为要用第二个参数指出要清除哪些位，用第一参数指出要设置哪位。这并不像听上去那么复杂，因为ios_ base类为此定义了常量（如表17.2所示）。具体地说，要修改基数，可以将常量ios_ base::basefield用作第二参数，将ios_ base::hex用作第一参数。也就是说，下面的函数调用与使用十六进制控制符的作用相同： cout.setf(ios_base::hex, ios_base::basefield); ios_ base类定义了可按这种方式处理的3组格式标记。每组标记都由一个可用作第二个参数的常量和两三个可用作第一参数的常量组成。第而参数清楚一批相关的位，然后第一参数将其中一位位置为1。表17.2列出了用作setf()的第二参数的常量的名称、可用作第一参数的相关常量以及它们的含义。例如，要选择左对齐，可将ios_ base::adjustfield用作第二参数，将ios_ base::left作为第一参数。左对齐意味着将值放在字段的左端，右对齐则表示将值放在字段的右端。内部对齐表示将符号或基数前缀放在字段左侧，余下的数字放在字段的右侧（遗憾的是，C++没有提供自对齐模式）。 定点表示法意味着使用格式123.4来表示浮点值，而不管数字的长度如何，科学表示法则意味着使用格式1.23e04，而不考虑数字的长度。如果您熟悉C语言中printf()的说明符，则可能知道，默认的C++模式对应于%g说明符，定点表示法对应于%f说明符，而科学表示法对应于%e说明符。 在C++标准中，定点表示法和科学表示法都有下面两个特征： 精度指的是小数位数，而不是总位数； 显示末尾的0。 setf()函数是ios_ base类的一个成员函数。由于这个类是ostream类的基类，因此可以使用cout对象来调用该函数。例如，要左对齐，可以使用下面的调用： ios_base::fmtflags old = cout.setf(ios::left, ios::adjustfield); 要恢复以前的设置，可以这样做： cout.setf(old, ios::adjustfiedl); 程序17.9是一个使用两个参数setf()的示例。 注意：程序17.9中使用了一个数学函数，有些C++系统不自动搜索数学库。例如，有些UNIX系统要求这样做： $ CC setf.C -lm -lm选项命令链接程序搜索数学库。同样，有些使用g++的Linux系统也要求这样做。 程序17.9 setf2.cpp #include &lt;iostream&gt; #include &lt;cmath&gt; int main() { using namespace std; cout.setf(ios_base::left, ios_base::adjustfield); cout.setf(ios_base::showpos); cout.setf(ios_base::showpoint); cout.precision(3); ios_base::fmtflags old = cout.setf(ios_base::scientific, ios_base::floatfield); cout &lt;&lt; &quot;Left Justification:\n&quot;; long n; for (n = 1; n &lt;= 41; n+=10) { cout.width(4); cout &lt;&lt; n &lt;&lt; &quot;|&quot;; cout.width(12); cout &lt;&lt; sqrt(double(n)) &lt;&lt; &quot;|\n&quot;; } cout.setf(ios_base::internal, ios_base::adjustfield); cout.setf(old, ios_base::floatfield); cout &lt;&lt; &quot;Internal Justification:\n&quot;; for (n = 1; n &lt;= 41; n+=10) { cout.width(4); cout &lt;&lt; n &lt;&lt; &quot;|&quot;; cout.width(12); cout &lt;&lt; sqrt(double(n)) &lt;&lt; &quot;|\n&quot;; } cout.setf(ios_base::right, ios_base::adjustfield); cout.setf(ios_base::fixed, ios_base::floatfield); for (n = 1; n &lt;= 41; n+=10) { cout.width(4); cout &lt;&lt; n &lt;&lt; &quot;|&quot;; cout.width(12); cout &lt;&lt; sqrt(double(n)) &lt;&lt; &quot;|\n&quot;; } return 0; } 输出： Left Justification: +1 |+1.000e+00 | +11 |+3.317e+00 | +21 |+4.583e+00 | +31 |+5.568e+00 | +41 |+6.403e+00 | Internal Justification: + 1|+ 1.00| + 11|+ 3.32| + 21|+ 4.58| + 31|+ 5.57| + 41|+ 6.40| +1| +1.000| +11| +3.317| +21| +4.583| +31| +5.568| +41| +6.403| 注意到精度3让默认的浮点显示（在这个程序中用于内部对齐）总共显示3位，而定点默认和科学模式只显示3位小数（e表示法的指数位数取决于实现）。 调用setf()的效果可以通过unsetf()消除，后者的原型如下: void unsetf(fmtflags mask); 其中，mask是位模式。mask中所有的位都设置位1，将使得对象的位被复位。也就是说，setf()将位设置为1，unsetf()将位恢复为0。例如： cout.setf(ios_base::showpoint); cout.unsetf(ios_base::boolshowpoint); cout.setf(ios_base::boolalpha); cout.unsetf(ios_base::boolalpha); 您可能注意到了，没有专门指示浮点数默认显示模式的标记。系统的工作原理如下：仅当只有定点位被设置时使用定点表示法；仅当只有科学位被设置时使用科学表示法；对于其他组合，如没有位被设置或两位都被设置，将使用默认模式。因此，启动默认模式的方法之一如下： cout.setf(0, ios_base::floatfield); //设置默认模式 第二个参数关闭这两位，而第一个参数不设置任何位。一种实现同样目标的简捷方式是，使用参数ios::floatfield来调用函数unsetf(): cout.unsetf(ios_base::floatfield); //设置默认模式 如果已知cout处于定点状态，则可以使用参数ios_ base::fixed调用函数unsetf()来切换到默认模式；然而，无论cout的当前状态如何，使用参数ios_ base::floatfield调用函数unsetf()都将切换到默认模式，因此这是一种更好的选择。 7. 控制标准符使用setf()不是进行格式化的、对用户最为友好的方法，C++提供了多个控制符，能够调用setf()，并自动提供正确的参数。前面已经介绍过dex、hex和oct，这些控制符（多数都不适用于老式C++实现）的工作方式都与hex相似。例如，下面的语句打开左对齐和定点选项： cout &lt;&lt; left &lt;&lt; fixed; 表17.3列出了这些控制符以及其他一些控制符。 提示：如果系统支持这些控制符，请使用他们；否则，仍然可以使用setf()。 8. 头文件iomanip使用iostream工具来设置一些格式值（如字段宽度）不太方便。为简化工作，C++在头文件iomanip中提供了其他一些控制符，它们能够提供前面讨论过的服务，但表示起来更方便。3个最常用的控制符分贝是setprecision()、setfill()和setw()，它们分别用来设置精度、填充字符和字段宽度。与前面讨论的控制符不同的是，这3个控制符带参数。setprecision()控制符接受一个指定精度的整数参数；setfill()控制符接受一个指定填充字符的char参数；setw()控制符接受一个指定字段宽度的整数参数。由于它们都是控制符，因此可以用cout语句连接起来。这样，setw()控制符在显示多列值时尤其方便。程序17.10演示了这一点，它对于每一行输出，都多次修改了字段宽度和填充字符，同时使用了一些较新的标准控制符。 注意：有些C++系统不自动搜索数学库。前面说过，有些UNIX系统要求使用如下命令选项来访问数学库：$ CC iomanip.C -lm 程序17.10 iomanip.cpp #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; int main() { using namespace std; cout &lt;&lt; fixed &lt;&lt; right; cout &lt;&lt; setw(6) &lt;&lt; &quot;N&quot; &lt;&lt; setw(14) &lt;&lt; &quot;square root&quot; &lt;&lt; setw(15) &lt;&lt; &quot;fourth root\n&quot;; double root; for (int n = 10; n &lt;= 100; n += 10) { root = sqrt(double(n)); cout &lt;&lt; setw(6) &lt;&lt; setfill(&apos;-&apos;) &lt;&lt; n &lt;&lt; setfill(&apos; &apos;) &lt;&lt; setw(12) &lt;&lt; setprecision(3) &lt;&lt; root &lt;&lt; setw(14) &lt;&lt; setprecision(4) &lt;&lt; sqrt(root) &lt;&lt; endl; } return 0; } 输出： N square root fourth root ----10 3.162 1.7783 ----20 4.472 2.1147 ----30 5.477 2.3403 ----40 6.325 2.5149 ----50 7.071 2.6591 ----60 7.746 2.7832 ----70 8.367 2.8925 ----80 8.944 2.9907 ----90 9.487 3.0801 ---100 10.000 3.1623 17.3 使用cin进行输入现在来介绍输入，即如何给程序提供数据。cin对象将标准输入表示为字节流。通常情况下，通过键盘来生成这种字符流。如果键入字符序列2011，cin对象将从输入流中抽取这几个字符。输入可以是字符串的一部分、int值、float值，也可以是其他类型。因此，抽取还涉及了类型转换。cin对象根据接收值的变量的类型，使用其方法将字符序列转换为所需的类型。 通常，可以这样使用cin: cin &gt;&gt; value_holder; 其中，value_ holder为存储输入的内存单元，它可以是变量、引用、被解除引用的指针，也可以是类或结构的成员。cin解释输入的方式取决于value_ holder的数据类型。istream类（在iostream头文件中定义）重载了抽取运算符&gt;&gt;，使之能够识别下面这些基本类型： signed char &amp;; unsigned char &amp;; char &amp;; short &amp;; unsigned short &amp;; int &amp;; unsigned int &amp;: long &amp;; unsigned long &amp;; long long &amp;(C++11)； unsigned long long &amp; (C++11); float &amp;; double &amp;; long double &amp;; 这些运算符函数被称为格式化输入函数（formatted input functions），因为它们可以将输入数据转换为目标指定的格式。 典型的运算符函数的原型如下： istream &amp; operator&gt;&gt;(int &amp;); 参数和返回值都是引用。引用参数（参见第8章）意味着下面这样的语句将导致operator&gt;&gt;()函数处理变量staff_size本身，而不是像常规参数那样处理它的副本： cin &gt;&gt; staff_size; 由于参数类型为引用，因此cin能够直接修改用作参数的变量的值。例如，上述语句将直接修改变量staff_ size的值。稍后将介绍引用返回值的重要意义。首先来看抽取运算符的类型转换方面。对于上述列出的各种类型参数，抽取运算符将字符输入转换为指定类型的值。例如，假设staff_size的类型为int，则编译器将： cin &gt;&gt; staff_size; 与下面的原型匹配： istream &amp; operator&gt;&gt;(int &amp;); 对应于上述原型的函数将读取发送给程序的字符流（假设字符2、3、1、8和4）。对于使用2字节int的系统来说，函数将他这些字符转换为整数23184的2字节二进制表示。如果statt_ size的类型为double，则cin将使用operator&gt;&gt;(double &amp;)将上述输入转换为值23184.0的8字节浮点表示。 顺便说一句，可以将hex、oct和dec控制符与cin一起使用，来指定整型输入解释为十六进制、八进制还是十进制格式。例如，下面的语句将输入12或0x12解释为十六进制的12或十进制的18，而将ff或FF解释为十进制的255： cin &gt;&gt; hex; istream来还为下列字符指针类型重载了&gt;&gt;抽取运算符： signed char *; char *； unsigned char *; 对于这种类型的参数，抽取运算符将读取输入中的下一个单词，将它放置到指定的地址，并加上一个空值字符，使之成为一个字符串。例如，假设有这样的一段代码： cout &lt;&lt; &quot;Enter your first name:\n&quot;; char name[20]; cin &gt;&gt; name; 如果通过键入Liz来进行响应，则抽取运算符将把字符Liz\0放到name数组中，（\0表示末尾的空值字符）。name标识符是一个char数组名，可作为数组第一个元素的地址，这使name的类型为char $\ast$（指向char的指针）。 每个抽取运算符返回调用对象的引用，这使得能够将输入拼接起来，就像拼接输出那样： char name[20]; float fee; int group; cin &gt;&gt; name &gt;&gt; fee &gt;&gt; group; 其中cin&gt;&gt;name返回的cin对象成了处理fee的对象。 17.3.1 cin&gt;&gt;如何检查输入不同版本的抽取运算符查看输入流的方法是相同的。它们跳过空白（空格、换行符和制表符），直到遇到非空白字符。即使对于单字符模式（参数类型为char、unsigned char或signed char），情况也是如此，但对于C语言的字符输入函数，情况并非如此（参见图17.5）。在单个字符模式下，&gt;&gt;运算符将读取该字符，将它放置到指定的位置。在其他模式下，&gt;&gt;运算符将读取一个指定类型的数据。也就是说，它读取从非空白字符开始，到与目标类型不匹配的第一个字符之间的全部内容。 例如，对于下面的代码： int elevation; cin &gt;&gt; elevation; 假设键入下面的字符： -123Z 运算符将读取字符-、1、2和3，因为它们都是整数的有效部分。但Z字符不是有效字符，因此输入中最后一个可接受的字符是3。Z将留在输入流中，下一个cin语句将从这里开始读取。与此同时，运算符将字符序列-123转换为一个整数值，并将它赋给elevation。 输入有时可能没有满足程序的期望。例如，假设输入Zcar，而不出-123Z。在这种情况下，抽取运算将不会修改elevation的值，并返回0（如果istream对象的错误状态被设置，if或while语句将判断该对象为false，这将在本章后面做详细的介绍）。返回值false让程序能够检查输入是否满足要求。如程序17.11所示。 程序17.11 check_it.cpp #include &lt;iostream&gt; int main() { using namespace std; cout &lt;&lt; &quot;Enter numbers: &quot;; int sum = 0; int input; while (cin &gt;&gt; input) { sum += input; } cout &lt;&lt; &quot;Last value entered = &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } 输出： Enter numbers: 200 10 -50 -123z 60 Last value entered = 0 Sum = 37 由于输入被缓冲。因此通过键盘输入的第二行在用户按下回车键之前，不会被发送给程序。然而，循环在字符Z处停止了对输入的处理，因此它不于任何一种浮点格式匹配。输入与预期格式不匹配反过来讲导致表达式cin&gt;&gt;input的结果为false，因此while循环被终止。 17.3.2 流状态我们来进一步看看不适当的输入会造成什么后果。cin或cout对象包含一个描述流状态（stream state）的数据成员（从ios_ base类那里继承的）。流状态（被定义为iostate类型，而iostate是一种bitmask类型）由3个ios_ base元素组成： eofbit、badbit或failbit，其中每个元素都是一位，可以是1（设置）或0（清楚）。当cin操作到达文件末尾时，它将设置eofbit；当cin操作未能读取到预期的字符时（像前一个例子那样），它将设置failbit。I/O失败（如试图读取不可访问的文件或试图写入写保护的磁盘），也可能讲failbit设置为1。在一些无法诊断的失败破坏流时，badbit元素将被设置（实现没有必要就哪些情况下设置failbit，哪些情况下设置bad达成一致）。当全部3个状态位都设置为0时，说明一切顺利。程序可以检查流状态，并使用这种信息来决定下一步做什么。表17.4列出了这些位和一些报告或改变流状态的ios_ base方法。 1. 设置状态表17.4中的两种方法——clear()和setstate()很相似。它们都重置状态，但采取的方式不同。clear()方法将状态设置为它的参数。因此，下面的调用将使用默认参数0，这将清除全部3个状态位（eofbit、badbit和failbit)。 clear(); 同样，下面的调用将状态设置位eofbit；也就是说，eofbit将被设置，另外两个状态位被清除： clear(eofbit); 而setstate()方法只影响其参数中已设置的位。因此，下面的调用将设置eofbit，而不会影响其他位： setstate(eofbit); 因此，如果failbit被设置，则仍将被设置。 为什么需要重新设置流状态呢？对于程序员来说，最常见的理由，在输入不匹配或到达文件尾时，需要使用不带参数的clear()重新打开输入。这样做是否有意义，取决于程序要执行的任务。稍后将介绍一些例子。setstate()的主要用途是为输入和输出函数提供一种修改状态的途径。例如，如果num是一个int，则下面的调用将可能导致operator&gt;&gt;(int &amp;)使用setstate()设置failbit或eofbit： cin &gt;&gt; num; 2. I/O和异常假设某个输入函数设置了eofbit，这是否会导致异常被引发呢？在默认情况下，答案是否定的。但可以使用exception()方法来控制异常如何被处理。 首先，介绍一些背景知识。exceptions()方法返回一个位字段，它包含3位，分别对应eofbit、failbit和badbit。修改流状态设计clear()和setstate()。这都将使用clear()。修改流状态后，clear()方法将当前的流状态与exceptions()返回的值进行比较。如果在返回值中某一位被设置，而当前状态中的对应位也被设置，则clear()将引发ios_ base::failure异常。如果两个值都设置了badbit，将发生这种情况。如果exceptions()返回goodbit，则不会引发异常。ios_ base::failure异常类是从std::exception类派生而来的，因此包含一个what()方法。 exception()的默认设置为goodbit，也就是说，没有引发异常。但重载的exceptions(iostate)函数使得能够控制其行为： cin.exceptions(badbit); //抛出badbit异常 位运算符OR(在附录E讨论)使得能够指定多位。例如，如果badbit或eof随后被设置，下面语句将引发异常： cin.exceptions(badbit | eofbit); 程序17.12对程序17.11进行了修改，以便程序能够在failbit被设置时引发并捕获异常。 程序17.12 cinexcp.cpp #include &lt;iostream&gt; #include &lt;exception&gt; int main() { using namespace std; cin.exceptions(ios_base::failbit); cout &lt;&lt; &quot;Enter numbers: &quot;; int sum = 0; int input; try{ while (cin &gt;&gt; input) { sum += input; } }catch(ios_base::failure &amp; bf) { cout &lt;&lt; bf.what() &lt;&lt; endl; cout &lt;&lt; &quot;O! the horroe!\n&quot;; } cout &lt;&lt; &quot;Last value entered = &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } 输出： Enter numbers: 20 30 40 pi 6 basic_ios::clear O! the horroe! Last value entered = 0 Sum = 90 这就是如何接受输入时使用异常。然而，应该使用它们吗？这取决于具体情况。就这个例子而言，答案是否定的。异常用于捕获不正常的意外情况，但这个例子将输入错误作为一种退出循环的方式。然而，让这个程序在badbit位被设置时引发异常可能是合理的，因为这种情况是意外的。如果程序被设计成一个数据文件中读取数据，直到到达文件尾，则在failbit位被设置时引发异常也是合理的，因为这表明数据文件出现了问题。 3. 流状态的影响只有在流状态良好（所有的位都被清除）的情况下，下面的测试才返回true: while (cin &gt;&gt; input) 如果测试失败，可以使用表17.4中的成员函数来判断可能的原因。例如，可以将程序17.11中的核心部分修改成这样： while (cin &gt;&gt; input) { sum += input; } if (cin.eof()) cout &lt;&lt; &quot;Loop terminated because EOF encountered\n&quot;; 设置流状态有一个非常重要的后果：流将对后面的输入或输出关闭，直到位被清除。例如，下面的代码不可行： while (cin &gt;&gt; input) { sum += input; } cout &lt;&lt; &quot;Last value entered = &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;Now enter a new number: &quot;; cin &gt;&gt; input; //不会工作 如果希望程序在流状态位被设置后能够读取后面的输入，就必须将流状态重置为良好。这可以通过调用clear()方法来实现： while (cin &gt;&gt; input) { sum += input; } cout &lt;&lt; &quot;Last value entered = &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;Now enter a new number: &quot;; cin.clear(); while (!isspace(cin.get())) continue; cin &gt;&gt; input; //工作 注意，这还不足以重新设置流状态。导致输入循环终止的不匹配输入仍留在输入队列中，程序必须跳过它。一种方法是一直读取字符，直到到达空白为止。isspace()函数（参见第6章）是一个cctype函数，它在参数是空白字符时返回true。另一种方法时，丢弃行中的剩余部分，而不仅仅是下一个单词： while (cin.get() != &apos;\n&apos;) continue; 这个例子假设循环由于不恰当的输入而终止。现在，假设循环是由于到达文件尾或由于硬件故障而终止的，则处理错误输入的新代码将毫无意义。可以使用fail()方法检测假设是否正确，来修复问题。由于历史原因，fail()在failbit或eofbit被设置时返回true，因此代码必须排除后一种情况。下面是一个排除这种情况的例子： while (cin &gt;&gt; input) { sum += input; } cout &lt;&lt; &quot;Last value entered = &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; endl; if ( cin.fail() &amp;&amp; !cin.eof() ) { cin.clear(); while ( !isspace(cin.get())) continue; } else { cout &lt;&lt; &quot;I cannot go on!\n&quot;; exit(1); } cout &lt;&lt; &quot;Now enter a new number: &quot;; cin &gt;&gt; input; 17.3.3 其他istream类方法第3章~第5章讨论了get()和getline()方法。您可能还记得，它们提供下面的输入功能： 方法get(char &amp;)和get(void)提供不跳过空白的单字符输入功能； 函数get(char $\ast$, int , char)和getline(char $\ast$, int , char)在默认情况下读取整行而不是一个单词。 它们被称为非格式化输入函数，因为它们只是读取字符输入，而不会跳过空白，也不进行数据转换。 来看一下istream类的这两组成员函数。 1. 单字符输入在使用char参数或没有参数的情况下，get()方法读取下一个输入字符，即使该字符是空格、制表符或换行符。get(char &amp; ch)版本将输入字符赋给其参数，而get(void)版本将输入字符转换为整型（通常是int）并将其返回。 （1）成员函数get(char &amp;) 先来看get(char &amp;)。假设程序中包含如下循环： int ct = 0; char ch; cin.get(ch); while (ch != &apos;\n&apos;) { cout &lt;&lt; ch; ct ++; cin.get(ch); } cout &lt;&lt; ct &lt;&lt; endl; 接下来，假设提供了如下输入： I C++ clearly.&lt;Enter&gt; 按下回车键后，这行输入将被发送给程序。上述程序片段键首先读取字符I，使用cout显示它，并将ct递增到1。接着，他读取I后面的空格字符，显示它，并将 ct递增到2。这一过程将一直继续下去，直到程序将回车键作为换行符处理，并终止循环。这里的重点是，通过使用get(ch)，代码读取、显示并考虑空格和可打印字符。 假设程序试图使用&gt;&gt;: int ct = 0; char ch; cin &gt;&gt; ch; while (ch != &apos;\n&apos;) { cout &lt;&lt; ch; ct++; cin &gt;&gt; ch; } cout &lt;&lt; ct &lt;&lt; endl; 则代码键首先跳过空格，这样讲不考虑空格，因此相应的输出压缩为如下： IC++clearly. 更糟糕的是，循环不会终止！由于抽取运算符跳过了换行符，因此代码不会见换行符赋给ch，所以while循环测试将不会终止循环。 get(char &amp;)成员函数返回一个指向调用它的istream对象的引用，这意味着可以拼接get(char &amp;)后后面的其他抽取： char c1, c2, c3; cin.get(c1).get(c2) &gt;&gt; c3; 首先，cin.get(c1)将第一个输入字符赋给c1，并返回调用对象——cin。这样代码缩为cin.get(c2)&gt;&gt;c3，它将第二个输入字符赋给c2。该函数调用返回cin，将代码缩为cin&gt;&gt;c3。这将把下一个非空白字符赋给c3。因此c1和c2的值最后可能为空格，但c3不是。 如果cin.get(char &amp;)到达文件尾——无论是真正的文件尾，还是通过键盘仿真的文件尾（对于DOS和Windows命令提示符模式，为按下Ctrl+Z；对于UNIX，是在行首按下Ctrl+D），它都不会给其他参数赋值。这是完全正确的，因为如果程序到达文件尾，就没有值可供赋给参数了。另外，该方法还调用setstate(failbit)，导致cin的测试结果为false: char ch; while (cin.get(ch)) { //输入处理 } 只要存在有效输入，cin.get(ch)的返回值都将是cin，此时的判定结果为true，因此循环将继续。到达文件尾时，返回值判定为false，循环终止。 （2）成员函数get(void) get(void)成员函数还读取空白，但使用返回值来讲输入传递给程序。因此可以这样使用它： int ct = 0; char ch; ch = cin.get(); while (ch != &apos;\n&apos;) { cout &lt;&lt; ch; ct++; ch = cin.get(); } cout &lt;&lt; ct &lt;&lt; endl; get(void)成员函数的返回类型为int(或某种更大的整型，这取决于字符集和区域)。这使得下面的代码是非法的： char c1, c2, c3; cin.get().get() &gt;&gt; c3; //错误 这里cin.get()将返回一个int值。由于返回值不是类对象，因此不能对它应用成员运算符。因此将出现语法错误。然而，可以在抽取序列的最后使用get(): char c1; cin.get(c1).get(); get(void)的返回类型为int，这意味着它后面不能跟抽取运算符。然而，由于cin.get(c1)返回cin，因此它可以放在get()的前面。上述代码将读取第一个输入字符，将其赋给c1，然后丢弃第二个输入字符。 到达文件尾后（不管是真正的文件尾还是模拟的文件尾），cin.get(void)都将返回值EOF——头文件iostream提供的一个符号常量。这种设计特性使得可以这样来读取输入： int ch; while( (ch = cin.get()) != EOF ) { //输入处理 } 这里应将ch的类型声明尾int，而不是char，因为值DOF可能无法使用char类型来表示。 第5章更详细地介绍了这些函数，表17.5对单字符输入函数的特性进行了总结。 2. 采用哪种单字符输入形式假设可以选择&lt;&lt;、get(char &amp;)或get(void)，应使用哪一个呢？首先，应确定是否希望跳过空白。如果跳过空白更方便，则使用抽取运算符&gt;&gt;。例如，提供菜单选项时，跳过空白更为方便： cout &lt;&lt; &quot;a. annoy client b. bill client\n&quot; &lt;&lt; &quot;c. clear client d. deceive client\n&quot; &lt;&lt; &quot;q. \n&quot;; cout &lt;&lt; &quot;Enter a, b, c, d, or q: &quot;; char ch; cin &gt;&gt; ch; while (ch != &apos;q&apos;) { switch(ch) { ... } cout &lt;&lt; &quot;Enter a, b, c, d, or q: &quot;; cin &gt;&gt; ch; } 要输入b进行响应，可以键入b并按回车键，这将生成两个字符的响应——b\n。如果使用get()，则必须添加在每次循环中处理\n字符的代码，而抽取运算符可以跳过它。 如果希望程序检查每个字符，请使用get()方法，例如计算字数的程序可以使用空格来判断单词何时结束。在get()方法中，get(char &amp;)的结果更佳。get(void)的主要优点是，它与标准C语言中的getchar()函数极其类似，这意味着可以通过包含iostream，并使用cin.get()替换所有的getchar()，用cout.put(ch)替换所有的putchar(ch)，来将C程序转换为C++程序。 3.字符串输入：getline()、get()和ignore()接下来复习一下第4章介绍的字符串输入成员函数。getline()成员函数和get()的字符串版本都读取字符串，它们的函数特征标相同（这是从更为通用的模板声明简化而来的）： istream &amp; get(char *, int, char); istream &amp; get(char *, int); istream &amp; getline(char *, int, char); istream &amp; getline(char *, int, char); 第一个参数是用于放置输入字符串的内存单元的地址。第二个参数比要读取的最大字符数大1（额外的一个字符用于存储结尾的空字符，以便将输入存储为一个字符串）。第三个参数指定用作分界符的字符，只有两个参数的版本将换行符作为分界符。上述函数都在读取最大数目的字符或遇到换行符后为止。 例如， 下面的代码将字符输入读取到字符数组line中： char line[50]; cin.get(line, 50); cin.get()函数将在到达第49个字符或遇到换行符（默认情况下）后停止将输入读取到数组中。get()和getline()之间的区别在于，get()将换行符留在输入流中，这样接下来的输入操作首先看到的将是换行符，而getline()抽取并丢弃输入流中的换行符。 第4章演示了如何使用两个成员函数的默认格式。现在来看一下接受三个参数的版本，第三个参数用于指定分界符。遇到分界符后，输入将停止，即使还未读取最大数目的字符。因此，在默认情况下，如果在读取指定数目的字符之前到达行尾，这两种方法都将停止读取输入。和默认情况一样，get()将分界字符留在输入丢列中，而getline()不保留。 程序17.13演示了getline()和get()是如何工作的，它还介绍了ignore()成员函数。该函数接受两个参数：一个是数字，指定要读取的最大字符数；另一个是字符，用作输入分界符。例如，下面的函数调用读取并丢弃接下来的255个字符或直到到达第一个换行符： cin.ignore(255, &apos;\n&apos;); 原型为两个参数提供的默认值为1和EOF，该函数的返回类型为istream &amp;: istream &amp; ignore(int = 1, int = EOF); 默认参数EOF导致ignore()读取指定数目的字符或读取到文件尾。 该函数返回调用对象，这使得能够拼接函数调用，如下所示： cin.ignore(255, &apos;\n&apos;).ignore(255, &apos;\n&apos;); 其中，第一个ignore()方法读取并丢弃一行，而第二个调用读取并丢弃另一行，因此一共读取了两行。现在来看一看程序17.13。 程序17.13 get_gun.cpp #include &lt;iostream&gt; const int Limit = 255; int main() { using std::cout; using std::cin; using std::endl; char input[Limit]; cout &lt;&lt; &quot;Enter a string for getline() preocessing:\n&quot;; cin.getline(input, Limit, &apos;#&apos;); cout &lt;&lt; &quot;Here is your input:\n&quot;; cout &lt;&lt; input &lt;&lt; &quot;\nDone with phase 1\n&quot;; char ch; cin.get(ch); cout &lt;&lt; &quot;The next input character is &quot; &lt;&lt; ch &lt;&lt; endl; if (ch != &apos;\n&apos;) cin.ignore(Limit, &apos;\n&apos;); cout &lt;&lt; &quot;Enter a string for get() processing:\n&quot;; cin.get(input, Limit, &apos;#&apos;); cout &lt;&lt; &quot;Here is your input:\n&quot;; cout &lt;&lt; input &lt;&lt; &quot;\nDone with phase 2\n&quot;; cin.get(ch); cout &lt;&lt; &quot;The next input character is &quot; &lt;&lt; ch &lt;&lt; endl; return 0; } 输出： Enter a string for getline() preocessing: Please pass me a #3 melon Here is your input: Please pass me a Done with phase 1 The next input character is 3 Enter a string for get() processing: I still want my #3 melon! Here is your input: I still want my Done with phase 2 The next input character is # 注意，getline()函数将丢弃输入中的分界字符#，而get()函数不会。 4. 意外字符串输入get(char $\ast$, int)和getline()的某些输入形式将影响流状态。与其他输入函数一样，这两个函数在遇到文件尾时将设置eofbit，遇到流被波坏（如设备故障）时将设置badbit。另外两种特殊情况是无输入以及输入到达或超过函数调用指定的最大字符数。下面来看这些情况。 对于上述两个方法，如果不能抽取字符，它们将把空值字符放置到输入字符串中，并使用setstate()设置failbit。方法在什么时候无法抽取字符呢？一种可能的情况是输入方法立刻到达文件尾。对于get(char $\ast$, int)来说，另一个种可能是输入了一个空行： char temp[80]; while (cin.get(temp, 80)) //空行终止 有意思的是，空行并不会导致getline()设置failbit。这是因为getline()仍将抽取换行符，虽然不会存储它。如果希望getline()在遇到空行时终止循环，则可以这样编写： char temp[80]; while (cin.getline(temp, 80) &amp;&amp; temp[0] != &apos;\0&apos;) 现在假设输入队列中的字符数等于或超过了输入方法指定的最大字符数。首先，来看getline()和下面的代码： char temp[30]; while (cin.getline(temp, 30)) getline()方法将从输入队列中读取字符，将它们放到temp数组的元素中，直到到达文件尾、将要读取的字符是换行符或存储了29个字符为止。如果遇到文件尾，则设置eofbit；如果将要读取的字符是换行符，则该字符将被读取丢弃；如果读取了29个字符，并且下一个不是换行符，则设置failbit。因此，包含30个或更多字符的数组行将终止输入。 现在来看get(char $\ast$, int)方法。它首先测试字符数，然后测试是否在文件尾以及下一个字符是否是换行符。如果它读取了最大数目的字符，则不设置failbit。然而，由此可以直到终止读取是否是由于输入字符过多引起的。可以用peek()（参见下一节）来查看一个输入字符。如果它是换行符，则说明get()已读取了整行；如果不是换行符，则说明get()是在到达行尾强停止的。这种技术对getline()不适用，因为getline()读取并丢弃换行符，因此查看下一个字符无法直到任何情况。然而，如果使用的是get()，则可以直到是否读取了整个一行。下一节将介绍这种方法的一个例子。另外，表17.6总结了这些行为。 17.3.4 其他istream方法除前面讨论过的外，其他istream方法包括read()、peek()、gcount()和putback()。read()函数读取指定数目的字节，并将它们存储在指定的位置。例如，下面的语句从标准输入流中读取144个字符，并将它们存储到gross数组中： char gross[144]; cin.read(gross, 144); 与getline()和get()不同的是，read()不会再输入后加上空值字符，因此不能将输入转换为字符串。read()方法不是专门为键盘输入设计的，它最常与ostream write()函数结合使用，来完成文件输入和输出。该方法的返回类型为istream &amp;，因此可以像下面这样将它拼接起来： char gross[144]; char score[20]; cin.read(gross, 144).read(score, 20); peek()函数返回输入中的下一个字符，但不抽取输入流中的字符。也就是说，它使得能够查看下一个字符。假设要读取输入，直到遇到换行符或句点，则可以使用peek()查看输入流中的下一个字符，以此来判断是否继续读取： char great_input[80]; char ch; int i = 0; while ( (ch = cin.peek() != &apos;.&apos; &amp;&amp; ch != &apos;\n&apos;) cin.get(great_input[i++]); great_input [i[ = &apos;\0&apos;; cin.peek()查看下一个输入字符，并将它赋给ch。然后，while循环的测试条件检查ch是否是句点或换行符。如果是，循环将该字符读入到数组中，并更新数组索引。当循环终止时，句点和换行符将留在输入流中，并作为接下来的输入操作读取的第一个字符。然后，代码将一个空值字符放在数组的最后，使之成为一个字符串。 gcount()方法返回最后一个非格式化抽取方法读取的字符数。这意味着字符是由get()、getline()、ignore()或read()方法读取的，不是由抽取运算符&lt;&lt;读取的，抽取运算符对输入进行格式化，使之与特定的数据类型匹配。例如，假设使用cin.get(myarray, 80)将一行读入myarray数组中，并想直到读取了多少个字符，则可以使用strlen()函数来计算数组的字符数，这种方法比使用cin.gcount()计算从输入流中读取了多少字符的速度要快。 putback()函数将一个字符插入到输入字符串中，被插入的字符将是下一个输入语句读取的第一个字符。putback()方法接受一个char参数——要插入的字符，其返回类型为istream &amp;，这使得可以将该函数调用与其他istream方法拼接起来。使用peek()的效果相当于先使用get()读取一个字符，然后使用putback()将该字符放回到输入流中。然而，putback()允许将字符放到不是刚才读取的位置。 程序17.14采用两种方式来读取并显示输入中#字符（不包括）之前的内容。第一种方法读取#字符，然后使用putback()将它插回到输入中。第二种方法在读取之前peek()查看下一个字符。 程序17.14 peeker.cpp #include &lt;iostream&gt; #include &lt;cstdlib&gt; int main() { using namespace std; char ch; while (cin.get(ch)) { if ( ch != &apos;#&apos;) cout &lt;&lt; ch; else { cin.putback(ch); break; } } if (!cin.eof()) { cin.get(ch); cout &lt;&lt; endl &lt;&lt; ch &lt;&lt; &quot; is next input character.\n&quot;; } else { cout &lt;&lt; &quot;End of file reached.\n&quot;; exit(0); } while (cin.peek() != &apos;#&apos;) { cin.get(ch); cout &lt;&lt; ch; } if (!cin.eof()) { cin.get(ch); cout &lt;&lt; endl &lt;&lt; ch &lt;&lt; &quot; is next input character.\n&quot;; } else cout &lt;&lt; &quot;End of file reached.\n&quot;; return 0; } 输出： I used a #3 pencil when I should have used a #2. I used a # is next input character. 3 pencil when I should have used a # is next input character. 程序说明 来详细讨论程序17.14中的一些代码。第一种方法是用while循环来读取输入： while (cin.get(ch)) { if (ch != &apos;#&apos;) cout &lt;&lt; ch; else { cin.putback(ch); break; } } 到达文件尾时，表达式（cin.get(ch)）将返回false，因此从键盘模拟文件尾将终止循环。如果#字符首先出现，则程序将该字符放回到输入流中，并使用break语句来终止循环。 第二种方法看上去简单： while( cin.peek() != &apos;#&apos;) { cin.get(ch); cout &lt;&lt; ch; } 程序查看下一个字符。如果它不是#，则读取并显示它，然后再查看下一个字符。这一过程将一直继续下去，直到出现分界字符。 现在来看一个例子（参见程序17.15），它使用peek()来确定是否读取了整行。如果一行中只有部分内容被加入到输入数组中，程序将删除余下的部分。 程序17.15 truncate.cpp #include &lt;iostream&gt; const int SLEN = 10; inline void eatline() { while (std::cin.get() != &apos;\n&apos;) continue; } int main() { using namespace std; char name[SLEN]; char title[SLEN]; cout &lt;&lt; &quot;Enter your name: &quot;; cin.get(name, SLEN); if (cin.peek() != &apos;\n&apos;) cout &lt;&lt; &quot;Sorry, we only have enouth room for &quot; &lt;&lt; name &lt;&lt; endl; eatline(); cout &lt;&lt; &quot;Dear &quot; &lt;&lt; name &lt;&lt; &quot;, enter your title:\n&quot;; cin.get(title, SLEN); if (cin.peek() != &apos;\n&apos;) cout &lt;&lt; &quot;We were forced to truncate your title.\n&quot;; eatline(); cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;\nTitle: &quot; &lt;&lt; title &lt;&lt; endl; return 0; } 输出： Enter your name: Ella Fishsniffer Sorry, we only have enouth room for Ella Fish Dear Ella Fish, enter your title: Excutive Adjunct We were forced to truncate your title. Name: Ella Fish Title: Excutive 注意，下面的代码确定第一条输入语句是否读取了整行： while (cin.get() != &apos;\n&apos;) continue; 如果get()读取了整行，它将保留换行符，而上述代码将丢弃换行符。如果get()只读取一部分，则上述代码将读取并丢弃该行中余下的内容。如果不删除余下的内容，则下一条输入语句将从第一个输入行中余下部分的开始位置读取。对于这个例子，这将导致程序把字符串sniffer读取到title数组中。 17.4 文件输入和输出大多数计算机程序都使用了文件。字处理程序创建文档文件；数据库程序创建和搜索信息文件；编译器读取源代码并生成可执行文件。文件本身是存储在某种设备上的一系列字节。通常，操作系统管理文件，跟踪它们的位置、大小、创建时间等。除非在操作系统级别编程，否则通常不必担心这些事情。需要的只是将程序与文本相连的途径、让程序读取文件内容的途径以及让程序创建和写入文件的途径。重定向（本章前面讨论过）可以提供一些文件支持，但它比显式程序中的文件I/O的局限性更大。另外，重定向来自操作系统，而非C++，因此并非所有系统都有这样的功能。前面简要地介绍过文件I/O，这里将更详细讨论这个主题。 C++ I/O类软件包处理文件输入和输出的方式与处理标准输入和输出的方式非常相似。要写入文件，需要创建一个ofstream对象，并使用ostream方法，如&lt;&lt;插入运算符或write()。要读取文件，需要创建一个ifstream对象，并使用istream方法，如&gt;&gt;抽取运算符和read()。然而，与标准输入和输出相比，文件的管理更为复杂。例如，将新打开的文件和流关联起来。可以以只读模式、只写模式或读写模式打开文件。写文件时，可能想创建新文件、取代旧文件或添加到旧文件中，还可能想在文件中来回移动。为帮助处理这些任务，C++在头文件fstream中定义了多个新类，其中包括用户文件输入的ifstream类和用于文件输出的ofstream类。C++还定义了一个fstream类，用于同步文件I/O。这些类都是从头文件iostream中的类派生而来的，因此这些新类的对象可以使用前面介绍过的方法。 17.4.1 简单的文件I/O要让程序写入文件，必须这样做： 创建一个ofstream对象来管理输出流； 将该对象与特定的文件关联起来； 以使用cout的方式使用该对象，唯一的区别是在输出文件进入文件，而不是屏幕。 要完成上述任务，首先应先包含头文件fstream。对于大多数实现来说，包含该文件便自动包括iostream文件，因此不必显式包含iostream。然后声明一个ofstream对象： ofstream fout; 对象名可以是任意有效的C++名称，如fout、outFile、cgate或didi。 接下来，必须将这个对象与特定的文件关联起来。为此，可以使用open()方法。例如，假设要打开文件jax.txt进行输出，则可以这样做： fout.open(&quot;jar.txt&quot;); 可以使用另一个构造函数将这两步（创建对象和关联到文件）合并成一条语句： ofstream fout(&quot;jar.txt&quot;); 然后，以使用cout的方式使用fout。例如，要将Dull Data放到文件中，可以这样做： fout &lt;&lt; &quot;Dull Data&quot;; 由于ostream是ofstream类的基类，因此可以使用所有的ostream方法，包括各种插入运算符定义、格式化方式和控制符。ofstream类使用被缓冲的输出，因此程序在创建像ofstream对象时，将为输出缓冲区分配空间。如果创建了两个ofstream对象，程序将创建两个缓冲区，每个对象各一个。像fout这样的ofstream对象从程序那里逐字节地收集输出，当缓冲区填满后，它便将缓冲区内容一同传输给目标文件。由于磁盘驱动器被设计成以大块的方式传输数据，而不是逐字节地传输，因此通过缓冲可以大大提高从程序到文件传输数据的速度。 以这种方式打开文件来进行输出时，如果没有这样的文件，将创建一个新文件；如果有这样的文件，则开打文件将清空文件，输出将进入到一个空文件中。本章后面介绍如何打开已有的文件，并保留其内容。 警告:以默认模式打开文件进行输出将自动把文件的长度截断为零，这相当于删除已有的内容。 读取文件的要求与写入文件相似： 创建一个ifstream对象来管理输入流； 将该对象与特定的文件关联起来； 以使用cin的方式使用该对象。 上述读取文件的步骤类似于写文件。首先，当然要包含头文件fstream。然后声明一个ifstream对象，将它与文件名关联起来。可以使用一两条语句来完成这项工作: ifstream fin; fin.open(&quot;jellyjar.txt&quot;); ifstream fis(&quot;jamjar.txt&quot;); //创建fis并关联jamjar.txt文件 现在，可以像使用cin那样使用fin或fis。例如，可以这样做： char ch; fin &gt;&gt; ch; char buf[80]; fin &gt;&gt; buf; fin.getline(buf, 80); string line; getline(fin, line); 输入和输出一样，也是被缓冲的，因此创建ifstream对象与fin一样，将创建一个由fin对象管理的输入缓冲区。与输出一样，通过缓冲，传输数据的速度比逐字节传输要快得多。 当输入和输出对象过期（如程序终止）时，到文件的连接将自动关闭。另外，也可以使用close()方法来显式地关闭到文件的连接： fout.close(); fin.close(); 关闭这样的连接并不会删除流，而只是断开流到文件的连接。然而，流管理装置仍被保留。例如，fin对象与它管理的输入缓冲区仍然在。您稍后将知道，可以将流重新连接到同一个文件或另一个文件。 我们来看一个简短的例子。程序17.16要求输入文件名，然后创建一个名称为输入名的文件，将一些信息写入到文件中，然后管理该文件。关闭文件将刷新缓冲区，从而确保文件被更新。然后，程序打开该文件，读取并显式其内容。注意，该程序以使用cin和cout的方式使用fin和fout。另外，该程序将文件名读取到一个string对象中，然后使用方式c_str()来给ofstream和ifstream的构造函数提供一个C-风格字符串参数。 程序17.16 fileio.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; using namespace std; int main() { string filename; cout &lt;&lt; &quot;Enter name for new file: &quot;; cin &gt;&gt; filename; ofstream fout(filename.c_str()); fout &lt;&lt; &quot;For your eyes onley!\n&quot;; cout &lt;&lt; &quot;Enter your secret number: &quot;; float secret; cin &gt;&gt; secret; fout &lt;&lt; &quot;Your secret number is &quot; &lt;&lt; secret &lt;&lt; endl; fout.close(); ifstream fin(filename.c_str()); cout &lt;&lt; &quot;Here are the contents of &quot; &lt;&lt; filename &lt;&lt; &quot;:\n&quot;; char ch; while (fin.get(ch)) cout &lt;&lt; ch; cout &lt;&lt; &quot;Done.\n&quot;; fin.close(); return 0; } 输出： Enter name for new file: pythag Enter your secret number: 3.14159 Here are the contents of pythag: For your eyes onley! Your secret number is 3.14159 Done. 如果查看该程序所在的目录，将看到一个名为pythag的文件，使用文件编辑器打开该文件，其内容将于程序输出相同。 17.4.2 流状态检查和is_open()C++文件流类从ios_ base类那里继承了一个流状态成员。正如前面指出的，该成员存储了指出流状态的信息：一切顺利、已到达文件尾、I/O操作失败等。如果一切顺利，则流状态为零。其他状态都是通过将特定位设置位1来记录。文件流还继承了ios_ base类中报告流状态的方法，表17.4对这些方式进行了总结。可以通过检查流状态来判断最后一个流操作是否成功。对于文件流，这包括检查试图打开文件时是否成功。例如，试图打开一个不存的文件进行输入时，将设置failbit位，因此可以这样进行检查： fin.open(argv([file]); if (fin.fail()) //如果打开失败 {...} 由于ifstream对象和istream对象一样，被放在需要bool类型的地方时，将被转换为bool值，因此您也可以这样做： fin.open(arge[file]); if (!fin) {...} 然而，较新的C++实现提供了一种更好的检查文件是否被打开的方法——is_open()方法： if(!fin.is_open()) {...} 这种方式之所以更好，是因为它能够检测出其他方式不能检测出的微妙问题，接下来的“警告”将讨论这一点。 警告：以前，检查文件是否成功打开的常见方式如下： if(fin.fail()) if(!fin) if(!fin.good()) fin对象被用于测试条件中时，如果fin.good()为false，将被转换为true；否则将被转换为false。因此上述三种方式等价。然而这些测试无法检测到这样一种情况：试图一不合格的文件模式（参见后面的“文件模式”一节）打开文件时失败。方法is_ open()能够检测到这种错误以及good()能够检测到的错误。然而，老式C++实现没有is_ open()。 17.4.3 打开多个文件程序可能需要打开多个文件。打开多个文件的策略取决于它们被如何使用。如果需要同时打开两个文件，则必须为每个文件创建一个流。例如，将两个排序后的文件拼接成第三个文件的程序，需要为两个输入文件创建两个ifstream对象，并为输出文件创建一个ofstream对象。可以同时打开的文件数取决于操作系统。 然而，可能要依次处理一组文件。例如，可能要计算某个名称在10个文件中出现的次数。在这种情况下，可以打开一个流，并将它依次关联到各个文件。这在节省计算机资源方面，比为每个文件打开一个流的效率高。使用这种方法，首先需要声明一个ifstream对象（不对它进行初始化），然后使用open()方法将这个流与文件关联起来。例如，下面是依次读取两个文件的代码： ifstream fin; fin.open(&quot;fat.txt&quot;); ... fin.close(); //关闭fin与文件fat.txt的连接 fin.clear(); //重置fin fin.open(&quot;rat.text&quot;); ... fin.close(); 稍后将介绍一个例子，但先来看这样一种将一系列文件输入给程序的技术，即让程序能够使用循环来处理文件。 17.4.4 命令行处理技术文件处理程序通常使用命令行参数来指定文件。命令行参数是用户在输入命令时，在命令行中输入的参数。例如，要在UNIX或Linux系统中计算文件包含的字数，可以在命令行提示符输入下面的命令： wc report1 report2 report3 其中，wc是程序名，report1、report2和report3是作为命令行参数传递给程序的文件名。 C++有一种让命令行环境中运行的程序能够访问命令行参数的机制，方法是使用下面的main(): int main(int argc, char *argv[]) argc为命令行中的参数个数，其中包括 命令名本身。argv变量为一个指针，它指向一个指向char的指针。这过于抽象，但可以将argv看作一个指针数组，其中的指针指向命令参数，argv[0]是一个指针，指向存储第一个命令行参数的字符串的第一个字符，依次类推。也就是说，argv[0]是命令行中的第一个字符串，依次类推。例如，假设有下面的命令行： wc report1 report2 report3 则argc为3，argv[0]为wc，argv[1]为report1，依次类推。下面的循环将把每个命令行参数分别打印在单独一行上： for (int i = 1; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; 以i=1开头将只打印命令行参数；以i=0开头将同时打印命令名。 当然，命令行参数与命令行操作系统（如Windows命令提示符模式、UNIX和Linux）紧密联系。其他程序也可能允许使用命令行参数。 很多Windows IDA（集成开发环境）都有一个提供命令行参数的选项。通常，必须选择一系列菜单，才能打开一个可以输入命令行参数的对话框。具体的步骤随厂商和升级版本而异，因此请查看文档。 很多Windows IDE都可以生成可执行文件，这些文件能够在Windows命令提示符模式下运行。 程序17.17结合使用命令行技术和文件流技术，来计算命令行上列出的文件包含的字符数。 程序17.17 count.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; int main(int argc, char * argv[]) { using namespace std; if (argc == 1) { cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; filename[s]\n&quot;; exit(EXIT_FAILURE); } ifstream fin; long count; long total = 0; char ch; for (int file = 1; file &lt; argc; file++) { fin.open(argv[file]); if (!fin.is_open()) { cerr &lt;&lt; &quot;Cloud not open &quot; &lt;&lt; argv[file] &lt;&lt; endl; fin.clear(); continue; } count = 0; while (fin.get(ch)) count++; cout &lt;&lt; count &lt;&lt; &quot; characters in &quot; &lt;&lt; argv[file] &lt;&lt; endl; total += count; fin.clear(); fin.close(); } cout &lt;&lt; total &lt;&lt; &quot; characters in all files\n&quot;; return 0; } 输出: [root@localhost ~]# ./a.out Usage: ./a.out filename[s] [root@localhost ~]# ./a.out paris rome Cloud not open paris Cloud not open rome 0 characters in all files //需要提前创建两个文件 [root@localhost ~]# ./a.out paris rome 63 characters in paris 22 characters in rome 85 characters in all files 该程序使用cerr表示错误信息。另外，消息使用argv[0]，而不出a.out: cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot;filename[s]\n&quot;; 如果修改了可执行文件的名称，则程序将自动使用新的名称。 该程序使用is_open()方法来确定能够打开指定的文件，下面更深入地探讨这一主题。 17.4.5 文件模式文件模式描述的是文件被如何使用：读、写、追加等。将流域文件关联时（无论是使用文件名初始化文件流对象，还是使用open()方法），都可以提供指定文件模式的第二个参数： ifstream fin(&quot;banjo&quot;, model); ofstream fout(); fout.oepn(&quot;harp&quot;, mode2); ios_ base类定义了一个openmode类型，用于表示模式；域fmtflags和iostate类型一样，它也是一种bitmask类型(以前，其类型为int)。可以选择ios_base类中定义的多个常量来指定模式，表17.7列出了这些常量及其定义。C++文件I/O作了一些改动，以便与ANSI C文件I/O兼容。 如果ifstream和ofstream构造函数以及open()方法都接受两个参数，为什么前面的例子只是用一个参数就可以调用它们呢？您可能猜到了，这些类成员函数的原型为第二个参数（文件模式参数）提供了默认值。例如，ifstream open()方法和构造函数用ios_ base::in（打开文件以读取）作为模式参数的默认值，而ofstream open()方法和构造函数用ios_ base::out | ios_ base::trunc(打开文件，以读取并截短文件)作为默认参数。位运算符OR（1）用于将两个位值合并成一个可用于设置两个位的值。fstream类不提供默认的模式值，因此在创建这种类的对象时，必须显式地提供模式。 注意，ios_ base::trunc标记意味着打开已有的文件，以接收程序输出时将被截短；也就是说，其以前的内容将被删除。虽然这种行为极大地降低了耗尽磁盘空间的危险，但您也许能够想象到这样的情形，即不希望打开文件时将其内容删除。当然，C++提供了其他选择。例如，如果要保留文件内容，并在文件尾添加（追加）新信息，则可以使用ios_ base::app模式： ofstream fout(&quot;bagels&quot;, ios_base::out | ios_base::app); 上述代码也使用|运算符来合并模式，因此ios_ base::out|ios_base::app意味着启动模式out和app（参见图17.6）。 老式C++实现之间可能有一些差异。例如，有些实现允许省略前一例子中的ios_base::out，有些则不允许。如果不使用默认模式，则最安全的方式是显式地提供所有的模式元素。有些编译器不支持表17.6中的所有选项，有些则提供了表中没有列出的其他选项。这些差异导致的后果之一是，可能必须对后面的例子作一些修改，使之能够在所用的系统中运行。好在C++标准提供了更高的统一性。 标准C++根据ANSI标准I/O定义了部分文件I/O。实现下下面这样的C++语句时： ifstream fin(filename, c++moe); 就像它使用了C的fopen()函数一样： fopen(filename, cmode); 其中，C++mode是一个openmode值，如ios_ base::in；而cmode是相应的C模式字符串，如“r”。表17.8列出了c++模式和C模式的对应关系。注意，ios_ base::out本身将导致文件被截断，但与ios_ base::in一起使用时，不会导致文件被截短。没有列出的组合，如ios_ base::in[vn]ios_ base::trunc，将禁止文件被打开。is_ open()方法用于检测这种故障。 注意，ios_ base::ate和ios_ base::app都将文件指针指向打开的文件尾。二者的区别在于，ios_ base::app模式只允许将数据添加到文件尾，而ios_base::ate模式将指针放到文件尾。 显然，各种模式的组合很多，我们将介绍集中有代表性的组合。 1. 追加文件来看一个在文件尾追加数据的程序。该程序维护一个存储来客清单的文件。该程序首先显式文件当前的内容。在尝试打开文件后，它使用is_ open()方法来检查该文件是否存在。接下来，程序以ios_ base::app模式打开文件，进行输出。然后，它请求用户从键盘输入，并将其添加到文件中。最后，程序显式修改后的文件内容。程序17.18演示了如何实现这些目标。请注意，程序是如何使用is_ open()方法来检测文件是否被成功打开的。 注意：在早期，文件I/O可能是C++最不标准的部分，很多老式编译器都不遵守当前的标准。例如，有些编译器使用诸如nocreate等模式，而这些模式不是当前标准的组成部分。另外，只有一部分编译器要求第二次打开同一个文件进行读取之前调用fin.clear()。 程序17.18 append.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; const char * file = &quot;guests.txt&quot;; int main() { using namespace std; char ch; ifstream fin; fin.open(file); if (fin.is_open()) { cout &lt;&lt; &quot;Here are the current contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (fin.get(ch)) cout &lt;&lt; ch; fin.close(); } ofstream fout(file, ios::out | ios::app); if (!fout.is_open()) { cerr &lt;&lt; &quot;Can&apos;t open &quot; &lt;&lt; file &lt;&lt; &quot; file for output.\n&quot;; exit(EXIT_FAILURE); } cout &lt;&lt; &quot;Enter guest names(enter a blank line to quit):\n&quot;; string name; while (getline(cin, name ) &amp;&amp; name.size() &gt; 0) fout &lt;&lt; name &lt;&lt; endl; fout.close(); fin.clear(); fin.open(file); if (fin.is_open()) { cout &lt;&lt; &quot;Here are the new contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (fin.get(ch)) cout &lt;&lt; ch; fin.close(); } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： Enter guest names(enter a blank line to quit): Genghis Kant Hank Attila Charles Bigg Here are the new contents of the guests.txt file: Genghis Kant Hank Attila Charles Bigg Done. 此时，guests.txt文件还没有创建，因此程序不能预览该文件。 但第二次运行该程序时，guests.txt文件已经存在，因此程序将预览该文件。另外，新数据被追加到旧文件的后面，而不是取代它们。 Here are the current contents of the guests.txt file: Genghis Kant Hank Attila Charles Bigg Enter guest names(enter a blank line to quit): Greta Greppo LaDonna Mobile Fannie Mae Here are the new contents of the guests.txt file: Genghis Kant Hank Attila Charles Bigg Greta Greppo LaDonna Mobile Fannie Mae Done. 可以用任何文本编辑器来读取guests.txt的内容，包括用来编写源代码的编辑器。 2. 二进制文件将数据存储在文件中时，可以将其存储为文本格式或二进制格式。文本格式指的是将所有内容（甚至数字）都存储为文本。例如，以文本格式存储值-2.324216e+07时，将存储该数字包含的13个字符。这需要将浮点数的计算机内部转换为字符格式，这正是&lt;&lt;插入运算符完成的工作。另一方面，二进制格式指的是存储值的计算机内部表示。也就是说，计算机不是存储字符，而是存储这个值的64位double表示。对于字符来说，二进制表示与文本表示是一样的，即字符的ASCII的二进制表示。对于数字来说，二进制表示与文本表示有很大的差别（参见图17.7）。 每种格式都有自己的优缺点。文本格式便于读取，可以使用编辑器或字处理器来读取和编辑文本，可以很方便地将文本文件从一个计算机系统传输到另一个计算机系统。二进制格式对于数字来说比较精确，因为它存储的是值的内部表示，因此不会有转换误差或舍入误差。以二进制格式保存数据的速度更快，因为不需要转换，并可以大块地存储数据。二进制格式通常占用的空间少，这取决于数据的特征。然而，如果另一个系统使用另一个种内部表示，则可能无法将数据传输给该系统。同一系统上不同的编译器也可能使用不同的内部结构布局表示。在这种情况下，则必须编写一个将一种数据转换成另一种的程序。 来看一个更具体的例子。考虑下面的结构定义和声明： const int LIM = 20; struct planet { char name[LIM]; double populatoin; double g; }; planet pl; 要将结构pl的内容以文本格式保存，可以这样做： ofstream fout(&quot;planets.dat&quot;, ios_base::out | ios_base::app); fout &lt;&lt; pl.name &lt;&lt; &quot; &quot; &lt;&lt; pl.population &lt;&lt; &quot; &quot; &lt;&lt; pl.g &lt;&lt; &quot;\n&quot;; 必须使用成员运算符显式地提供每个结构成员，还必须将相邻的数据分隔开，以便区分。如果结构有30个成员，则项工作将很乏味。 要将二进制格式存储相同的信息，可以这样做： ofstream fout(&quot;planets.dat&quot;, ios_base::out | ios_base::app | ios_base::binary); fout.write( (char *) &amp;pl, sizeof pl); 上述代码使用计算机的内部数据表示，将整个结构作为一个整体保存。不能将该文件作为文本读取，但与文本相比，信息的保存更为紧凑、精确。它确实更便于键入代码。这两种方法做了两个修改： 使用二进制文件模式； 使用成员函数write()。 下面更详细的介绍这两项修改。 有些操作系统（如windows）支持两种文件格式：文本格式和二进制格式。如果要用二进制格式保存数据，应使用二进制文件格式。在C++中，可以将文件模式设置位ios_base::binary常量来完成。要知道为什么在Windows系统上需要完成这样的任务，请参见后面的旁注“二进制文件和文本文件”。 二进制文件和文本文件 使用二进制文件模式时，程序将数据从内存传输到文件（反之亦然）时，将不会发生任何隐藏的转换，而默认的文本模式并非如此。例如，对于windows文本文件，它们使用两个字符的组合（回车和换行）表示换行符；Macintosh文本文件使用回车来表示换行符；而UNINX和Linux文件使用换行（linefeed）来表示换行符。C++是从UNIX系统发展而来的，因此也是用换行（linefeed）来表示换行符。为增加可移植性，WindowsC++程序在写文本模式文件时，自动将C++换行符转换为回车和换行符；MacintoshC++程序在写文件时，将换行符换函为回车。在读取文本文件时，这些程序将本地转换符转换位C++格式。对于二进制数据，文本格式会引起问题，因此double值中间的字节可能与换行符的ASCII码有相同的位模式。另外，在文件尾的检测方式也有区别。因此以二进制格式保存数据，应使用二进制文件模式（UNIX系统只有一种文件模式，因此对于它来说，二进制模式和文本模式是一样的）。 要以二进制格式（而不是文本格式）存储数据，可以使用write()成员函数。前面说过，这种方法将内存中指定数目的字节复制到文件中。本章前面用它复制过文本，但它只逐字节地复制数据，而不进行任何转换。例如，如果将一个long变量的地址传递给它，并命令复制4个字节，它将复制long值中得4个字节，而不会将它转换为文本。唯一不方便得地方是，必须将地址强制转换为指向char的指针。也可以用同样的方式来复制整个planet结构。要获得字节数，可以使用sizeof运算符。 fout.write( (char *) &amp;pl, sizeof pl); 这条语句导致程序前往pl结构的地址，并将开始的36个字节（sizeof pl表达式的值）复制到与fout相关联的文件中。 要使用文件恢复信息，请通过一个ifstream对象使用相应的read()方法： ifstream fin(&quot;planets.dat&quot;, ios_base::in | ios_base::binary); fin.read( (char *) &amp;pl, sizeof pl); 这将从文件中复制sizeof pl个字节到pl结构中。同样的方法也适用于不适用虚函数的类。在这种情况下，只有数据成员被保存，而方法不会被保存。如果类有虚方法，则也将复制隐藏指针（该指针指向虚函数的指针表）。由于下一次运行程序时，虚函数表可能在不同的位置，因此将文件中的旧指针信息复制到对象中，将可能造成混乱（参见编程练习6中的注意）。 提示：read()和write()成员函数的功能是相反的。请用read()来恢复用write()写入的数据。 程序17.19使用这些方法来创建和读取二进制文件。从形式上看，该程序与程序17.18相似，但它使用的是write()和read()，而不是插入运算符和get()方法。另外，它还使用控制符来格式化屏幕输出。 注意：虽然二进制文件概念是ANSI C的组成部分，但一些C和C++实现并没有出提供二进制文件模式的支持。原因在于：有些系统只有一种文件类型，因此可以将二进制操作（如read()和write()）用于标准文件格式。因此，如果实现认为ios_ base::binary是非法常量，只要删除它即可。如果实现不支持fixed和right，则可以使用cout.setf(ios_ base::fixed, iose_ base::floatfield)和cout.setf(ios_ base::right, ios_ base::adjustfield)。另外，也可能必须用ios替换ios_ base。其他编译器可能还有其他特征。 程序17.19 binary.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;iomanip&gt; #include &lt;cstdlib&gt; inline void eatline() { while (std::cin.get() != &apos;\n&apos;) continue; } struct planet { char name[20]; double population; double g; }; const char * file = &quot;planets.dat&quot;; int main() { using namespace std; planet pl; cout &lt;&lt; fixed &lt;&lt; right; ifstream fin; fin.open(file, ios_base::in | ios_base::binary); if (fin.is_open()) { cout &lt;&lt; &quot;Here are the current contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (fin.read((char *) &amp;pl, sizeof pl)) { cout &lt;&lt; setw(20) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; } fin.close(); } //add new data ofstream fout(file, ios_base::out | ios_base::app | ios_base::binary); if (!fout.is_open()) { cerr &lt;&lt; &quot;Can not open &quot; &lt;&lt; file &lt;&lt; &quot; file for output:\n&quot;; exit(EXIT_FAILURE); } cout &lt;&lt; &quot;Enter planet name (enter a blank line to quit):\n&quot;; cin.get(pl.name, 20); while (pl.name[0] != &apos;\0&apos;) { eatline(); cout &lt;&lt; &quot;Enter planetary population: &quot;; cin &gt;&gt; pl.population; cout &lt;&lt; &quot;Enter planet&apos;s acceleration of gravity: &quot;; cin &gt;&gt; pl.g; eatline(); fout.write( (char *) &amp;pl, sizeof pl); cout &lt;&lt; &quot;Enter planet name (enter a blank line to quit):\n&quot;; cin.get(pl.name, 20); } fout.close(); //shoe revised file fin.clear(); fin.open(file, ios_base::in | ios_base::binary); if (fin.is_open()) { cout &lt;&lt; &quot;Here are the new contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (fin.read((char *) &amp;pl, sizeof pl)) { cout &lt;&lt; setw(20) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; } fin.close(); } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： Enter planet name (enter a blank line to quit): Earth Enter planetary population: 6928198253 Enter planet&apos;s acceleration of gravity: 9.81 Enter planet name (enter a blank line to quit): Here are the new contents of the planets.dat file: Earth: 6928198253 9.81 Done. 再次运行该该程序： Here are the current contents of the planets.dat file: Earth: 6928198253 9.81 Enter planet name (enter a blank line to quit): Jenny&apos;s world Enter planetary population: 32155648 Enter planet&apos;s acceleration of gravity: 8.93 Enter planet name (enter a blank line to quit): Here are the new contents of the planets.dat file: Earth: 6928198253 9.81 Jenny&apos;s world: 32155648 8.93 Done. 看到该程序的主要特征后，下面再次讨论前面提到的几点。程序在读取行星的g值后，将使用下面的代码（以内嵌eatline()函数的形式）： while (std::cin.get(0 != &apos;\n&apos;) continue; 这将读取并丢弃输入中换行符之间的内容。考虑到循环中的下一条输入语句： cin.get(pl.name, 20); 如果保留换行符，该语句将换行符作为空行读取，然后终止循环。 您可能会问，如果该程序是否可以使用string对象而不是字符数组来表示planet结构的name成员？答案是否定的，至少在不对设计做重大修改的情况下是否定的。问题在于，string对象本身实际上没有没有包含字符串，而是包含一个指向其中存储了字符串的内容单元的地址。因此，将结构复制到文件中，复制的将不是字符串数据，而是字符串的存储地址。当您再次运行该程序是，该地址将毫无意义。 17.4.6 随机存储在最后一个文件示例中，将探讨随机存储。随机存储指的是移动（不是依次移动）到文件的任何位置。随机存储常用于数据库文件，程序维护一个独立的索引文件，该文件指出数据在主数据文件中的位置。这样，程序便可以直接跳到这个位置，读取（还可能修改）其中的数据。如果文件由长度相同的记录组成，这种方法实现起来最简单。每条记录表示一组相关的数据。例如，在程序17.19的示例中，每天文件记录将表示关于特定行星的全部数据。很自然，文件记录对应于程序结构或类。 我们将以程序17.19中的二进制文件程序为基础，充分利用planet结构为文件记录模式，来创建这个例子。为使编程更具创造性，该示例将以读写模式打开文件，以便能够读取和修改记录。为此，可以创建一个fstream对象。fstream类是从iostream类派生而来的，而后者基于istream和ostream两个类，因此它继承了它们的方法。它还继承了两个缓冲区，一个用于输入，一个用于输出，并能同步化这两个缓冲区的处理。也就是说，当程序读写文件时，它将协调地移动输入缓冲区中的输入指针和输出缓冲区中的输出指针。 该示例完成了一下工作： 显式planet.data文件当前的内容； 询问要修改哪条记录； 修改该记录； 显示修改后的文件。 更复杂的程序将使用菜单和循环，使得能在操作列表中不断进行选择。但这里的版本只能执行每种操作一次。这种简化让您能够检验读写文件的多个方面，而不陷入程序设计事务之中。 警告：这个程序假设planets.dat文件已经存在，该文件由程序17.19中的binary.cpp程序创建的。 要回答的第一个问题是：应使用哪种文件模式。为读取文件，需要使用ios_ base::in模式。为执行二进制I/O，需要使用ios_ base::binary模式。为写入文件，需要ios_ base::out或ios_ base::app模式。然而，追加模式只允许程序将数据添加到文件尾，文件的其他部分是只读；也就是说，可以读取原始数据，但不能修改它；要修改数据，必须使用ios_ base::out。表17.8表明，同时使用in模式和out模式将得到读/写模式，因此只需添加二进制元素即可。如前所述，要使用|运算符来组合模式。因此，需要使用下面的语句： finout.open(file, ios_base::in | ios_base::out | ios_base::binary); 接下来，需要一种在文件中移动的方式。fstream类为此继承了两个方法：seekg()和seekp()，前者将输入指针移动到指定的文件位置，后者将输出指针移动到指定的文件位置（实际上，由于fstream类使用缓冲区来存储中间数据，因此指针指向的是缓冲区中的位置，而不是实际的文件）。也可以将seekg()用于ifstream对象，将seekp()用于ofstream对象。下面是seekg()的原型： basic_istream&lt;charT, traits&gt; &amp; seekg(off_type, ios_base::seekdir); basic_istream&lt;charT, traits&gt; &amp; seekg(pos_type); 正如您看到的，它们都是模板。本章将使用char类型的模式具体化。对于char具体化，上面两个原型等同于下面的代码： istream &amp; seekg(streamoff, ios_base::seekdir); istream &amp; seekg(streampos); 第一个原型定位到里第二个参数指定的文件位置特定距离（单位为字节）的位置；第二个原型定位到里文件开头特定距离（单位为字节）的位置。 类型升级 在C++早期，seekg()方法比较简单。Streamoff和streampos类型是一些标准整型（如long）的typedef。但为创建可移植系统标准，必须处理这样的现实情况：对于有些文件系统，整型参数无法提供足够的信息，因此streamoff和streampos允许是结构和类类型，条件是它们允许一些基本的操作，如使用整型作为初始值等。随后，老版本的istream类被basic_ istream模板取代，streampos和streamoff被basic_ istream模板取代。然而，streampos和streamoff继续存在，作为pos_ type和off_ type的char的具体化。同样，如嗯将seekg()用于wistream对象，可以使用wstreampos和wstreamoff类型。 来看seekg()的第一个原型参数。streamoff值被用来度量相对于文件特定位置的偏移量（单位为字节）。streamoff参数表示相对于三个位置之一的偏移量为特定值（以字节为单位）的文件位置（类型可定义为整型或类）。seek_ dir参数ios_ base类中定义的另一种整型，有3个可能的值。常量ios_ baes::beg指相对于文件开始处的偏移量。常量ios_ base::cur指相对于当前位置的偏移量。常量ios_ base::end指相对于文件尾的偏移量。下面是一些调用示例，这里假设fin是一个ifstream对象： fin.seekg(30, ios_base::beg); fin.seekg(-1. ios_base::cur); //回退一个字节 fin.seekg(0, ios_base::end); //跳到文件尾 下面来看第二个原型，streampos类型的值定位到文件中的一个位置。它可以是类，但如果这样的话，这个类将包含一个接收streamoff参数的构造函数和一个接受整数参数的构造函数，以便将两种类型转换尾streampos值。streampos值表示文件中的绝对位置（从文件开始处算起）。可以将streampos位置看作是相对于文件开始处的位置（以字节为单位，第一个字节的编号为0）。因此下面的语句将文件指针指向第112个字节，这是文件中的第113个字节： fin.seekg(112); 如果要检查文件指针的当前位置，对于输入流，可以使用tellg()方法，对于输出流，可以使用tellp()方法。它们都返回一个表示当前位置的streampos值（以字节为单位，从文件开始处算起）。创建fstream对象时，输入指针和输出指针将一前一后地移动，因此tellg()和tellp()返回的值相同。然而，如果使用istream对象来管理输入流，而是用ostream对象来管理同一个文件的输出流，则输入指针和输出指针将被彼此独立地移动，因此tellg()和tellp()将返回不同的值。 然后，可以使用seekg()移动到文件的开头。下面是打开文件、移动文件头并显示文件内容的代码片段： fstream finout; finout.open(file, ios:in | ios::out | ios::binary); int ct = 0; if (finout.is_open()) { finout.seekg(0); cout &lt;&lt; &quot;Here are the current contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (finout.read((char *) &amp;pl, sizeof pl)) { cout &lt;&lt; ct++ &lt;&lt; &quot;: &quot; &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; } if (finout.eof()) finout.clear(); else { cerr &lt;&lt; &quot;Error in reading &quot; &lt;&lt; file &lt;&lt; &quot;.\n&quot;; exit(EXIT_FAILURE); } } else { cerr &lt;&lt; file &lt;&lt; &quot; could not be opened -- bye.\n&quot;; exit(EXIT_FAILURE); } 这与程序17.19的开头很相似，但也修改和添加了一些内容。首先，程序以读/写模式是一个fstream对象，并使用seekg()将文件指针放在文件开头（对于这个例子而言，这其实不是必须的，但它说明了如何使用seekg()）。接下来，程序在给记录编号方面做了一些小的改成。然后添加了以下重要的代码： if (finout.eof()) finout.clear(); else { cerr &lt;&lt; &quot;Error in reading &quot; &lt;&lt; file &lt;&lt; &quot;.\n&quot;; exit(EXIT_FAILURE); } 上述代码解决的问题是，程序读取并显示整个文件后，将设置eofbit元素。这使程序相信，它已经处理完文件，并禁止对文件做进一步的读写。使用clear()方法重置流状态，并打开eofbit后，程序便可以再次访问该文件。else部分处理程序因到达文件尾之外的其他原因（如硬件故障）而停止读取的情况。 接下来需要确定要修改的记录，并修改它。为此，程序让用户输入记录号。将该编号域记录包含的字节数相乘，得到该记录第一个字节的编号。如果record是记录号，则字节编号为record $\ast$ sizeof pl: cout &lt;&lt; &quot;Enter the record number you wish to change: &quot;; long rec; cin &gt;&gt; rec; eatline(); if (rec &lt; 0 || rec &gt;= ct) { cerr &lt;&lt; &quot;Invalid record number -- bye.\n&quot;; exit(EXIT_FAILURE); } streampos place = rec * sizeof pl; finout.seekg(place); 变量ct表示记录号。如果试图超出文件尾，程序将退出。 接下来，程序显示当前的记录： finout.read((char *) &amp;pl, sizeof pl); cout &lt;&lt; &quot;Your selection: \n&quot;; cout &lt;&lt; rec &lt;&lt; &quot;: &quot; &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; if (finout.eof()) finout.clear(); 显示记录后，程序让您修改记录： cout &lt;&lt; &quot;Enter planet name: &quot;; cin.get(pl.name, LIM); eatline(); cout &lt;&lt; &quot;Enter planetary population: &quot;; cin &gt;&gt; pl.population; cout &lt;&lt; &quot;Enter planet&apos;s acceleration of gravity: &quot;; cin &gt;&gt; pl.g; finout.seekp(place); finout.write((char *) &amp;pl, sizeof pl) &lt;&lt; flush; if (finout.fail()) { cerr &lt;&lt; &quot;Error on attempted write\n&quot;; exit(EXIT_FAILURE); } 程序刷新输出，以确保进入下一步之前，文件被更新。 最后，为显示修改后的文件，程序使用seekg()将文件指针重新指向开头。程序17.20列出了完整的程序。不要忘了，该程序假设binary.cpp创建的planets.dat文件可用的。 程序17.20 random.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;iomanip&gt; #include &lt;cstdlib&gt; const int LIM = 20; struct planet { char name[LIM]; double population; double g; }; const char * file = &quot;planets.dat&quot;; inline void eatline() { while(std::cin.get() != &apos;\n&apos;) continue; } int main() { using namespace std; planet pl; cout &lt;&lt; fixed; fstream finout; finout.open(file, ios::in | ios::out | ios::binary); int ct = 0; if (finout.is_open()) { finout.seekg(0); cout &lt;&lt; &quot;Here are the current contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (finout.read((char *) &amp;pl, sizeof pl)) { cout &lt;&lt; ct++ &lt;&lt; &quot;: &quot; &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; } if (finout.eof()) finout.clear(); else { cerr &lt;&lt; &quot;Error in reading &quot; &lt;&lt; file &lt;&lt; &quot;.\n&quot;; exit(EXIT_FAILURE); } } else { cerr &lt;&lt; file &lt;&lt; &quot; could not be opened -- bye.\n&quot;; exit(EXIT_FAILURE); } // change a record cout &lt;&lt; &quot;Enter the record number you wish to change: &quot;; long rec; cin &gt;&gt; rec; eatline(); if (rec &lt; 0 || rec &gt;= ct) { cerr &lt;&lt; &quot;Invalid record number -- bye.\n&quot;; exit(EXIT_FAILURE); } streampos place = rec * sizeof pl; finout.seekg(place); if (finout.fail()) { cerr &lt;&lt; &quot;Error on attempted seek\n&quot;; exit(EXIT_FAILURE); } finout.read((char *) &amp;pl, sizeof pl); cout &lt;&lt; &quot;Your selection: \n&quot;; cout &lt;&lt; rec &lt;&lt; &quot;: &quot; &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; if (finout.eof()) finout.clear(); cout &lt;&lt; &quot;Enter planet name: &quot;; cin.get(pl.name, LIM); eatline(); cout &lt;&lt; &quot;Enter planetary population: &quot;; cin &gt;&gt; pl.population; cout &lt;&lt; &quot;Enter planet&apos;s acceleration of gravity: &quot;; cin &gt;&gt; pl.g; finout.seekp(place); finout.write((char *) &amp;pl, sizeof pl) &lt;&lt; flush; if (finout.fail()) { cerr &lt;&lt; &quot;Error on attempted write\n&quot;; exit(EXIT_FAILURE); } // show revised file ct = 0; finout.seekg(0); cout &lt;&lt; &quot;Here are the new contents of the &quot; &lt;&lt; file &lt;&lt; &quot; file:\n&quot;; while (finout.read((char *) &amp;pl, sizeof pl)) { cout &lt;&lt; ct++ &lt;&lt; &quot;: &quot; &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; &quot;: &quot; &lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population &lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl; } finout.close(); cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： Here are the current contents of the planets.dat file: 0: Earth: 6928198253 9.81 1: Jenny&apos;s world: 32155648 8.93 Enter the record number you wish to change: 1 Your selection: 1: Jenny&apos;s world: 32155648 8.93 Enter planet name: Trantor Enter planetary population: 89521844777 Enter planet&apos;s acceleration of gravity: 10.53 Here are the new contents of the planets.dat file: 0: Earth: 6928198253 9.81 1: Trantor: 89521844777 10.53 Done. 通过使用该程序中的技术，对器进行扩展，使之能够让用户添加新信息和删除记录。如果打算扩展该程序，最后通过使用类和函数来重新组织它。例如，可以将planet结构转换为一个类定义，然后对&lt;&lt;插入运算符进行重载，使得cout&lt;&lt;pl按示例的格式显示类的数据成员。另外，该实例没有对输入进行检查，让您可以添加代码来检查数值输入是否合适。 使用临时文件 开发应用程序时，经常需要使用临时文件，这种文件的存在是短暂的，必须受程序控制。您是否考虑过，在C++中如何使用临时文件呢？创建临时文件、复制另一个文件的内容并删除文件其实都很简单。首先，需要为临时文件制定一个命名方案，但如何确保每个文件都被指定了独一无二的文件名呢？cstdio中声明的tmpnam()标准函数可以帮助您。 char * tmpnam( char * pszName); tmpnam()函数创建一个临时文件名，将它放在pszName指向的C-风格字符串中。常量L_ tmpnam和TMP_ MAX（二者都是在cstdio中定义的）限制了文件名包含的字符数以及在确保当前目录中不生成重复文件名的情况下tmpnam()课被调用的最多次数。下面是生成10个临时文件名的代码。 #include &lt;cstdio&gt; #include &lt;iostream&gt; int main() { using namespace std; cout &lt;&lt; &quot;This system can generate up to &quot; &lt;&lt; TMP_MAX &lt;&lt; &quot; temporary names of up to &quot; &lt;&lt; L_tmpnam &lt;&lt; &quot; characters.\n&quot;; char pszName[L_tmpnam] = {&apos;\0&apos;}; cout &lt;&lt; &quot;Here are ten names:\n&quot;; for (int i = 0; i &lt; 10 ; i++) { tmpnam(pszName); cout &lt;&lt; pszName &lt;&lt; endl; } return 0; } 具体来说，使用tmpnam()可以生成TMP_NAM个不同的文件名，其中每个文件名包含的字符数不超过L_tmpnam个。生成什么样的文件名取决于实现，您可以运行该程序，来看看编译器给您生成的文件名。 17.5 内核格式化iostream族（family）支持程序与终端之间的I/O，而fstream族使用相同的接口提供程序和文件之间的I/O。C++库还提供了sstream族，它们使用相同的接口提供程序和string对象之间的I/O。也就是说，可以使用用于cout的ostream方法格式化信息写入到string对象中，并使用istream方法（如getline()）来读取string对象中的信息。读取string对象中的格式化信息或将格式化信息写入string对象中被称为内核格式化（incore fomatting）。下面简要地介绍一下这些工具（string的sstream族支取代了char数组的strstream.h族支持）。 头文件sstream定义了一个从ostream类派生而来的ostringstream类（还有一个基于wostream的wostringstream类，这个类用于宽字符集）。如果创建了一个ostringstream对象，则可以将信息写入其中，它将存储这些信息。可以将可用于cout的方法用于ostringstream对象。也就是说，可以这样做： ostringstream outstr; double price = 380.0; char * ps = &quot; for a copy of the ISO/EIC C++ standard!&quot;; outstr.precision(2); outstr &lt;&lt; fixed; outstr &lt;&lt; &quot;Pay only CHF &quot; &lt;&lt; price &lt;&lt; ps &lt;&lt; endl; 格式化文本进入缓冲区，在需要的情况下，该对象将使用动态内存分配来增大缓冲区。ostringstream类有一个名为str()的成员函数，该函数返回一个被初始化为缓冲区内容的字符串对象： string mesg = outstr.str(); 使用str()方法可以“冻结”该对象，这样便不能将信息写入该对象中。 程序17.21是一个有关内核格式化的简短示例。 程序17.21 strout.cpp #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; int main() { using namespace std; ostringstream outstr; string hdisk; cout &lt;&lt; &quot;What&apos;s the name of your hard disk?: &quot;; getline(cin, hdisk); int cap; cout &lt;&lt; &quot;What&apos;s its capacity in GB?: &quot;; cin &gt;&gt; cap; outstr &lt;&lt; &quot;The hard disk &quot; &lt;&lt; hdisk &lt;&lt; &quot; has a capacity of &quot; &lt;&lt; cap &lt;&lt; &quot; gigabytes.\n&quot;; string result = outstr.str(); cout &lt;&lt; result; return 0; } 输出： What&apos;s the name of your hard disk?: Datarapture What&apos;s its capacity in GB?: 2000 The hard disk Datarapture has a capacity of 2000 gigabytes. istringstream类允许使用istream方法族读取istringstream对象中的数据，istringstream对象可以使用string对象进行初始化。 假设facts是一个string对象，要创建与该字符串相关联的istringstream对象，可以这样做： istringstream instr(facts); 这样，便可以使用istream方法读取instr中的数据。例如，如果instr包含大量字符格式的整数，则可以这样读取它们： int n; int sum = 0; while (instr &gt;&gt; n) sum += n; 程序17.22使用重载的&gt;&gt;运算符读取字符串中的内容，每次读取一个单词。 程序17.22 strin.cpp #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; int main() { using namespace std; string lit = &quot;It was a dark and stormy day, and&quot; &quot; the full moon glowed brilliantly.&quot;; istringstream instr(lit); string word; while (instr &gt;&gt; word) cout &lt;&lt; word &lt;&lt; endl; return 0; } 输出： It was a dark and stormy day, and the full moon glowed brilliantly. 总之，istringstream和ostringstream类使得能够使用istream和ostream类的方法来管理存储在字符串中的字符数据。 17.6 总结输入流： 键盘-&gt;缓冲区-&gt;程序 输出流： 程序-&gt;缓冲区-&gt;屏幕/文件 缓冲区：多个字节一起操作，减少磁盘写入和读取操作，加快速度 fstream 继承： iostream 继承： istream ostream 继承：ios 继承：ios_base cout put()显示字符 write()显示字符串 cout格式化 cout.setf()设置输出格式： 一个参数，两个参数 cout &lt;&lt; dec, oct, hex设置显示十进制/八进制/十六进制 cout.width() 调整字段宽度 cout.fill(‘#’) 填充字符 cout.precision(2) 设置浮点数的显示精度 iomanip头文件 setw(), setfill(), setprecision() cin 流状态： eofbit badbit failbit 单字符： cin.get(ch) ch = cin.get() 字符串： getline() get() ignore() 其他方法：peek()， gcount()，putback() 文件输入输出 fstream 文件模式 is_open() 内核格式化]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网C/C++错题集]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%89%9B%E5%AE%A2%E7%BD%91C%2B%2B%E9%94%99%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[牛客网C/C++每天练习十题，记录重要知识点和错题。 词法分析器用于识别：单词词法分析是编译的第一阶段。词法分析器的主要任务是读入源程序的输入字符、将他们组成词素（ 源程序中的一个字符序列，它和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例 ），生成并输出一个词法单元序列，每个词法单元对应一个词素。这个词法单元序列被输出到语法分析器进行语法分析。 编译的过程一般分为6步，：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成和目标代码优化。 结构体地址：题目： struct Date { char a; int b; int64_t c; char d; }; Date data[2][10];在64位系统上，如果Data的地址是x，那么data[1][5].c的地址是（） a.整体所占的内存大小应该是结构中成员类型最大的整数倍，此处最大的类型是int_64t，占8个字节。。即最后所占字节的总数应该是8的倍数，不足的补足； b.数据对齐原则-内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面所有成员已经占用的空间大小必须是该成员类型大小的整数倍，如果不够，则前面的成员占用的空间要补齐，使之成为当前成员类型的整数倍。假设是地址是从0开始，结构体中第一个成员类型char型占一个字节，则内存地址0-1，第二个成员从2开始，int型所占内存4个字节，根据原则b，第一个成员所占内存补齐4的倍数，故第一个成员所占内存：1 + 3 = 4； 第二个成员占5-8. 第三个成员占8个字节，满足原则b，不需要补齐，占9-16. 第四个成员占一个字节，占17. 故总内存为1 + 3 + 4 + 8 + 1 = 17个字节，但根据原则a，总字节数需是8的倍数，需将17补齐到24. 故此结构体总字节数为：24字节 data[1][5]，意思是前面有15个元素。则第15个元素的起始地址为： 24 * 15 = 360， 即 X + 360则data[1][5].c的地址为： 360 + 1 + 3 + 4 = 368，即 X + 368 枚举定义合法性在 C 语言中，此定义和语句是合法的：enum aa{ a=5,b,c}bb; bb=(enum aa)5;请问这句话的说法是正确的吗？ enum aa{a=5,b,c} bb;是C语言中定义的枚举类型;意思是：定义aa这个数据类型，其取值范围是a,b,c三个数，其中，a=5, b=6,c=7(如果不给b,c指定数值，就是其前一个数+1)。 同时定义aa 这个数据类型的变量bb, bb = (enum aa)5；和你学到的 int a = (int)b;功能一样，是把数值5转义成(enum aa)数据类型，同时赋值给变量bb; include和import#import是#include的替代指令，防止重复引用 三个文件：文件A.h 文件B.h 文件C.h 文件C.h需要引入A.h、B.h ,文件B.h需要引入文件A.h,这样就重复引用了A.h两次，使用#import可以进行优化。 Objective-C 中 #import 和 #include 的区别 预编译指令Objective-C：#importC，C++：#include #import由gcc编译器支持 在 Objective-C 中，#import 被当成 #include 指令的改良版本来使用。除此之外，#import 确定一个文件只能被导入一次，这使你在递归包含中不会出现问题。 使用哪一个还是由你来决定。一般来说，在导入 Objective-C 头文件的时候使用 #import，包含 C 头文件时使用 #include。 #import比起#include的好处就是不会引起交叉编译 每个C语言程序文件的编译错误分为（ ）类编译把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。按照编译的工作内容推断编译错误可分为词法错误和语法错误 typedef用typedef可以定义各种类型名，但不能定义变量用typedef只是将已存在的类型用一个新的名称代替使用typedef便于程序的通用 指针占几个字节指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关。譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节 为定义行为未定义行为（Undefined Behavior）是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。一句话，未定义行为就是运行结果不确定 1.变量即是左边结果，又是右边的操作数，如a+=a++，a %= b ^= a ^= b ^= a 2.使用越界数组也是C的一个“未定义行为” 3.允许一个随便指的指针的读写。 4.使用未初始化的变量 下列 C 代码中，不属于未定义行为的有：__ int i=0;i=(i++); char *p=”hello”;p[1]=’E’ char *p=”hello”;char ch=*p++ int i=0;printf(“%d%d\n”,i++,i--) 都是未定义行为 都不是未定义行为 A错，因为i++返回的是0,而此时i应该是1。然后又让i=0，不同编译器的不同入栈方式，可能得到i=0或i=1两种结果。 B错，因为一个指针企图修改一个const char*编译器是不允许的吧。 C没问题，c去读一个const char*，ch=‘c’。 D错，与A类似。我们希望得到的结果是01，但是由于不同编译器printf的入栈顺序有所差异，可能会得到00（先计算i–，再计算i++）的结果。 综上叙，E F不正确，由此得到C。 1.2e0.5错误e后面必须为整数 循环下面for语句执行时的循环次数为（）。 int i, j; for ( i=0, j=5;i=j; ) { cout&lt;&lt;i&lt;&lt;j&lt;&lt; ndl; i++; j--; } 其中的条件是i，如果i等于0，循环结束，只有j等于0，i才会等于0。 内联函数一般用于加快程序执行速度 可能减少可执行文件大小 可能增加可执行文件大小 首先 内联函数 本意就是为了提高程序运行速度所做的一项改进.但是它也可能使得程序运行变慢. 它可能使得可执行文件变小也可能使之变大.总之在使用不当都可能出现… strlen 和sizeof定义char dog[]=”wang\0miao”;那么sizeof(dog)与strlen(dog)分别是多少： sizeof返回数组所占的字节数，’wang’ ‘miao’共占8字节，显式’\0’占1字节，字符串末尾隐式’\0’占1字节，共10字节。 strlen返回字符串的长度，以遇到’\0’结束符为准，因此为4。 注意char a[3]; a = &quot;AB&quot;; 上述语法错误，a是一个常量地址，无法修改。而语句二将一个地址赋给一个常量地址，因此是错误的。 预处理命令C语言有编辑、编译、执行三大过程。 C语言在编译前由预处理器对预处理命令进行处理，编译时进行语法分析。 执行过程就是运行程序。 C语言的预处理主要有三个方面的内容： 1.宏定义； 2.文件包含； 3.条件编译。 预处理命令以符号“#”开头。 运算符优先级第一级别： :: 第二级别： () [] ++（后自增） –（后自减） -&gt; . 第三级别： ！ not ~ ++（先自增） –(先自减) - * &amp; 第四级别： -&gt;* 第五级别： * / % 第六级别： + - 第七级别： &lt;&lt; &gt;&gt; 第八级别： &lt; &lt;= &gt; &gt;= 第九级别： == eq != 第十级别： &amp; 第十一级别： ^ 第十二级别： | 第十三级别： &amp;&amp; 第十四级别： || 第十五级别： : ?(条件运算符) 第十六级别： = += *= -= %= 第十七级别： throw 第十八级别： ,（逗号分隔符） 不能被重载的运算符只有五个，分别是 . （成员访问运算符） （成员指针访问运算符） :: （域运算符） sizeof （长度运算符） ?: （条件运算符） 前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。 字节对齐 某个变量存放的起始位置相对于结构的起始位置的偏移量是该变量字节数的整数倍； 结构所占用的总字节数是结构种字节数最长的变量的字节数的整数倍。 一般情况，C++/C的变量所占字节数： char: 1字节； short: 2字节； int: 4字节； long: 4字节； long long: 8字节； float: 4字节； double: 8字节； bool: 1字节； C/C++/C#/Java 都是严格区分大小写的计算机语言多态C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数 1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。 2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。 3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。 4：多态用虚函数来实现，结合动态绑定. 5:纯虚函数是虚函数再加上 = 0； 6：抽象类是指包括至少一个纯虚函数的类。 纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。 C++源程序文件编译而成的目标文件的缺省扩展名为 .obj编译生成.obj文件，链接后生成.exe 函数默认返回类型 int你可以测试一下： abc() { } int i; i = abc(); printf(&quot;%d&quot;,i); 如果abc（）是void，那么i = abc();一定会出错。如果编译程序不报错，那么说明这个函数是有返回值的。另外说一句，在C++中不允许函数的隐含类型 指针现在有以下两个函数，调用test的结果是：不确定 char* getMem(void) { char p[] = “hello world ”; p[5] = 0x0; return p; } void test(void) { char *s = 0x0; s = getMem(); printf(s); } p是个数组，在{}里面定义是个局部变量，说明这个函数执行完毕之后局部变量销毁p这个数组中的值都没有了。 p虽然是个数组，但是单独用p这个变量，值是p这块数组的首地址，因为返回的是值传递，所以这个首地址被传到了下面的s中，s指向这个内存，而这个内存在getMem函数调用结束后就销毁了，里面存放的不知道是什么了。所以打印的话不一定出现什么。 &amp;a以下代码的输出是（） int a[5]={1,2,3,4,5}; int *ptr=(int*)(&amp;a+1); printf(&quot;%d,%d&quot;,*(a+1),*(ptr-1)); 答案是： 2， 5 这里有个特殊的地方，测试代码printf(“%d\n”,a); printf(“%d\n”,&amp;a);这两个输出的地址是相同的，也就是&amp;a是把数组看成一个整体，&amp;a+1就是跳过数组的长度指向最后一个数字的下一个整型。*(ptr-1)就在再后退一个整型，也就是数组的最后一个元素。 格式化输出使用printf函数打印一个double类型的数据，要求：输出为10进制，输出左对齐30个字符，4位精度。以下哪个选项是正确的？ -： 左对齐 30： 最小字段宽度 .4： 精确度保留小数4位 f： double精度浮点数 e： 科学计数法 或和与的短路问题设x、y、t均为int型变量，则执行语句：t=3; x=y=2; t=x++||++y; 后，变量t和y的值分别为____。 结果为： 1, 2 zt_xcykx++||++y执行后的结果是真，即1，然后赋值给t。因为是或运算，所以在判断x++时真后，后面的++y就不再执行了，所以y值没有变还是2 define和typedeftest.c文件中包括如下语句： #define INT_PTR int* typedef int* int_ptr; INT_PTR a,b; int_ptr c,d; 文件中定义的四个变量中，哪个变量类型不是指针类型？ #define INT_PTR int* 这是宏定义，编译预处理阶段要进行宏替换，INT_PTR a,b会变成 int * a,b 所以b不是指针类型 typedef int* int_ptr; 这是自定义类型，也就是把int_ptr定义为 int型指针，编译阶段会把c,d都识别为指针 容器和类型在C++STL中常用的容器和类型，下面哪些支持下标”[]”运算？ vector list deque map set unordered_map unordered_set stack string 答案： vector、deque、map、unordered_map、string 标准 STL 序列容器： vector 、 string 、 deque 和 list 。 提供了快速访问元素的能力。 标准STL 关联容器： set 、 multiset 、 map 和 multimap 。 非标准序列容器slist 和 rope 。 slist 是一个单向链表， rope 本质上是一 “ 重型 ”string 。 非标准的关联容器hash_set 、 hase _multiset 、 hash _map 和 hash _multimap 。 几种标准的非STL 容器，包括数组、 bitset 、 valarray 、 stack 、 queue 和 priority_queue 。 关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。 关联容器不支持顺序容器的位置相关的操作。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值得操作。 关联容器支持高效的关键字查找和访问。两个主要的关联容器(associative container)类型是map和set。map中的元素是一些关键字—-值(key–value)对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字：set支持高效的关键字查询操作—-检查一个给定关键字是否在set中。 按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)； 无序集合：unordered_set(用哈希函数组织的set)；unordered _multiset(哈希组织的set，关键字可以重复出现)。 set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL实战]]></title>
    <url>%2F2019%2F03%2F04%2FMySQL%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[MySQL实战：行程和用户、工资排名前N、分数排名。 项目十：行程和用户（难度：困难）Trips 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。 +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id | Status |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。 +----------+--------+--------+ | Users_Id | Banned | Role | +----------+--------+--------+ | 1 | No | client | | 2 | Yes | client | | 3 | No | client | | 4 | No | client | | 10 | No | driver | | 11 | No | driver | | 12 | No | driver | | 13 | No | driver | +----------+--------+--------+ 写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。 +------------+-------------------+ | Day | Cancellation Rate | +------------+-------------------+ | 2013-10-01 | 0.33 | | 2013-10-02 | 0.00 | | 2013-10-03 | 0.50 | +------------+-------------------+ 赠送创建表格代码，见文末附录。 答案SELECT t.Request_at as Day, ROUND(SUM(CASE WHEN t.status=&apos;completed&apos; THEN 0 ELSE 1 END)/COUNT(*), 2) AS &apos;Cancellation Rate&apos; FROM Trips t INNER JOIN Users u1 ON t.Client_Id=u1.Users_Id AND u1.Banned=&apos;No&apos; WHERE t.Request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos; GROUP BY t.Request_at; 备注：ROUND(x,d) ，x指要处理的数，d是指保留几位小数 项目十一：各部门前3高工资的员工（难度：中等）将昨天employee表清空，重新插入以下数据（其实是多插入5,6两行）： +----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | +----+-------+--------+--------------+ 编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回： +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | +------------+----------+--------+ 此外，请考虑实现各部门前N高工资的员工功能。 答案CREATE TABLE Department (Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Name VARCHAR(10)); CREATE TABLE Employee (Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Name VARCHAR(10), Salary BIGINT, DepartmentId INT NOT NULL); INSERT INTO Employee (Id, Name, Salary, DepartmentId) VALUES (1, &quot;Joe&quot;, 70000, 1), (2, &quot;Henry&quot;, 80000, 2), (3, &quot;Sam&quot;, 60000, 2), (4, &quot;Max&quot;, 90000, 1), (5, &quot;Janet&quot;, 69000, 1), (6, &quot;Randy&quot;, 85000, 1); INSERT INTO Department (Id, Name) VALUES (1, &quot;IT&quot;), (2, &quot;Sales&quot;); SELECT Department.Name AS Department, e1.Name AS Employee, e1.Salary AS Salary FROM Employee e1 JOIN Department ON e1.DepartmentId = Department.Id WHERE 3 &gt; ( SELECT COUNT(DISTINCT e2.Salary) FROM Employee e2 WHERE e2.Salary &gt; e1.Salary AND e1.DepartmentId = e2.DepartmentId ) ORDER BY Department.Name, e1.Salary DESC; 注意：计算比当前员工工资高的员工数量，如果工资比其高的员工数量小于3，则其排名前3 项目十二 分数排名 - （难度：中等）依然是昨天的分数表，实现排名功能，但是排名是非连续的，如下： +-------+------+ | Score | Rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 3 | | 3.65 | 4 | | 3.65 | 4 | | 3.50 | 6 | +-------+------+ 答案--创建表 CREATE TABLE score (Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Score DOUBLE); --插入数据 INSERT INTO score (Id, Score) VALUES (1, 3.50), (2, 3.65), (3, 4.00), (4, 3.85), (5, 4.00), (6, 3.65); SELECT Score, (SELECT COUNT(DISTINCT Score) FROM score WHERE Score &gt;= s.Score) AS Rank FROM score s ORDER BY Score DESC; 项目十建表附录 CREATE TABLE IF NOT EXISTS Trips ( Id INT, Client_Id INT, Driver_Id INT, City_Id INT, Status ENUM(&apos;completed&apos;, &apos;cancelled_by_driver&apos;, &apos;cancelled_by_client&apos;), Request_at VARCHAR(50) ); CREATE TABLE IF NOT EXISTS Users ( Users_Id INT, Banned VARCHAR(50), Role ENUM(&apos;client&apos;, &apos;driver&apos;, &apos;partner&apos;) ); TRUNCATE TABLE Trips; INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;1&apos;, &apos;1&apos;, &apos;10&apos;, &apos;1&apos;, &apos;completed&apos;, &apos;2013-10-01&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;2&apos;, &apos;2&apos;, &apos;11&apos;, &apos;1&apos;, &apos;cancelled_by_driver&apos;, &apos;2013-10-01&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;3&apos;, &apos;3&apos;, &apos;12&apos;, &apos;6&apos;, &apos;completed&apos;, &apos;2013-10-01&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;4&apos;, &apos;4&apos;, &apos;13&apos;, &apos;6&apos;, &apos;cancelled_by_client&apos;, &apos;2013-10-01&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;5&apos;, &apos;1&apos;, &apos;10&apos;, &apos;1&apos;, &apos;completed&apos;, &apos;2013-10-02&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;6&apos;, &apos;2&apos;, &apos;11&apos;, &apos;6&apos;, &apos;completed&apos;, &apos;2013-10-02&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;7&apos;, &apos;3&apos;, &apos;12&apos;, &apos;6&apos;, &apos;completed&apos;, &apos;2013-10-02&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;8&apos;, &apos;2&apos;, &apos;12&apos;, &apos;12&apos;, &apos;completed&apos;, &apos;2013-10-03&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;9&apos;, &apos;3&apos;, &apos;10&apos;, &apos;12&apos;, &apos;completed&apos;, &apos;2013-10-03&apos;); INSERT INTO Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) VALUES (&apos;10&apos;, &apos;4&apos;, &apos;13&apos;, &apos;12&apos;, &apos;cancelled_by_driver&apos;, &apos;2013-10-03&apos;); TRUNCATE TABLE Users; INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;1&apos;, &apos;No&apos;, &apos;client&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;2&apos;, &apos;Yes&apos;, &apos;client&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;3&apos;, &apos;No&apos;, &apos;client&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;4&apos;, &apos;No&apos;, &apos;client&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;10&apos;, &apos;No&apos;, &apos;driver&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;11&apos;, &apos;No&apos;, &apos;driver&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;12&apos;, &apos;No&apos;, &apos;driver&apos;); INSERT INTO Users (Users_Id, Banned, Role) VALUES (&apos;13&apos;, &apos;No&apos;, &apos;driver&apos;);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel文件导入导出和实战]]></title>
    <url>%2F2019%2F03%2F03%2FExcel%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%92%8C%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Excel文件导入到Mysql，以及Mysql导出到本地文件中。最后附加三个练习题！ Excel导入到Mysql首先创建一个对应的表格Employee，然后右键点击刷新，会出现下图中的Employee表格。 其次，右键Employee表格，点击导入向导，出现下图： 然后，选择需要导入的文件类型，这里选择xlsx；再，选择源文件和表格： 设置起始行等： 确定目标表和源表： 选择源表的具体列（如果源表列名与目标表列名相同，会设置为默认）： 点击下一步，选择添加模式： 点击开始，进行导入 显示成功： 从Mysql导出到Excel从上面导入的表格数据中导出所有数据： 选择源表，和本地的目标表格： 确定源表： 附加选项 点击开始 导出成功： 作业项目七: 各部门工资最高的员工（难度：中等）创建Employee 表，包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 +----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | +----+-------+--------+--------------+ 创建Department 表，包含公司所有部门的信息。 +----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | Sales | Henry | 80000 | +------------+----------+--------+ 答案CREATE TABLE Department (Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Name VARCHAR(10)); CREATE TABLE Employee (Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Name VARCHAR(10), Salary BIGINT, DepartmentId INT NOT NULL); INSERT INTO Employee (Id, Name, Salary, DepartmentId) VALUES (1, &quot;Joe&quot;, 70000, 1), (2, &quot;Henry&quot;, 80000, 2), (3, &quot;Sam&quot;, 60000, 2), (4, &quot;Max&quot;, 90000, 1); INSERT INTO Department (Id, Name) VALUES (1, &quot;IT&quot;), (2, &quot;Sales&quot;); SELECT d.Name Department, e.Name Employee, Salary FROM Employee e, Department d WHERE e.DepartmentId = d.Id AND Salary IN (SELECT MAX(Salary) FROM Employee, Department WHERE DepartmentId = Department.Id GROUP BY Department.Id); 项目八: 换座位（难度：中等）小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。其中纵列的 id 是连续递增的小美想改变相邻俩学生的座位。你能不能帮她写一个 SQL query 来输出小美想要的结果呢？ 请创建如下所示seat表：示例： +---------+---------+ | id | student | +---------+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +---------+---------+ 假如数据输入的是上表，则输出结果如下： +---------+---------+ | id | student | +---------+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +---------+---------+ 注意：如果学生人数是奇数，则不需要改变最后一个同学的座位。 答案--创建表 CREATE TABLE seat (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, student VARCHAR(20)); --插入数据 INSERT INTO seat (id, student) VALUES (1, &quot;Abbot&quot;), (2, &quot;Doris&quot;), (3, &quot;Emerson&quot;), (4, &quot;Green&quot;), (5, &quot;Jeames&quot;); --方法一 SELECT a.id, a.student FROM ( SELECT id-1 as id,student FROM seat WHERE id%2=0 UNION SELECT id+1 as id,student FROM seat WHERE id%2=1 AND id != (SELECT MAX(id) FROM seat) UNION SELECT id,student FROM seat WHERE id%2=1 AND id = (SELECT MAX(id) FROM seat) )a ORDER BY a.id; --方法二 SELECT (CASE WHEN id % 2 != 0 AND id != counts THEN id+1 WHEN id % 2 != 0 AND id = counts THEN id ELSE id-1 END) AS id, student FROM seat, (SELECT COUNT(*) counts FROM seat) as seat_count ORDER BY id; 项目九: 分数排名（难度：中等）编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 创建以下score表： +----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+ 例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）： +-------+------+ | Score | Rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+ 答案--创建表 CREATE TABLE score (Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Score DOUBLE); --插入数据 INSERT INTO score (Id, Score) VALUES (1, 3.50), (2, 3.65), (3, 4.00), (4, 3.85), (5, 4.00), (6, 3.65); SELECT Score, (SELECT COUNT(Score) + 1 FROM score WHERE Score &gt; s.Score) AS Rank FROM score s ORDER BY Score DESC;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表联结]]></title>
    <url>%2F2019%2F03%2F01%2F%E8%A1%A8%E8%81%94%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这节介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。 JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 别名SELECT a.name AS a_name FROM stdudents AS a; --AS可以省略 SELECT a.name a_name FROM students a; 其中a为students表格的别名，a_ name为a.name的别名，注意别名与实际名称之间不用逗号。 INNER JOIN SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; LEFT JOINSELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b on a.runoob_author =s b.runoob_author; RIGHT JOINSELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b on a.runoob_author = b.runoob_author; UNIONUNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法： SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; 参数： expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 CROS JOINCROSS JOIN又称为笛卡尔乘积，实际上是把两个表乘起来。 语法： SELECT * FROM [TABLE 1] CROSS JOIN [TABLE 2] --或者如下 SELECT * FROM [TABLE 1], [TABLE 2] SELECT * FROM runoob_tbl CROSS JOIN tcount_tbl; 自连接自连接是连接的一种用法,但并不是连接的一种类型,因为他的本质是把一张表当成两张表来使用。 mysql有时在信息查询时需要进行对自身连接（自连接），所以我们需要为表定义别名。 应用场景： 比如如果需要找到员工表中，工资比“小明”高的员工信息。 一般做法是：首先找到小明的工资，然后对所有员工的工资与小明的工资进行比较。需要两步。 如果采用自连接只需要一步： SELECT b.* FROM salary a, salary b WHERE a.name = &quot;小明&quot; AND a.price &lt; b.pirce; 总结 自连接： 针对一个表，进行自己连接，一般解决寻找与其中某条数据相比更高/地等问题。 CROSS JOIN：跟自连接相似，不过是对于两个表格，如果不加条件，显示的数据是：N$\ast$M，N,M分别是两个表的数据数量。 INNER JOIN： 满足on条件的，内连接取满足条件表达是的两个表的交际。 LEFT JOIN: 左连接表示以左表为准，返回左表所有数据，与右表匹配的值，没有匹配的则以NULL取代。 RIGHT JOIN: 右外连接是以右表为准，返回右表所有的数据，与左表匹配的值，没有匹配的则以空（null）取代。 FULL JOIN： 返回两个表符合条件的所有行，a表没有匹配的则a表的列返回null，b表没有匹配的则b表的列返回null，即返回的是左连接和右连接的并集。 UNION： 该操作符用于合并两个或多个 SELECT 语句的结果集。 注意：外连接（outer join）分为：左外连接（left join / left outer join）、右外连接（right join / right outer join）和全外连接（full join / full outer join） join是自然连接，对两张表中字段名和数据类型都相同的字段进行等值连接，并返回符合条件的结果，而inner join是内连接,显示符合连接条件的记录，连接条件已经指明了。这里需要注意join的时候和inner join连接时使用的连接条件是不一样的，所以在结果中记录出现的顺序会有所不同，但两个结果结合是一样的。 作业项目五：组合两张表 （难度：简单）在数据库中创建表1和表2，并各插入三行数据（自己造）表1: Person +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId 是上表主键 表2: Address +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：FirstName, LastName, City, State 答案CREATE TABLE Person (PersionID INT NOT NULL AUTO_INCREMENT PRIMARY KEY, FirstName VARCHAR(20), LastName VARCHAR(20)); CREATE TABLE Address (AddressId INT NOT NULL AUTO_INCREMENT PRIMARY KEY, PersonId INT, City VARCHAR(20), State VARCHAR(20)); --第一个表中的PersionID打错了，需要修改为PersonId ALTER TABLE Person CHANGE PersionID PersonId INT NOT NULL; --把Address的Person设置为外键 ALTER TABLE Address ADD CONSTRAINT fk_person_id FOREIGN KEY(PersonID) REFERENCES Person(PersonID); --插入数据 INSERT INTO Person (PersonId, FirstName, LastName) VALUES (&apos;1&apos;, &apos;A&apos;, &apos;F&apos;), (&apos;2&apos;, &apos;B&apos;, &apos;G&apos;), (&apos;3&apos;, &apos;C&apos;, &apos;H&apos;); INSERT INTO Address (AddressId, PersonId, City, State) VALUES (&apos;1&apos;, &apos;1&apos;,&apos;ChangSha&apos;, &apos;Hunan&apos;), (&apos;2&apos;, &apos;2&apos;, &apos;NanJing&apos;, &apos;JiangSu&apos;), (&apos;3&apos;, &apos;3&apos;, &apos;Shen&apos;, &apos;Guang&apos;); SELECT FirstName, LastName, City FROM Person a RIGHT JOIN Address b ON a.PersonId = b.PersonId; 项目六：删除重复的邮箱（难度：简单）编写一个 SQL 查询，来删除 email 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 +----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Email表应返回以下几行: +----+------------------+ | Id | Email | +----+------------------+ | 1 | a@b.com | | 2 | c@d.com | +----+------------------+ 答案--创建表 CREATE TABLE email(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, Email VARCHAR(20)); --插入数据 INSERT INTO email (id, Email) VALUES (1, &quot;a@b.com&quot;), (2, &quot;c@d.com&quot;), (3, &quot;a@b.com&quot;); SELECT a.*, b.* FROM email a, email b WHERE a.Email = b.Email; DELETE a FROM email a, email b WHERE a.Email = b.Email AND a.id &gt; b.id; SELECT * FROM email;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰SQL教程--表操作(四)]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%BB%96%E9%9B%AA%E5%B3%B0SQL%E6%95%99%E7%A8%8B--%E8%A1%A8%E6%93%8D%E4%BD%9C(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，前面已经详细讲述了SELECT语句的详细用法。 而对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录；UPDATE：更新已有记录；DELETE：删除已有记录。 MySQL表数据类型 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 创建表CREATE创建数据库： CREATE DATABASE &lt;数据库名&gt;; 使用创建数据库： USE &gt;数据库名&gt;; 删除数据库： DROP DATABASE &lt;数据库名&gt;; 建MySQL数据表需要以下信息： 表名 表字段名 定义每个表字段 语法： CREATE TABLE table_name (column_name column_type); 下面以创建RUNOOB数据库为例： CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 解析： 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 插入数据INSERT基本语法： INSERT INTO &lt;表名&gt; (字段1, 字段2, ....) VALUES (值1, 值2, ....); 例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值： INSERT INTO student (class_id, name, gender, score) VALUES (2, &apos;大牛&apos;, &apos;M&apos;, 80); 注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) ...，但是对应的VALUES就得变成(80, &#39;M&#39;, &#39;大牛&#39;, 2)。 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值： INSERT INTO students (class_id, name, gender, score) VALUES (1, &apos;大宝&apos;, &apos;M&apos;, 87), (2, &apos;二宝&apos;, &apos;M&apos;, 81); 删除表和数据删除表语法： DROP TABLE table_name; 删除数据语法： DELETE FROM &lt;表名&gt; WHERE ...; 例如，我们想删除students表中id=1的记录： DELETE FROM studnets WHERE id = 1; 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据。 删除表格中所有数据，但是保留表格： TRUNCATE TABLE &lt;表名&gt;; 三者区别：当你不再需要该表时， 用 drop；当你仍要保留该表，但要删除所有记录时， 用 truncate；当你要删除部分记录时（always with a WHERE clause), 用 delete。 不能使用TRUNCAATE的情况1、由 FOREIGN KEY 约束引用的表。（您可以截断具有引用自身的外键的表。） 2、参与索引视图的表。 3、通过使用事务复制或合并复制发布的表。 4、对于具有以上一个或多个特征的表，请使用 DELETE 语句。 5、TRUNCATE TABLE 不能激活触发器，因为该操作不记录各个行删除。 修改数据语法： UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; --例子 UPDATE students SET name=&apos;大牛&apos;, score=66 WHERE id=1; 交换数据中的值： UPDATE salary SET sex = CASE WHEN sex = &apos;f&apos; THEN &apos;m&apos; ELSE &apos;f&apos; END; SELECT * FROM salary; 修改表当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 删除、修改或添加字段首先创建一张表，表明testalter_tbl: create table testalter_tbl ( i INT, c CHAR(1) ); 如下命令使用了ALTER命令及DROP子句来删除表格中的字段： ALTER TABLE table_name DROP &lt;删除的字段名&gt;; 如下命令使用ADD子句来想数据表中添加列： ALTER TABLE table_name ADD &lt;列名&gt; &lt;类型&gt;； 如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。 FIRST 和 AFTER 关键字可用于 ADD 与 MODIFY 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。 修改字段类型及名称如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。 例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令: ALTER TABLE testalter_tbl MODIFY c CHAR(10); SHOW COLUMNS FROM testalter_tbl; 使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例： ALTER TABLE testalter_tbl CHANGE i j BIGINT; 当你修改字段时，你可以指定是否包含值或者是否设置默认值。 ALTER TABLE testalter_tbl MODIFY j BIGINT NOT NULL DEFAULT 100; 修改字段默认值ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000; 作业项目三：超过5名学生的课（难度：简单）创建如下所示的courses 表 ，有: student (学生) 和 class (课程)。例如,表: +---------+------------+ | student | class | +---------+------------+ | A | Math | | B | English | | C | Math | | D | Biology | | E | Math | | F | Computer | | G | Math | | H | Math | | I | Math | | A | Math | +---------+------------+ 编写一个 SQL 查询，列出所有超过或等于5名学生的课。应该输出: +---------+ | class | +---------+ | Math | +---------+ Note: 学生在每个课中不应被重复计算。 答案创建表： CREATE TABLE courses (student VARCHAR(10), class VARCHAR(20)); 插入数据： INSERT INTO courses (student, class) VALUES (&apos;A&apos;, &apos;Math&apos;), (&apos;B&apos;, &apos;English&apos;), (&apos;C&apos;, &apos;Math&apos;), (&apos;D&apos;, &apos;Biology&apos;), (&apos;E&apos;, &apos;Math&apos;), (&apos;F&apos;, &apos;Computer&apos;), (&apos;G&apos;, &apos;Math&apos;), (&apos;H&apos;, &apos;Math&apos;), (&apos;I&apos;, &apos;Math&apos;), (&apos;A&apos;, &apos;Math&apos;); 查询操作： SELECT class FROM (SELECT DISTINCT student, class FROM courses) as cour GROUP BY class HAVING COUNT(class) &gt;=5; 项目四：交换工资（难度：简单）创建一个 salary表，如下所示，有m=男性 和 f=女性的值 。例如: | id | name | sex | salary | |----|------|-----|--------| | 1 | A | m | 2500 | | 2 | B | f | 1500 | | 3 | C | m | 5500 | | 4 | D | f | 500 | 交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。运行你所编写的查询语句之后，将会得到以下表: | id | name | sex | salary | |----|------|-----|--------| | 1 | A | f | 2500 | | 2 | B | m | 1500 | | 3 | C | f | 5500 | | 4 | D | m | 500 | 答案创建表： CREATE TABLE salary (id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(10) NOT NULL, sex CHAR(1) NOT NULL, salary BIGINT); 插入数据： INSERT INTO salary (name, sex, salary) VALUES (&apos;A&apos;, &apos;m&apos;, 2500), (&apos;B&apos;, &apos;f&apos;, 1500), (&apos;C&apos;, &apos;m&apos;, 5500), (&apos;D&apos;, &apos;f&apos;, 500); 查询 UPDATE salary SET sex = CASE WHEN sex = &apos;f&apos; THEN &apos;m&apos; ELSE &apos;f&apos; END; SELECT * FROM salary;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰SQL教程--查询数据(三)]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%BB%96%E9%9B%AA%E5%B3%B0SQL%E6%95%99%E7%A8%8B--%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[在关系数据库中，最常用的操作就是查询！结合DateWhale-MySQL集训进行学习，文末有DateWhale-MySQL集训给出的练习项目。 准备数据为了便于讲解和练习，我们先准备好了一个students表和一个classes表，它们的结构和数据如下： students表存储了学生信息： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 4 1 小米 F 73 5 2 小白 F 81 6 2 小兵 M 55 7 2 小林 M 85 8 3 小新 F 91 9 3 小王 M 89 10 3 小丽 F 85 classes表存储了班级信息： id name 1 一班 2 二班 3 三班 4 四班 如果想用MySQL练习，可以下载这个SQL脚本，然后在命令行运行： mysql -u root -p &lt; init-test-data.sql 就可以自动创建test数据库，并且在test数据库下创建students表和classes表，以及必要的初始化数据。 和内存数据库不同的是，对MySQL数据库做的所有修改，都会保存下来。如果你希望恢复到初始状态，可以再次运行该脚本。 基本查询查询数据库中所有数据： SELECT * FROM &lt;表名&gt;; 查询students表中所有数据： SELECT * FROM students; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句： SELECT 100+200; //计算100+100 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 条件查询使用SELECT * FROM &lt;表名&gt;可以查询一张表中的所有记录。但是有时候，我们并不是希望获得所有记录，而是根据条件选择性地获取指定条件的记录。例如，查询分数在80分以上的学习记录。 SELECT语句可以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是: SELECT * FROM students WHERE score &gt;= 80; 其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录： 因此，条件查询的语法就是： SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;; ANDSELECT * FROM students WHERE score &gt;= 80 AND gender = &apos;M&apos;; ORSELECT * FROM students WHERE score &gt;= 80 OR gender = &apos;M&apos;; NOTSELECT * FROM students WHERE NOT class_id = 2; 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。 常用的条件表达式 条件 表达式举例1 表达式举例2 说明 使用=判断相等 score = 80 name = ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;=判断大于或相等 score &gt;= 80 name &gt;= ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;= ‘abc’ 使用&lt;=判断小于或相等 score &lt;= 80 name &lt;= ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ 查询分数在60分(含)～90分(含)之间的学生可以使用的WHERE语句WHERE score BETWEEN 60 AND 90 WHERE score &gt;= 60 AND score &lt;= 90 查询前N条数据LIMIT N SELECT * FROM students LIMIT 5; 投影查询如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 例如，从students表中返回id、score和name这三列： SELECT id, score, name FROM students; 使用SELECT 列1, 列2, 列3 FROM ...时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是: SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...; 例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变： SELECT id, score points, name FROM students; 排序 ORDER BY默认情况是按主键进行排序的。 按score分数从低到高排序： SELECT id, name, gender, score FROM students ORDER BY score; 如果反过来，按成绩从高到低(DESC)排序： SELECT id, name, gender, score FROM students ORDER BY score DESC; 如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序: SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; 默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序： SELECT id, name, gender, score FROM students WHERE class_id = 1 ORDER BY score DESC; 分页查询使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现。我们先把所有学生按照成绩从高到低进行排序，把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 0; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。 如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3： SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 3; 如果OFFSET设定超过查询的最大数量不会报错，而是得到一个空的结果集。 注意 OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 聚合查询对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询： SELECT COUNT(*) FROM students; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果： SELECT COUNT(*) num FROM students; COUNT(*)和COUNT(id)实际上效果是一样的。聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生，多少80分以上的学生等： SELECT COUNT(*) boys FROM students WHERE gender = &apos;M&apos;; 聚合函数 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 //计算男生平均成绩: SELECT AVG(score) average FROM students WHERE gender = &apos;M&apos;; // SELECT AVG(score) average FROM students WHERE gender = &apos;X&apos;; 注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL。 分组如果我们要统计一班的学生数量，我们知道，可以用 SELECT COUNT(*) num FROM students WHERE class_id = 1; 如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？ 对于聚合查询，SQL还提供了“分组聚合”的功能。如下： SELECT COUNT(*) num FROM students GROUP BY class_id; 执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。 SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 如果把name放入结果集中，不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 使用多个列进行分组 SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender; HAVING分组后的条件使用HAVING来限定，WHERE是对原始数据进行条件限定，几个关键字使用的顺序为： where \ group by\ having \ order by 例如： SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender; 多表查询SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理 要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名： SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cname FROM students, classes; 可以给表设置一个别名，这样可以简化使用表名.列名这样的方式来引用列和设置别名 ： SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name, cname FROM students s, classes c; 多表查询也可以使用WHERE条件，如下： SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c WHERE s.gender = &apos;M&apos; AND c.id = 1; 注意： 使用多表查询可以获取M x N行记录。 连接查询连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 例如，我们想选出students表的所有学生信息，可以用一条简单的SELECT语句完成： SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s; 但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s INNER JOIN classes c ON s.class_id = c.id; 注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选，加上WHERE子句、ORDER BY等子句。 有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果: SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s RIGHT OUTER JOIN classes c ON s.class_id = c.id; 执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。 这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。 有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是： INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id 返回的结果集仅包含1，2，3。 RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一列，并添加class_id=5，由于classes表并不存在id=5的列，所以，LEFT OUTER JOIN的结果会增加一列，对应的class_name是NULL： -- 先增加一列class_id=5: INSERT INTO students (class_id, name, gender, score) values (5, &apos;新生&apos;, &apos;M&apos;, 88); -- 使用LEFT OUTER JOIN SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s LEFT OUTER JOIN classes c ON s.class_id = c.id; 最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s FULL OUTER JOIN classes c ON s.class_id = c.id; 总结对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。 假设查询语句是： SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 判断语句CASE expression WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... WHEN conditionN THEN resultN ELSE result END CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。 例如，对students表中同学的成绩分等级： SELECT id, class_id, name, score, case WHEN score &gt; 90 THEN &apos;优秀&apos; WHEN score &gt; 80 AND score &lt;= 90 THEN &apos;良好&apos; WHEN score &gt; 70 AND score &lt;= 80 THEN &apos;中等&apos; WHEN score &gt; 60 AND score &lt;= 70 THEN &apos;及格&apos; ELSE &apos;不及格&apos; END score_num FROM students; 注释单行注释： create database database-x -- 创建数据库 多行注释： create database database-x /* 创建一个数据库 名字为database-x */ 函数时间函数、数值函数、字符串函数 格式规范https://zhuanlan.zhihu.com/p/27466166 https://www.sqlstyle.guide/ 参考资料：RUNOOB教程) 张雪峰SQL教程 Datawhale-MySQL 作业项目一：查找重复的电子邮箱（难度：简单）创建 email表，并插入如下三行数据 +----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 编写一个 SQL 查询，查找 email 表中所有重复的电子邮箱。根据以上输入，你的查询应返回以下结果： +---------+ | Email | +---------+ | a@b.com | +---------+ 说明：所有电子邮箱都是小写字母。 答案SELECT Email FROM email_table GROUP BY Email HAVING COUNT(Email) &gt;= 2; 项目二：查找大国（难度：简单）创建如下 World 表 +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000 | | Albania | Europe | 28748 | 2831741 | 12960000 | | Algeria | Africa | 2381741 | 37100000 | 188681000 | | Andorra | Europe | 468 | 78115 | 3712000 | | Angola | Africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ 如果一个国家的面积超过300万平方公里，或者(人口超过2500万并且gdp超过2000万)，那么这个国家就是大国家。编写一个SQL查询，输出表中所有大国家的名称、人口和面积。例如，根据上表，我们应该输出: +--------------+-------------+--------------+ | name | population | area | +--------------+-------------+--------------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +--------------+-------------+--------------+ 答案SELECT name, population, area FROM World WHERE area &gt; 3000000 OR (population &gt; 25000000 AND gdp &gt; 20000000); 附作业创建表代码： --项目一 -- 创建表 CREATE TABLE email ( ID INT NOT NULL PRIMARY KEY, Email VARCHAR(255) ) -- 插入数据 INSERT INTO email VALUES(&apos;1&apos;,&apos;a@b.com&apos;); INSERT INTO email VALUES(&apos;2&apos;,&apos;c@d.com&apos;); INSERT INTO email VALUES(&apos;3&apos;,&apos;a@b.com&apos;); --项目二 -- 创建表 CREATE TABLE World ( name VARCHAR(50) NOT NULL, continent VARCHAR(50) NOT NULL, area INT NOT NULL, population INT NOT NULL, gdp INT NOT NULL ); -- 插入数据 INSERT INTO World VALUES( &apos;Afghanistan&apos;, &apos;Asia&apos;,652230,25500100,20343000); INSERT INTO World VALUES( &apos;Albania&apos;, &apos;Europe&apos; ,28748,2831741,12960000); INSERT INTO World VALUES( &apos;Algeria&apos;, &apos;Africa&apos; ,2381741,37100000,188681000); INSERT INTO World VALUES( &apos;Andorra&apos; , &apos;Europe&apos; ,468,78115,3712000); INSERT INTO World VALUES( &apos;Angola&apos; , &apos;Africa&apos; ,1246700,20609294,100990000);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--友元、异常和其他（十五）]]></title>
    <url>%2F2019%2F02%2F24%2FC%2B%2B%20Primer%20Plus--%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96%EF%BC%88%E5%8D%81%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[首先介绍一些C++语言最初的特性，然后介绍C++语言新增的一些特定。前者包括友元类、友元成员函数和嵌套类，它们是在其他类种声明的类；后者包括异常、运行阶段类型识别(RTTI)和改进后的类型转换控制。 15.1 友元前面介绍的一些示例将友元函数用于类的扩展接口中，类并非只能拥有友元函数，也可将类作为友元。在这种情况下，友元类的所有方法都可以访问原始类的私有成员和保护成员。另外，也可以做更严格的限制，只将特定的成员函数指定为另一个类的友元。哪些函数、成员函数或类为友元是由类定义的，而不能从外部强加友情。因此，尽管友元被授予了从外部访问类的私有部分的权限，但它们并不与面向对象编程思想相悖；相反，它们提供了公有接口的灵活性。 15.1.1 友元类什么时候希望一个类成为另一个类的友元呢？我们来看一个例子。假定需要编写一个模拟电视机和遥控器的简单程序。决定定义一个Tv类和一个Remote类，来分别表示电视剧和要控制。很明显，这两个类之间应当存在某种关系，但是什么样的关系呢？遥控器并非电视机，反之亦然，所以公有继承的is关系并不适用。遥控器也非电视机的一部分，反之亦然，因此包含或私有继承和保护继承的has-a关系也不适用。事实上，遥控器可以改变电视机的状态，这表明应将Romote类作为Tv类的一个友元。 首先定义Tv类。快车使用一组状态成员（描述电视机各个方面的变量）来表示电视机。下面是一些可能的状态： 开/关； 频道设置； 音量设置； 有线电视或天线调节模式； TV调谐或A/V输入。 调节模式指的是，在美国，对于有线接受和UHF广播接收，14频道和14频道以上的频道间隔是不同的。输入选择包括TV(有线TV或广播TV)和DVD。有些电视机可能提供更多的选择，如多种DVD/蓝光输入，但对于这个示例的目的而言，这个清单足够了。 另外，电视机还有一些不是状态变量的参数。例如，可接受频道数随电视机而异，可以包括一个记录这个值的成员。 接下来，必须给类提供一些修改这些设置的方法。当前，很多电视机都将控件藏在面板后面，但大多数电视机还是可以在不使用遥控器的情况下进行换台等工作的，通常只能逐频道换台，而不能随意选台。同样，通常还有两个按钮，分别用来增加和降低音量。 遥控器的控制力应与电视机内置的控制空能相同，它的很多方法都可通过使用Tv方法来实现。另外，遥控器通常都提供随意选择频道的功能。另外，很多遥控器都有多种工作模式，如用作电视控制器和DVD遥控器。 这些考虑因素表明，定义应类似于程序15.1。定义中包括一一些被定义为枚举的常量。下面的语句使Remote成为友元类： friend class Remote; 友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。由于Remote类提到了Tv类，所以编译器必须了解Tv类后，才能处理Remote类，为此，最简单的方法是首先定义Tv类。也可以使用前向声明，这将稍后介绍。 程序15.1 tv.h #ifndef TV_H_ #define TV_H_ class Tv { public: friend class Remote; enum {off, on}; enum {MinVal, MaxVal = 20}; enum {Antenna, Cable}; enum {TV, DVD}; Tv(int s = off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {} void onoff() {state = (state == on) ? off : on; } bool ison() const { return state == on; } bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode() { mode = (mode == Antenna)? Cable : Antenna; } void set_input() { input = (input==TV) ? DVD : TV; } void settings() const; private: int state; int volume; int maxchannel; int channel; int mode; int input; }; class Remote { private: int mode; public: Remote(int m = Tv::TV) : mode(m) {} bool volup(Tv &amp; t) { return t.volup(); } bool voldown(Tv &amp; t) { return t.voldown(); } void onoff(Tv &amp; t) { t.onoff(); } void chanup(Tv &amp; t) { t.chanup(); } void chandown(Tv &amp; t) { t.chandown(); } void set_chan(Tv &amp; t, int c) { t.channel = c; } void set_mode(Tv &amp; t) { t.set_mode(); } void set_input(Tv &amp; t) { t.set_input(); } }; #endif 在程序15.1中，大多数类方法都被定义为内联的。除构造函数外，所有的Remote方法都将一个Tv对象引用作为参数，这表明遥控器必须针对特定的电视机。程序15.2列出了其余的定义。音量设置函数将音量成员增减一个单位，除非声音到达最大或最小。频道选择函数使用循环方法。 很多方法都使用条件运算符在两种状态之间切换： void onoff() { state = (state == on) ? off : on; } 如果两种状态值分别为true(1)和false(0)，则可以结合使用将在附录E讨论的按位异或和赋值运算符(^=)来简化代码： void onoff() { state ~= 1; } 事实上，在单个无符号char变量中可存储多大8个双状态设置，分别对它们进行切换；但现在已经不用这样做了，使用附录E中讨论的按位运算符可以完成。 程序15.2 tv.cpp #include &quot;tv.h&quot; #include &lt;iostream&gt; bool Tv::volup() { if (volume &lt; MaxVal) { volume++; return true; } else return false; } bool Tv::voldown() { if (volume &gt; MinVal) { volume--; return true; } else return false; } void Tv::chanup() { if (channel &lt; maxchannel) channel++; else channel = 1; } void Tv::chandown() { if (channel &gt; 1) channel--; else channel = maxchannel; } void Tv::settings() const { using std::cout; using std::endl; cout &lt;&lt; &quot;TV is &quot; &lt;&lt; (state == off ? &quot;Off&quot; : &quot;On&quot;) &lt;&lt; endl; if (state == on) { cout &lt;&lt; &quot;Volume setting = &quot; &lt;&lt; volume &lt;&lt; endl; cout &lt;&lt; &quot;Channel setting = &quot; &lt;&lt; channel &lt;&lt; endl; cout &lt;&lt; &quot;Mode = &quot; &lt;&lt; (mode == Antenna ? &quot;antenna&quot; : &quot;cable&quot;) &lt;&lt; endl; cout &lt;&lt; &quot;Input = &quot; &lt;&lt; (input == TV ? &quot;TV&quot; : &quot;DVD&quot;) &lt;&lt; endl; } } 程序15.3是一个简短的程序，可以测试一些特定。另外，可使用同一个遥控器控制两台不同的电视机。 程序15.3 use_tv.cpp #include &lt;iostream&gt; #include &quot;tv.h&quot; int main() { using std::cout; Tv s42; cout &lt;&lt; &quot;Initial settings for 42\&quot; TV:\n&quot;; s42.settings(); s42.onoff(); s42.chanup(); cout &lt;&lt; &quot;\nAdjusted settings for 42\&quot; TV:\n&quot;; s42.chanup(); cout &lt;&lt; &quot;\nAdjusted settings for 42\&quot; TV:\n&quot;; s42.settings(); Remote grey; grey.set_chan(s42, 10); grey.volup(s42); grey.volup(s42); cout &lt;&lt; &quot;\n42\&quot; setting after using remote: \n&quot;; s42.settings(); Tv s58(Tv::on); s58.set_mode(); grey.set_chan(s58, 28); cout &lt;&lt; &quot;\n58\&quot; settings:\n&quot;; s58.settings(); return 0; } 输出： Initial settings for 42&quot; TV: TV is Off Adjusted settings for 42&quot; TV: Adjusted settings for 42&quot; TV: TV is On Volume setting = 5 Channel setting = 4 Mode = cable Input = TV 42&quot; setting after using remote: TV is On Volume setting = 7 Channel setting = 10 Mode = cable Input = TV 58&quot; settings: TV is On Volume setting = 5 Channel setting = 28 Mode = antenna Input = TV 这个练习的主要目的在于表明，类友元是一种自然用语，用于表示一些关系。如果不使用某些形式的友元关系，则必须将Tv类的私有部分设置为公有的，或者创建一个笨拙的、大型类来包含电视机和遥控器。这种解决方法无法反应这样的事实，即同一个遥控器可用于多台电视机。 15.1.2 友元成员函数从上一个例子中的代码可知，大多数Remote方法都是用Tv类的公有接口实现的。这意味着这些方法不是真正需要用作友元。事实上，唯一直接访问Tv成员的Remote方法是Remote::set_chan()，因此它是唯一需要用作友元的方法。确实可以选择仅让特定的类成员成员另一个类的友元，而不是让整个类成为友元，但这样做稍微有点麻烦，必须小心排列各种声明和定义的顺序。下面介绍其中的原因。 让Remote::set_chan()成为Tv类的友元方法是，在Tv类声明中将其声明为友元： class Tv { friend void Remote::set_chan(Tv &amp; t, int c); ... }; 然而，要使编译器能够处理这条语句，它必须知道Remote的定义。否则，它无法知道Remote是一个类，而set_chan是这个类的方法。这意味着应该Remote的定义放到Tv的定义前面。Remote的方法提到了Tv对象，而这意味着Tv定义应当位于Remote定义之前。避开这种循环依赖的方法是，使用前向声明(forward declaration)。为此，需要在Remote定义的前面插入下面的语句： class Tv; 这样，排列次序应如下： class Tv; //前向定义 class Remote { ... }; class Tv { ... }; 能否像下面这样排列呢？ class Remote; class Tv { ... }; class Remote { ... }; 答案是不能。原因在于，在编译器在Tv的声明中看到Remote的一个方法被声明为Tv类的友元之前，应该先看淡Remote类的声明和set_chan()方法的声明。 还有一个麻烦。程序15.1的Remote声明包含了内联代码，例如： void onoff(Tv &amp; t) { t.onoff() } 由于这将调用Tv的一个方法，所以编译器此时必须已经看到了Tv类的声明，这样才能知道Tv有哪些方法，但正如看到的，该声明位于Remote声明的后面。这种问题的解决办法是，使Remote声明中只包含方法声明，并将实际的定义放在Tv类之后。这样，排列顺序将如下： class Tv; //前向定义 class Remote { ... };//使用Tv的方法仅仅提供原型 class Tv { ... }; //Remote方法的定义放在这里 Remote方法的原型与下面类似： void onoff(Tv &amp; t); 检查该原型时，所有的编译器都需要知道Tv是一个类，而前向声明提供了这样的信息。当编译器到打真正的方法定义时，它已经读取了Tv类的声明，并拥有了编译这些方法所需的信息。通过在方法定义中使用inline关键字，仍然可以使其成为内联方法。程序15.4列出了修订后的头文件。 程序15.4 tvfm.h #ifndef TVFM_H_ #define TVFM_H_ class Tv; class Remote { private: int mode; public: enum State{off, on}; enum {MinVal, MaxVal = 20}; enum {Antenna, Cable}; enum {TV, DVD}; Remote(int m = TV) : mode(m) {} bool volup(Tv &amp; t); bool voldown(Tv &amp; t); void onoff(Tv &amp; t); void chanup(Tv &amp; t); void chandown(Tv &amp; t); void set_mode(Tv &amp; t); void set_input(Tv &amp; t); void set_chan(Tv &amp; t, int c); }; class Tv { public: friend void Remote::set_chan(Tv &amp; t, int c); enum State{off, on}; enum {MinVal, MaxVal = 20}; enum {Antenna, Cable}; enum {TV, DVD}; Tv(int s = off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV){} void onoff() { state = (state == on) ? off : on; } bool ison() const { return state == on; } bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; } void set_input() { input = (input == TV) ? DVD : TV; } void settings() const; private: int state; int volume; int maxchannel; int channel; int mode; int input; }; inline bool Remote::volup(Tv &amp; t) { return t.volup(); } inline bool Remote::voldown(Tv &amp; t) { return t.voldown(); } inline void Remote::onoff(Tv &amp; t) { t.onoff(); } inline void Remote::chanup(Tv &amp; t) { t.chanup(); } inline void Remote::chandown(Tv &amp; t) { t.chandown(); } inline void Remote::set_mode(Tv &amp; t) { t.set_mode(); } inline void Remote::set_input(Tv &amp; t) { t.set_input(); } inline void Remote::set_chan(Tv &amp; t, int c) { t.channel = c; } #endif 如果在tv.cpp和use_tv.cpp中包含tvfm.h而不是tv.h，程序的行为与前一个程序相同，区别在于，只有一个Remote方法是Tv类的友元，而在原来的版本中，所有的Remote方法都是Tv类的友元。图15.1说明了这种区别。 前面介绍过，内联函数的链接性是内部的，这意味着函数定义必须在使用函数的文件中。在这个例子中，内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。也可以将定义放在实现文件中，但必须删除关键字inline，这样函数的链接性为外部的。 顺便说一句，让整个Remote类成为友元并不需要前向声明，因为友元语句本身已经指出Remote是一个类： friend class Remote; 15.1.3 其他友元关系除本章讨论的，还有其他友元和类的组合形式，下面简要地介绍其中一些。 假设由于技术进步，出现了交互式遥控器。例如，交互式遥控器让您能够回答电视节目中的问题，如果回答错误，电视将在控制器上产生嗡嗡声。忽略电视使用这种设施安排观众进入节目的可能性，我们只看C++的编程方面。新的方案将受益于相互的友情，一些Remote方法能够像前面那样影响Tv对象，而一些Tv方法也能影响Remote对象。这可以通过让类彼此成员对象的友元来实现，即除了Remote是Tv的友元外，Tv也是Remote的友元。需要记住一点，对于使用Remote对象的Tv方法，其原型可在Remote类声明之前声明，但必须在Remote类声明之后定义，以便编译器有足够的信息来编译该方法。这种方案与下面类似： class Tv { friend class Remote; public: void buzz(Remote &amp; r); ... }; class Remote { friend class Tv; public: void bool volup(Tv &amp; t) { t.volup(); } ... }; inline void Tv::buzz(Remote &amp; r) { ... } 由于Remote的声明位于Tv声明的后面，所以可以在类声明中定义Remote::volup()，但Tv::buzz()方法必须在Tv声明的外部定义，使其位于Remote声明的后面。如果不希望buzz()是内联的，则应在一个单独的方法定义文件中定义它。 15.1.4 共同的友元需要使用友元的另一种情况是，函数需要访问两个类的私有数据。从逻辑上看，这样的函数应是每个类的成员函数，但这是不可能的，它可以是一个类的成员，同时是另一个类的友元，但有时将函数作为两个类的友元更合理。例如，假设Probe类和一个Analyzer类，前者表示某种可编程的测量设备，后者表示某种可编程的分析设备。这两个类都有内部同步，则应该包含下述代码行： class Analyzer; class Probe { friend void sync(Analyzer &amp; a, const Probe &amp; p); friend void sync(Probe &amp; p, const Analyzer &amp; a); ... }; class Analyzer { friend void sync(Analyzer &amp; a, const Probe &amp; p); friend void sync(Probe &amp; p, const Analyzer &amp; a); ... }; inline void sync(Analyzer &amp; a, const Probe &amp; p) { ... } inline void sync(Probe &amp; p, const Analyzer &amp; a) { ... } 前向声明使编译器看到Probe类声明中的友元声明时，知道Analyzer是一种类型。 15.2 嵌套类在C++中，可以将类声明放在另一个类中。在另一个类中声明的类被称为嵌套类（nested class），它通过提供类新的类型类作用域来避免名称混乱。包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符。 对类进行嵌套并与包含并不同。包含意味着将类对象作为另一个类的成员，而对类进行嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。 对类进行嵌套通常是为了帮助实现另一个类，并避免名称冲突。Queue类示例（第12章程序12.8）嵌套了结构的定义，从而实现了一种变相的嵌套类： class Queue { private: struct Node {Item item; struct Node * next; }; ... }; 由于结构是一种其成员在默认情况下为公有类，所以Node实际上是一个嵌套类，但该定义并没有充分利用类的功能。具体来说，它没有显式构造函数，下面进行补救。 首先，找到Queue示例中创建Node对象的位置。从类声明(程序11.10)和方法定义（程序12.11）可知，唯一创建了Node对象的地方是enqueue()方法： bool Queue::enqueue(const Item &amp; item) { if (isfull()) return false; Node * add = new Node; add-&gt;item = item; add-&gt;next = NULL: } 上述代码创建Node后，显式地给Node成员赋值，这种工作更合适由构造函数来完成。 知道应该什么地方以及如何使用构造函数后，便可以提供一个适当的构造函数定义： class Queue { class Node { public: Item item; Node * next; Node (const Item &amp; i) : item(i), next(0) {} }; ... }; 该构造函数将节点的item成员初始化为i，并将next指针设置为0，这是使用C++编写空指针的方法之一。由于使用Queue类创建的所有节点的next的初始值都被设置为空指针，因此这个类只需要该构造函数。 接下来，需要使用构造函数重新编写enqueue(): bool Queue::enqueue(const Item &amp; item) { if (isfull()) return false; Node * add = new Node(item); } 这使得enqueue()代码更短，也更安全，因此它自动进行初始化，无需程序记住应做什么。 这个例子在类声明中定义了构造函数。假设想在方法文件中定义构造函数，则定义必须指出Node类是在Queue类中定义的。这是通过使用两次作用域解析运算符来完成的： Queue::Node::Node(const Item &amp; i) : item(i), next(0) {} 15.2.1 嵌套类和访问权限有两种访问权限适合于嵌套类。首先，嵌套类的声明位置决定了嵌套类的作用域，即它决定了程序的哪些部分可以创建这种类对象。其次，和其他类一样，嵌套类的公有部分、保护部分和私有部分控制了对类成员的访问。在哪些地方可以使用嵌套类以及如何使用嵌套类，取决于作用域和访问控制。下面将更详细地进行介绍。 1. 作用域如果嵌套类是在另一个类的私有部分的，则只有后者知道它。在前一个例子中，被嵌套在Queue声明中的Node类就属于这个情况（看起来Node是在私有部分之前定义的，但别忘了，类的默认访问权限是私有的），因此，Queue成员可以使用Node对象和指向Node对象的指针，但是在程序的其他部分甚至不知道存在Node类。对于从Queue派生而来的类，Node也是不可见的，因为派生类不能直接访问基类的私有部分。 如果嵌套类是在另一个类的保护部分声明的，则它对于后者来说是可见的，但对于外部世界则是不可见的。然而，在这种情况中，派生类将知道嵌套类，并可以直接创建这种类型的对象。 如果嵌套类在另一个类的公有部分声明的，则允许后者、后者的派生类以及外部世界使用它。因为它是公有的。然而，由于嵌套类的作用域为包含它的类，因此在外部世界使用它，必须使用类限定符。例如，假设有下面的声明： class Team { public: class Coach { ... }; ... }; 现在假定有一个失业的教练，他不属于任何球队。要在Team类的外面创建Coach对象，可以这样做： Team::Coach forhire; 嵌套结构和枚举的作用域与此相同。其实，很多程序员都是公有枚举来提供客户程序员使用的类常数。例如，很多类实现都被定义为支持iostream使用这种技术来提供不同的格式选项，前面已经介绍过这方面的内容，第17章将更加全面地进行介绍。表15.1总结了嵌套类、结构和枚举的作用域特征。 2. 访问控制类可见后，其决定作用的将是访问控制。对嵌套类访问权的控制规则与对常规类相同。在Queue类声明中声明Node类并没有赋予Queue类对Node类的访问特权，也没有赋予Node类任何对Queue类的访问特权。因此，Queue类对象只能显式地访问Node对象的公有成员。由于这个原因，在Queue示例中，Node类的所有成员都被声明为公有的。这样有悖于应将数据成员声明为私有的这一惯例，但Node类是Queue类内部实现的一项特性，对于外部世界是不可见的。这是因为Node类是在Queue类的私有部分声明的。所以，虽然Queue的方法可直接访问Node的成员，但使用Queue类的客户不能这样做。 总之，类声明的位置决定了类的作用域或可见性。类可见后，访问控制规则（私有、保护、公有、友元）将决定程序对嵌套类成员的访问权限。 15.2.2 模板中的嵌套您知道，模板适合于实现诸如Queue等容器类。您可能会问，将Queue类定义转换为模板时，是否会由于它包含嵌套类而带来问题？答案是不会。程序15.5演示了如何进行这种转换。和类模板一样，该头文件也包含类模板和方法函数模板。 程序15.5 queuetp.h #ifndef QUEUETP_H_ #define QUEUETP_H_ template &lt;class Item&gt; class QueueTP { private: enum {Q_SIZE = 10}; class Node { public: Item item; Node * next; Node(const Item &amp; i) : item(i), next(0) {} }; Node * front; Node * rear; int items; const int qsize; QueueTP(const QueueTP &amp; q) : qsize(0) {} QueueTP &amp; operator=(const QueueTP &amp;q) { return *this; } public: QueueTP(int qs = Q_SIZE); ~QueueTP(); bool isempty() const { return items == 0; } bool isfull() const { return items == qsize; } int queuecount() const { return items; } bool enqueue(const Item &amp; item); bool dequeue(Item &amp; item); }; template &lt;class Item&gt; QueueTP&lt;Item&gt;::QueueTP(int qs) : qsize(qs) { front = rear = 0; items = 0; } template &lt;class Item&gt; QueueTP&lt;Item&gt;::~QueueTP() { Node * temp; while (front != 0) { temp = front; front = front-&gt;next; delete temp; } } template &lt;class Item&gt; bool QueueTP&lt;Item&gt;::enqueue(const Item &amp; item) { if (isfull()) return false; Node * add = new Node(item); items++; if (front == 0) front = add; else rear-&gt;next = add; rear = add; return true; } template &lt;class Item&gt; bool QueueTP&lt;Item&gt;::dequeue(Item &amp; item) { if ( front == 0) return false; item = front-&gt;item; items--; Node * temp = front; front = front-&gt;next; delete temp; if (items == 0) rear = 0; return true; } #endif 程序15.5中模板有趣的一点是，Node是利用通用类型Item来定义的。所以，下面的声明将导致Node被定义成用于存储double: QueueTP&lt;double&gt; dq; 而下面的声明将导致Node被定义成用于存储char值： QueueTP&lt;char&gt; cq; 这两个Node类将在两个独立的QueueTP类中定义，因此不会发生名称冲突。即一个节点的类型为QueueTP::Node，而另一个节点的类型为QueueTP::Node。 程序15.6 nested.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;queuetp.h&quot; using namespace std; int main() { QueueTP&lt;string&gt; cs(5); string temp; while (!cs.isfull()) { cout &lt;&lt; &quot;Please enter your name, You will be &quot; &lt;&lt; &quot;served in the order of arrival.\nname:&quot;; getline(cin, temp); cs.enqueue(temp); } cout &lt;&lt; &quot;The queue is full. Processing begins!\n&quot;; while (!cs.isempty()) { cs.dequeue(temp); cout &lt;&lt; &quot;Now processing &quot; &lt;&lt; temp &lt;&lt; &quot;...\n&quot;; } return 0; } 输出： Please enter your name, You will be served in the order of arrival. name:1 Please enter your name, You will be served in the order of arrival. name:2 Please enter your name, You will be served in the order of arrival. name:3 Please enter your name, You will be served in the order of arrival. name:4 Please enter your name, You will be served in the order of arrival. name:5 The queue is full. Processing begins! Now processing 1... Now processing 2... Now processing 3... Now processing 4... Now processing 5... 15.3 异常程序有时会遇到运行阶段错误，导致程序无法正常地运行下去。例如，程序可能试图打开一个不可用的文件，请求过多的内存，或者遇到不能容忍的值。通常，程序员都会试图预防这种意外情况。C++异常为处理这种情况提供了一种强大而灵活的工具。异常是相对比较新的C++功能，有些老式编译器可能没有实现。另外，有些编译器默认关闭这种特性，您可能需要使用编译器选项来启用它。 讨论异常之前，先来看看程序员可使用的一些基本方法。作为试验，以一个计算两个数的调和平均数的函数为例。两个数的调和平均数的定义是：这两个数倒数的平均值的倒数。因此表达式为： 2.0 * x * y / (x + y) 如果y是x的负值，则上述公式将导致除数为零—–一种不允许的计算。对于被零除的情况，很多新式编译器通过生成一个表示无穷大的特殊浮点值来处理，cout将这种值显示为Inf、inf、INF或类似的东西；而其他的编译器可能生成在发生被零除时的程序崩溃。最后编写在所有系统上都以相同的受控方法运行的代码。 15.3.1 调用abort()对于这种问题，处理方式之一是，如果其中一个参数是另一个参数的负值，则调用abort()函数。abort()函数的原型位于头文件cstdlib中，其典型实现是向标准错误流（即cerr使用的错误流）发成消息abnormal program termination(程序异常终止)，然后程序终止。它还返回一个随实现而异的值，高所操作系统（如果程序是由另一个程序调用的，则告诉父进程），处理失败。abort()是否刷新文件缓存区（用于存储读写到文件中的数据的内存区域）取决于实现。如果愿意，也可以使用exit()，该函数刷新文件缓冲区，但不显示消息。程序15.7是一个abort()的小程序。 程序15.7 error1.cpp #include &lt;iostream&gt; #include &lt;cstdlib&gt; double hmean(double a, double b); int main() { double x, y, z; std::cout &lt;&lt; &quot;Enter two numbers: &quot;; while (std::cin &gt;&gt; x &gt;&gt; y) { z = hmean(x, y); std::cout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter next set of numbers &lt;q to quit&gt;: &quot;; } std::cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } double hmean(double a, double b) { if (a == -b) { std::cout &lt;&lt; &quot;untenable arguments to hmean()\n&quot;; std::abort(); } return 2.0 * a * b / (a + b); } 输出： Enter two numbers: 3 6 Harmonic mean of 3 and 6 is 4 Enter next set of numbers &lt;q to quit&gt;: 10 -10 untenable arguments to hmean() Aborted 注意，在hmean()中调用abort()函数将直接终止程序，而不是先返回到main()。一般而言，显示的程序异常中断消息随编译器而异。 为了避免异常终止，程序应在调用hmean()函数之前检查x和y的值。然而，依靠程序员来执行这种检查是不安全的。 15.3.2 返回错误码一种比异常终止更灵活的方法是，使用函数的返回值来指出问题。例如，ostream类的get(void)成员通常返回一个输入字符的ASCII码，但到达文件尾时，将返回特殊值EOF。对hmean()来说，这种方法不管用。任何数值都是有效的返回值，因此不存在可用于指出问题的特殊值。在这种情况下，可使用指针参数或引用参数来将值返回给调用程序，并使用函数的返回值来指出成功还是失败。istream族重载&gt;&gt;运算符使用了这种技术的变体。通过告知调用程序时成功还是失败了，使得程序可以采取除异常终止程序之外的其他措施。程序15.8是一个蚕蛹这种方法的示例，它将hmean()的返回值重新定义为bool，让返回值指出成功了还是失败了，另外还给函数增加了第三个参数，用于提供答案。 程序15.8 error2.cpp #include &lt;iostream&gt; #include &lt;cfloat&gt; bool hmean(double a, double b, double * ans); int main() { double x, y, z; std::cout &lt;&lt; &quot;Enter two numbers: &quot;; while (std::cin &gt;&gt; x &gt;&gt; y) { if ( hmean(x, y, &amp;z)) std::cout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;One value should not be the negative &quot; &lt;&lt; &quot;of the other - try again.\n&quot;; std::cout &lt;&lt; &quot;Enter next set of numbers &lt;q to quit&gt;: &quot;; } std::cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } bool hmean(double a, double b, double * ans) { if (a == -b) { *ans = DBL_MAX; return false; } else { *ans = 2.0 * a * b / (a + b); return ans; } } 输出： Enter two numbers: 3 6 Harmonic mean of 3 and 6 is 4 Enter next set of numbers &lt;q to quit&gt;: 10 -10 One value should not be the negative of the other - try again. Enter next set of numbers &lt;q to quit&gt;: q Bye! 程序说明在程序15.8中，程序设计避免了错误输入导致的恶果，让用户能够继续输入。当然，设计确实依据用户检查函数的返回值，这项工作是程序员所不经常做的。例如，为使程序短小精悍，本书的程序都没有检查cout是否成功的处理了输出。 第三个参数可以是指针或引用。对于内置类型的参数，很多程序员都倾向于使用指针，因为这样可以明显看出哪个参数用于提供答案。 另一种在某个地方存储返回条件的方法是使用一个全局变量。可能问题的函数可以在出现问题时将该全局变量设置为特定值，而调用程序可以检查该变量。传统的C语言数学库就是用这种方法，它使用的全局变量名为errno。当然，必须确保其他函数没有将该全局变量用于其他目的。 15.3.3 异常机制下面介绍如何使用异常机制来处理错误。C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一个部分传递到另一个部分的途径。对异常的处理有3个组成部分： 引发异常； 使用处理程序捕获异常； 使用try块。 程序在出现问题时将引发异常。例如，可以修改程序15.7中的hmean()，使之引发异常，而不是调用abort()函数。throw语句实际上就是跳转，即命令程序跳到另一条语句。throw关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。 程序使用异常处理程序来捕获异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起来的代码块，指出要采取的措施。catch关键字和异常类型用作标签，指出当异常引发时，程序应跳到这个位置执行。异常处理程序也被称为catch块。 try块表示其他特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块由酱紫指示的，关键字try的后面是一个由花括号括起来的代码块，表明需要注意这些代码引发的异常。 要了解这3个元素是如何协同工作的，最简单的方法是看一个简短的例子。如程序15.9。 程序15.9 error3.cpp #include &lt;iostream&gt; double hmean(double a, double b); int main() { double x, y, z; std::cout &lt;&lt; &quot;Enter two numbers: &quot;; while (std::cin &gt;&gt; x &gt;&gt; y) { try { z = hmean(x, y); } catch (const char * s) { std::cout &lt;&lt; s &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter a new pair of numbers: &quot;; continue; } std::cout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter next set of numbers &lt;q to quit&gt;:&quot;; } std::cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } double hmean(double a, double b) { if (a == -b) throw &quot;bad hmean() arguments: a = -b not allowed!&quot;; return 2.0 * a * b / (a + b); } 输出： Enter two numbers: 3 6 Harmonic mean of 3 and 6 is 4 Enter next set of numbers &lt;q to quit&gt;:10 -10 bad hmean() arguments: a = -b not allowed! Enter a new pair of numbers: Harmonic mean of 10 and -10 is 4 Enter next set of numbers &lt;q to quit&gt;:10 10 Harmonic mean of 10 and 10 is 10 Enter next set of numbers &lt;q to quit&gt;:5 5 Harmonic mean of 5 and 5 is 5 Enter next set of numbers &lt;q to quit&gt;:0 1 Harmonic mean of 0 and 1 is 0 Enter next set of numbers &lt;q to quit&gt;:0 0 bad hmean() arguments: a = -b not allowed! Enter a new pair of numbers: Harmonic mean of 0 and 0 is 0 Enter next set of numbers &lt;q to quit&gt;:q Bye! 程序说明在程序15.9中，try块与下面类似： try { z = hmean(x, y); } 如果其中的语句导致异常被引发，则后面的catch块将对异常进行处理。如果程序在try块的外面调用hmean()，将无法处理异常。 引发异常的代码与下面类似： if (a == -b) throw &quot;bad hmean() arguments : a = -b not allowed&quot;; 其中被引发的异常是字符串”bad hmean() arguments : a = -b not allowed”。异常类型可以是字符串或其他C++类型；通常为类类型，本章后面示例将说明这一点。 执行throw语句类似于执行返回语句，因为它也将终止函数的执行；但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数。在程序15.9中，该函数是调用函数。稍后将有一个沿函数调用序列后退多步的例子。另外，在这个例子，throw将程序控制权返回给main()。程序将在main()中寻找引发的异常类型匹配的异常处理程序（位于try块后面）。 处理程序（或catch块）与下面类似： catch (char * s) { std::cout &lt;&lt; s &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Enter a new pair of number: &quot;; continue; } catch块有点类似于函数定义，但并不是函数定义。关键字catch表明这是一个处理程序，而char$\ast$s则表明该处理程序与字符串异常匹配。s与函数参数定义极其类似，因为匹配的引发将被赋给s。另外，当异常与该处理程序匹配时，程序执行括号中的代码。 执行完try块中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行处理程序后面的第一条语句。因此处理值3和6时，程序15.9中程序执行报告结果的输出语句。 接下来看将10和-10传递给hmean()函数后发生的情况。if语句导致hmean()引发异常。这将终止hmean()的执行。程序向后搜索时发现hmean()函数是从main()中的try块中调用的，因此程序查找与异常类型匹配的catch块。程序唯一的一个catch块的参数为char$\ast$，因此它与引发的异常匹配。程序将字符串 “bad hmean() arguments: a = -b not allowed!” 赋给变量s，然后执行处理程序中的代码。处理程序首先打印s—-捕获的异常，然后打印要求用户输入新数据的指示，最后执行continue语句，命令程序跳过while循环的剩余部分，跳到起始位置。continue使程序跳到循环的其实处，这表明处理程序语句是循环的一部分，而catch行是执行程序流程的标签（参见图15.2）。 如果引发了异常，而没有try块或没有匹配的处理程序时，默认情况下，程序最终将调用abort()函数，但可以修改这种行为。 15.3.4 将对象用作异常类型通常，引发异常的函数将创建一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常。另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，catch块可以根据这些信息来决定采取什么样的措施。例如，下面是针对函数hmean()引发的异常而提供的一种设计： class bad_hmean { private: double v1; double v2; public: bad_hmean(int a = 0, int b = 0) : v1(a), v2(b) {} void mesg(); }; inline void bad_hmean::mesg() { std::cout &lt;&lt; &quot;hmean(&quot; &lt;&lt; v1 &lt;&lt; &quot;, &quot; &lt;&lt; v2 &lt;&lt; &quot;): &quot; &lt;&lt; &quot;invalid arguments: a = -b\n&quot;; } 可以将一个bad_hmean对象初始化为传递给函数hmean()的值，而方法mesg()可用于报告问题（包括传递给函数hmean()的值）。函数hmean()可以十三亿下面这样的代码： if (a == -b) throw bad_hmean(a,b); 上述代码调用构造函数bad_hmean()，以初始化对象，使其存储参数值。 程序15.10和15.11添加了另一个异常类bad_gmean以及另一个名为gmean()的函数，该函数引发bad_gmean异常。函数gmean()计算两个数的几何平均值，即成绩的平方根。这个函数要求两个参数都不能为负，如果参数为负，它将引发异常。程序15.10是一个头文件，其中包含就异常类的定义；而程序15.11是一个示例程序，它使用了该头文件。注意，try块后面跟着两个catch块： try { ... } catch (bad_hmean &amp; bg) { ... } catch (bad_gmean &amp; hg) { ... } 如果函数hmean()引发bad_heam异常，第一个catch块将捕获到该异常；如果gmean()引发bad_gmean异常，异常将逃过第一个catch块，被第二个catch块捕获。 程序15.10 exc_mean.h #include &lt;iostream&gt; class bad_hmean { private: double v1; double v2; public: bad_hmean(double a = 0, double b = 0) : v1(a), v2(b) {} void mesg(); }; inline void bad_hmean::mesg() { std::cout &lt;&lt; &quot;hmean(&quot; &lt;&lt; v1 &lt;&lt; &quot;, &quot; &lt;&lt; v2 &lt;&lt; &quot;): &quot; &lt;&lt; &quot;invalid arguments: a = -b \n&quot;; } class bad_gmean { public: double v1; double v2; bad_gmean(double a = 0, double b = 0) : v1(a), v2(b) {} const char * mesg(); }; inline const char * bad_gmean::mesg() { return &quot;gmean() arguments should be &gt;= 0&quot;; } 程序15.11 error.cpp #include &lt;iostream&gt; #include &lt;cmath&gt; #include &quot;exc_mean.h&quot; double hmean(double a, double b); double gmean(double a, double b); int main() { using std::cout; using std::cin; using std::endl; double x, y, z; cout &lt;&lt; &quot;Enter two number: &quot;; while (cin &gt;&gt; x &gt;&gt; y) { try { z = hmean(x, y); cout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl; cout &lt;&lt; &quot;Geometric mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; gmean(x, y) &lt;&lt; endl; cout &lt;&lt; &quot;Enter next set of numbers &lt;q to quit&gt;: &quot;; } catch (bad_hmean &amp; bg) { bg.mesg(); cout &lt;&lt; &quot;Try again.\n&quot;; continue; } catch (bad_gmean &amp; hg) { cout &lt;&lt; hg.mesg(); cout &lt;&lt; &quot;Values used: &quot; &lt;&lt; hg.v1 &lt;&lt; &quot;, &quot; &lt;&lt; hg.v2 &lt;&lt; endl; cout &lt;&lt; &quot;Sorry, you don&apos;t get to play any more.\n&quot;; break; } } cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } double hmean(double a, double b) { if ( a == -b) throw bad_hmean(a,b); return 2.0 * a * b / (a + b); } double gmean(double a, double b) { if (a &lt; 0 || b &lt; 0) throw bad_gmean(a, b); return std::sqrt(a * b); } 输出： Enter two number: 4 12 Harmonic mean of 4 and 12 is 6 Geometric mean of 4 and 12 is 6.9282 Enter next set of numbers &lt;q to quit&gt;: 5 -5 hmean(5, -5): invalid arguments: a = -b Try again. 5 -1 Harmonic mean of 5 and -1 is -2.5 gmean() arguments should be &gt;= 0Values used: 5, -1 Sorry, you don&apos;t get to play any more. Bye. 首先，bad_hmean异常处理程序使用了一条continue语句，而bad_gmean异常处理程序使用一条break语句。因此，如果用户给函数hmean()提供的参数不正确，将导致程序跳过循环中余下的代码，进入下一次循环；而用户给函数gmean()提供的参数不正确时将结束循环。这演示了程序如何确定引发的异常（根据异常类型）并据此采取响应的措施。 其次，异常类bad_gmean和bad_hmean使用的技术不同，具体来说，bad_gmean使用的是公有数据和一个公有方法，该方法返回一个C-风格字符串。 15.3.5 异常规范和C++11有时候，一种理念看似有前途，但实际上的使用效果并不好。一个这样的例子是异常规范（exception specification），这是C++98新增的一项功能，但C++11将其摒弃了。这意味着C++11仍然处于标准之中，但以后可能会从标准踢出，因此不建议使用它。 然而，忽视异常规范前，您至少应该知道它是什么样的，如下所示： double harm(double a) throw(bad_thing); double marm(double) throw(); 其中throw()部分就是异常规范，它可能出现在函数原型和函数定义中，可包含类型列表，也可不包含。异常规范的另一个作用是，让编译器添加执行运行阶段检查的代码，检查是否返回了异常规范。这很难检查。例如，marm()可能不会引发异常，但它可能调用一个函数是，而这个函数调用的另一个函数发生了异常。另外，您给函数编写代码时它不会引发异常，但库更新后它却会引发异常。总之，编程社区达成的一致意见是，最后不要使用这项功能。 然而，C++11确实指出一种特殊的异常规范：您可使用新增的关键字noexcept指出函数不会引发异常： double marm() noexcept(); 有关这种异常规范是否必要和有用存在一些争议，有些人任务最后不要使用它；而有些人认为引入这个新关键字很有必要，理由是知道函数不会引发以后有助于编译器优化代码，通过使用这个关键字，编写函数的程序员相当于给出了承诺。 还有运算符noexcept()，它判断其操作数释放会引发异常，详情参阅附录E。 15.3.6 栈解退假设try块没有直接调用引发异常的函数，而是调用了对引发异常的函数进行调用的函数，则程序流程将从引发异常的函数跳到包含try块和处理程序的函数。这涉及到栈解退，下面进行介绍。 首先，来看一看C++通常是如何处理函数调用和返回的。C++通常通过将信息放在栈（参见第9章）中来处理函数调用。具体来说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放在栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，依此类推。当函数结束时，程序流将跳到该函数被调用时存储的地址处，同时栈顶的元素被释放。因此，函数通常都是返回到调用它的函数，依次类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数将被调用。 现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块（参见图15.3）中的返回地址。随后，控制权将转到块为的异常处理程序，而不是函数调用后面的第一条语句。这个过程称为栈解退。引发机制的一个非常重要的特性是，和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数返回仅仅处理该函数放在栈中的对象，而throw语句则处理try块和throw之间整个函数调用序列放在栈中的对象。如果没有栈解退这种特性，则引发异常后，对于中间函数条用放在栈中的自动类对象，其析构函数将不会被调用。 程序15.12是一个栈解退的示例。其中，mian()调用了means()，而means()又调用了hmean()和gmean()。函数means()计算算术平均数、调用平均数和几何平均数。main()和means()都创建demo类的对象（demo是一个类，指出什么时候构造函数和析构函数被调用），以便您直到发生异常时这些对象将被如何处理。函数main()中的try块能够捕获bad_hmean和badgmean异常，而函数means()中的try只能捕获bad_mean异常。catch块的代码如下： catch (bad_hmean &amp; bg) { bg.mesg(); std::cout &lt;&lt; &quot;Caught in means()\n&quot;; throw; } 上述代码显示消息后，重新引发异常，这将向上把异常发送给main()。一般而言，重新引发的异常将由下一个捕获这种异常的try-catch块组合进行处理，如果没有找到这样的处理程序，默认情况下程序将异常终止。程序15.12使用的头文件和程序15.11使用的相同（即exc_mean.h）。 程序15.12 error5.cpp #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;string&gt; #include &quot;exc_mean.h&quot; class demo { private: std::string word; public: demo (const std::string &amp; str) { word = str; std::cout &lt;&lt; &quot;demo &quot; &lt;&lt; word &lt;&lt; &quot; creatd.\n&quot;; } ~demo() { std::cout &lt;&lt; &quot;demo &quot; &lt;&lt; word &lt;&lt; &quot; destroyed.\n&quot;; } void show() const { std::cout &lt;&lt; &quot;demo &quot; &lt;&lt; word &lt;&lt; &quot; lives!\n&quot;; } }; double hmean(double a, double b); double gmean(double a, double b); double means(double a, double b); int main() { using std::cout; using std::cin; using std::endl; double x, y, z; { demo d1(&quot;found in block in main()&quot;); cout &lt;&lt; &quot;Enter two numbers: &quot;; while (cin &gt;&gt; x &gt;&gt; y) { try{ z = means(x, y); cout &lt;&lt; &quot;The mean mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl; cout &lt;&lt; &quot;Enter next pair: &quot;; } catch (bad_hmean &amp; bg) { bg.mesg(); cout &lt;&lt; &quot;Try again.\n&quot;; continue; } catch (bad_gmean &amp; hg) { cout &lt;&lt; hg.mesg(); cout &lt;&lt; &quot;Values used: &quot; &lt;&lt; hg.v1 &lt;&lt; &quot;, &quot; &lt;&lt; hg.v2 &lt;&lt; endl; cout &lt;&lt; &quot;Sorry, you don&apos;t get to play any more.\n&quot;; break; } } } cout &lt;&lt; &quot;Bye!\n&quot;; cin.get(); cin.get(); return 0; } double hmean(double a, double b) { if ( a == -b) throw bad_hmean(a,b); return 2.0 * a * b / (a + b); } double gmean(double a, double b) { if (a &lt; 0 || b &lt; 0) throw bad_gmean(a, b); return std::sqrt(a * b); } double means(double a, double b) { double am, hm, gm; demo d2(&quot;found in means()&quot;); am = (a + b) / 2.0; try { hm = hmean(a, b); gm = gmean(a, b); } catch (bad_hmean &amp; bg) { bg.mesg(); std::cout &lt;&lt; &quot;Caught in means().\n&quot;; throw; } d2.show(); return (am + hm + gm) / 3.0; } 输出： demo found in block in main() creatd. Enter two numbers: 6 12 demo found in means() creatd. demo found in means() lives! demo found in means() destroyed. The mean mean of 6 and 12 is 8.49509 Enter next pair: 6 -6 demo found in means() creatd. hmean(6, -6): invalid arguments: a = -b Caught in means(). demo found in means() destroyed. hmean(6, -6): invalid arguments: a = -b Try again. 6 -8 demo found in means() creatd. demo found in means() destroyed. gmean() arguments should be &gt;= 0 Values used: 6, -8 Sorry, you don&apos;t get to play any more. demo found in block in main() destroyed. Bye! 程序说明来看看程序的运行过程。首先，正如demo类的构造函数指出的，在main()函数中创建了一个demo对象。接下来，调用了函数means()，它创建了另一个demo对象。函数means()，它创建了另一个demo对象。函数means()使用6和12来调用函数hmean()和gmean()，它们将结果返回给means()，后者计算一个结果并将其返回。返回结果前，means()调用d2.show()；返回结果后，函数means()执行完毕，因此自动调用为d2调用析构函数： demo found in means() lives! demo found in means() destroyed. 接下来的输入循环将值6和-6发送给函数means()，然后means()创建一个新的demo对象，并将值传递给heman()。函数hmean()引发bad_hmean异常，该异常被means()中的catch块捕获，下面的输出指出了这一点： demo found in means() creatd. hmean(6, -6): invalid arguments: a = -b 该catch块中的throw导致函数means()终止执行，并将异常传递给main()。语句d2.show()没有被执行表明means()函数被提前终止。但需要指出的是，还是为d2.调用了析构函数： demo found in means() destroyed. 这演示了异常极其重要的一点：程序进行栈解退以回到能够捕获异常的地方时，将释放栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。 与此同时，重新引发的异常被传递给main()，在该函数中，合适的catch块将捕获它并对其进行处理： hmean(6, -6): invalid arguments: a = -b Try again. 接下来开始了第三次输入循环：6和-8被发送给函数means()。同样，means()创建一个新的demo对象，然后将6和-8传递给hmean()，后者在处理它们时没有出现问题。然而，means()将6和-8传递给gmean()，后者引发了bad_gmean异常。由于means(0不能捕获bad_gmean异常，因此异常被传递给mai()，同时不再执行means()中的代码。同样，当程序进行栈解退时，被释放局部的动态变量，因此为d2调用了析构函数： demo found in block in main() destroyed. 最后，main()中的bad_gmean异常处理程序捕获了该异常，循环结束： gmean() arguments should be &gt;= 0 Values used: 6, -8 Sorry, you don&apos;t get to play any more. 然后程序正常终止：显示一些消息并自动为d1调用析构函数。如果catch块使用的是exit(EXIT_FAILURE)而不是break，则程序将立刻终止，用户将看不到下述消息： demo found in main() lives! Bye! 但仍能够看到如下消息： demo found in block in main() destroyed. 同样，异常机制将负责释放栈中的自动变量。 15.3.7 其他异常特性虽然throw-catch机制类似于函数参数和函数返回机制，但还是有些不同之处。其中一直是函数fun()中的返回语句将控制器返回到调用fun()的函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获响应异常的try-catch组合。例如，程序15.12中，当函数hmeans()引发异常时，控制权将传递给函数means()；然而，当gmeans()引发异常时，控制权将向上传递给main()。 另一个不同之处是，引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。例如，请看下面的代码： class problem {...}; ... void super() throw(problem) { ... if (oh_no) { problem oops; throw oops; } ... } try{ super(); } catch(problem &amp; p) { ... } p将指向oops的副本而不是oops本身。这是件好事，因为函数super()执行完毕，oops将不复存在，顺便来说一句，将引发异常和创建对象组合在一起看更简单： throw problem(); //构造并抛出默认problem对象 既然throw语句将生成副本，为何代码中使用引用呢？毕竟，将引用作为返回值的通常原因是避免创建副本以提供效率。答案是，引用还有另一个重要特征：基类引用可以执行派生类对象。假设有一组通常继承关联起来的异常，则在异常规范中只需引出一个基类，它将与任何派生对象匹配。 假设有一个异常类层次结构，并要分别处理不同的异常类型，则使用基类引用将能够捕获任何异常对象；而是用派生类对象只能捕获它所属类及从这个类派生而来的类的对象。引发的异常对象将被第一个与之匹配的catch块捕获。这意味着catch块的排列顺序应该与派生顺序相反： class bad_1 {}; class bad_2 : public bad_1 {}; class bad_3 : public bad_2 {}; ... void duper() { if (oh_no) throw bad_1(); if (rats) throw bad_2(); if (drat) throw bad_3(); } ... try{ duper(); } catch(bad_3 &amp;be) {...} catch(bad_2 &amp;be) {...} catch(bad_1 &amp;be) {...} 如果将bad_1 &amp;处理放在最前面，它将捕获异常bad_1、bad_2和bad_3；通过相反的顺序排列，bad_3异常将被bad_3 &amp;处理程序所捕获。 提示：如果有一个异常类型继承层次结构，应这样排列catch块：将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。 通过正常地排列catch块的顺序，让您能够在如何处理异常方面有选择的余地。然而，有时候可能不知道会发生哪些异常。例如，假设您编写了一个调用另一个函数的函数，而您并不知道被调用的函数可能引发哪些异常。在这种情况下，仍能捕获异常，即使不知异常的类型。方法是使用省略号来表示异常类型，从而捕获任何异常： catch (...) {} 如果知道一些可能引发的异常，可以将上述捕获所有异常的catch块放到最后面，这有点类似于switch语句中的default: try{ deuper(); } catch(bad_3 &amp;be) {...} catch(bad_2 &amp;be) {...} catch(bad_1 &amp;be) {...} catch(bad_hmean &amp; h) {...} catch (...) {...} 可以创建捕获对象而不是引用的处理程序。在catch语句中使用基类的对象时，将捕获所有的派生类对象，但派生特性将被剥去，因此将使用虚方法的基类版本。 15.3.8 exception类C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序设计中包含错误处理功能更容易，以免事后采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。总之，异常是这样一种特性：类似于类，可以改变您的编程方式。 较新的C++编译器将异常合并到语言中。例如，为支持该语句，exception头文件（以前为exception.h或except.h）定义了exception类，C++可以把它用作其他异常类的基类。代码三可以引发exception异常，也可以将exception类用作基类。有一个名为what()的虚拟成员函数，它返回一个字符串，该字符串的特征随实现而异。然而，由于这是一个虚方法，因此可以在从exception派生而来的类中重新定义它： #include &lt;exception&gt; class bad_hmean : pulbic std::exception { public: const char * what() { return &quot;bad arguments to hmean()&quot;; } ... }; class bad_gmean : public std::exception { public: const char * what() { return &quot;bad arguments to gmean()&quot;; } }; 如果不想以不同的方式处理这些派生而来的异常，可以在同一个基类处理程序中捕获它们： try{ ... } catch(std::exception &amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; } 否则，可以分别捕获它们。 C++库定义了很多基于exception的异常类型。 1. stdexcept异常类头文件stdexcept定义了其他几个异常类。首先，该文件定义了logic_error和runtime_error类，它们都是以公有方式从exception派生而来的： class logic_error : public exception { public: explicit logic_error(cosnt string &amp; what_arg); ... }; class domain_error : public logic_error { public: explicit domain_error(const string &amp; what_arg); }; 注意，这些类的构造函数接受一个string对象作为参数，该参数提供了方法what()以C-风格字符串返回的字符数据。 这两个新类被用作两个派生类系列的基类。异常类系列logic_error描述了典型的逻辑错误。总体而异，通过合理的编程可以避免这种错误，但实际上这些错误还是可能发生的。每个类的名称指出了它用于报告的错误类型： domain_error invalid_argument; length_error; out_ of_bounds。 每个类独有一个类似于logic_error的构造函数，让您能够提供一个方法what()返回的字符串。 数学函数有定义域（domain）和值域（range）。定义域由参数的可能取值组成，值域由函数可能的返回值组成。例如，正玄函数的定义域为负无穷到正无穷大，因为任何实数都有正玄值；但正玄函数的值域为-1到+1。另一方面，反正玄函数的定义域为-1到+1，值域为-$\pi$到+$\pi$。如果您编写一个函数，该函数将一个参数传递给函数std::asin()，则可以让该函数在参数不在定义域-1到+1之间引发domian_error异常。 异常invalid_ argument指出给函数传递了一个意外的值。例如，如果函数希望接受一个这样的字符串，其中每个字符要么是‘0’要么是‘1’，则当传递的字符串中包含其他字符时，该函数将引发invalid_argument异常。 异常length_erro用于指出没有足够的空间来执行所需的操作。例如，string类的append()方法在合并得到的字符串长度超过最大允许长度时，将引发length _ rror异常。 异常out_of_bounds通常用于指示索引错误。例如，您可以定义一个类似于数组的类，其operatro$()[]$在使用的索引无效时引发out_of_bounds异常。 接下来，runtime_error异常系列描述了可能在运行期间发生但难以预计和防范的错误。每个类的名称指出了它用于报告的错误类型： range_error; overflow_error; underflow_error。 每个类独有一个类似于runtime_error的构造函数，让您能够提供一个供方法what()返回的字符串。 下溢（underflow）错误在浮点数计算中。一般而言，存在浮点类型可以表示的最小非零值，计算结果比这个值还小时将导致下溢错误。整型和浮点型都可能发生下溢错误，当计算结果超过了某种类型能够表示的最大数量级时，将发生上溢错误。计算结果可能不在函数允许的范围之内，但没有发生上溢或下溢错误，在这种情况下，可以使用range_error异常。 一般而言，logic_error系列异常表明存在可以通过编程修复的问题，而runtime_error系列异常表明存在无法避免的问题。所有这些错误类有相同的常规特征，它们之间的主要区别在于：不同的类名让您能够分别处理每种异常。另一方面，继承关系让您能够一起处理它们。例如，下面的代码首先单独捕获out_of_bounds异常，然后统一捕获其他logic_error系列异常，最后统一捕获exception异常、runtime_error系列异常以及其他从exception派生而来的异常: try{ ... } catch (out_of_bounds &amp; oe) {...} catch (logic_error &amp; oe) {...} catch (exception &amp; oe) {...} 如果上述库类不能满足您的需求，应该从logic_error或runtime_error派生一个异常类，以确保您异常类可诡异同一个继承层次结构中。 2. bad_alloc异常和new对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。头文件包含bad_alloc类的声明，它是从exception类公有派生而来的。但在以前，当无法分配请求的内存量时，new返回一个空指针。 程序15.13演示了最新的方法。捕获到异常后，程序将显示继承的what()方法返回的消息，然后终止。 程序15.13 newexcp.cpp #include &lt;iostream&gt; #include &lt;new&gt; #include &lt;cstdlib&gt; using namespace std; struct Big { double stuff[20000]; }; int main() { Big * pb; try{ cout &lt;&lt; &quot;Trying to get a big block of memory:\n&quot;; pb = new Big[1000000]; cout &lt;&lt; &quot;Got past the new request:\n&quot;; } catch (bad_alloc &amp; ba) { cout &lt;&lt; &quot;Caught the exception!\n&quot;; cout &lt;&lt; ba.what() &lt;&lt; endl; exit(EXIT_FAILURE); } cout &lt;&lt; &quot;Memory successfully allocated.\n&quot;; pb[0].stuff[0] = 4; cout &lt;&lt; pb[0].stuff[0] &lt;&lt; endl; delete [] pb; return 0; } 输出： //new10000个Big结构时，正常运行 Trying to get a big block of memory: Got past the new request: Memory successfully allocated. 4 //new1000000个Big结构时，捕获到bad_alloc异常 Trying to get a big block of memory: Caught the exception! std::bad_alloc 在这里，方法what()返回字符串“std::bad_alloc”。 3.空指针和new很多代码都是在new失败时返回空指针时编写的。为处理new的变化，有些编译器提供了一个标记（开关），让用户选择所需的行为。当前，C++标准提供了一种在失败时返回空指针的new，其用法如下： int * pi = new (std::nothrow) int; int * pa = new (std::nothrow) int[500]; 使用这种new，可将程序15.13的核心代码改为如下： Big * pb; pb = new (std::nothrow) Big[10000]; if (pb == 0) { cout &lt;&lt; &quot;Could not allcoated memory. Bye.\n&quot;; exit(EXIT_FAILURE); } 15.3.9 异常、类和继承异常、类和继承以三种方式相互关联。首先，可以先标准C++库所做的那样，从一个异常类派生出另一个；其次，可以在类定义中嵌套异常声明来组合异常；第三，这种嵌套声明本身可被继承，还可用作基类。 程序15.14头文件声明了一个Sales类，它用于存储一个年份以及一个包含12个月的销售数据的数组。LabeledSales类是从Sales派生而来的，新增了一个用于存储数据标签的成员。 程序15.14 sales.h #ifndef SALES_H_ #define SALES_H_ #include &lt;stdexcept&gt; #include &lt;string&gt; class Sales { public: enum {MONTHS = 12}; class bad_index : public std::logic_error { private: int bi; public: explicit bad_index(int ix, const std::string &amp; s = &quot;Index error in Sales object\n&quot;); int bi_val() const { return bi; } virtual ~bad_index() throw() {} }; explicit Sales(int yy = 0); Sales(int yy, const double * gr, int n); virtual ~Sales() {} int Year() const { return year; } virtual double operator[](int i) const; virtual double &amp; operator[](int i); private: double gross[MONTHS]; int year; }; class LabeledSales : public Sales { public: class nbad_index : public Sales::bad_index { private: std::string lb1; public: nbad_index(const std::string &amp; lb, int ix, const std::string &amp; s = &quot;Index error in LabeledSales object\n&quot;); const std::string &amp; label_val() { return lb1; } virtual ~nbad_index() throw() {} }; explicit LabeledSales(const std::string &amp; lb = &quot;none&quot;, int yy = 0); LabeledSales(const std::string &amp; lb, int yy, const double * gr, int n); virtual ~LabeledSales() {} const std::string &amp; Label() const { return label; } virtual double operator[](int i) const; virtual double &amp; operator[](int i); private: std::string label; }; #endif 来看一下程序15.14的几个细节。首先，符号常量MONTHS位于Sales类的公有部分，这使得派生类（如LabeledSales）能够使用这个值。 接下来，bad_index被嵌套在Sales类的公有部分中，这使得客户类的catch块可以使用这个类作为类型。注意，在外部使用这个类型时，需要摔死Sales::bad _index来标识。这个类从logic _ error类派生而来的，能够存储和报告数组索引的超界值。 nbad _ index类被嵌套到LabeledSales的公有部分，这使得客户类快车通过LabeledSales::nbad_ index来使用它。它是从bad_index类派生而来的，新增了存储和报告LabeledSales对象的标签的功能。由于bad _index是从logic _error派生而来，因此nabd _index归根到底也是从logic _error派生而来的。 这两个类都有重载的operator[]$()$方法，这些方法设计用于访问访问存储在对象中的数组元素，并在索引超界时引发异常。 bad_index和nbad_index类都使用了异常规范throw(),这是因为它们归根结底是从基类exception派生而来的，而exceptoin得虚构造函数使用了异常规范throw()。这是c++98的一项功能，在C++11中，exception的构造函数没有使用异常规范。 异常规范：函数声明之后，列出该函数可能抛出异常类型，并保证该函数不会抛出其他类型的异常。 程序15.15时是程序中没有声明为内联的方法的实现。 程序15.15 sales.cpp #include &quot;sales.h&quot; using std::string; Sales::bad_index::bad_index(int ix, const string &amp; s) : std::logic_error(s), bi(ix) {} Sales::Sales(int yy) { year = yy; for (int i = 0; i &lt; MONTHS; ++i) gross[i] = 0; } Sales::Sales(int yy, const double * gr, int n) { year = yy; int lim = (n &lt; MONTHS) ? n : MONTHS; int i; for (i = 0; i &lt; lim; ++i) gross[i] = gr[i]; for (; i &lt; MONTHS; ++i) gross[i] = 0; } double Sales::operator[](int i) const { if (i &lt; 0 || i &gt;= MONTHS) throw bad_index(i); return gross[i]; } double &amp; Sales::operator[](int i) { if (i &lt; 0 || i &gt;= MONTHS) throw bad_index(i); return gross[i]; } LabeledSales::nbad_index::nbad_index(const string &amp; lb, int ix, const string &amp; s) : Sales::bad_index(ix, s) { lb1 = lb; } LabeledSales::LabeledSales(const string &amp; lb, int yy, const double * gr, int n) : Sales(yy, gr, n) { label = lb; } double LabeledSales::operator[](int i) const { if (i &lt; 0 || i &gt;= MONTHS) throw nbad_index(Label(), i); return Sales::operator[](i); } double &amp; LabeledSales::operator[](int i) { if (i &lt; 0 || i &gt;= MONTHS) throw nbad_index(Label(), i); return Sales::operator[](i); } 程序15.16在一个程序中使用了这些类：首先试图超越LabeledSales对象sales2中数组的末尾，然后试图超越Sales对象sales中数组的末尾。这些尝试是在两个try块中进行的，让您能够检测每种异常。 程序15.16 use_sales.cpp #include &lt;iostream&gt; #include &quot;sales.h&quot; int main() { using namespace std; double vals1[12] = { 1220, 1100, 1122, 2212, 1232, 2334, 2884, 2393, 3302, 2922, 3002, 3544 }; double vals2[12] = { 12, 11, 22, 21, 32, 34, 28, 29, 33, 29, 32, 35 }; Sales sales1(2011, vals1, 12); LabeledSales sales2(&quot;Blogstar&quot;, 2012, vals2, 12); cout &lt;&lt; &quot;First try block:\n&quot;; try { int i; cout &lt;&lt; &quot;Year = &quot; &lt;&lt; sales1.Year() &lt;&lt; endl; for (i = 0; i &lt; 12; i++) { cout &lt;&lt; sales1[i] &lt;&lt; &apos; &apos;; if (i % 6 == 5) cout &lt;&lt; endl; } cout &lt;&lt; &quot;Year = &quot; &lt;&lt; sales2.Year() &lt;&lt; endl; cout &lt;&lt; &quot;Label = &quot; &lt;&lt; sales2.Year() &lt;&lt; endl; for (i = 0; i &lt;= 12; i++) { cout &lt;&lt; sales2[i] &lt;&lt; &apos; &apos;; if (i % 6 == 5) cout &lt;&lt; endl; } cout &lt;&lt; &quot;End of try block 1.\n&quot;; } catch (LabeledSales::nbad_index &amp; bad) { cout &lt;&lt; bad.what(); cout &lt;&lt; &quot;Company: &quot; &lt;&lt; bad.label_val() &lt;&lt; endl; cout &lt;&lt; &quot;bad index: &quot; &lt;&lt; bad.bi_val() &lt;&lt; endl; } catch (LabeledSales::bad_index &amp; bad) { cout &lt;&lt; bad.what(); cout &lt;&lt; &quot;bad index: &quot; &lt;&lt; bad.bi_val() &lt;&lt; endl; } cout &lt;&lt; &quot;\n Next try blck:\n&quot;; try{ sales2[2] = 37.5; sales1[20] = 23345; cout &lt;&lt; &quot;End of try block 2.\n&quot;; } catch (LabeledSales::nbad_index &amp; bad) { cout &lt;&lt; bad.what(); cout &lt;&lt; &quot;Company: &quot; &lt;&lt; bad.label_val() &lt;&lt; endl; cout &lt;&lt; &quot;bad index: &quot; &lt;&lt; bad.bi_val() &lt;&lt; endl; } catch (Sales::bad_index &amp; bad) { cout &lt;&lt; bad.what(); cout &lt;&lt; &quot;bad index: &quot; &lt;&lt; bad.bi_val() &lt;&lt; endl; } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： First try block: Year = 2011 1220 1100 1122 2212 1232 2334 2884 2393 3302 2922 3002 3544 Year = 2012 Label = 2012 12 11 22 21 32 34 28 29 33 29 32 35 Index error in LabeledSales object Company: Blogstar bad index: 12 Next try blck: Index error in Sales object bad index: 20 Done. 15.3.10 异常何时会迷失方向异常被引发后，在两种情况下，会导致问题。首先，如果它是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配（在继承层次结构中，类类型与这个类及其派生类的对象匹配），否则称为意外异常。在默认情况下,这将导致程序异常终止（虽然C++11摒弃了异常规范，当仍支持它，且有些现有的代码使用了它）。如果异常不在函数中引发的（或者函数没有异常规范），则必须捕获他。如果没被捕获（在没有try块或没有匹配的catch块时，将出现这种情况），则异常被称为未捕获异常。在默认情况下，这将导致程序异常终止。然而，可以修改程序对意外异常和未捕获异常的反应。下面来看如何修改，先从未捕获异常开始。 未捕获异常不会导致程序立刻异常终止。相反，程序将首先调用函数terminate()。在默认情况下，terminate()调用abort()函数。可以指定terminate()应调用的函数（而不是abort()）来修改terminate()的这种行为。为此，可调用set_terminate()函数。set_terminate()和terminate()都是在头文件exception中声明的： typedef void (*terminate_handler)(); terminate_handler set_terminate(terminate_handler f) throw(); //C++98 terminate_handler set_terminate(terminate_handler f) noexcept() //C++11 void terminate() //C++98 void termiante() noexcept //C++11 其中的typedef使terminate_ handler成为这样一种类型的名称：指向没有参数和返回值得函数得指针。set_ termiante()函数将不带任何参数且返回类型为void得函数得名称（地址）作为参数，并返回该函数得地址。如果调用了set_ terminate()函数多次，则terminate()将调用最后依次set _teminate()调用设置的函数。 来看一个例子。假设希望未捕获的异常导致程序打印一条消息，然后调用exit()函数，将退出状态值设置为5。首先，请包含头文件exception。可以使用using编译指令、适当的using声明或std::限定符，来使其声明可用。 #include &lt;exception&gt; using namespace std; 然后，设计一个完成上述两种操作所需的函数，其原型如下： void myQuie() { cout &lt;&lt; &quot;Terminating due to uncaught exception\n&quot;; exit(5); } 最后，在程序的开头，将终止操作指定为调用该函数。 set_terminate(myQuit); 现在，如果引发了一个异常且没有被捕获，程序将调用terminate()，而后者将调用myQuit()。 接下来看意外异常。通常给函数指定异常规范，可以让函数的用户知道要捕获哪些异常。假设函数原型如下： double Argh(double, double) throw(out_of_bounds); 则可以这样使用该函数： try{ x = Argh(a, b) } catch (out_of_bounds &amp; ex) { ... } 知道应捕获哪些异常很有帮助，因为默认情况下，未捕获的异常将导致程序异常终止。 原则上，异常规范应包含函数调用的其他函数引发的异常。例如，如果Argh()调用了Duh()函数，而后者可能引发retort对象异常，则Argh()和Duh()的异常规范中都应包含retort。除非自己编写所有的函数，并且特别仔细，否则无法保证上述工作都已正确完成。例如，可能使用的是老式商业库，而其中的函数没有异常规范。这表明应进一步探讨这样一点，即如果函数引发了其异常规范中没有的异常，情况将如何？这也表明异常规范机制处理起来比较麻烦，这也是C++11将其摒弃的原因之一。 在这种情况下，行为与未捕获的异常极其相似。如果发生意外异常，程序将调用unexpected()函数。这个函数将调用terminate()，后者在默认情况下将调用abort()。正如有一个可用于修改terminate()的行为的set_terminate()函数一样，也有一个可用于修改unexpected()的行为的set_unexpected()函数。这些新函数也是在头文件exception中声明的： typedef void (*unexpected_handler)(); unexpected_handler set_unexpected(unexpected_handler f) throw(); //C++98 unexpected_handler set_unexpected(unexpected_handler f) noexcept; //C++11 void unexpected(); //C++98 void unexpected() noexcept; //c++11 然而，与提供set_ terminate()的函数的行为相比，提供给set _unexpected()的函数的行为受到严格的限制。具体来说，unexpected _handler函数可以： 通过调用terminate()（默认行为）、abort()或exit()来终止程序； 引发异常。 引发异常的结果取决于unexpected_handler函数所引发的异常以及引发意外异常的函数的异常规范: 如果新引发的异常与原来的异常规范匹配，则程序将从那里开始进行正常处理，即寻找与新引发的异常匹配的catch块。基本上，这种方法将用预期的异常取代意外异常； 如果新引发的异常与原来的异常规范不匹配，且异常规范中没有包括std::bad_exception类型，则程序将调用terminate()。bad_exception是从exception派生而来的，其声明位于头文件exception中； 如果新引发的异常与原来的异常规范不匹配，且原来的异常规范中包含了std::bad_exception类型，则不匹配的异常将被std::bad_exception异常所取代。 总之，如果要捕获所有的异常，则可以这样做: 首先确保异常头文件的声明可用： #include &lt;exception&gt; using namespace std; 然后，设计一个替代函数，将意外异常转换为bad_exception异常，该函数的原型如下： voi myUnexpected() { throw std::bad_exception(); } 仅使用throw，而不指定异常将导致重新引发原来的异常。然而，如果异常规范中包含了这种类型，则该异常将被bad_exception对象所取代。 接下来在程序的开始位置，将意外异常操作指定为调用该函数： set_unexpected(myUnexpected); 最后，将bad_exception类型包括在异常规范中，并添加如下catch块序列： double Argh(double, double) throw(out_of_bounds, bad_exception); ... try{ x = Argh(a, b); } catch(out_of_bounds &amp; ex) {} catch(bad_exception &amp; ex) {} 15.3.11 有关异常的注意事项从前面关于如何使用异常的讨论可知，应在设计程序时就加入异常处理功能，而不是以后再添加。这样做有些缺点。例如，使用异常会增加程序代码，降低程序的运行速度。异常规范不适用于模板，因此模板函数引发的异常可能随特定的具体化而异。异常和动态内存分配并非总是协同工作。 下面进一步讨论动态内存分配和异常。首先，请看下面的函数： void test1(int n) { string mesg(&quot;I&apos;m trapped in an endless loop&quot;); ... if (oh_no) throw exception(); ... return ; } string类采用动态内存分配。通常，当函数结束时，将为mesg调用string的析构函数。虽然throw过早地终止了函数，但它仍然使得析构函数被调用，这要归功于栈解退。因此在这里，内存被正确地管理。 接下来看下面这个函数： void test2(int n) { double * ar = new double[n]; ... if (oh_no) throw exception(); ... delete [] ar; return; } 这里有个问题。解退栈时，将删除栈中的变量ar。但函数过早的终止意味着函数末尾的delete[]语句被忽略。指针消失了，但它指向的内存块未被释放，并且不可访问。总之，这些内存被泄露了。 这种泄露是可以避免的。例如，可以再引发异常的函数中捕获该异常，在catch块中包含一些清理代码，然后重新引发异常： void text3(int n) { double * ar = new double[n]; ... try{ if (oh_no) throw exception(); } catch (exception &amp; ex) { delete [] ar; throw; } delete [] ar; return; } 然而，这将增加忽略和产生其他错误的机会。另一种解决办法是使用第16章将讨论的智能指针模板之一。 总之，虽然异常处理对于某些项目极为重要，但它们也会增加编程的工作量、增大程序、降低程序的速度。另一方面，不进行错误检查的代价可能非常高。 异常处理 在现代库中，异常处理的复杂程度可能再创新高—–主要原因在于文档没有对异常处理例程进行解释或解释得很蹩脚。任何熟练使用现代操作系统的仍都遇到过未处理的异常导致的错误或问题。这些错误背后的程序员通常面临一场艰难的战役，需要不断了解库的复杂性：什么异常将被引发，它们发生的原因和时间，如何处理它们，等等。 程序员新手很快发现，理解库中异常处理像学习语言本身一样困难，现代库中包含的例程和模式可能像C++语法细节一样陌生而困难。要开发出有些的软件，必须花时间了解库和类中的复杂内容，就像必须话时间学习C++本身异常。通过库文档或源代码了解到的异常和错误处理细节将使程序员和他的软件受益。 15.4 RTTIRTTI是运行阶段类型识别（Runtime Type Identification）的简称。这是新添加到C++中的特性之一，很多老式实现不支持。另一些实现可能包含开关RTTI的编译器设置。RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。很多类库已经为其类对象出疼死了实现这种功能的方式，但由于C++内部并不支持，因此各个厂商的机制通常互不兼容。创建一种RTTI语言标准使得未来的库能够彼此兼容。 15.4.1 RTTI的用途假设有一个类层次结构，其中的类都是从同一个基类派生而来的，则可以让基类指针指向其中任何一个类的对象。这样便可以调用这样的函数：在处理一些信息后，选择一个类，并创建这种类型的对象，然后返回它的地址，而该地址可以被赋给基类指针。如何知道指针指向的是哪种对象呢？ 在回答这个问题之前，先考虑为何要知道类型。可能希望调用类方法的正确版本，在这种情况下，只要该函数是类层次结构中所有成员都拥有的虚函数，则并不真正需要知道对象的类型。但派生对象可能包含不是继承而来的方法，在这种情况下，只有某些类型的对象可以使用该方法。也可能是处于调试目的，像跟踪生成的对象的类型。对于后两种情况，RTTI提供解决方法。 15.4.2 RTTI的工作原理C++有3个支持RTTI的元素。 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回0—-空指针。 typeid运算符返回一个指出对象的类型的值。 teyp_info结构存储了有关特性类型的信息。 只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生类对象的地址赋给基类指针。 警告：RTTI只适合用于包含虚函数的类。 下面详细较少RTTI的这3个元素。 1. dynamic_cast运算符dynamic_cast运算符是最常用的RTTI组件，它不能回答“指针指向的是哪类对象”这样的问题，但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。我们来看一看这意味着什么。 假设有下面这样的层次结构： class Grand {//有虚函数}; class Superb : public Grand { ... }; class Magnificent : public Superb { ... }; 接下来假设有下面的指针： Grand * pg = new Grand; Grand * ps = new Superb; Grand * pm = mew Magnificent; 最后，对于下面的类型转换： Magnificent * p1 = (Magnificent *) pm; //#1 Magnificent * p2 = (Magnificent *) pg; //#2 Superb * p3 = (Magnificent *) pm; //#3 哪些是安全的？根据类声明，它们可能都是安全的，但只有那些指针类型与对象的类型（或对象的直接或间接基类的类型）相同的类型转换才一定是安全的。例如，类型转换#1是安全的，因为它将Magnificent类型的指针指向类型为Magnificent的对象。类型转换#2是不安全的，因为它将基类对象（Grand）的地址赋给派生类（Magnificent）指针。因此，程序将期望基类对象有派生类的特征，而通常这是不可能的。例如，Magnificent对象可能包含一些Grand对象没有的数据成员。然而，类型转换#3是安全的，因此它将派生类对象的地址赋给基类指针。即公有派生类确保Magnificent对象同时也是一个Superb对象（直接基类）和一个Grand对象（间接基类）。因此，将它的地址赋给这3种类型的指针都是安全的。虚函数确保了将这3种指针中的任何一种指向Magnificent对象时，都将调用Magnificent方法。 注意，与问题“指针指向的是哪种类型的对象”相比，问题“类型转换是否安全”更通用，也更有用。通常，想知道类型的原因在于：知道类型后，就可以知道调用特定的方法是否安全。要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。下面的例子说明了这一点。 然而，先来看一下dynamic_cast的语法。该运算符的用法如下，其中pg指向一个对象： Superb * pm = dynamic_cast&lt;Superb *&gt;(pg); 这提出了这样的问题：指针pg的类型是否可被安全地转换为Superb $\ast$？如果可以，运算符将返回对象的地址，否则返回一个空指针。 注意：通常，如果指向的对象（$\ast$pt）的类型为Type或者从Type直接或间接派生而来的，则下面的表达式将指针pt转换为Type类型的指针： dynamic_cast&lt;Type *&gt;(pt) 否则，结果为0，即空指针。 程序15.17演示了这种处理。首先，它定义了3个类，名称为Grand、Superb和Magnificent。Grand类定义了一个虚函数Speak()，而其他类都重新定义了该虚函数。Superb类定义了一个虚函数Say()，而Magnificent也重新定义了它（参见图15.4）。程序定义了GetOne()函数，该函数随机创建这3种类种某种类的对象，并对其进行初始化，然后将地址作为Grand$\ast$指针返回。循环将该指针赋给Grand$\ast$变量pg，然后使用pg调用Speak()函数。因为这个函数是虚的，所以代码能够正确地调用指向的对象的Speak()版本： for (int i = 0; i &lt; 5; i++) { pg = GetOne(); pg-&gt;Speak(); ... } 然而，不能用相同的方式（即使用指向Grand的指针）来调用Say()函数，因为Grand类没有定义它。然而，可以使用dynamic_cast运算符来检查是否可以将pg的类型安全地转换为Superb指针。如果对象的类型为Superb或Magnificent，则可以安全转换。在这两种情况下，都可以安全地调用Say()函数： if (ps = dynamic_cast&lt;Superb *&gt;(pg)) ps-&gt;Say(); 赋值表达式的值是它左边的值，因此if条件的值为ps。如果类型转换成功，则ps的值为非零；如果类型转换失败，即pg指向的是一个Grand对象，ps的值将为0。程序15.17列出了所有的代码。顺便说一句，有些编译器可能会对无目的的赋值提出警告。 程序15.17 rtti1.cpp #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using std::cout; class Grand { private: int hold; public: Grand(int h = 0) : hold(h) {} virtual void Speak() const { cout &lt;&lt; &quot;I am a grand class!\n&quot;; } virtual int Value() const { return hold; } }; class Superb : public Grand { public: Superb(int h = 0) : Grand(h) {} void Speak() const { cout &lt;&lt; &quot;I am a superb class!\n&quot;; } virtual void Say() const { cout &lt;&lt; &quot;I hold the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!\n&quot;;} }; class Magnificent : public Superb { private: char ch; public: Magnificent(int h = 0, char c = &apos;A&apos;) : Superb(h) { ch = c; } void Speak() const { cout &lt;&lt; &quot;I am a magnificent class!\n&quot;; } void Say() const { cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot; and the integer &quot; &lt;&lt; Value() &lt;&lt; &quot;!\n&quot;; } }; Grand * GetOne(); int main() { std::srand(std::time(0)); Grand * pg; Superb * ps; for (int i = 0; i &lt; 5; i++) { pg = GetOne(); pg-&gt;Speak(); if (ps = dynamic_cast&lt;Superb *&gt; (pg)) ps-&gt;Say(); } return 0; } Grand * GetOne() { Grand * p; switch(std::rand() % 3) { case 0: p = new Grand(std::rand() % 100); break; case 1: p = new Superb(std::rand() % 100); break; case 2: p = new Magnificent(std::rand() % 100, &apos;A&apos; + rand() % 26); break; } return p; } 输出： I am a superb class! I hold the superb value of 1! I am a grand class! I am a grand class! I am a superb class! I hold the superb value of 79! I am a magnificent class! I hold the character U and the integer 67! 注意：即使编译器支持RTTI，在默认情况下，它也可能关闭该特性。如果该特性被关闭，程序可能仍能够通过编译，但将出现运行阶段错误。在这种情况下，您应查看文档或菜单选项。 正如您看到的，只为Superb和Magnificent类调用了Say()方法（每次运行时输出都可能不同，因为该程序使用rand()来选择对象类型）。 也可以将dynameic_cast用于引用，其用法稍微有点不同：没有与空指针对应的引用值，因此无法使用特殊的引用值来指示失败。当请求不正确时，dynamic_cast将引发类型为bad_cast的异常，这种异常是从exception类派生而来的，它是在头文件typeinfo中定义的。因此，可以像下面这样使用该运算符，其中rg是对Grand对象的引用： #include &lt;typeinfo&gt; ... try{ Superb &amp; rs = dynamic_cast&lt;Superb &amp;&gt; (rg); ... } catch(bad_cast &amp;){ ... } 2.typeid运算符和type_info类typeid运算符使得能够确定两个对象是否为同类类型。它与sizeof()有些相像，可以接受两个参数： 类名 结果为对象的表达式 typid运算符返回一个对type_info对象的引用，其中type_info是在头文件typinfo中定义的一个类。type_info类重载了==和！=运算符，以便可以使用这些运算符来对类型进行比较。例如，如果pg指向一个Magnificent对象，则下述的表达式的结果为bool值true，否则为false: typeid(Magnificent) == typeid(*pg) 如果pg是一个空指针，程序将引发bad_typeid异常。该异常类型是从exception类派生而来的，是在头文件typeinfo中声明的。 type_info类的实现随厂商而异，但包含一个name()成员，该函数返回一个随实现而异的字符串：通常（但并非一定）是类的名称。例如，下面的语句显示指针pg指向的对象所属的类定义的字符串： cout &lt;&lt; &quot;Now processing type &quot; &lt;&lt; typeid(*pg).name() &lt;&lt; &quot;.\n&quot;; 程序15.18对程序15.17作了修改，以使用typeid运算符和name()成员函数。注意，它们都适用于dynamic_cast和virtual函数不能处理的情况。typeid测试用来选择一种操作，因此操作不是类的方法，所以不能通过类指针调用它。name()方法语句演示了如何将方法用于调试。 程序15.18 rtti2.cpp #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;typeinfo&gt; using std::cout; class Grand { private: int hold; public: Grand(int h = 0) : hold(h) {} virtual void Speak() const { cout &lt;&lt; &quot;I am a grand class!\n&quot;; } virtual int Value() const { return hold; } }; class Superb : public Grand { public: Superb(int h = 0) : Grand(h) {} void Speak() const { cout &lt;&lt; &quot;I am a superb class!\n&quot;; } virtual void Say() const { cout &lt;&lt; &quot;I hold the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!\n&quot;;} }; class Magnificent : public Superb { private: char ch; public: Magnificent(int h = 0, char c = &apos;A&apos;) : Superb(h) { ch = c; } void Speak() const { cout &lt;&lt; &quot;I am a magnificent class!\n&quot;; } void Say() const { cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot; and the integer &quot; &lt;&lt; Value() &lt;&lt; &quot;!\n&quot;; } }; Grand * GetOne(); int main() { std::srand(std::time(0)); Grand * pg; Superb * ps; for (int i = 0; i &lt; 5; i++) { pg = GetOne(); cout &lt;&lt; &quot;Now processing type &quot; &lt;&lt; typeid(*pg).name() &lt;&lt; &quot;.\n&quot;; pg-&gt;Speak(); if (ps = dynamic_cast&lt;Superb *&gt; (pg)) ps-&gt;Say(); if (typeid(Magnificent) == typeid(*pg)) cout &lt;&lt; &quot;Yes, you&apos;re really magnificent.\n&quot;; } return 0; } Grand * GetOne() { Grand * p; switch(std::rand() % 3) { case 0: p = new Grand(std::rand() % 100); break; case 1: p = new Superb(std::rand() % 100); break; case 2: p = new Magnificent(std::rand() % 100, &apos;A&apos; + rand() % 26); break; } return p; } 输出： Now processing type 11Magnificent. I am a magnificent class! I hold the character S and the integer 25! Yes, you&apos;re really magnificent. Now processing type 6Superb. I am a superb class! I hold the superb value of 62! Now processing type 6Superb. I am a superb class! I hold the superb value of 72! Now processing type 5Grand. I am a grand class! Now processing type 6Superb. I am a superb class! I hold the superb value of 89! 与前一个程序的输出一样，每次运行该程序的输出都可能不同，因为它使用rand()来选择类型。另外，调用name()时，有些编译器可能提供不同的输出，如Grand(而不是5Grand)。 3.误用RTTI的例子C++界有很多仍对RTTI口诛笔伐，他们认为RTTI是多余的，是导致程序效率低下和糟糕编程方法的罪魁祸首。这里不讨论对RTTI的争论，而介绍一下应避免的编程方法。 请看程序15.17的核心代码： Grand * pg; Superb * ps; for (int i = 0; i &lt; 5; i++) { pg = GetOne(); pg-&gt;Speak(); if (ps = dynamic_cast&lt;Superb *&gt; (pg)) ps-&gt;Say(); } 通过放弃dynamic_cast和虚函数，而是用typeid，可以将上述代码重新编写为： Grand * pg; Superb * ps; Magnificent * pm; for (int i = 0; i &lt; 5; i++) { pg = GetOne(); if (typeid(Magnificent) == typeid(pg)) { pm = (Magnificent*) pg; pm-&gt;Speak(); pm-&gt;Say(); } else if (typeid(Superb) == typeid(*pg)) { ps = (Superb *) pg; ps-&gt;Speak(); ps-&gt;Say(); } else pg-&gt;Speak(); } 上述代码不仅比原来的更难看、更长，而且显式地指出各个类存在严重的缺陷。例如，假设您发现必须从Magnificent类派生一个Insufferable类，而后者需要重新定义Speak()和Say()。使用typeid来显式地测试每个类型时，必须修改for循环的代码，添加一个else if，但无需修改原来的版本。下面的语句适用于所有从Grand派生而来的类： pg-&gt;Speak(); 而下面的语句适用于所有从Superb派生而来的类： if (ps = dynamic_cast&lt;Superb *&gt; (pg)) ps-&gt;Say(); 提示：如果发现在扩展的if else语句系列中使用了typeid，则应考虑是否应该使用虚函数和dynamic_cast。 15.5 类型转换运算符在C++的创始人Bjarne Stroustrup看来，C语言的类型转换运算符太过松散。例如，请看下面的代码： struct Data { double data[200]; }; struct Junk { int junk[100]; }; Data d = {2.5e33, 3.5e-19, 20.2e32}; char * pch = (char *) (&amp;d); //#1 将一个Data指针转换为char指针 char ch = char (&amp;d); //#2 将地址转换为一个字符 Junk * pj = (Junk *) (&amp;d); //#3 将Data指针转换为Junk指针 首先，上述3种类型转换种，哪一种有意义？除非不讲理，否则它们种没有一个是有意义的。其次，这3种类型转换种哪种是允许的呢？在C语言中都是允许的。 对于这种松散情况，Stroustrop采取的措施是，更严格地限制允许的类型转换，并添加4个类型转换运算符，使转换过程更规范： dynamic_cast const_cast static_cast reinterpret_cast 可以根据目的选择一个适合的用品认识，而不是使用通用的类型转换。这指出了进行类型转换的原因，并让编译器能够检查程序的行为是否与设计者想法吻合。 dynamic_cast运算符已经在前面介绍过了。总之，假设High和Low是两个类，而ph和ph的类型分别为High$\ast$和Low$\ast$，而仅当Low是High的可访问积累（直接或间接）时，下面语句才将一个Low$\ast$指针赋给pl: pl = dynamic_cast&lt;Low *&gt; ph; 否则，该语句将空指针赋给pl。通常，该运算符的语法如下： dynamic_cast&lt;type-name&gt; (expression) 该运算符的用途是，使得能够在类层次结构中进行向上转换（由于is-a关系，这样的类型转换是安全的），而不允许其他转换。 const_ cast运算符用于执行只有一种用途的类型转换，即改变值为const或volatile，其语法与dynamic_cast运算符相同： const_cast &lt;type-name&gt; (expression) 如果类型的其他方面也被修改，则上述类型转换将出错。也就是说，除了const或volatile特征（有或无）可以不同外，type_name和expression的类型必须相同。再次假设High和Low是两个类： High bar; const High * pbar = &amp;bar; ... High * pb = const_cast&lt;High *&gt; (pbar); //正确 const Low * pl = const_cast&lt;const Low *&gt; (pbar); //错误 第一个类型转换使得$\ast$pb成为一个可用于修改bar对象值的指针，它删除const标签。第二个类型转换是非法的，因为它同时尝试将类型从const High $\ast$改为const Low $\ast$。 提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可以修改的。在这种情况下，可以将这个值声明为const，并在需要修改它得时候，使用const_cast。这也可以通过通用类型转换来实现，但通用转换也可能同时改变类型： High bar; const High * pbr = &amp;bar; ... High * pb = (High *) (pbar); //有效 Low * pl = (Low *） （pbar); //有效 由于编程时可能无意间同时改变类型和常量特征，因此使用const_cast运算符更安全。 const_cast不是万能得。它可以修改指向一个值得指针，但修改const值的结构不确定的。程序1.19的简单示例阐明了这一点： 程序15.19 constcast.cpp #include &lt;iostream&gt; using std::cout; using std::endl; void change(const int * pt, int n); int main() { int pop1 = 38383; const int pop2 = 2000; cout &lt;&lt; &quot;pop1, pop2: &quot; &lt;&lt; pop1 &lt;&lt; &quot;, &quot; &lt;&lt; pop2 &lt;&lt; endl; change(&amp;pop1, -103); change(&amp;pop2, -103); cout &lt;&lt; &quot;pop1, pop2: &quot; &lt;&lt; pop1 &lt;&lt; &quot;, &quot; &lt;&lt; pop2 &lt;&lt; endl; return 0; } void change(const int * pt, int n) { int * pc; pc = const_cast&lt;int *&gt; (pt); *pc += n; } 输出： pop1, pop2: 38383, 2000 pop1, pop2: 38280, 2000 const_cast运算符可以删除const int $\ast$ pt中的const，使得编译器能够接受change()中的语句： *pc += n; 正如您看到的，调用change()时，修改了pop1，但没有修改pop2。在change()中，指针被声明为const int $\ast$，因此不能用来修改指向的int。指针pc删除了const特征，因此可以用来修改指向的值，但仅当指向的值不是const才行。因此，pc可用于修改pop1，但不能用于修改pop2。 static_cast运算符的语法与其他类型转换运算符相同： static_cast &lt;type-name&gt; (expression) 仅当type_ name可被隐式转换为expression所属的类型或expression可被隐式地转换为type_name所属的类型时，上述转换才是合法的，否则将出错。假设High是Low的基类，而Pond是一个无关的类，则从High到Low的转换、从Low到High的转换都是合法的，而从Low到Pond的转换是不允许的： High bar; Low blow; ... High * pb = static_cast&lt;High *&gt; (&amp;blow); //有效的向上转换 Low * pl = static_cast&lt;Low *&gt; (&amp;bar); //有效的向下转换 Pond * pmer = static_cast&lt;Pond *&gt; &lt;&amp;blow&gt;; //无效 第一种转换是合法的，因为向上转换可以显式地进行。第二种转换是从基类指针到派生类指针，在不进行显式类型转换的情况下，将无法进行。但由于无需进行类型转换，便可以进行另一个方向的类型转换，因此使用static_cast来进行向下转换是合法的。 同理，由于无需进行类型转换，枚举值就可以被转换为整型，所以可以用static_cast将整型转换为枚举值。同样，可以使用stati _cast来将doubel转换为int、将float转换为long以及其他各种数值转换。 reinterpret_ cast运算符用于天生危险的类型转换。它不允许删除const，但会执行其他令人生厌的操作。有时程序员必须做一些依赖于实现的、令人生厌的操作，使用reinterpret_const运算符可以简化对这种行为的跟踪工作。该运算符的语法与另外3个相同： reinterpret_cast &lt; type_name &gt; (expression) 下面是一个示例： struct dat {short a; short b;}; long value = 0xA224B118; dat * pd = reinterpret_cast &lt;dat *&gt; (&amp;value); cout &lt;&lt; hex &lt;&lt; pd-&gt;a; //显式前两个字节的值 通常，这样的转换适用于依赖于实现的底层编程技术，是不可移植的。例如，不同系统在存储多字节整型时，可能以不同的顺序存储其中的字节。 然而，reinterprete_cast运算符并不支持所有的类型转换。例如，可以将指针类型转换为足以存储指针表示的整型，但不能将指针变换为更小的整数或浮点数。另一个限制是，不能将函数指针转换为数据指针，反之亦然。 在C++中，普通类型转换也受到限制。基本上，可以执行其他类型转换可执行的操作，加上一些组合，如static_cast或reinterpret _cast后跟const _cast，但不能执行其他转换。因此，下面的类型转换在C语言中是允许的，但在C++中通常不允许，因为对于大多数C++实现，char类型都太小，不能存储指针： char ch = char (&amp;d); 这些限制是合理的。 15.6 总结友元类 友元成员函数 其他友元关系 共同友元 嵌套类和访问权限 模板中的嵌套 异常 RTTI 类型转换]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--string类和标准模板库（十六）]]></title>
    <url>%2F2019%2F02%2F24%2FC%2B%2B%20Primer%20Plus--string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前面学习了C++的代码重用，这样做一个很大的回报是可以重用别人编写的代码，这正是类库的用武之地。有很多商业C++类库，也有一些库是C++程序包自带的。本章介绍一些其他可重用代码，它们将给编程工作带来快乐！本章将更深入讨论string类；然后介绍“智能指针”模板类，它们让管理动态内存更容易；接下来介绍标准模板库（STL）,它是一组用于处理各种容器对象的模板。 16.1 string类很多应用程序都需要处理字符串。C语言在string.h（在C++中为cstring）中提供了一系列的字符串函数，很多早期的C++实现为处理字符串提供了自己的类。第4章介绍了ANSI/ISO C++ string类，而第12章创建了一个不大的String类，说明设计表示字符串的类的某些方面。 string类由头文件string支持的（注意，头文件string.h和cstring支持对C-风格字符串进行操纵的C库字符串函数，但不支持string）。要使用类，关键字在于知道它的公有接口，而string类包含大量的方法，其他包含了若干构造函数，用于将字符串赋给变量、合并字符串、比较字符串和访问各个元素的重载运算符以及用于在字符串中查找字符和子字符串的工具等。 16.1.1 构造字符串先来看string的构造函数。毕竟，对于类而言，最重要的内容之一是，有哪些方法可用于创建其对象。程序16.1使用了string的7个构造函数（用ctor标识，这是传统C++中构造函数的缩写）。表16.1简要地描述了这些构造函数，它首先使用顺序简要描述了程序16.1使用的7个构造函数，然后列出了C++11新增的两个构造函数。使用构造函数时都进行了简化，即隐藏了这样一个事实：string实际上是模板具体化basic_ string的一个typedef，同时省略了与内存管理相关的参数（这将在本章后面介绍）。size _type是一个依赖于实现的整型，是在头文件string中定义的。string类将string::npos定义为字符串的最大长度，通常为unsigned int的最大值。另外，表格中使用缩写NBTS（null-terminated string）来表示以空字符结束的字符串—-传统的C字符串。 程序16.1 str1.cpp #include &lt;iostream&gt; #include &lt;string&gt; int main() { using namespace std; string one(&quot;Lottery Winner!&quot;); cout &lt;&lt; one &lt;&lt; endl; string two(20, &apos;$&apos;); cout &lt;&lt; two &lt;&lt; endl; string three(one); cout &lt;&lt; three &lt;&lt; endl; one += &quot; Oops!&quot;; cout &lt;&lt; one &lt;&lt; endl; two = &quot;Sorry! That was &quot;; three[0] = &apos;p&apos;; string four; four = two + three; cout &lt;&lt; four &lt;&lt; endl; char alls[] = &quot;All&apos;s well that ends well&quot;; string five(alls, 20); cout &lt;&lt; five &lt;&lt; &quot;!\n&quot;; string six(alls+6, alls+10); cout &lt;&lt; six &lt;&lt; &quot;, &quot;; string seven(&amp;five[6], &amp;five[10]); cout &lt;&lt; seven &lt;&lt; &quot;...\n&quot;; string eight(four, 7, 17); cout &lt;&lt; eight &lt;&lt; &quot; in motion!&quot; &lt;&lt; endl; return 0; } 程序16.1中还使用了重载+=运算符，它将一个字符串附加到另一个字符串的后面；重载的=运算符用于将一个字符串赋给另一个字符串；重载的&lt;&lt;运算符用于显式string对象；重载的[]运算符用于访问字符串的各个字符。 输出： Lottery Winner! $$$$$$$$$$$$$$$$$$$$ Lottery Winner! Lottery Winner! Oops! Sorry! That was pottery Winner! All&apos;s well that ends! well, well... That was pottery in motion! 1.程序说明程序16.1，首先演示了将string对象初始化为常规的C-风格字符串，然后使用重载的&lt;&lt;运算符来显式它： string one(&quot;Lottery Winner&quot;); cout &lt;&lt; one &lt;&lt; endl; 接下来的构造函数将string对象two初始化为由20个$字符组成的字符串： string two(20, &apos;$&apos;); 复制构造函数将string对象three初始化为string对象one： string three(one); 重载的+=运算符将字符串“Oops!”附加到字符串one的后面： one += &quot; Oops!&quot;; 这里将一个C-风格字符串附加到另一个string对象的后面。+=运算符被多次重载，以便能够附加string对象和单个字符： one += two; one += &apos;!&apos;; 同样，=运算符也被重载，以便可以将string对象、C-风格字符串或char值赋给string对象： two = &quot;Sorry! That was &quot;; two = one; two = &apos;?&apos;; 重载[]运算符使得可以使用数组表示法来访问string对象中的各个字符： three[0] = &apos;P&apos;; 默认构造函数创建一个以后可对其进行赋值的空字符串: string four; four = two + three; 第二行使用重载的+运算符创建了一个临时string对象，然后使用重载的=运算符将它赋给对象four。正如所料的，+运算符将其两个操作数组合成一个string对象。该运算符被多次重载，以便第二个操作数可以是string对象、C风格字符串或char值。 第5个构造函数将一个C-风格字符串和一个整数作为参数，其中的整数参数表示要复制多少个字符： char alls[] = &quot;All&apos;s well that ends; string five(alls, 20); 从输出可知，这里只使用了前20个字符(“All’s well that ends”)来初始化five对象。正如表16.1指出的，如果字符数超过了C-风格字符串的长度，仍将复制请求数目的字符。所以在上面的例子，如果用40代替20，将导致15个无用字符被复制到five的结尾处（即构造函数将内存中位于字符串”All’s well that ends well”后面的内容作为字符）。 第6个构造函数有一个模板参数： template &lt;class Iter&gt; string (Iter begin, Iter end); begin和end将像指针那样，指向内存中两个位置（通常，begin和end可以是迭代器—-广泛用于STL中的广义化指针）。构造函数将使用begin和end指向的位置之间的值，对string对象进行初始化。[begin, end)来自数学中，意味着包含begin，但不包括en在内的区间。即，end指向被使用的最后一个值后面的一个位置。请看下面的语句： string six(alls+6, alls+19); 由于数组名相当于指针，所以alls+6和alls+10的类型都是char $\ast$，因此使用模板时，将用类型char $\ast$替换Item。第一个参数指向数组alls中的第一个w，而第二个参数指向第一个well后面的空格，six将被初始化为字符串”well“。图16.1说明了该构造函数的工作原理。 现在假设要用这个构造函数将对象初始化为另一个string对象（假设five）的一部分内容，则下面的语句不管用： string seven(five+5, five+10); 原因在于，对象名（不同于数组名）不会被看作是对象的地址，因此five不是指针，所以five+6是没有意义的。然后，five[6]是一个char值，所以&amp;char[6]是一个地址，因此可被用作构造函数的一个参数： string seven(&amp;five[6], &amp;five[10]); 第7个构造函数将一个string对象的部分内容复制到构造的对象中： string eight(four, 7, 16); 上述语句从four的第8个字符(位置7)开始，将16个字符复制到eight中。 2. C++新增的构造函数构造函数string(string &amp;&amp; str)类似于复制构造函数，导致新创建的string为str的副本。但与复制构造函数不同的是，它不保证将str视为const。这种构造函数被称为移动构造函数。在有些请看下，编译器可使用它而不是复制构造函数，以优化性能。第18章的”移动语义和右值引用“一节将讨论这个主题。 构造函数string(initializer_list il)让您能够将列表初始化语法用于string类。也就是说，它使得下面的声明是合法的： string piano_man = {&apos;L&apos;, &apos;i&apos;, &apos;s&apos;, &apos;z&apos;, &apos;t&apos;}; string comp_lang {&apos;L&apos;, &apos;i&apos;, &apos;s&apos;, &apos;p&apos;}; 就string而言，这可能用处不大，因为使用C-风格字符串更容易，但确实实现了让列表初始化语法普遍使用的意图。本章后面讲更深入讨论模板initializer_list。 16.1.2 string类输入对于类，很有帮助的另一个点是，知道有哪些输入方式可用。对于C-风格字符串，有3种方式： char info[100]; cin &gt;&gt; info; //读取一个单词 cin.getline(info, 100); //读取一行，丢弃\n cin.get(info, 100); //读取一行，\n保留在队列种 对于string对象，有两种方式： string stuff; cin &gt;&gt; stuff; //读取一个单词 getline(cin, stuff); //读取一行，丢弃\n 两个版本的getline()都有一个可选参数，用于指定使用哪个字符来确定输入的边界： cin.getline(info, 100, &apos;:&apos;); //从：开始读取内容，丢弃: getline(cin, stuff, &apos;:&apos;); //从：开始读取内容，丢弃: 在功能上，它们之间的主要区别在于，string版本的getline()将自动调用目标string对象的大小，使之刚好能够存储输入的字符： char fname[10]; string lname; cin &gt;&gt; fname; //如果输入字符数大于9，将出错 cin &gt;&gt; lname; //可以读取一个非常长的单词 cin.getline(fname, 10); //可能截断输入 getline(cin, lname); //没有截断 自动调整大小的功能让string版本的getline()不需要指定读取多少个字符的数值参数。 在设计方面的一个区别是，读取C-风格字符串的函数是istream类的方法，而string版本是独立的函数。这就是对于C-风格字符串输入，cin是调用对象；而对于string对象输入，cin是一个函数参数的原因。这种规则也适用于&gt;&gt;形式，如果使用函数形式来编写代码，这一点将显而易见： cin.operator&gt;&gt;(fname); //ostream类方法 operator&gt;&gt;(cin, lname); //普通函数 下面更深入地探讨一下string输入函数。正如前面指出的，这两个函数都是自动调整目标string的大小，使之与输入匹配。但也存在一些限制。第一个限制因素是string对象的最大允许长度，由常量string::npos指定。这通常是最大的unsigned int值，因此对于普通的交互式输入，这不会带来实际的限制；但如果您试图将整个文件的内容读取到单个string对象中，这可能称为限制因素。第二限制因素是程序可以使用的内存量。 string版本的getline()函数从输入中读取字符，并将其存储到目标string中，直到发生下列三种请看之一： 到达文件尾，在这种情况下，输入流的eofbit将被设置，这意味着方法fail()和eof()都将返回true; 遇到分解字符（默认为\n），在这种情况下，将把分解字符从输入流种删除，不存储它； 读取的字符数到达最大允许值（string::npos和可供分配的内存字节数种较小的一个），在这种情况下，将设置输入流的failbit，这意味着方法fail()将返回true。 输入流对象有一个统计系统，用于跟踪流的错误状态。在这个系统种，检测到文件尾后将设置eofbit存储器，检测到输入错误时将设置failbit存储器，出现无法识别的故障（如硬盘故障）时将设置badbit寄存器，一切顺利时将设置goodbit寄存器。第17章将更深入讨论这一点。 string版本的operator&gt;&gt;()函数的行为与此类似，只是它不断读取，直到遇到空白字符并将其留在输入队列种，而不是不断去读，直到遇到分界字符并将其丢弃。空白字符指的是空格、换行符和制表符，更普遍地说，是任何将其作为参数类调用isspace()时，该函数返回true的字符。 本书前面多个控制台string输入示例。由于用于string对象的输入函数使用输入流，能够识别文件尾，因此也可以使用它们来从文件种读取输入。程序16.2是一个从文件种读取字符串的简单实例，它假设文件种包含用冒号字符串分隔的字符串，并使用指定分界符的getline()方法。然后，显式字符串并给它们编号，每个字符串占一行。 程序16.2 strfile.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; int main() { using namespace std; ifstream fin; fin.open(&quot;tobuy.txt&quot;); if (fin.is_open() == false) { cerr &lt;&lt; &quot;Can&apos;t open file. Bye.\n&quot;; exit(EXIT_FAILURE); } string item; int count = 0; getline(fin, item, &apos;:&apos;); while (fin) { ++count; cout &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; item &lt;&lt; endl; getline(fin, item, &apos;:&apos;); } cout &lt;&lt; &quot;Done.\n&quot;; fin.close(); return 0; } 文件tobuy.txt的内容： Sardines:chocolate ice cream:pop corm:leeks: cottage cheese:olive oil : butter:tofu: 通常，对于程序要查看的文本文件，应将其放在可执行程序或项目文件所在的目录种：否则必须提供完成的路径名。在Windows系统种，C-风格字符串种的转义序列\表示一个斜杠： fin.open(&quot;C:\\CPP\\tobuy.txt&quot;); 输出： 1: Sardines 2: chocolate ice cream 3: pop corm 4: leeks 5: cottage cheese 6: olive oil 7: butter 8: tofu 9: Done. 注意，将：指定为分界字符后，换行符将被视为常规字符。因此在tobuy.txt中第一行末尾的换行符将成为包含”cottage cheese“的字符串中的第一个字符。同样，第二行末尾的换行符是第9个输入字符串中唯一的内容。 16.1.3 使用字符串现在，您知道可以使用不同方式来创建string对象、显式string对象的内容、将数据读取和附加到string对象中、给string对象赋值以及两个string对象连接起来。除此之外，还能做些什么呢？ 可以比较字符串。String类对全部6个关系运算符都进行了重载。如果在遇到及其排序中，一个对象位于另一个对象的前面，则前者视为小于后者。如果机器排列序列为ASCII码，则数字将小于大写字符，而大写字符小于小写字符。对于每个关系运算符，都以三种方式被重载，以便能够将string对象与另一个string对象、C-风格字符串进行比较，并能够将C-风格字符串与string对象进行比较： string snake1(&quot;cobra&quot;); string snake2(&quot;cora1&quot;); char snake3[20] = &quot;anaconda&quot;; if (snake1 &lt; snake2) //operator&lt;(const string &amp;, const string &amp;) ... if (snake1 == snake3) //operator==(const string &amp;, const char *) ... if (snake3 != snake2) //operator!=(const char *, const string &amp;) ... 可以确定字符串的长度。size()和length()成员函数都返回字符串中的字符数： if (snake1.length() == snake3.size()) cout &lt;&lt; &quot;Both strings have the same length.\n&quot;; 为什么这两个函数完成相同的任务呢？length()成员来自较早版本的string类，而size()则是为提供STL兼容性而添加的。 可以以多种不同的方式在字符串中搜索给定的子字符串或字符。表16.2简要地描述了find()方法的4个版本。如前所述，string::npos是字符串可存储的最大字符数，通常是无符号int或无符号long的最大取值。 string库还提供了相关的方法：rfind()、find_ first_ of()、find_ last_ of()、find_ first_ not _of()和find last not _of()，它们的重载函数特征标都与find()方法相同。rfind()方法查找子字符串或字符最后一次出现的位置；find _first _of()方法在字符串中查找参数中任何一个字符首次出现的位置。例如，下面的语句返回r在“cobra”中的位置（即索引3），因为这是“hark”中各个字符在”cobra”首次出现的位置： int where = snake1.find_first_of(&quot;hark&quot;); find_last_of()方法的功能与此相同，只是它查找的是最后一次出现的位置。因此，下面的语句返回a在“cobra”中的位置： int where = snake1.find_last_of(&quot;hark&quot;); find_first_not_of()方法在字符串中查找第一个不包含在参数中的字符，因此下面的语句返回c在“cobra”中的位置，因为“hark”中没有c： int where = snake1.find_first_not_of(&quot;hark&quot;); 还有很多其他的方法，这些方法足以创建一个非图形版本的Hangman拼字游戏。该游戏将一系列的单词存储在一个string对象数组中，然后随机选择一个单词，让人猜测单词的字母。如果猜错6次，玩家就输了。该程序使用find()函数来检查玩家的猜测，使用+=运算符创建一个string对象来记录玩家的错误猜测。为记录玩家猜对的请看，程序创建了一个单词，其长度与被猜的单词相同，但包含的是连字符。玩家猜对字符时，将用该字符替换相应的连字符。程序16.3列出了该程序的代码。 程序16.3 hangman.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;cctype&gt; using std::string; const int NUM = 26; const string wordlist[NUM] = {&quot;apiary&quot;, &quot;beetle&quot;, &quot;cereal&quot;, &quot;danger&quot;, &quot;ensign&quot;, &quot;florid&quot;, &quot;garage&quot;, &quot;health&quot;, &quot;insult&quot;, &quot;jackal&quot; &quot;keeper&quot;, &quot;loaner&quot;, &quot;manage&quot;, &quot;nonce&quot;, &quot;onset&quot;, &quot;plaid&quot;, &quot;quilt&quot;, &quot;remot&quot;, &quot;stolid&quot;, &quot;train&quot;, &quot;useful&quot;, &quot;valid&quot;, &quot;whence&quot;, &quot;xenon&quot;, &quot;yearn&quot;, &quot;zippy&quot;}; int main() { using std::cout; using std::cin; using std::tolower; using std::endl; std::srand(std::time(0)); char play; cout &lt;&lt; &quot;Will you play a word game?&lt;y/n&gt;&quot;; cin &gt;&gt; play; while (play == &apos;y&apos;) { string target = wordlist[std::rand() % NUM]; int length = target.size(); string attempt(length, &apos;-&apos;); string badchars; int guesses = 6; cout &lt;&lt; &quot;Guess my secret word, It has &quot; &lt;&lt; length &lt;&lt; &quot; letters, and you guess\n&quot; &lt;&lt; &quot;one letter at a time. You get &quot; &lt;&lt; guesses &lt;&lt; &quot; wrong guesses.\n&quot;; cout &lt;&lt; &quot;Your word: &quot; &lt;&lt; attempt &lt;&lt; endl; while (guesses &gt; 0 &amp;&amp; attempt != target) { char letter; cout &lt;&lt; &quot;Guess a letter: &quot;; cin &gt;&gt; letter; if (badchars.find(letter) != string::npos || attempt.find(letter) != string::npos) { cout &lt;&lt; &quot;You already guessed that. Try again.\n&quot;; continue; } int loc = target.find(letter); if (loc == string::npos) { cout &lt;&lt; &quot;Oh, bad guess!\n&quot;; --guesses; badchars += letter; } else { cout &lt;&lt; &quot;Good guess!\n&quot;; attempt[loc] = letter; loc = target.find(letter, loc+1); while (loc != string::npos) { attempt[loc] = letter; loc = target.find(letter, loc+1); } } cout &lt;&lt; &quot;Your word: &quot; &lt;&lt; attempt &lt;&lt; endl; if (attempt != target) { if (badchars.length() &gt; 0) cout &lt;&lt; &quot;Bad choices: &quot; &lt;&lt; badchars &lt;&lt; endl; cout &lt;&lt; guesses &lt;&lt; &quot;bad guesses left\n&quot;; } } if (guesses &gt; 0) cout &lt;&lt; &quot;That&apos;s right!\n&quot;; else cout &lt;&lt; &quot;Sorry, the word is &quot; &lt;&lt; target &lt;&lt; &quot;.\n&quot;; cout &lt;&lt; &quot;Will you play another? &lt;y/n&gt;&quot;; cin &gt;&gt; play; play = tolower(play); } cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } 输出： Will you play a word game?&lt;y/n&gt;y Guess my secret word, It has 6 letters, and you guess one letter at a time. You get 6 wrong guesses. Your word: ------ Guess a letter: e Oh, bad guess! Your word: ------ Bad choices: e 5bad guesses left Guess a letter: a Oh, bad guess! Your word: ------ Bad choices: ea 4bad guesses left Guess a letter: i Good guess! Your word: i----- Bad choices: ea 4bad guesses left Guess a letter: n Good guess! Your word: in---- Bad choices: ea 4bad guesses left Guess a letter: s Good guess! Your word: ins--- Bad choices: ea 4bad guesses left Guess a letter: u Good guess! Your word: insu-- Bad choices: ea 4bad guesses left Guess a letter: l Good guess! Your word: insul- Bad choices: ea 4bad guesses left Guess a letter: t Good guess! Your word: insult That&apos;s right! Will you play another? &lt;y/n&gt;n Bye. 程序说明在程序16.3中，由于关系运算符被重载，因此可以像对待数字那样对待字符串： while (guesses &gt; 0 &amp;&amp; attempt != target) 与对C-风格字符串使用strcmp()相比，这样简单些。 该程序使用find()来检查玩家以前是否猜过某个字符。如果是，则它要么位于badchars字符串中，要么位于attempt字符串中： if (badchars.find(letter) != string::nops || attempt.find(letter) != string::nops) npos变量是string类的静态成员，它的值是string对象能存储的最大字符数。由于索引从0开始，所以它比最大的索引值大1，因此可以使用它来表示没有查找字符或字符串。 该程序利用了这样一个事实：+=运算符的某个重载版本使得能够将一个字符附加到字符串中： badchars += letter; 该程序的核心是从检查玩家选择的字符是否位于被猜测的单词中开始的：、 int loc = target.find(letter); 如果loc是一个有效值，则可以将该字母放置在答案字符串的相应位置： attempt[loc] = letter; 然而，由于字母在被猜测的单词中可能出现多次，所以程序必须一直进行检查。该程序使用了find()的第二个参数，该参数可以指定从字符串什么位置开始搜索。因此字母是在位置loc找到的，所以下一次搜索应从loc+1开始。while循环使搜索一直进行下去，直到找不到该字符为止。如果loc位于字符串尾，则表明find()没有找到该字符： loc = target.find(letter, loc+1); while (loc != string::npos) { attempt[loc] = letter; loc = target.find(letter, loc+1); } 16.1.4 string还提供了哪些功能string库还提供了很多其他的工具，包括完成上述功能的函数：删除字符串的部分或全部内容、用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容、将数据插入到字符串中或删除字符串中的数据、将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较、从字符串中提取子字符串、将一个字符串中的内容赋值到另一个字符串中、交换两个字符串的内容。这些函数中的大多数都被重载，以便能够同时处理C-风格字符串和string对象。附录F简要地介绍了string库中的函数。 首先来看自动调整大小的功能。在程序16.3中，每当程序将一个字母附加到字符串末尾时将发生什么呢？不能仅仅将已有的字符串加大，因为相邻的内存可能被占用了。因此，可能需要分配一个新的内存块，并将原来的内容复制到新的内存单元中。如果执行大量这样的操作，效率将非常低，因此很多C++实现分配一个比实际字符串大的内存块，为字符串提供了增大空间。然而，如果字符串不断增加，超过了内存块的大小，程序将分配一个大小为原来两倍的新内存块，以提供足够的增大空间，避免不断地分配新的内存块。方法capacity()返回当前分配给字符串的内存块的大小，而reserve()方法让您能够请求内存块的最小长度。程序16.4是一个使用这些方法的示例。 程序16.4 str2.cpp #include &lt;iostream&gt; #include &lt;string&gt; int main() { using namespace std; string empty; string small = &quot;bit&quot;; string larger = &quot;Elephants are a girl&apos;s best friend&quot;; cout &lt;&lt; &quot;Size:\n&quot;; cout &lt;&lt; &quot;\tempty: &quot; &lt;&lt; empty.size() &lt;&lt; endl; cout &lt;&lt; &quot;\tsmall: &quot; &lt;&lt; small.size() &lt;&lt; endl; cout &lt;&lt; &quot;\tlarger: &quot; &lt;&lt; larger.size() &lt;&lt; endl; cout &lt;&lt; &quot;Capacities:\n&quot;; cout &lt;&lt; &quot;\tempty: &quot; &lt;&lt; empty.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;\tsmall: &quot; &lt;&lt; small.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;\tlarger: &quot; &lt;&lt; larger.capacity() &lt;&lt; endl; empty.reserve(50); cout &lt;&lt; &quot;Capacity after empty.reserve(50): &quot; &lt;&lt; empty.capacity() &lt;&lt; endl; return 0; } 输出： Size: empty: 0 small: 3 larger: 34 Capacities: empty: 0 small: 3 larger: 34 Capacity after empty.reserve(50): 50 注意，该实现使用的最小容量为15个字符，这比标准容量选择（16的倍数）小1。其他实现可能做出不一样的选择（本文中就不同）。 如果您有string对象，但需要C-风格字符串，该如何办呢？例如，您可能先打开一个其名称存储在string对象中的文件： string filename; cout &lt;&lt; &quot;Enter file name: &quot;; cin &gt;&gt; filename; ofstream fout; 不幸的是，open()要求使用一个C-风格字符串作为参数：幸运的是，c_str()方法返回一个指向C-风格字符串的指针，该C-风格字符串的内容与用于调用c_str()方法的string对象相同。因此可以这样做： fout.open(filename.c_str()): 16.1.5 字符串种类本节将string类看作是基于char类型的。事实上，正如前面指出的，string库实际上是基于一个模板类的： template &lt;class charT, class traits = char_traits&lt;charT&gt;, class = Allocator = allocator&lt;charT&gt;&gt; basic_string {}; 模板basic_string有4个具体化，每个具体化都有一个typedef名称：、 typedef basic_string&lt;char&gt; string; typedef basic_stirng&lt;wchar_t&gt; wstring; typedef basic_string&lt;char16_t&gt; u16string; //C++11 typedef basic_string&lt;char32_t&gt; u32string; //C++11 这让您能够使用基于wchar_ t、char16_ t和char的字符串。甚至可以开发某种类似字符的类，并对它使用basic_ string类模板。traits类描述关于选定字符类型的特定请看，如如何对值进行比较。对于wchar_ t、char16_ t、char32_ t和char类型，有预定义的char_ traits模板具体化，它们都是traits的默认值。Allocator是一个管理内存分配的类。对于各种字符类型，都有预定义的allocator模板具体化，它们都是默认的。它们使用new和delete。 16.2 智能指针模板类智能指针是行为类似于指针的类对象，但这种对象还有其他功能。本节介绍三个可帮助管理动态内存分配的智能指针模板。先来看需要哪些功能以及这些功能是如何实现的。请看下面的函数： void remodel(std::string &amp; str) { std::string * ps = new std::string(str); ... str = ps; return; } 您可能发现了其中的缺陷。每当调用时，该函数都分配堆中的内存，但从不收回，从而导致内存泄露。您可能也直到解决之道—-只要别忘了在return语句前添加下面的语句，以释放分配的内存即可： delete ps; 然而，但凡涉及“别忘了”的解决办法，很少是最佳的。因为您有时可能忘了，有时可能记住了，但可能在不经意间删除或注释掉了这些代码。即使确实没有忘记，也可能有问题。请看下面的变体： void remodel(std::string &amp; str) { std::string * ps = new std::string(str); ... if (weird_thing()) throw exception(); str = *ps; delete ps; return; } 当出现异常时，delete将不会被指定，因此也将导致内存泄露。 可以按照第14章介绍的方式修复这种问题，但如果有更灵巧的解决办法就好了。来看一些需要些什么。当remodel()这样的函数终止（不管是正常终止，还是由于异常终止），本地变量都将从栈内存中删除—-因此指针ps占据的内存将被释放。如果ps指向的内存也被释放，那该多好。如果ps有一个析构函数，该析构函数将在ps过期时释放它指向的内存。因此，ps的问题在于，它只是一个常规指针，不是有析构函数的类对象。如果它是对象，则可以在对象过期时，让它的析构函数删除指向的内存。这正是auto _ptr、unique _ptr和share _ptr背后的思想。模板auto _ptr是C++98提供的解决方法，C++已将其摒弃，并提供了另外两种解决方法。然而，虽然auto _ptr被摒弃，但它已使用了多年；同时，如果您的编译器不支持其他两种解决方法，auto _ptr将是唯一的选择。 16.2.1 使用智能指针这三个智能指针模板（auto_ ptr、unique_ ptr和shared_ ptr）都定义了类似指针的对象，可以将new获得（直接或间接）的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存：在智能指针过期时，这些内存将自动被释放。图16.2说明了auto_ ptr和常规指针在行为方面的差别：shared_ ptr和unique_ ptr的行为与auto_ ptr相同。 要创建智能指针，必须包含头文件memory，该文件模板定义。然后是同通常的模板语法来实现所需类型的指针。例如，模板auto_ptr包含如下构造函数: template &lt;class X&gt; class auto_ptr{ public: explicit auto(X * p = 0) throw(); ... }; 前面介绍过，throw()意味着构造函数不会引发异常；与auto_ ptr一样，throw()也被摒弃。因此，请求X类型的auto_ptr将获得一个指向X类型的auto _ptr: auto_ptr&lt;double&gt; pd(new double); auto_ptr&lt;string&gt; ps(new string); new double是new返回的指针，指向新分配的内存块。它是构造函数auto_ptr的参数，即对应于原型中形参p的实参。通常，new string也是构造函数的实参。其他两种智能指针使用同样的语法： unique_ptr&lt;double&gt; pdu(new double); shared_ptr&lt;string&gt; pss(new string); 因此，要转换remodel()函数，应按下面3个步骤进行： 包含头文件memory; 将指向string的指针替换为指向string的智能指针对象； 删除delete语句。 下面是使用auto_ptr修改该函数的结果： #include &lt;memory&gt; void remodel(std::string str) { std::auto_ptr&lt;std::string&gt; ps(new std::string); ... if (weird_thing()) throw exception(); str = *ps; return; } 注意到智能指针模板位于名称空间std中。程序16.5是一个简单的程序，演示了如何使用全部三种智能指针。要编译该程序，您的编译器必须支持C++11新增的类shared_ptr和unique _ptr。每个智能指针都放在一个代码块中，这样离开代码块时，指针将过期。Report类使用方法报告对象创建和销毁。 程序16.5 smrtptrs.cpp #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class Report { private: string str; public: Report(const string s) : str(s) { cout &lt;&lt; &quot;Object created!\n&quot;; } ~Report() {cout &lt;&lt; &quot;Object deleted!\n&quot;; } void comment() const { cout &lt;&lt; str &lt;&lt; endl; } }; int main() { { auto_ptr&lt;Report&gt; ps (new Report(&quot;using auto_ptr&quot;)); ps-&gt;comment(); } { shared_ptr&lt;Report&gt; ps (new Report(&quot;using share_ptr&quot;)); ps-&gt;comment(); } { unique_ptr&lt;Report&gt; ps (new Report(&quot;using unique_ptr&quot;)); ps-&gt;comment(); } return 0; } 编译： g++ -std=c++11 smrtptrs.cpp 输出： Object created! using auto_ptr Object deleted! Object created! using share_ptr Object deleted! Object created! using unique_ptr Object deleted! 所有智能指针类都有一个explicit构造函数，该构造函数将指针作为参数。因此不需要自动将指针转换为智能指针对象： shared_ptr&lt;double&gt; pd; double *p_reg = new double; pd = p_red; //不被允许，隐式转换 pd = shared_ptr&lt;double&gt;(p_red); //被允许，显式转换 shared_ptr&lt;double&gt; pshared = p_reg; //不被允许，隐式转换 shared_ptr&lt;double&gt; pshared(p_reg); //被允许，现实转换 由于智能指针模板类的定义方式，智能指针对象的很多方面都类似于常规指针。例如，如果ps是一个智能指针对象，则可以对它执行解除引用操作($\ast$ps)、用它来访问结果成员（ps-&gt;puffIndex）、将它赋给指向相同类型的常规智能。还可以将智能指针对象赋给另一个同类型的智能指针对象，但将引起一个问题，这将在下一节讨论。 但在此之前，先说说对全部三种智能指针都应避免的一点： string vacation(&quot;I wandered lonely as a cloud.&quot;); shared_ptr&lt;string&gt; pvac(&amp;vacation); //错误 pvac过期时，程序将把delete运算符用于非堆内存，这将是错误的。 程序16.5演示的情况而言，三种智能指针都能满足要求，但情况并非总是这样简单。 16.2.2 有关智能指针的注意事项为何有三种智能指针呢？实际上有4种，但本书不讨论weak_ptr。为何摒弃auto_ptr呢？ 先来看看下面的赋值语句： auto_ptr&lt;string&gt; ps (new string(&quot;I reigned lonely as cloud.&quot;)); auto_ptr&lt;string&gt; vocation; vocation = ps; 上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期，另一次是vocation过期。要避免这种问题，方法有多种。 定义赋值运算符，使之执行深度复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本。 建立所有权（ownership）概念，对于特定的对象，只能有一个指针指针可拥有它，这样只有拥有对象的指针指针的构造函数会删除该对象。然后，让复制操作转换所有权。这就是用于auto _ptr和unique的策略，但unique _ptr的策略更严格。 创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数（reference counting）。例如，赋值时，计数将加1，而指针过期时，计数将减1。仅当最后一个指针过期时，才调用delete。这是shared_ptr采用的策略。 当然，同样的策略也适用于复制构造函数。 每种方法都有其用途。程序16.6是一个不适合使用auto_ptr的示例。 程序16.6 fowl.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;memory&gt; int main() { using namespace std; auto_ptr&lt;string&gt; films[5] = { auto_ptr&lt;string&gt; (new string(&quot;Fowl Balls&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Duck Walks&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Chicken Runs&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Turkey Error&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Goose Eggs&quot;)) }; auto_ptr&lt;string&gt; pwin; pwin = films[2]; cout &lt;&lt; &quot;The nominees for best avian baseball film are\n&quot;; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; *films[i] &lt;&lt; endl; cout &lt;&lt; &quot;The winner is &quot; &lt;&lt; *pwin &lt;&lt; &quot;!\n&quot;; cin.get(); return 0; } 输出： The nominees for best avian baseball film are Fowl Balls Duck Walks Segmentation fault 消息core dumped表明，错误地使用auto_ptr可能导致问题（这种代码的行为是不确定的，其行为可能随系统而异）。这里的问题在于，下面的语句将所有权从films[2]转让给pwin: pwin = films[2]; 这将导致films[2]不再引用该字符串。在auto_ptr放弃对象的所有权后，便可能使用它来访问该对象。当程序打印films[2]指向的字符串时，却发现这是一个空指针，这显然讨厌的意外。 如果程序16.6中使用shared_ ptr代替auto_ ptr(这要求编译器支持C++新增的shared _ptr类)，则程序将正常运行，其输出如下： The nominees for best avian baseball film are Fowl Balls Duck Walks Chicken Runs Turkey Error Goose Eggs The winner is Chicken Runs! 差别在于pwin和films[2]指向同一个对象，而引用计数从1增加到2。在程序末尾，后声明的pwin首先调用其析构函数，该析构函数将引用计数降低到1。然后，shared_ptr数组的成员将被释放，对于fims[2]调用析构函数时，将引用计数降低到0，并释放以前分配的空间。 因此使用shared_ ptr时，程序16.6运行正常；而使用auto_ ptr时，该程序在运行阶段崩溃。如果使用unique _ptr，结果将如何呢？与auto _ptr一样，unique _ptr也采用所有权模型。但使用unique _ptr时，程序不会等到运行阶段崩溃，而在编译器因下述代行出现错误： pwin = films[2]; 显然，该进一步探索auto_ ptr和unique_ptr之间的差别。 16.2 unique_ptr为何优于auto _ptr请看下面的语句： auto_ptr&lt;string&gt; p1(new string(&quot;auto&quot;));#1 auto_ptr&lt;string&gt; p2; #2 p2 = p1; #3 在语句#3中，p2接管string对象的所有权后，ps的所有权将被剥夺。前面说过，这是件好事，可防止p1和p2的析构函数试图删除同一个对象；但如果程序随后试图使用p1，这将是件坏事，因此p1不再指向有效的数据。 下面来看使用unique_ptr的情况： unique_ptr&lt;string&gt; p3(new string(&quot;auto&quot;)); #4 unique_ptr&lt;string&gt; p4; #5 p4 = p3; #6 编译器认为语句#6是非法的，避免了#3不再指向有效数据的问题。因此，unique_ ptr比auto_ptr更安全（编译阶段错误比潜在的程序崩溃更安全）。 但有时候，将一个智能指针赋给另一个并不会留下危险的悬挂指针。假设有如下函数定义： unique_ptr&lt;string&gt; demo(const char * s) { unique_ptr&lt;string&gt; temp(new string(s)); return temp; } 并假设编写了如下代码： unique_ptr&lt;string&gt; ps; ps = demo(&quot;Uniquely special&quot;); demo()返回一个临时unique_ ptr，然后ps接管了原本归返回的unique_ ptr所有的对象，而返回的unique_ ptr被销毁。这没有问题。因为ps用于了string对象的所有权。但这里的另一个好处是，demo()返回的临时unique_ ptr很快被销毁，没有机会使用它来访问无效的数据。换句话来说，没有理由禁止这种赋值。神奇的是，编译器确实允许这种赋值！ 总之，程序试图将一个unique_ ptr赋给另一个时，如果源unique_ ptr是个临时右值，编译器允许这样做；如果源unique_ ptr将存在一段时间，编译器将禁止这样做： using namespace std; unique_ptr&lt;string&gt; pu1 (new string(&quot;Hi ho!&quot;)); unique_ptr&lt;stirng&gt; pu2; pu2 = pu1; #1不被允许 unique_ptr&lt;string&gt; pu3; pu3 = unique_ptr&lt;string&gt;(new string &quot;Yo!&quot;); #2被允许 语句#1将留下悬挂的unique_ ptr(pu1)，这可能导致危害。语句#2不会留下悬挂的unique_ ptr，因为它调用unique_ ptr的构造函数，该构造函数创建的临时对象在其所有权让给pu后将会被销毁。这种随情况而异的行为表明，unique_ ptr优于允许两种赋值的auto_ ptr。这也是禁止（只是一种建议，编译器并不禁止）在容器对象中使用auto_ ptr，但允许使用unique_ ptr的原因。如果容器算法试图对包含unique_ ptr的容器执行类似于语句#1的操作，将导致编译器错误；如果算法试图执行类似于语句#2的操作，则不会有任何问题。而对于auto_ ptr，类似于语句#1的操作可能导致不确定的行为和神秘的崩溃。 当然，您可能确实想执行类似于语句#1的操作。仅当以非智能的方式使用遗弃的智能指针（如接触引用时），这种赋值才不安全。要安全地重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让您能够将一个unique_ ptr赋给另一个。下面是一个使用前述demo()函数的例子，该函数返回一个unique_ptr对象： using namespace std; unique_ptr&lt;string&gt; ps1, ps2; ps1 = demo(&quot;Uniquely special&quot;); ps2 = move(ps1); ps1 = demo(&quot; and more&quot;); cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; 您可能会问，unique_ptr如何能够区分安全和不安全的用法呢？答案是它使用了C++新增的移动构造函数和右值引用，这将在第18章讨论。 相比于，auto_ ptr, unique_ ptr还有另一个优点。它有一个可用于数组的变体。别忘了，必须将delete和new配对，将delete[]和new[]配对。模板auto_ ptr使用delete而不是delete[]，因此智能与new一起使用，而不能与new[]一起使用。但unique_ ptr有使用new[]和delete[]的版本： std::unique_ptr &lt;double[]&gt; pda(new double(5)); 使用new分配内存时，才能使用auto_ ptr和shared_ ptr，使用new []分配内存时，不能使用它们。不使用new分配内存时，不能使用auto_ ptr或shared_ ptr；不使用new或new[]分配内存时，不能使用unique_ptr。 16.2.4 选择智能指针应使用哪种智能指针呢？如果程序要使用多个指向同一个对象的指针，应选择shared_ ptr。这样的情况包括：有一个指针数组，并使用一些辅助指针来表示特定的元素，如最大的元素和最小的元素；两个对象包含都指向第三个对象的指针；STL容器包含指针。很多STL算法都支持赋值和赋值操作，这些操作可用于shared_ ptr，但不能用于unique_ ptr（编译器发出警告）和auto_ ptr（行为不确定）。如果您的编译器没有提供shared_ ptr，可使用Boost库提供的shared_ptr。 如果程序不需要多个指向同一个对象的指针，则可使用unique_ ptr。如果函数使用new分配内存，并返回指向该内存的指针，将其返回类型声明为unique_ ptr是不错的选择。这样，所有权将转让给接受返回值的unique_ ptr，而该智能指针将复杂调用delete。可将unique_ ptr存储到STL容器中，只要不调用将一个unique_ ptr赋值或复制另一个的方法或算法（如sort()）。例如，可在程序中使用类似于下面的代码段，这里假设程序包含正确的include和using语句： unique_ptr&lt;int&gt; make_int(int n) { return unique_ptr&lt;int&gt;(new int(n)); } void show(unique_ptr&lt;int&gt; * pi) { return &lt;&lt; *a &lt;&lt; &quot; &quot;; } int main() { vector&lt;unique_ptr&lt;int&gt;&gt; vp(size); for (int i = 0; i &lt; vp.size(); i++) vp[i] = make_itn(rand() % 1000); vp.push_back(make_int(rand() % 1000); for_each(vp.begin(), vp.end(), show()); return 0; } 其中的push_ back()调用在没有问题，因为它返回一个临时unique_ ptr，该unique_ ptr被赋给vp中的一个unique_ ptr。另外，如果按值而不是按引用给show()传递对象，for_ each()语句将非法，因为这将导致使用一个来自vp的非临时unique_ ptr初始化pi，而这是不允许的。前面说过，编译器将发现错误使用uniqut_ptr的企图。 在unique_ ptr为右值时，可将其赋给shared_ ptr，这与将一个unique_ ptr赋给另一个需要满足的条件相同。与前面一样，在下面的代码中，make_ int()的返回类型为unique_ptr： unique_ptr&lt;int&gt; pup(make_int(rand() % 10000); shared_ptr&lt;int&gt; spp(pup); //不被允许，pup是一个值 shared_ptr&lt;int&gt; spr(make_int(rand() % 10000); 模板shared_ ptr包含一个显式构造函数，可用于将右值unique_ ptr转换为shared_ ptr。shared_ ptr将接管原来归unique_ ptr所有的对象。 在满足unique_ ptr要求的条件下，也可使用auto_ ptr，但unique_ ptr是更好的选择。如果您的编译器没有提供unique_ ptr，可考虑使用BOOST库提供的scoped_ ptr，它与unique_ptr类似。 16.3 标准模板库STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；算法是完成特定任务（如对数组进行排序或在链表中查找特定值）的处方；迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针；函数对象是类似于函数的对象，可以是类对象或函数指针（包括函数名，因为函数名被用作指针）。STL使得能够构造各种容器（包括数组、队列和链表）和执行各种操作（包括搜索、排序和随机排列）。 Alex Setpanov和Meng Lee在Hewlett-Packard实验室开发了STL，并于1994年发布其实现。ISO/ANSI C++委员会投票同意将其作为C++标准的组成部分。STL不是面向对象的编程，而是一种不同的编程模式——泛型编程(generic programming)。这使得STL在功能和方法方面都很有趣。关于STL的信息很多，无法用一章的篇幅全部介绍。这里，将介绍一些有代表性的例子，并领会泛型编程方法的精神。首先看看几个具体的例子，让您对容器、迭代器和算法有一些感性的认识，然后再介绍低层的设计理念，并简要介绍STL。附录G对各种STL方法和函数进行了总结。 16.3.1 模板类vector第四章简要地介绍了vector类，下面更详细地介绍它。在计算中，矢量（vector）对应数组，而不出第11章介绍的数学矢量（在数学中，可以使用N个分量来表示N维数学矢量，因此从这面讲，数学矢量类似于一个N维数组。然而，数学矢量还有一些计算机矢量不具备的其他特征，如内积和外积）。计算矢量存储了一组可随机访问的值，即可以使用索引来直接访问矢量的第10个元素，而不必首先访问前面第9个元素。所以，vector类提供了第14章介绍的valarray和ArrayTP以及第4章介绍的array类似的操作，即可以创建vector对象，将一个vector对象赋给另一个对象，使用[]运算符来访问vector元素。要使类成为通用的，应将它设计为模板类，STL正是这样做的——在头文件vector中定义了一个vector模板。 要创建vector模板对象，可使用通常表示法来指出要使用的类型。另外，vector模板使用动态内存分配，因此可以用初始化参数指出需要多少矢量： #include &lt;vector&gt; using namespace std; vector&lt;int&gt; rating(5); int n; cin &gt;&gt; n; vector&lt;double&gt; scores(n); 由于运算符[]被重载，因此创建vector对象后，可以使用通常的数组表示法来访问各个元素： rating[0] = 9; for (itn i = 0; i &lt; n; i++) cout &lt;&lt; scores[i] &lt;&lt; endl; 分配器 与strIng类相似，各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。例如，vector模板的开头与下面类似： template &lt;class T, class Allocator = allocator&lt;T&gt; &gt; class vector {....}; 如果省略该模板参数的值，则容器模板将默认使用allocator类。这个类使用new和delete。 程序16.7是一个要求不高的应用程序，它使用了这个类。该程序创建了两个vector对象———一个是int规范，另一个是string规范，它们都包含5个元素。 程序16.7 vect1.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; const int NUM = 5; int main() { using std::vector; using std::string; using std::cin; using std::cout; using std::endl; vector&lt;int&gt; rating(NUM); vector&lt;string&gt; titles(NUM); cout &lt;&lt; &quot;You will da exactly as told. You will enter\n&quot; &lt;&lt; NUM &lt;&lt; &quot; book titles and your rating(0-10).\n&quot;; int i; for (i = 0; i &lt; NUM; i++) { cout &lt;&lt; &quot;Enter title #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; getline(cin, titles[i]); cout &lt;&lt; &quot;Enter your rating (0-10): &quot;; cin &gt;&gt; rating[i]; cin.get(); } cout &lt;&lt; &quot;Thank you. Your entered the following:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; for (i = 0; i &lt; NUM; i++) cout &lt;&lt; rating[i] &lt;&lt; &quot;\t&quot; &lt;&lt; titles[i] &lt;&lt; endl; return 0; } 输出： You will da exactly as told. You will enter 5 book titles and your rating(0-10). Enter title #1: The Cat Who Knew C++ Enter your rating (0-10): 6 Enter title #2: Felonious Feelines Enter your rating (0-10): 4 Enter title #3: Warlords of Wonk Enter your rating (0-10): 3 Enter title #4: Don&apos;t Touch That Metaphor Enter your rating (0-10): 5 Enter title #5: Panic Oriented Programming Enter your rating (0-10): 8 Thank you. Your entered the following: Rating Book 6 The Cat Who Knew C++ 4 Felonious Feelines 3 Warlords of Wonk 5 Don&apos;t Touch That Metaphor 8 Panic Oriented Programming 该程序使用vector模板只是为方便创建动态分配的数组。下一节将介绍一个使用更多类方法的例子。 16.3.2 可对矢量执行的操作除分配存储空间外，vector模板还可以完成哪些任务呢？所有STL容器都提供了一些基本的方法，其中包括： size()：返回容器中元素数目 swap()：交换两个容器的内容 begin()：返回一个指向容器中第一个元素的迭代器 end()：返回一个表示超过容器尾的迭代器 什么是迭代器？它是一个广义指针。事实上，它可以是指针，也可以是一个可对器执行类似指针的操作——如解除引用（如operator$\ast$()）和递增（如operator++()）的对象。稍后将知道，通过将指针广义化为迭代器，让STL能够为各种不同的容器（包括那些简单指针无法处理的类）提供统一的接口。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef，其作用域为整个类。例如，要为vector的double类型规范声明一个迭代器，可以这样做： vector&lt;double&gt;::iterator pd; 假设scores是一个vector对象： vector&lt;double&gt; scores; 则可以使用迭代器pd执行这样的操作： pd = score.begin(); //pd指向第一个元素 *pd = 22.3; //解除pd引用，并初始化一个元素 ++pd; //pd指向下一个元素 正如您看到的，迭代的行为就像指针。顺便说一句，还有一个C++11自动类型推断很有用的地方。例如，可以不这样做： vector&lt;double&gt;::iterator pd = scores.begin(); 而这样做： auto pd = scores.begin(); 回到前面的示例。什么是超过结尾（past-the-end）呢？它是一种迭代器，指向容器最后一个元素后面的哪个元素。这与C-风格字符串最后一个字符后面的空字符类似，只是空字符是一个值，而“超过结尾”是一个指向元素的指针（迭代器）。end()成员函数表示超过结尾的位置。如果将迭代器设置为容器的一个元素，并不断地递增，最终它将到达容器结尾，从而遍历整个容器的内容。因此，如果scores和pd的定义与前面的示例中相同，则可以用下面的代码来显示容器的内容： for (pd = scores.begin(); pd != scores.end(); pd++) cout &lt;&lt; *pd &lt;&lt; endl; 所有容器都包含刚才讨论的那些方法。vector模板类也包含一些只有某些STL容器才有的方法。push_back()是一个方便的方法，它将元素添加到矢量的末尾。这样做时，它将负责内存管理，增加矢量的长度，使之能够容纳新的成员。这意味着可以编写这样的代码： vector&lt;double&gt; scores; double temp; while (cin &gt;&gt; temp &amp;&amp; temp &gt;= 0) scores.push_back(temp); cout &lt;&lt; &quot;You entered &quot; &lt;&lt; scores.size() &lt;&lt; &quot; scores.\n&quot;; 每次循环都给scores对象增加一个元素。在编写或运行程序时，无需了解元素的数目。只要能够取得足够的内存，程序就可以根据需要增加scores的长度。 erase()方法删除矢量中给定区间的元素。它接受两个迭代器参数，这些参数定义了要删除的区间。了解STL如何使用两个两个迭代器来定义区间至关重要。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。例如，下述代码删除第一个和第二个元素，即删除begin()和begin()+1指向的元素（由于vector提供了随机访问功能，因此vector类迭代器定义了诸如begin()+2等操作）： scores.erase(scores.begin(), scores.begin()+2); 如果it1和it2是迭代器，则STL文档使用[p1, p2)来表示从p1到p2（不包括）的区间。因此，区间[begin(), end()]将包含集合的所有内容（参见图16.3），而区间[p1, p1)为空。[)表示法并不是C++的组成部分，因此不能再代码中使用，而只能出现再文档中。 注意：区间[it1, it2)由迭代器it1和it2指定，其范围为it1到it2（不包括it2）。 insert()方法的功能与erase()相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。例如，下面的代码将矢量new_ v中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面： vector&lt;int&gt; old_v; vector&lt;int&gt; new_v; ... odl_v.insert(old_v.begin(), new_v.begin()+1, new_v.end()); 顺便说一句，对于这种情况，拥有超尾元素是非常方便的，因为这使得在矢量尾部附加元素非常简单。下面的代码将新元素插入到old.end()前面，即矢量最后一个元素的后面。 old_v.insert(old_v.end(), new_v.begin() + 1, new_v.end()); 程序16.8演示了size()、begin()、end()、push_back()、erase()和insert()的用法。为简化数据处理。将程序16.7中的rating和title组合成了一个Review结构，并使用FillReview()和ShowReivew()函数来输入和输出Review对象。 程序16.8 vect2.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; struct Review{ std::string title; int rating; }; bool FillReview(Review &amp; rr); void ShowReview(const Review &amp; r); int main() { using std::cout; using std::vector; vector&lt;Review&gt; books; Review temp; while (FillReview(temp)) books.push_back(temp); int num = books.size(); if (num &gt; 0) { cout &lt;&lt; &quot;Thank you, you entered the following:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; for (int i = 0; i &lt; num; i++) ShowReview(books[i]); cout &lt;&lt; &quot;Reprising:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; vector&lt;Review&gt;::iterator pr; for (pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); vector&lt;Review&gt; oldlist(books); if (num &gt; 3) { books.erase(books.begin()+1, books.begin()+3); cout &lt;&lt; &quot;After erasure:\n&quot;; for (pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); books.insert(books.begin(), oldlist.begin()+1, oldlist.begin()+2); cout &lt;&lt; &quot;After insertion:\n&quot;; for (pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); } books.swap(oldlist); cout &lt;&lt; &quot;Swapping oldlist with books:\n&quot;; for (pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); } else cout &lt;&lt; &quot;Noting entered, noting gained.\n&quot;; return 0; } bool FillReview(Review &amp; rr) { std::cout &lt;&lt; &quot;Enter book title (q to quit): &quot;; std::getline(std::cin, rr.title); if (rr.title == &quot;q&quot;) return false; std::cout &lt;&lt; &quot;Enter book rating: &quot;; std::cin &gt;&gt; rr.rating; if (!std::cin) return false; while (std::cin.get() != &apos;\n&apos;) continue; return true; } void ShowReview(const Review &amp; rr) { std::cout &lt;&lt; rr.rating &lt;&lt; &quot;\t&quot; &lt;&lt; rr.title &lt;&lt; std::endl; } 输出： Enter book title (q to quit): The Cat Who Knew Vectors Enter book rating: 5 Enter book title (q to quit): Candid Canines Enter book rating: 7 Enter book title (q to quit): Warriors of Wonk Enter book rating: 4 Enter book title (q to quit): Quantum Manners Enter book rating: 8 Enter book title (q to quit): q Thank you, you entered the following: Rating Book 5 The Cat Who Knew Vectors 7 Candid Canines 4 Warriors of Wonk 8 Quantum Manners Reprising: Rating Book 5 The Cat Who Knew Vectors 7 Candid Canines 4 Warriors of Wonk 8 Quantum Manners After erasure: 5 The Cat Who Knew Vectors 8 Quantum Manners After insertion: 7 Candid Canines 5 The Cat Who Knew Vectors 8 Quantum Manners Swapping oldlist with books: 5 The Cat Who Knew Vectors 7 Candid Canines 4 Warriors of Wonk 8 Quantum Manners 16.3.3 对矢量可执行的其他操作程序员通常要对数组执行很多操作，如搜索、排序、随机排序等。矢量模板类包含了执行这些常见的操作的方法吗？没有！STL从更广泛的角度定义了非成员（non-member）函数来执行这些操作，即不是为每个容器类定义find()成员函数，而是定义了一个适用于所有容器类的非成员函数find()。这种设计理念省去了大量重复的工作。例如，假设有8个容器类，需要支持10种操作。如果每个类都有自己的成员函数，则需要定义80(8$\ast$10)个成员函数。但采用STL方式时，只需要定义10个非成员函数即可。在定义的新的容器类时，只要遵循正确的指导思想，则它也可以使用已有的10个非成员函数来执行查找、排序等操作。 另一方面，即使有执行相同任务的非成员函数，STL有时也会定义一个成员函数。这是因为对有些操作来说，类特定算法的效率比通常算法高，因此vector的成员函数swap()的效率 比非成员函数swap()高，但非成员函数让您能够交换两个类型不同的容器的内容。 下面来看3个具体代表性得STL函数：for_ each()、random_ shuffle()和sort()。for_ each()函数可用于很多容器类，它接受3个参数。前两个是定义容器中区间的迭代器，最后一个是指向函数的指针（更普遍地说，最后一个参数是一个函数对象，函数对象将稍后介绍）。for_ each()函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不能修改容器元素的值。可以用for _each()函数来代替for循环。例如，可以将下面的代码： vector&lt;Review&gt;::iterator pr; for (pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); 替换为： for_each(books.begin(), books.end(), ShowReview); 这样避免显示地使用迭代器变量。 Random_shuffle()函数接受两个指定区间的迭代器参数，并随机排列该区间中的元素。例如，下面的语句随机排列books矢量中所有元素： random.shuffle(books.begin(), books.end()): 与可用于任何容器类的for_each不同，该函数要求容器类允许随机访问，vector类可以做到这一点。 srot()函数也要求容器支持随机访问。该函数有两个版本，第一个版本接受两个定义区间的迭代器参数，并使用为存储在容器中的类型元素定义的&lt;运算符，对区间中的元素进行操作。例如，下面的语句按升序对coolstuff的内容进行排序，排序时使用内置&lt;运算符对值进行比较： vector&lt;int&gt; coolstuff; ... sort(coolstuff.begin(), coolstuff.end()); 如果容器元素是用户定义的对象，则要使用sort()，必须定义能够处理该类型的operator&lt;()函数。例如，如果为Review提供了成员或非成员函数operator&lt;()，则可以对包含Review对象的矢量进行排序。由于Review是一个结构，因此其成员是公有的，这样的非成员函数将为： bool operator&lt;(const Review &amp; r1, const Review &amp; r2) { if (r1.title &lt; r2.title) return true; else if (r1.title == r2.title &amp;&amp; r1.rating &lt; r2.rating) return true; else return false; } 有了这样的函数后，就可以对包含Review对象（如books）的矢量进行排序了： sort(books.begin(), books.end()); 上述版本的operator&lt;()函数按title成员的字母顺序排序。如果title成员相同，则按照rating排序。然而，如果想要按降序或是按rating（而不是title）排序，该如何办呢？可以使用另一种格式的sort()。它接受3个参数，前两个参数也是指定区间的迭代器，最后一个参数是指向要使用的函数的指针（函数对象），而不出用于比较的operator&lt;()。返回值可转换为bool，false表示两个参数的顺序不正确。下面是一个例子： bool WorseThan(const Review &amp; r1, const Review &amp; r2) { if (r1.rating &lt; r2.rating) return true; else return false; } 有了这个函数后，就可以使用下面的语句将包含Review对象的books矢量按rating升序排列： sort(books.begin(), books.end(), WorseThan); 注意，与operator&lt;()相比，WorseThan()函数执行的对Review对象进行排序的工作不那么完整。如果两个对象的title成员相同，operator&lt;()函数将按rating进行排序，而WorseThan()将它们视为相同。第一种排序成为全排序（total ordering），第二种排序称为完整弱排序（strict weak ordering）。在全排序种，如果a&lt;b和b&lt;a都不成立，则a和b必定相同。在完整弱排序种，情况就不是这样了。它们可能相同，也可能只是在某方面相同，如WorseThan()示例中的rating成员。所以在完整弱排序中，只能说它们等价，而不是相同。 程序16.9演示了这些STL函数的用法。 程序16.9 vect3.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; struct Review{ std::string title; int rating; }; bool operator&lt;(const Review &amp; r1, const Review &amp; r2); bool worseThan(const Review &amp; r1, const Review &amp; r2); bool FillReview(Review &amp; rr); void ShowReview(const Review &amp; r); int main() { using namespace std; vector&lt;Review&gt; books; Review temp; while (FillReview(temp)) books.push_back(temp); if (books.size() &gt; 0) { cout &lt;&lt; &quot;Thank you, you entered the following:\n&quot; &lt;&lt; books.size() &lt;&lt; &quot; rating:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; for_each(books.begin(), books.end(), ShowReview); sort(books.begin(), books.end()); cout &lt;&lt; &quot;Sorted by title:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; for_each(books.begin(), books.end(), ShowReview); sort(books.begin(), books.end(), worseThan); cout &lt;&lt; &quot;Sorted by ragint:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; for_each(books.begin(), books.end(), ShowReview); random_shuffle(books.begin(), books.end()); cout &lt;&lt; &quot;After shuffling:\n&quot; &lt;&lt; &quot;Rating\tBook\n&quot;; for_each(books.begin(), books.end(), ShowReview); } else cout &lt;&lt; &quot;No entries.\nBye.\n&quot;; return 0; } bool operator&lt;(const Review &amp; r1, const Review &amp; r2) { if (r1.title &lt; r2.title) return true; else if (r1.title == r2.title &amp;&amp; r1.rating &lt; r2.rating) return true; else return false; } bool worseThan(const Review &amp; r1, const Review &amp; r2) { if (r1.rating &lt; r2.rating) return true; else return false; } bool FillReview(Review &amp; rr) { std::cout &lt;&lt; &quot;Enter book title (q to quit): &quot;; std::getline(std::cin, rr.title); if (rr.title == &quot;q&quot;) return false; std::cout &lt;&lt; &quot;Enter book rating: &quot;; std::cin &gt;&gt; rr.rating; if (!std::cin) return false; while (std::cin.get() != &apos;\n&apos;) continue; return true; } void ShowReview(const Review &amp; rr) { std::cout &lt;&lt; rr.rating &lt;&lt; &quot;\t&quot; &lt;&lt; rr.title &lt;&lt; std::endl; } 输出： Enter book title (q to quit): The Cat Who Can Teach You Weight Loss Enter book rating: 8 Enter book title (q to quit): The Dogs of Dharma Enter book rating: 6 Enter book title (q to quit): The Wimps of Wonk Enter book rating: 3 Enter book title (q to quit): Farewell and Delete Enter book rating: 7 Enter book title (q to quit): q Thank you, you entered the following: 4 rating: Rating Book 8 The Cat Who Can Teach You Weight Loss 6 The Dogs of Dharma 3 The Wimps of Wonk 7 Farewell and Delete Sorted by title: Rating Book 7 Farewell and Delete 8 The Cat Who Can Teach You Weight Loss 6 The Dogs of Dharma 3 The Wimps of Wonk Sorted by ragint: Rating Book 3 The Wimps of Wonk 6 The Dogs of Dharma 7 Farewell and Delete 8 The Cat Who Can Teach You Weight Loss After shuffling: Rating Book 3 The Wimps of Wonk 8 The Cat Who Can Teach You Weight Loss 6 The Dogs of Dharma 7 Farewell and Delete 16.3.4 基于范围的for循环（c++11）第5章介绍过，基于范围的for循环是为用于STL而设计的。为复习该循环，下面是第5章的第一个示例： double price[5] = {1.22, 2.33, 5.22, 8.32, 9.65}; for (double x : prices) cout &lt;&lt; x &lt;&lt; std::endl; 在这种循环中，括号内的代码声明一个类型与容器存储的内容相同的变量，然后指出了容器的名称。接下来，循环体使用指定的变量依次访问容器的每个元素。例如，对于下述摘自程序16.9的语句： for_each(books.begin(), books.end(), ShowReview); 可将其替换为下面基于范围的for循环： for (auto x : books) ShowReview(x); 根据books的类型（vector）,编译器将推断出x的类型为Review，而循环将依次将books中的每个Review对象传递给ShowReview()。 不同于for_each()，基于范围的for循环可修改容器的内容，诀窍是指定一个引用参数。例如，假设如下函数： void InflateReview(Review &amp;r) {r.rating++;} 可使用如下循环对books的每个元素执行该函数： for(auto &amp; x : books) InflateReview(x); 16.4 泛型编程有了一些使用STL的经验后，来看一看底层理念。STL是一种泛型编程（generic programming）。面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。 泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。当然，模板使得能够按泛型定义函数或类，而STL通过通用算法更进了一步。模板让这一切成为可能，但必须对元素进行仔细地设计。为解模板和设计是如何协同工作的，来看一看需要迭代器的原因。 16.4.1 为何使用迭代器理解迭代器是理解STL的关键所在。模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。 为了了解为何需要迭代器，我们来看如何为两种不同数据表示实现find函数，然后来看如何推广这种方法。首先看一个在double数组中搜索特定值的函数，可以这样编写函数： double * find_ar(double * ar, int n, const double &amp; val) { for (int i = 0; i&lt; n; i++) if (ar[i] == val) return &amp;ar[i]; return 0; } 如果函数在数组中找到这样的值，则返回该值在数组中的地址，否则返回一个空指针。该函数使用下标来遍历数组。可以用模板将这种算法推广到包含==运算符的、任意类型的数组。尽管如此，这种算法仍然与一种特定的数据结构（数组）关联在一起。 下面来看看搜索另一个数据结构———链表的情况（第12章使用链表实现了Queue类）。链表由链接在一起的Node结构组成： struct Node { double item; Node * p_next; }; 假设有一个指向链表第一个节点的指针，每个节点的p_ next指针指向下一个节点，链表最后一个节点的p_next指针被设置为0，则可以这样编写find_ll()函数： Node * find_ll(Node * head, const double &amp; val) { Node * start; for (start = head; start != 0; start = start-&gt;p_next) if (start-&gt;item == val) return start; return 0; } 同样，也可以使用模板将这种算法推广到指出==运算符的任何数据类型的链表。然而，这种算法也是与特定的数据结构——链表关联在一起。 从实现细节上看，这两个find函数的算法是不同的：一个使用数组索引来遍历元素，另一个则将start重置为start-&gt;p_next。但从广义上说，这两种算法是相同的：将值依次与容器中的每个值进行比较，知道找到匹配的为止。 泛型编程旨在使用同一个find函数来处理数组、链表或任何其他容器类型。即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。模板提供了存储在容器中的数据类型的通用表示，因此还需编程容器中的值的通用表示，迭代器正是这样的通用表示。 要实现find函数，迭代器应具有哪些特征呢？下面是一个简短的列表： 应能够对迭代器执行解除引用的操作，以便能够访问它引用的值。即如果p是一个迭代器，则应对$\ast$p进行定义。 应能够将一个迭代器赋给另一个。即如果p和q都是迭代器，则应对表达式p=q进行定义。 应能够将一个迭代器与另一个迭代器进行比较，看它们是否相等。即如果p和q都是迭代器，则应对p==q和p!=q进行定义。 应能够使用迭代器遍历容器中的所有元素，这可以通过迭代器p定义++p和p++来实现。 迭代器也可以完成其他的操作，但有上述功能就足够了，至少对于find函数是如此。实际上，STL按功能的强弱定义了多种级别的迭代器。这将在后面介绍。顺便说一句，常规指针就能满足迭代器的要求，因此，可以这样重新编写find_arr()函数： typedef double * iterator; iterator find_ar (iterator ar, int n, const double &amp; val) { for (int i = 0; i &lt; n; i++, ar++) if (*ar == val) return ar; return 0; } 然后可以修改函数参数，使之接受两个指示区间的指针参数，其中的一个指向数组的起始位置，另一个指向数组的超尾；同时函数可以通过返回尾指针，来指出没有找到要找的值。下面的find_ar()版本完成了这些修改： typedef double * iterator iterator find_ar(iterator begin, iterator end, const double &amp; val) { iterator ar; for (ar = begin; ar != end; ar++) if( *ar == val ) return ar; return endl; } 对于find_ll()函数，可以定义一个迭代器类，其中定义了运算符$\ast$和++： struct Node { double item; double * p_next; }; class iterator { Node * pt; public: iterator() : pt(0) {} iterator(Node * pn) : pt(pn) {} double operator*() { return pt-&gt;item; } iterator &amp; operator++() { pt = pt-&gt;p_next; return *this; } iterator operator++(int) { iterator tmp = *this; pt = pt-&gt;p_next; return tmp; } //....operator==(), operator!=(), etc }; 为区分++运算符的前缀版本和后缀版本，C++将operator++作为前缀版本，将operator++(int)作为后缀版本；其中的参数永远也不会被用到，所以不必指定其名称。 这里重点不是如何定义iterator类，而是有了这样的类后，第二个find函数就可以这样编写： iterator find_ll(iterator head, const double &amp; val) { iterator start; for (start = head; start != 0; ++start) if (*start == val) return start; return 0; } 这和find_ ar()几乎相同，差别在于如何判断已到达最后一个值。find_ ar()函数使用超尾迭代器，而find_ ll()使用存储在最后一个节点中的控制。除了这种差别外，这两个函数完全相同。例如，可以要求链表的最后一个元素后面还有一个额外的元素，即让数组和链表都有超尾元素，并在迭代器到达超尾位置时结束搜索。这样，find_ ar()和find_ll()检测超尾的方式将相同，从而成为相同的算法。注意，增加超尾元素后，对迭代器的要求编程了对容器类的要求。 STL遵循上面介绍的方法。首先，每个容器类（vector、list、deque等）定义了相应的迭代器类型。对于其中的某个类，迭代器可能是指针，而对于另一个类，则可能是对象。不管实现方式如何，迭代器都将提供所需的操作，如$\ast$和++（有些类需要的操作可能比其他多）。其次，每个容器都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，这个值将被赋给迭代器。每个容器都有being()和end()方法，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器。每个容器类都使用++操作，让迭代器从指向第一个元素逐步指向超尾位置，从而遍历容器中的每一个元素。 使用容器类时，无需知道其迭代器是如何实现的，也无需知道超尾是如何实现的，而只需知道它有迭代器，其begin()返回一个指向第一个元素的迭代器，end()返回一个指向超尾位置的迭代器即可。例如，假设要打印vector对象中的值，则可以这样做： vector&lt;double&gt;::iterator pr; for (pr = scores.begin(); pr != scores.end(); pr++) cout &lt;&lt; *pr &lt;&lt; endl; 其中，下面的代码行将pr的类型声明尾vector类的迭代器： vector&lt;double&gt; class: vector&lt;double&gt;::iterator pr; 如果要使用list类模板来存储分数，则代码如下： list&lt;double&gt;::iterator pr; for (pr = scores.being(); pr != scores.end(); pr++) cout &lt;&lt; *pr &lt;&lt; endl; 唯一不同的是pr的类型。因此，STL通过尾每个类顶一个适当的迭代器，并以统一的风格设计类，能够对内部表示绝然不同的容器，编写相同的代码。 使用C++新增的自动类型推断可进一步简化：对于矢量或列表，都可使用如下代码： for (auto pr = scores.begin(); pr != scores.end(); pr++) cout &lt;&lt; * pr &lt;&lt; enld; 实际上，作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数（如for_each()）来处理细节。也可使用C++11新增的基于范围的for循环： for(auto x : scores) cout &lt;&lt; x &lt;&lt; endl; 来总结一下STL方法。首先是处理容器的算法，应尽可能用通用的术语来表达算法，使之独立于数据类型和容器类型。为使通用算法能够适用于具体情况，应定义能够满足算法需要的迭代器，并把要求加到容器设计上。即基于算法的要求，设计基本迭代器的特征和容器特征。 16.4.2 迭代器类型不同的算法对迭代器的要求也不同。例如，查找算法需要定义++运算符，以便迭代器能够遍历整个容器；它要求能够读取数据，但不要求能够写数据（它只查看数据，而并不修改数据）。而排序算法要求能够随机访问，以便能够交换两个不相邻的元素。如果item是一个迭代器，则可以通过定义+运算符来实现随机访问，这样就可以使用像iter+10这样的表达式了。另外，排序算法要求能够读写数据。 STL定义了5种迭代器，并根据所需的迭代器类型对算法进行了描述。这5种迭代器分别是输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器。例如，find()的原型与下面类似： template&lt;class InputIterator, class T&gt; InuptIterator find(InputIterator first, InputIterator last, const T&amp; value); 这指出，这种算法需要一个输入迭代器。同样，下面的原型指出排序算法需要一个随机访问迭代器： template&lt;class RandomAccessItearator&gt; void sort(RandomAccessIterator first, RandomAccessIterator last); 对于这5种迭代器，都可以执行解除引用操作（即为它们定义了$\ast$运算符），也可进行比较，看起是相等（使用==运算符，可能被重载了）还是不相等（使用！=运算符，可能被重载了）。如果两个迭代器相同，则对它们执行解除引用操作得到的值将相同。即如果表达式iter1==iter2为真，则下述的表达式也为真： iter1 == iter2 // 为真 *iter1 == *iter2 //也为真 当然，对于内置运算符和指针来说，情况也是如此。因此，这些要求将指导您如何对迭代器类重载这些运算符。下面来看迭代器的其他特征。 1. 输入迭代器术语“输入”是从程序的角度来说的，即来自容器的信息被视为输入，就像来自键盘的信息对程序来说是输入一样。因此，输入迭代器可被程序用来读取容器种的信息。具体来说，对输入迭代解除引用将使程序能够读取容器中的值，但不一定能让程序修改值。因此，需要输入迭代器的算法将不会修改容器中的值。 输入迭代器必须能够访问容器中所有的值，这是通过支持++运算符（前缀格式和后缀格式）来实现的。如果将输入迭代器设置为指向容器中的第一个元素，并不断将其递增，直到到达超尾位置，则它将依次指向容器中的每一个元素。顺便说一句，并不能保证输入迭代器第二次遍历容器时，顺序不变。另外，输入迭代器被递增后，也不能保证其先前的值仍然可以被解除引用。基于输入迭代器的任何算法都应当是单通行（single-pass）的，不依赖于前一次遍历时的迭代器值，也不依赖与本次遍历中前面的迭代器值。 注意，输入迭代器是单向迭代器，可以递增，但不能倒退。 2. 输出迭代器STL使用术语“输出”来指用于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。输出迭代器与输入迭代器相似，只是解除引用让程序能够修改容器值，而不能读取。也许您会感到奇怪，能够写，却不能读。发送到显示器上的输出就是如此，cout可以修改发送到显示器的字符流，却不能读取屏幕上的内容。STL足够同样，其容器可以表示输出设备，因此容器也可能如此。另外，如果算法不用读取容器的内容就可以修改它（如通过生成要存储的新值），则没有利用要求它使用能够读取内容的迭代器。 简而言之，对于单通行、只读算法，可以使用输入迭代器；而对于单通信、只写算法，则可以使用输出迭代器。 3. 正向迭代器与输入迭代器和输入迭代器相似，正向迭代器只使用++运算符来遍历容器，所以它每次沿容器向前移动一个元素；然而，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值。另外，将正向迭代器递增后，仍然可以对前面的迭代器解除引用（如果保存了它），并可以得到相同的值。这些特征使得多次通行算法成为可能。 正向迭代器既可以使得能够读取和修改数据，也可以使得只能读取数据： int * pirw; //读写迭代器 const int * pir; //仅读取迭代器 4. 双向迭代器假设算法需要能够双向遍历容器，情况将如何呢？例如，reverse函数可以交换第一个元素和最后一个元素、将指向第一个元素的指针加1、将指向第二个元素的指针减1，并重复这种处理过程。双向迭代器具有正向迭代的所有特性，同时指出两种（前缀和后缀）递减运算符。 5. 随机访问迭代器有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何一个元素，这叫随机访问，需要随机访问迭代器。随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系运算符。表16.3列出了除双向迭代器的操作外，随机访问迭代器还支持的操作。其中，X表示随机迭代器类型，T表示指向的类型，a和b都是迭代器，n为整数，r为随机迭代器变量或引用。 像a+n这样的表达式仅当a和a+n都位于容器区间（包括超尾）内时才是合法。 16.4.3 迭代器层次结构您可能已经注意到，迭代器类型形成了一个层次结构。正向迭代器具有输入迭代器和输出迭代器的全部功能，同时还有自己的功能；双向迭代器具有正向迭代器的全部功能，同时还有自己的功能；随机访问迭代器具有正向迭代器的全部功能，同时还有自己的功能。表16.4总结了主要的迭代器功能。其中，i为迭代器，n为整数。 根据特定迭代器类型编写的算法可以使用该种迭代器，也可以使用具有所需功能的任何其他迭代器。所以具有随机访问迭代器的容器可以使用为输入迭代器编写的算法。 为何需要这么多迭代器呢？目的是为了在编写算法尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。这样，通过使用级别最低的输入迭代器，find()函数便可用于任何包含可读取值的容器。而sort()函数由于需要随机访问迭代器，所以智能用于支持这种迭代器的容器。 注意，各种迭代器的类型并不是确定的，而只是一种概念性描述。正如前面指出的，每个容器类都定义了一个类级typedef名称——iterator，因此vector类的迭代器类型为vector::interator。然而，该类的文档将指出，矢量迭代器是随机访问迭代器，它允许使用基于任何迭代器类型的算法，因此随机访问迭代器具有所有迭代器的功能。同样，list类的迭代器类型为list::iterator。STL实现了双向链表，它使用双向迭代器，因此不能使用基于随机访问迭代器的算法，但可以使用基于要求较低的迭代器算法。 16.4.4 概念、改进和模型STL有若干个用C++语言无法表达的特性，如迭代器种类。因此，虽然可以设计具有正向迭代器特征的类，但不能让编译器将算法限制为只使用这个类。原因在于，正向迭代器是一系列要求，而不是类型。所设计的迭代器可以满足这种要求，常规指针也能满足这种要求。STL算法可以使用任何满足其要求的迭代器实现。STL文献使用术语概念（concept）来描述一系列的要求。因此，存在输入迭代器概念、正向迭代器概念，等等。顺便说一句，如果所设计的容器类需要迭代器，可考虑STL，它包含用于标准种类的迭代器模板。 概念可以具有类似继承的关系。例如，双向迭代器继承了正向迭代器的功能。然而，不能将C++继承机制用于迭代器。例如，可以将正向迭代器实现为一个类，而将双向迭代器实现为一个常规指针。因此，对C++而言，这种双向迭代器是一个内置类型，不能从类派生而来。然而，从概念上看，它确实能够继承。有些STL文件使用术语改进（refinement）来表示概念上的继承，因此，双向迭代器是对正向迭代器概念的一种改进。 概念的具体实现被称为模型（model）。因此，指向int的常规指针是一个随机访问迭代器模型，也是一个正向迭代器模型，因为它满足该概念的所有要求。 1. 将指针用作迭代器迭代器是广义指针，而指针满足所有的迭代器要求。迭代器是STL算法的接口，而指针是迭代器，因此STL算法可以使用指针来对基于指针的非STL容器进行操作。例如，可将STL算法用于数组。假设，Receipts是一个double数组，并要按升序对它进行排序： const int SIZE = 100; double Receipts[SIZE]; STL sort()函数接受指向容器第一个元素的迭代器和指向超尾的迭代器作为参数。&amp;Receipts[0]是一个元素的地址，&amp;Receipts[SIZE]是数组最好一个元素后面的元素地址。因此，下面的函数调用对数组进行排序： sort(Receipts, Receipts+SIZE); C++确保了表达式Receipts+n被定义的，只要改表达式的结果位于数组中。因此，C++支持将超尾概念用于数组，使得可以将STL算法用于常规数组。由于指针是迭代器，而算法时基于迭代器的，这使得可见STL算法用于常规数组。同样，可以将STL算法用于自己设计的数组形式，只要提供适当的迭代器（可以是指针，也可以是对象）和超尾指示器即可。 copy()、ostream_iterator和istream_iterator STL提供了一些预定义迭代器。为了解其中的原因，这里首先介绍一些背景知识。有一种算法（名为copy()）可以将数据从一个容器复制到另一个容器中。这种算法是以迭代器方式实现的，所以它可以从一种容器到另一种容器进行复制，甚至可以在数组之间复制，因此可以将指向数组的指针用作迭代器。例如，下面的代码将一个数组复制到另一个矢量中： int casts[10] ={6,7,8,9,1,2,34,10,12,13}; vector&lt;int&gt; dice[10]; copy(casts, casts+1-, dice.begin(); copy()的前两个迭代器参数表示要复制的范围，最好一个迭代器参数表示要将第一个元素复制到什么位置。前两个参数必须是（或最好是）输入迭代器，最好一个参数必须是（或最好是）输出迭代器。copy()函数将覆盖目标中已有的数据，同时目标容器必须足够大，以便能够容纳被复制的元素。因此，不能使用copye()将数据放到空矢量中——至少，如果不采用本章后面较少的技巧，则不能这样做。 现在，假设要将信息复制到显示器上。如果有一个表示输出流的迭代器，则可以使用copy()。STL为这种迭代器提供了ostream_iterator模板。用STL的话说，该模板是输出迭代器概念的一个模型，它也是一个适配器（adapter）——一个类或函数，可以将一些其他接口转换为STL使用的接口。可以通过包含头文件iterator并作下面的声明来创建这种迭代器： #include &lt;iterator&gt; ... ostream_iterator&lt;int, char&gt; out_iter(cout, &quot; &quot;); out_ iter迭代器现在是一个接口，让您能够使用cout来显示消息。第一个模板参数（这里为int）指出了被发送给输出流的数据类型；第二个模板参数（这里为char）指出了输出流使用的字符类型（另一个可能的值是wchar_t）。构造函数的第一个参数（这里为cout）指出了要使的输出流，它也可以用于文件输出流（参见第17章）；最后一个字符串参数是在发送给输出流的每个数据像后显示的分隔符。 可以这样使用迭代器： *out_iter++ = 15; //工作类似于： cout&lt;&lt; 15 &lt;&lt; &quot; &quot;; 对于常规指针，这意味着将15赋给指针指向的位置，然后将指针加1。但对于该ostream_iterator，这意味着将15和空格组成的字符串发送给cout管理的输出流中，并为下一个输出操作做好了准备。可以将copy()用于迭代器，如下所示： copy(dice.begin(), dice.end(), out_iter); //复制矢量到输出流中 这意味着将dice容器的整个区间复制到输出流中，即显示容器的内容。 也可以不创建命名的迭代器，而直接构造一个匿名迭代器。即可以这样使用适配器： copyt(dcie.begin(), dice.end(), ostream_iterator&lt;int, char&gt;(cout, &quot; &quot;)); iterator头文件还定义了一个istream_iterator模板，使istream输入可用作迭代器接口。它是一个输入迭代器概念的模型，可以使用两个istream_iterator对象来定义copy()的输入范围： copye(istream_iterator&lt;int, char&gt;(cin), istream_iterator&lt;int, char&gt;(), dice.begin()); 与ostream_iterator相似，istream_oterator也是用两个模板参数。第一个参数指出要读取数据类型，第二个参数指出输入流使用的字符类型。使用构造函数参数cin意味者使用由cin管理的输入流，省略构造函数参数表示输入失败，因此上述代码从输入流中读取，直到文件结尾、类型不匹配或出现其他输入故障为止。 2. 其他有用的迭代器除了ostream_iterator和istream_iterator之外，头文件iterator还提供了其他一些专用的预定义迭代器类型。它们是reverse_iterator、back_insert_iterator、frond_insert_iterator和insert_iterator。 我们先来看reverse_iterator的功能。对reverse_iterator执行递增操作将导致它被递减。为什么不直接对常规迭代器进行递减呢？主要原因是为了简化对已有的函数的使用。假设要显示dice容器的内存，正如刚才介绍的，可以使用copy()和ostream_iterator来将内容复制到输出流中： ostream_iterator&lt;int, char&gt; out_iter(cout, &quot; &quot;); copy(dice.begin(), dice.end(), out_iter); 现在假设要反向打印容器的内容。有很多方法都不管用，但与其在这里耽误功夫，不如来看看能够完成这种任务的方法。vector类有一个名为rbegin()的成员函数和一个名为rend()的成员函数，前者返回一个指向超尾的反向迭代器，后者返回一个指向第一个元素的反向迭代器。因为对迭代器执行递增操作将导致它被递减，所以可以使用下面的语句来反向显示内容： copy(dice.rbegin(), dice.rend(), out_iter); 甚至不必声明反向迭代器。 注意：rbegin()和end()返回相同的值（超尾），但类型不同（reverse_iterator和iterator）。同样，rend()和begin()也返回相同的值（指向第一个元素的迭代器），但类型不同。 必须对反向指针做一种特殊补偿。假设rp是一个被初始化为dice.rbeing()的反转指针。那么$\ast$rp是什么呢？因此rbegin()返回超尾，因此不能对该地址进行解除引用。同样，如果rend()是第一个元素的位置，则copy()必须提早一个位置停止，因为区间的结尾处不包括在区间中。 反向指针通过先递减，再解除引用解决了这两个问题。即$\ast$rp将在$\ast$rp的当前值之前对迭代器执行解除引用。也就是说，如果rp指向位置6，则$\ast$rp将是位置5的值，依次类推。程序16.10演示了如何使用copy()、istream迭代器和反向迭代器。 该程序16.10 copyit.cpp #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; int main() { using namespace std; int casts[10] = {6,7,2,9,4,11,8,7,10,5}; vector&lt;int&gt; dice(10); copy(casts, casts+10, dice.begin()); cout &lt;&lt; &quot;Let the dice be cast!\n&quot;; ostream_iterator&lt;int, char&gt; out_iter(cout, &quot; &quot;); copy(dice.begin(), dice.end(), out_iter); cout &lt;&lt; endl; cout &lt;&lt; &quot;Implicit use of reverse iterator.\n&quot;; copy(dice.rbegin(), dice.rend(), out_iter); cout &lt;&lt; endl; cout &lt;&lt; &quot;Explicit use of reverse iterato.\n&quot;; vector&lt;int&gt;::reverse_iterator ri; for (ri = dice.rbegin(); ri != dice.rend(); ++ri) cout &lt;&lt; *ri &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0; } 输出： Let the dice be cast! 6 7 2 9 4 11 8 7 10 5 Implicit use of reverse iterator. 5 10 7 8 11 4 9 2 7 6 Explicit use of reverse iterato. 5 10 7 8 11 4 9 2 7 6 如果可以在显式声明迭代器和使用STL函数来处理内部问题（如通过将rbegin()返回值传递给函数）之间做选择，请采用后者。后一种方法要做的工作比较少，人文出错的机会也较少。 另外三种迭代器（back_insert_iterator, front_insert_iterator和insert_iterator）也将提供STL算法的通用性。很多STL函数都与copy()相似，将结果发送到输出迭代器执行的位置。前面说过，下面的语句将值赋值到从dice.begin()开始的位置： copy(casts, casts+10, dice.begin()); 这些值将覆盖dice中以前的内容，且该函数假设dice有足够的空间，能够容纳这些值，即copy()不能自动根据发送值调整目标容器的长度。程序16.10考虑到了这种情况，将dice声明为包含10个元素。然而，如果预先不知道dice的长度，该如何办呢？或者要将元素添加到dice中，而不是覆盖已有的内容，又该如何办呢？ 三种插入迭代器通过将复制转换为插入解决了这些问题。插入将添加新的元素，而不会覆盖已有的数据，并使用自动内存分配来确保能够容纳新的信息。back_ insert_ iterator将元素插入到容器尾部，而front_ insert_ iterator将元素插入到容器的前端。最后，insert_ iterator将元素插入到insert_ iterator构造函数指定的位置前面。这三个插入迭代器都是输出容器概念的模型。 这里存在一些限制。back_ insert_ iterator只能用于允许在尾部快速插入的容器（快速插入指的是一个时间固定的算法，将在本章后面的“容器很概念”一节做进一步的讨论），vector类符合这种要求。front_ insert_ iterator只能用于允许在起始位置做时间固定插入的容器类型，vector类不能满足这种要求，但queue满足。insert_ iterator没有这些限制，因此可以用它把信息插入到矢量的前端。然而，front_ insert_iterator对于哪些支持它的容器来说，完成任务的速度更快。 提示：可以用insert_iterator将复制数据的算法转换为插入输入的算法。 这些迭代器将容器类型作为模板参数，将实际容器标识符作为构造函数参数。也就是说，要为名为dice的vector容器创建一个back_ insert_ iterator，可以这样做： back_insert_iterator&lt;vector&lt;int&gt; back_iter(dice); 必须声明容器类型的原因是，迭代器必须使用合适的容器方法。back_ insert_ iterator的构造函数将假设传递给它的类型有一个push_ back()方法。copy()是一个独立的函数，没有重新调整容器大小的权限。但前面的声明让back_ iter能够使用方法vector::push_back()，该方法有这样的权限： 声明front_ insert_iterator的方式与此相同。对于insert _iterator声明，还需一个指示插入位置的构造函数参数： insert_iterator&lt;vector&lt;int&gt;&gt; insert_iter(dice, dice.begin()); 程序16.11演示了这两种迭代器的用法，还是用for_each()而不是ostream迭代器进行输出。 程序16.11 inserts.cpp #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; void output(const std::string &amp; s) { std::cout &lt;&lt; s &lt;&lt; &quot; &quot;; } int main() { using namespace std; string s1[4] = {&quot;fine&quot;, &quot;fish&quot;, &quot;fashion&quot;, &quot;fate&quot;}; string s2[2] = {&quot;busy&quot;,&quot;bats&quot;}; string s3[2] = {&quot;silly&quot;, &quot;singers&quot;}; vector&lt;string&gt; words(4); copy(s1, s1+4, words.begin()); for_each(words.begin(), words.end(), output); cout &lt;&lt; endl; copy(s2, s2+2, back_insert_iterator&lt;vector&lt;string&gt; &gt; (words)); for_each(words.begin(), words.end(), output); cout &lt;&lt; endl; copy(s3, s3+2, insert_iterator&lt;vector&lt;string&gt; &gt; (words, words.begin())); for_each(words.begin(), words.end(), output); cout &lt;&lt; endl; return 0; } 输出： fine fish fashion fate fine fish fashion fate busy bats silly singers fine fish fashion fate busy bats 第一个copy()从s1中复制4个字符串到words中。这之所以可行，在某种程度上说是由于words被声明为能够存储4个字符串，这等于被复制的字符串数目。然后，back_ insert_ iterator将s2中的字符串插入到words数组的末尾，将words的长度增加到6个元素。最后，insert_ iterator将s3中的两个字符串插入到words的第一个元素的前面，将word的长度增加到8个元素。如果程序试图使用words.end()和words.begin()作为迭代器，将s2和s3复制到wrods中，words将没有空间来存储型数据，程序可能会由于内存违规而异常终止。 如果您被这些迭代器搞晕，则请记住，主要使用就会熟悉它们。另外还请记住，这些预定义迭代器提高了STL算法的通用性。因此，copy()不仅可以将信息从一个容器复制到另一个容器，还可以将信息从容器复制到输出流，从输入流复制到容器中。还可以使用copy()将信息插入到另一个容器中。因此使用同一个函数可以完成很多工作。copy()只是是使用输出迭代器的若干STL函数之一，因此这些预定义迭代器也增加了这些函数的功能。 16.4.5 容器种类STL具有容器概念和容器类型。概念是具有名称（如容器、序列容器、关联容器等）的通用类别；容器类型是可用于创建具体容器对象的模板。以前的11个容器类型分别是deque、list、queue、priority_queue、stack、vector、map、multimap、set、multiset和bitset（本章不讨论bitset，它是在比特级处理数据的容器）；C++新增了forward _list、unordered _map、unordered _multimap、unordered _set和unordered _multiset，且不将bitset视为容器，而将其视为一种独立的类别。因为概念对类型进行了分类，下面先讨论它们。 1. 容器概念没有与基本容器概念相对应的类型，但概念描述了所有容器类都通用的元素。它是一个概念化的抽象基类——说它概念化，是因为容器类并不真正使用继承机制。换句话说，容器概念指定了所有STL容器类都必须满足的一系列要求。 容器是存储其他对象的对象。被存储的对象必须是同一种类型，它们可以是OOP意义上的对象，也可以是内置类型值。存储在容器中的数据为容器所有，这意味着当容器过期时，存储在容器中的数据也将过期（然而，如果数据是指针的话，则它指向的数据并不一定过期）。 不能将任何类型的对象存储在容器中，具体来说，类型必须是可复制构造的和可赋值的。基本类型满足这些要求；主要类定义没有将赋值运算符和复制构造函数声明为私有或保护的，则也满足这种要求。C++11改进了这些概念，添加了术语可复制插入（CopyInsertable）和可移动插入（MoveInsertable），但这里只进行简单的概述。 基本容器不能保证其元素按特定的顺序存储，也不能保证元素的顺序不变，但对概念进行改进后，则可以增加这样的保证。所有的容器都提供某些特征和操作。表16.5对一些通用特征进行了总结。其中，X表示容器类型，如vector；T表示存储在容器中的对象类型；a和b表示类型为X的值；r表示类型为X&amp;的值；u表示类型为X的标识符（即如果X表示vector），则u是一个vecot对象）。 表16.5中的“复杂度”一列描述了执行操作所需的时间。这个表列出了3种可能性，从快到慢依次为： 编译时间 固定时间 线性时间 如果复杂度为编译时间，则操作将在编译时执行，执行时间为0。固定复杂度意味着操作发生在运行阶段，但独立于对象种的元素数目。线性复杂度意味着时间与元素数目成正比。即如果a和b都是容器，则a==b具有线性复杂度，因此==操作必须用于容器种的每个元素。实际上，这是最糟糕的情况。如果两个容器的长度不同，则不需要作任何单独比较。 固定时间和线性时间复杂度 假设有一个装满大包裹的狭长盒子，包裹一字排开，而盒子只有一端是打开的。假设任务是从打开的一端取出一个包裹，则这将是一项固定时间任务。不管在打开的一端后面有10个还是1000个包裹，都没有区别。 现在假设任务是取出盒子中没有打开的一端的那个包裹，则这将是线性时间任务。如果盒子里有10个包裹，则必须取出10个包裹才能拿到封口端的那个包裹；如果有100个包裹，则必须取出100个包裹。假设有一个不知疲倦的工人来做，每次只能取出1个包裹，则需要取10次或更多。 现在假设任务是取出任意一个包裹，则可能取出第一个包裹。然而，通常必须移动的包裹数目仍旧与容器中包裹的数目成正比，所以这种任务依然是线性时间复杂度。 如果盒子各边都可以打开，而不是狭长的，则这种任务的复杂度将是固定的，因为可以直接取出想要的包裹，而不用移动其他的包裹。 时间复杂度概念描述了容器长度对执行时间的影响，而忽略了其他因素。如果超人从一端开打的黑车中取出包裹的速度比普通人快100倍，则他完成任务时，复杂度仍然是线性时间的。在这种情况下，他取出封闭盒子中包裹（一端打开，复杂度为线性时间）的速度比普通人取出开放盒子中包裹（复杂度为固定时间）要快，条件是盒子里没有太多的包裹。 复杂度要求是STL特征，虽然实现细节可以隐藏，但性能规格应公开，以便程序员能够直到完成特定操作的计算成本。 2. C++11新增的容器要求表16.6列出了C++11新增的通用容器要求。在这个表中，rv表示类型为X的非常量右值，如函数的返回值。另外，在表16.5中，要求X::iterator满足正向迭代器的要求，而以前只要求它不是输出迭代器。 复制构造函数和赋值以及移动构造和移动赋值之间的差别在于，复制操作保留源对象，而移动操作可修改源对象，还可能转让所有权，而不做任何复制。如果源对象是临时的，移动操作的效率将高于常规复制。第18章将更详细地介绍移动语义。 30. 序列可以通过添加要求来改进基本的容器概念。序列（sequence）是一个重要的改进，因此7种STL容器类型（deque、C++新增的forward_ list、queue、list、priority_queue、stack和vector）都是序列（本书前面说过，队列让您能够在队尾添加元素，在队首删除元素。deque表示的双端队列允许在两端添加和删除元素）。序列概念增加了迭代器至少是正向迭代器这样的要求，这保证了元素将按特定顺序排序，不会在两次迭代之间发生变化。array也被归类到序列容器，虽然它并不满足序列的所有要求。 序列还要求其元素按严格的线性顺序排列，即存在第一个元素、最后一个元素，除第一个元素和最后一个元素外，每个元素前后都分别有一个元素。数组和链表都是序列，但分支结构（其中每个节点都指向两个子节点）不是。 因为序列种的元素具有确定的顺序，因此可以执行诸如将值插入到特定位置、删除特定区间等操作。表16.7列出了这些操作以及序列必须完成的其他操作。该表格使用的表示法与表16.5相同，此外，t表示类型为T（存储在容器种的值的类型）的值，n表示整数，p、q、i和j表示迭代器。 因为模板类deque、list、queue、priority_queue、stack和vector都是序列概念的模型，所以它们都支持表16.7所示的运算符。除此之外，这6个模型中的一些还可使用其他操作。在允许的情况下，它们的复杂度为固定时间。表16.8列出了其他操作。 表16.8有些需要说明的地方。首先，a[n]和a.at(n)都返回一个指向容器中第n个元素（从0开始编号）的引用。它们之间的差别在于，如果n落在容器的有效区间外，则a.at(n)将执行边界检查，并引发out_of _range异常。其次，可能有人会问，为何list和deque定义了push _front()，而没有为vector定义？假设要将一个新值插入到包含100个元素的矢量的最前面。要腾出空间，必须将第99个元素移动到位置100，然后把第98个元素移动到位置99，依次类推。这种操作的复杂度是线性时间，因此移动100个元素所需的时间为移动为移动单个元素的100倍。但表16.8的操作被假设为仅当其复杂度为固定时间才被实现。链表和双端队列的设计被允许将元素添加到前端，而不用移动其他元素，所以它们可以以固定时间的复杂度来实现push _front()。图16.4说明了push _front()和push_back()。 下面详细介绍这7中序列容器类型。 （1）vector 前面介绍了多个使用vector模板的例子，该模板是在vector头文件中声明的。简单地说，vector是数组的一种类表示，它提供了自动内存管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。 除序列外，vector还是可反转容器（reversible container）概念的模型。这增加了两个方法：rbegin()和rend()，前者返回一个指向方针序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。因此，如果dice是一个vector容器，而Show(int)是显示一个整数的函数，则下面的代码将首先正向显式dice的内容，然后反向显式： for_each(dice.begin(), dice.end(), Show()); cout &lt;&lt; endl; for_each(dice.rbegin(), dice.end(), Show(); cout &lt;&lt; endl; 这两种方法返回的迭代器都是类级类型reverse_iterator。对这样的迭代器进行递增，将导致它反向遍历可反转容器。 vector模板类是最简单的序列类型，除非其他类型的特殊优点能够更好地满足程序的要求，否则应默认使用这种类型。 (2) deque deque模板类（在头文件deque头文件中声明）表示双端队列（double-ended queue），通常被简称为deque。在STL中，其实现类似于vector容器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删除元素的时间是固定的，而不像vector中那样是线性时间的。所以，如果多数操作发生在序列的起始位置和结尾处，则应考虑使用deque数据结构。 为实现在deque双端执行插入和删除操作的时间为固定的这一目的，deque对象的设计比vector对象更为复杂。因此，尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入和删除操作，但vector容器执行这些操作时速度更快些。 (3) list list模板类（在list头文件中声明）表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素相链接，这意味着可以双向遍历链表。list和vector之间关键的区别在于，list在链表中任一位置进行插入和删除的时间都是固定的（vector模板提供了除结尾外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。 与vector相似，list也是可以反转容器。与vector不同的是，list不支持数组表示法和随机访问。与矢量迭代器不同，从容器中插入或删除之后，链表迭代器指向元素将不变。我们来解释一下这句话。例如，假设有一个指向vector容器第5个元素的迭代器，并在容器的起始位置插入一个元素。此时，必须移动其他所有元素，以便腾出位置，因此插入后，第5个元素包含的值将是第4个元素的值。因此，迭代器指向的位置不变，但数据不同。然后，在链表中插入新元素并不会移动已有的元素，而只是修改链表信息。指向某个元素的迭代器仍然指向该元素，但它链接的元素可能与以前不同。 除序列和可反转容器的函数外，list模板还包含了链表专用的成员函数。表16.9列出了其中一些（有关STL方法和函数的完整列表，请参见附录G）。通常，不必担心Alloc模板参数，因为它有默认值。 程序16.12 list.cpp #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;iterator&gt; #include &lt;algorithm&gt; void outint(int n) { std::cout &lt;&lt; n &lt;&lt; &quot; &quot;; } int main() { using namespace std; list&lt;int&gt; one(5, 2); int stuff[5] = {1, 2, 4, 8, 6}; list&lt;int&gt; two; two.insert(two.begin(), stuff, stuff + 5); int more[6] = {6, 4, 2, 4, 6, 5}; list&lt;int&gt; three(two); three.insert(three.end(), more, more + 6); cout &lt;&lt; &quot;List one: &quot;; for_each(one.begin(), one.end(), outint); cout &lt;&lt; endl &lt;&lt; &quot;List two: &quot;; for_each(two.begin(), two.end(), outint); cout &lt;&lt; endl &lt;&lt; &quot;List three: &quot;; for_each(three.begin(), three.end(), outint); three.remove(2); cout &lt;&lt; endl &lt;&lt; &quot;List three minus 2s: &quot;; for_each(three.begin(), three.end(), outint); three.splice(three.begin(), one); cout &lt;&lt; endl &lt;&lt; &quot;List three after splice: &quot;; for_each(three.begin(), three.end(), outint); cout &lt;&lt; endl &lt;&lt; &quot;List one: &quot;; for_each(one.begin(), one.end(), outint); three.unique(); cout &lt;&lt; endl &lt;&lt; &quot;List three after uniqut: &quot;; for_each(three.begin(), three.end(), outint); three.sort(); three.unique(); cout &lt;&lt; endl &lt;&lt; &quot;List three after sort &amp; unique: &quot;; for_each(three.begin(), three.end(), outint); two.sort(); three.merge(two); cout &lt;&lt; endl &lt;&lt; &quot;Sorted two merged into three: &quot;; for_each(three.begin(), three.end(), outint); cout &lt;&lt; endl; return 0; } 输出： List one: 2 2 2 2 2 List two: 1 2 4 8 6 List three: 1 2 4 8 6 6 4 2 4 6 5 List three minus 2s: 1 4 8 6 6 4 4 6 5 List three after splice: 2 2 2 2 2 1 4 8 6 6 4 4 6 5 List one: List three after uniqut: 2 1 4 8 6 4 6 5 List three after sort &amp; unique: 1 2 4 5 6 8 Sorted two merged into three: 1 1 2 2 4 4 5 6 6 8 8 （4）程序说明 程序16.12中使用了for_each()算法和outint()函数来显式列表。在C++11中也可以使用基于范围的for循环： for (auto x : three) cout &lt;&lt; x &lt;&lt; &quot; &quot;; insert()和splice()之间的区别在于：insert()将原始区间的副本插入到目标地址，而splice()则将原始区间移动到目标地址。因此，在one的内容与three合并后，one为空。（splice()方法还有其他原型，用于移动单个元素和元素区间）。splice()方法执行后，迭代器仍有效。也就是说，如果将迭代器设置为指向one中的元素，则在splice()将它重新定位到元素three后，该迭代器仍然指向相同的元素。 注意，unique()只能将相邻的相同值压缩为单个值。程序执行three.unique()后，three中人包含不相邻的两个4和两个6。但应用sort()后再应用unique()时，每个值将只占一个位置。 还有非成员sort()函数(程序16.9)，但它需要随机访问迭代器。因此快速插入的代价是放弃随机访问功能，所以不能将非成员函数sort()用于链表。因此，这个类中包括了一个只能在类中使用的成员版本。 (5) list工具箱 list方法组成了一个方便的工具箱。例如，假设有两个邮件列表要整理，则快车对每个列表进行排序，合并它们，然后使用unique()来删除重复的元素。 sort()、merge()、unique()方法还各自拥有接受另一个参数的版本，该参数用于指定用来比较元素的函数。同样，remove()方法也有一个接受另一个参数的版本，该参数用于指定用来确定是否删除元素的函数。这些参数都是谓词函数，将稍后介绍。 (6) forward _ lsit(C++11) C++新增了容器类forward_ list，它实现了单向链表。在这种链表中，每个节点都只有链接到下一个节点，而没有链接到前一个节点。因此，forward_ list只需要正向迭代器，而不需要双向迭代器。因此，不同于vector和list，forward_ lsit是不可反转的容器。相比于list，forward_ list更简单、更紧凑，但功能也更少。 (7) queue queue模板类（在头文件queue中声明）是一个适配器类。由前所述，ostream_ iterator模板就是一个适配器，让输出流能够使用迭代器接口。同样，queue模板让底层类（默认为deque）展示典型的队列接口。 queue模板的限制比deque更多。它不仅不允许随机访问队列元素，甚至不允许遍历队列。它把使用限制在定义队列的基本操作上，可以将元素添加到队尾、从对首删除元素、查看队首和队尾的值、检查元素数目和测试队列是否为空。表16.10列出了这些操作。 注意，pop()是一个删除数据的方法，而不是检索数据的方法。如果要使用队列中的值，应首先使用front()来检索这个值，然后使用pop()将它从队列中删除。 (8) priority _ queue priority_ queue模板类（在queue头文件中）是另一个适配器，它支持的操作与queue相同。两者之间的主要区别在于，在priority_ queue中，最大的元素被移到队首（生活不总是公平的，队列也一样）。内部区别在于，默认的底层类是vector。可以修改用于确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数： priority_queue&lt;int&gt; pq1; //默认版本 priority_queue&lt;int&gt; pq2(greater&lt;int&gt;); //使用greater&lt;int&gt;来排序 greater&lt;&gt;()函数是一个预定义的函数对象，本章稍后介绍它。 (9) stack 与queue相似，stack(在头文件stack中声明)也是一个适配器，它给底层类（默认情况下为vector）提供了典型的栈接口。 stack模板的限制比vector更多。它不仅不允许随机访问栈元素，甚至不允许遍历栈。它把使用限制在定义栈的基本操作上，即可以将压入推到栈顶、从栈顶弹出元素、查看栈顶的值、检查元素数目和测试栈是否为空。表16.11列出了这些操作。 与queue相似，如果要使用栈中的值，必须首先使用top()来检索这个值，然后使用pop()将它从栈中删除。 (10) array(c++11) 第四章介绍过，模板类array是在头文件array中定义的，它并非STL容器，因为其长度是固定的。因此，array没有定义调整容器大小的操作，如push_ back()和insert()，但定义了对它来说有意义的成员函数，如operator[] ()和at()。可将很多标准STL算法用于array对象，如copy()和for_ each()。 16.4.4 关联容器关联容器（associative container）是对容器概念的另一个改进。关联容器将值和键关联在一起，并使用键来查找值。例如，值可以是表示雇员信息（如姓名、地址和电话号码等）的结构，而键可以是唯一的员工编号。为获取雇员信息，程序将使用键查找雇员结构。前面说过，对于容器X，表达式X::value_ type通常指出了存储在容器中的值类型。对于关联容器来说，表达式X::key_ type指出了键的类型。 关联容器的优点在于，它过提供了对元素的快速访问。与序列相似，关联容器也允许插入新元素，但不能指定元素的插入位置。原因是关联容器通常有用于确定数据放置位置的算法，以便能够快速检索信息。 关联容器通常是使用某种树实现的。树是一种数据结构，其根节点链接到一个或两个节点，而这些节点又连接到一个或两个节点，从而行程分支结构。像链表一样，节点使得添加和删除数据项比较简单；但相对于链表，树的查找速度更快。 STL提供了4中关联容器：set、multiset、map和multimap。前两种是在头文件set中定义的，而后两种是在头文件map中定义的。 最简单的关联容器是set，其值类型与键相同，键是唯一的，这意味着集合中不会有多个相同的键。确实，对于set来说，值就是键。mutltiset类似于set，只是可能有多个值的键相同。例如，如果键和值的类型为int，则multiet对象的内容可以是1、2、2、2、3、5、7、7。 在map中，值与键的类型不同，键是唯一的，每个键只能对应一个值。multimap与map相似，只是一个键可以与多个值关联。 有关这些类型的信息很多，无法在本章全部列出（但附录G列出了方法），这里值介绍一个使用set的简单例子和一个使用multimap的简单例子。 1. set示例STL set模拟了多个概念，它是关联集合，可反转，可排序，且键是唯一的，所以不能存储多个相同的值。与vector和list相似，set也使用模板参数来指定要存储的值类型。 set&lt;string&gt; A; 第二个模板参数是可选的，可用于指示用来对键进行排序的比较函数或对象。默认情况下，将使用模板less&lt;&gt;(稍后将讨论)。老式C++实现可能没有提供默认值，因此必须显式指定模板参数： set&lt;string, less&lt;string&gt; &gt; A; 请看下面的代码： const int N = 6; string s1[N] = {&quot;buffoon&quot;, &quot;thinkers&quot;, &quot;for&quot;, &quot;heavy&quot;, &quot;can&quot;, &quot;for&quot;}; set&lt;string&gt; A(s1, s2 + N); ostream_iterator&lt;string, char&gt; out(cout, &quot; &quot;); copy(A.begin(), A.end(), out); 与其他容器相似，set也有一个将迭代器区间作为参数的构造函数（参见表16.6）。这提供了一种将集合初始化为数组内容的简单方法。请记住，区间的最后一个元素是超尾，s1+N指向数组s1尾部后面的一个位置。上述代码片段的输出表明，键是唯一的（字符串“for”在数组中出现了次，但在集合中只出现1次），且集合被排序： buffoon can for heavy thinkers 数学为集合定义了一些标准操作，例如，并集包含两个集合合并后的内容。如果两个集合包含相同的值，则这个值将在并集中只出现一次，这是因为键是唯一的。交集包含两个集合都有的元素。两个集合的差是第一个集合减去两个集合都有的元素。 STL提供了支持这些操作的算法。它们都是通用函数，而不是方法，因此并非只能用于set对象。然而，所有set对象都自动满足使用这些算法的先决条件，即容器是经过排序的。set_ union()函数接受5个迭代器。前两个迭代器定义了第一个集合的区间，接下来的两个定义了第二个集合区间，最后一个迭代器是输出迭代器，指出键结果集合复制到什么位置。例如，要显示集合A和B的并集，可以这样做： set_union(A.begin(), A.end(), B.begin(), B.end(), ostream_iterator&lt;string, char&gt; out(cout, &quot; &quot;)); 函数set_ intersection()和set_ difference()分别查找交集和获得两个集合的差，它们的接口与set_ union()相同。 两个有用的set方法是lower_ bound()和upper_ bound()。方法lower_ bound()将键作为参数并返回一个迭代器，该迭代器指向集合中第一个不小于键参数的成员。同样，方法upper_ bound()将键作为参数，并返回一个迭代器，该迭代器指向集合中第一个大于键参数的成员。例如，如果有一个字符串集合，则可以用这些方法获得一个这样的区间，即包含集合中从“b”到“f”的所有字符串。 因此排序决定了插入的位置，所以这种类包含只指定要插入的信息，而不指定位置的插入方法。例如，如果A和B是字符串集合，则可以这样做： string s(&quot;tennis&quot;); A.insert(s); //插入一个值 B.insert(A.begin(), A.end()); //插入一个范围 程序16.13 setops.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;algorithm&gt; #include &lt;iterator&gt; int main() { using namespace std; const int N = 6; string s1[N] = {&quot;buffon&quot;, &quot;thinkers&quot;, &quot;for&quot;, &quot;heavy&quot;, &quot;can&quot;, &quot;for&quot;}; string s2[N] = {&quot;metal&quot;, &quot;any&quot;, &quot;food&quot;, &quot;elegant&quot;, &quot;deliver&quot;, &quot;for&quot;}; set&lt;string&gt; A(s1, s1+N); set&lt;string&gt; B(s2, s2+N); ostream_iterator&lt;string, char&gt; out(cout, &quot; &quot;); cout &lt;&lt; &quot;Set A: &quot;; copy(A.begin(), A.end(), out); cout &lt;&lt; endl; cout &lt;&lt; &quot;Set B: &quot;; copy(B.begin(), B.end(), out); cout &lt;&lt; endl; cout &lt;&lt; &quot;Union of A and B:\n&quot;; set_union(A.begin(), A.end(), B.begin(), B.end(), out); cout &lt;&lt; endl; cout &lt;&lt; &quot;Intersection of A and B:\n&quot;; set_intersection(A.begin(), A.end(), B.begin(), B.end(), out); cout &lt;&lt; endl; cout &lt;&lt; &quot;Difference of A and B:\n&quot;; set_difference(A.begin(), A.end(), B.begin(), B.end(), out); cout &lt;&lt; endl; set&lt;string&gt; C; cout &lt;&lt; &quot;Set C:\n&quot;; set_union(A.begin(), A.end(), B.begin(), B.end(), insert_iterator&lt;set&lt;string&gt; &gt; (C, C.begin())); copy(C.begin(), C.end(), out); cout &lt;&lt; endl; string s3(&quot;grungy&quot;); C.insert(s3); cout &lt;&lt; &quot;Set C after insertion:\n&quot;; copy(C.begin(), C.end(), out); cout &lt;&lt; endl; cout &lt;&lt; &quot;Showing a range:\n&quot;; copy(C.lower_bound(&quot;ghost&quot;), C.upper_bound(&quot;spook&quot;), out); cout &lt;&lt; endl; return 0; } 输出： Set A: buffon can for heavy thinkers Set B: any deliver elegant food for metal Union of A and B: any buffon can deliver elegant food for heavy metal thinkers Intersection of A and B: for Difference of A and B: buffon can heavy thinkers Set C: any buffon can deliver elegant food for heavy metal thinkers Set C after insertion: any buffon can deliver elegant food for grungy heavy metal thinkers Showing a range: grungy heavy metal 和本章中大多数示例一样，程序16.13在处理名称空间std时采用了偷懒得方式： using namespace std; 这样做旨在简化表达方式。这些示例使用了名称空间std中非常多得元素，如果使用using声明或作用域运算符，代码将变得混乱： std::set&lt;std::string&gt; B(s2, s2+N); std::ostream_iterator(std::string, char&gt; out(std::cout, &quot; &quot;); std::cout &lt;&lt; &quot;Set A: &quot;; std::copy(A.begin(), A.end(), out); 2. multimpa示例与set相似，multimap也是可反转得、经过排序的关联容器，但键和值的类型不同，且同一个键可能与多个值相关联。 基本的multimap声明使用模板参数指定键的类型和存储的值类型。例如，下面的声明创建一个multimap对象，其中键类型为int，存储的值类型为string： multimap&lt;int, string&gt; codes; 第三个模板参数是可选的，指出用于对键进行排序的比较函数或对象。在默认情况下，键使用模板less&lt;&gt;，该模板将键类型作为参数。老式C++实现可能要求显式指定该模板参数。 为将信息结合在一起，实际的值类型将键类型和数据类型结合为一对。为此，STL使用模板类pair将这两种值存储到一个对象中。如果keytype是键类型，而datatype是存储的数据类型，则值类型为pari。例如，前面声明的codes对象的值类型为pair。 例如，假设要用区号作为键来存储城市名。（这恰好与codes声明一致，它将键类型声明为int，数据类型声明为string），则一种方法是创建一个pair，再将它插入： pair&lt;const int, string&gt; item(213, &quot;Los Angeles&quot;); codes.insert(item); 也可以使用一条语句创建匿名pair对象并将它插入： codes.insert(pair&lt;const int, string&gt; (213, &quot;Los Angeles&quot;)); 因为数据项是按键排序的，所以不需要指出插入位置。 对于pair对象，可以使用first和second成员来访问其两个部分了： pair&lt;const int, string&gt; item(213, &quot;Lost Angeles&quot;); cout &lt;&lt; item.first &lt;&lt; &quot; &quot; &lt;&lt; item.second &lt;&lt; endl; 如何获得有关multimap对象的信息呢？成员函数count()接受键作为参数，并返回具有该键的元素数目。成员函数lower_ bound()和upper_ bound()将键作为参数，且工作原理与处理set时相同。成员函数equal_ range()用键作为参数，且返回两个迭代器，它们表示的区间与该键匹配。为返回两个值，该方法将它们封装在一个pair对象中，这里pair的两个模板参数都是迭代器。例如，下面的代码打印codes对象中区号为718的所有城市： pair&lt;multimap&lt;KeyType, string&gt;::iterator, multimap&lt;KeyType, string&gt;::iterator&gt; range = codes.equal_range(718); cout &lt;&lt; &quot;Cities with area code 718:\n&quot;; std::multimap&lt;KeyType, std::string&gt;::iterator it; for(it = range.first; it != range.second; ++it) cout &lt;&lt; (*it).second &lt;&lt; endl; 在声明中可使用C++11自动类型推断功能，这样代码将简化为如下所示： auto range = codes.equal_range(718); cout &lt;&lt; &quot;Cities with area code 718:\n&quot;; for (auto it = range.first; it != range.second; ++it) cout &lt;&lt; (*it).second &lt;&lt; endl; 程序16.14演示了上述大部分技术，它也使用 typedef来简化代码。 程序16.14 multimap.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; typedef int KeyType; typedef std::pair&lt;const KeyType, std::string&gt; Pair; typedef std::multimap&lt;KeyType, std::string&gt; MapCode; int main() { using namespace std; MapCode codes; codes.insert(Pair(415, &quot;San Francisco&quot;)); codes.insert(Pair(510, &quot;Oakland&quot;)); codes.insert(Pair(718, &quot;Brooklyn&quot;)); codes.insert(Pair(718, &quot;Staten Islan&quot;)); codes.insert(Pair(414, &quot;San Rafael&quot;)); codes.insert(Pair(510, &quot;Berkeley&quot;)); cout &lt;&lt; &quot;Number of cities with area code 415: &quot; &lt;&lt; codes.count(415) &lt;&lt; endl; cout &lt;&lt; &quot;Number of cities with area code 718: &quot; &lt;&lt; codes.count(718) &lt;&lt; endl; cout &lt;&lt; &quot;Number of cities with area code 510: &quot; &lt;&lt; codes.count(510) &lt;&lt; endl; cout &lt;&lt; &quot;Area Code City\n&quot;; MapCode::iterator it; for (it = codes.begin(); it != codes.end(); it++) cout &lt;&lt; &quot; &quot; &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl; pair&lt;MapCode::iterator, MapCode::iterator&gt; range = codes.equal_range(718); cout &lt;&lt; &quot;Cities with area code 718:\n&quot;; for (it = range.first; it != range.second; it++) cout &lt;&lt; (*it).second &lt;&lt; endl; return 0; } 输出： Number of cities with area code 415: 1 Number of cities with area code 718: 2 Number of cities with area code 510: 2 Area Code City 414 San Rafael 415 San Francisco 510 Oakland 510 Berkeley 718 Brooklyn 718 Staten Islan Cities with area code 718: Brooklyn Staten Islan 16.4.5 无序关联容器（C++11）无序关联容器是对容器概念的另一种改进。与关联容器一样，无序关联容器也将值与键关联起来，并使用键来查找值。但底层的差别在于，关联容器是基于树结构的，而无序关联容器是基于数据结构哈希表的，这旨在提供添加和删除元素的速度以及提供查找算法的效率。有4种无序关联容器，它们是： unordered _set, unordered _multiset, unordered _map和unordered _multimap，将在附录G种详细地介绍。 16.5 函数对象很多STL算法都使用函数对象——也叫函数符（functor）。函数符是可以以函数方式与()结合使用的任意对象。这包括函数名、指向函数的指针和重载了()运算符的类对象（即定义了函数operator()()的类）。例如，可以像这样定义一个类： class Linear { private: double slope; double y0; public: Linear(double s1_ = 1, double y_ = 0) : slope(s1_), y0(y_) {} double operator() (double) { return y0 + slope * x; } }; 这样，重载的()运算符将使得能够像函数那样使用Linear对象： Linear f1; Linear f2(2.5, 10.0); Linear y1 = f1(2.5); double y2 = f2(0.4); 其中y1将使用表达式0+1$\ast$12.5来计算，y2将使用10.0+2.5$\ast$0.4来计算。在表达式y0+slope$\ast$x中，y0和slope的值来自对象的构造函数，而x的值来自operator()()的参数。 还记得函数for_each()吗？它将指定的函数用于区间中的每个成员： for_each(books.begin(), books.end(), ShowReview); 通常，第3个参数可以是常规函数，也可以是函数符。实际上，这提出了一个问题：如何声明第3个参数呢？不能把它声明为函数指针，因为函数指针指定了参数类型。由于容器可以包含任意类型，所以预先无法知道应使用哪种参数类型。STL通常使用模板解决了这个问题。for_each的原型看上去就像这样： template&lt;class InputIterator, class Function&gt;; Function for_each(InputIterator first, InputIterator last, Function f); ShowReview()的原型如下： void ShowReview(cosnt Review &amp;); 这样，标识符ShowReview的类型将为void($\ast$)(const Review &amp;)，这也是赋给模板参数Function的类型。对于不同的函数调用，Function参数可以表示具有重载的()运算符的类类型。最后，for _each()代码将具有一个使用f()的表达式。在ShowReview()示例中，f是指向函数的指针，而f()调用该函数。如果最后的for _each()参数是一个对象，则f()将是调用其重载的()的运算符的对象。 16.5.1 函数符概念正如STL定义了容器和迭代器的概念一样，它也定义了函数符概念。 生成器（generator）是不用参数就可以调用的函数符。 一元函数（unary function）是用一个参数可以调用的函数符。 二元函数（binary function）是用两个参数可以调用的函数符。 例如，提供给for_each()的函数符相当是一元函数，因为它每次用于一个容器元素。 当然，这些概念都有相应的改进版： 返回bool值的一元函数是谓词（predicate）; 返回bool值的二元函数是二元谓词（binary predicate）。 一些STL函数需要谓词参数或二元谓词参数。例如，程序16.9使用了sort()的这样一个版本，即将二元谓词作为其第3个参数： bool WorseThan(const Review &amp; r1, const Review &amp; r2); ... sort(books.begin(), books.end(), WorseThan); list模板有一个将谓词作为参数的remove_if()成员，该函数将谓词应用于区间中的每个元素，如果谓词返回true，则函数这些元素。例如，下面的代码删除链表three中所有大于100的元素： bool tooBie(int n) { return n &gt; 100; } list&lt;int&gt; scores; ... scores.remove_if(tooBig); 最后这个例子演示了类函数符适用的地方。假设要删除另一个链表中所有大于200的值。如果能将取舍值作为第二个参数传递给tooBig()，则可以使用不同的值调用该函数，但谓词智能有一个参数。然而，如果设计一个TooBig类，则可以使用类成员而不是函数参数来传递额外的信息： template&lt;class T&gt; class TooBig { private: T cutoff; public: TooBig(const T &amp; t) : coutoff(t) {} bool operator()(const T &amp; v) { return v &gt; cutoff; } }; 这里，一个值（V）作为函数参数传递，而第二个参数（cutoff）是由类构造函数设置的。有了该定义后，就可以将不同的TooBig对象初始化为不同的取舍值，供调用remove_if()时使用。程序16.15演示了这种技术。 程序16.15 functor.cpp #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;iterator&gt; #include &lt;algorithm&gt; template&lt;class T&gt; class TooBig { private: T cutoff; public: TooBig(const T &amp; t) : cutoff(t) {} bool operator() (const T &amp; v) { return v &gt; cutoff; } }; void outint(int n) { std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;} int main() { using std::list; using std::cout; using std::endl; TooBig&lt;int&gt; f100(100); int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; list&lt;int&gt; yadayada(vals, vals+10); list&lt;int&gt; etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; cout &lt;&lt; &quot;Original lists:\n&quot;; for_each(yadayada.begin(), yadayada.end(), outint); cout &lt;&lt; endl; for_each(etcetera.begin(), etcetera.end(), outint); cout &lt;&lt; endl; yadayada.remove_if(f100); etcetera.remove_if(TooBig&lt;int&gt;(200)); cout &lt;&lt; &quot;Trimmed lists:\n&quot;; for_each(yadayada.begin(), yadayada.end(), outint); cout &lt;&lt; endl; for_each(etcetera.begin(), etcetera.end(), outint); cout &lt;&lt; endl; return 0; return 0; } 输出： Original lists: 50 100 90 180 60 210 415 88 188 201 50 100 90 180 60 210 415 88 188 201 Trimmed lists: 50 100 90 60 88 50 100 90 180 60 88 188 一个函数符（f100）是一个声明的对象，而另一个函数符TooBig(200)是一个匿名对象，它是有构造函数调用创建的。 假设已经有了一个接受两个参数的模板参数： template&lt;class T&gt; bool tooBig(const T &amp; val, const T &amp; lim) { return val &gt; lim; } 则可以使用类将它转换为单个参数的函数对象： template &lt;class T&gt; class TooBig2 { private: T cutoff; public: TooBig2(const T &amp; t) : cutoff(t) {} bool operator()(const T &amp; v) { return tooBig&lt;T&gt; (v, cutoff);} }; 即可以这样做： TooBig&lt;int&gt; tB100(100); int x; cin &gt;&gt; x; if (tB100(x)) ... 因此，调用tB100(x)相当于调用tooBig(x, 100)，但有两个参数的函数被转换为单参数的函数对象，其中第二个参数被用于构建函数对象。简而言之，类函数符TooBig2是一个函数适配器，使函数能够满足不同的接口。 在程序中，可使用C++11的初始化列表功能来简化初始化。为此，可将如下代码： int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; list&lt;int&gt; yadayada(vals, vals+10); list&lt;int&gt; etcetera(vals, vals+10); 替换为下述代码： list&lt;int&gt; yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; list&lt;int&gt; etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; 16.5.2 预定义的函数符STL定义了多个基本函数符，它们执行诸如将两个值相加、比较两个值是否相等操作。提供这些函数对象是为了支持函数作为参数的STL函数。例如，考虑函数transform()。它有两个版本。第一个版本接受4个参数，前两个参数是指定容器区间的迭代器（现在您应该已熟悉了这种方法），第3个参数是指定将结构复制到哪里的迭代器，最后一个参数是一个函数符，它被应用于区间中的每个元素，生成结果中的新元素。例如，请看下面的代码： const int LIM = 5; double arr1[LIM] = {36, 39, 42, 45, 48}; vector&lt;double&gt; gr8(arr1, arr1+LIM); ostream_iterator&lt;double, char&gt; out(cout, &quot; &quot;); transform(gr8.begin(), gr8.end(), out, sqrt); 上述代码计算每个元素的平方根，并将结果发送到输出流。目标迭代器可以位于原始区间中。例如，将上述示例中的out替换为gr8.begin()后，新值将覆盖原来的值。很明显，使用的函数符必须接受单个参数的函数符。 第2个版本使用一个接受两个参数的函数，并将该函数用于两个区间中元素。它用另一个参数（即第3个）标识第二个区间的起始位置。例如，如果m8是另一个vector对象，mean(double, double)返回两个值的平均值，则下面的代码将输出来自gr8和m8的值的平均值： transform(gr8.begin(), gr8.end(), m8.begin(), out, mean); 现在假设要将两个数组相加。不能将+作为参数，所以对于类型double来说，+是内置的运算符，而不是函数，可以定义一个将两个数相加的函数，然后使用它： double add(double x, double y) { return x + y; } ... transform(gr8.begin(), gr8.end(), m8.begin(), out, add); 然而，这样必须为每种类型单独定义一个函数。更好的办法是定义一个模板（除非STL已经有一个模板了，这样就不必定义）。头文件functional定义了多个模板类函数对象，其中包括plus&lt;&gt;()。 可以用plus&lt;&gt;来完成常规的相加运算： #include &lt;functional&gt; ... plus&lt;double&gt; add; double yy = add(2.3, 3.4); 它使得将函数对象作为参数很方便： transform(gr8.begin(), gr8,end(), m8.begin(), out, plus&lt;double&gt;()); 这里代码没有创建命名的对象，而是用plus构造函数构造了一个函数符，以完成相加运算（括号表示调用默认构造函数，传递给transform()的是构造出来的函数对象）。 对于所有内置的算术运算符、关系运算符和逻辑运算符，STL都提供了等价的函数符。表16.12列出了这些函数符的名称。它们可以用于处理C++内置类型或任何用户定义类型（如果重载了相应的运算符）。 警告: 老式C++实现使用函数符名times，而不是multiplies。 16.5.3 自适应函数符和函数适配器表16.12列出了预定义函数符都是自适应的。实际上，STL有5个相关的概念：自适应生成器（adaptable generator）、自适应一元函数（adaptable unary function）、自适应二元函数（adaptable binary function）、自适应谓词（adaptabl predicate）和自适应二元谓词（adaptable binary predicate)。 使函数符成为自适应的原因是，它携带了标识符参数类型和返回类型的typedef成员。这些成员分别是result_ type、first_ argument_ type和second_ argument_ type，它们的作用是不言自明的。例如，plus对象的返回类型被表示为plus::result_ type，这是int的typedef。 函数符自适应的意义在于：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。例如，接受一个自适应函数符参数的函数可以使用result_ type成员来声明一个与函数的返回类型匹配的变量。 STL提供了使用这些工具的函数适配器类。例如，假设要将矢量gr8的每个元素都增加2.5倍，则需要使用接受一个一元函数参数的transform()版本，就像前面的例子那样： transform(gr8.begin(), gr8.end(), out, sqrt); multiplies()函数符可以指定乘法运算，但它是二元函数，因此需要一个函数适配器，将接受两个参数的函数转换为接受一个参数的函数符。前面的TooBig2示例提供了一种方法，但STL使用binder1st和binder2nd类自动完成这一过程，它们将自适应二元函数转换为自适应一元函数。 来看binder1st。假设有一个自适应二元函数对象f2()，则可以创建一个binder1st对象，该对象与一个被用作f2()第一个参数的特定值（val）相关联： binder1st(f2, val) f1; 这样，使用单个参数调用f1(x)时，返回的值与将val作为第一个参数、将f1()的参数作为第二个参数调用f2()返回的值相同。即f1(x)等价于f2(val, x)，只是前者是一元函数，而不是二元函数。f2()函数被适配。同样，仅当f2()是一个自适应函数时，这才能实现。 看上去有点麻烦。然而，STL提供了函数bind1st()，以简化binder1st类的使用。可以访问其提供用于构建binder1st对象的函数名称和值，它将返回一个这种类型的对象。例如，要将二元函数multiplies()转换为将参数乘以2.5的一元函数，则可以这样做： bind1st(multiplies&lt;double&gt;(), 2.5); 因此，将gr8中的每个元素与2.5相乘，并显式结果的代码如下： transform(gr8.begin(), gr8.end(), out, bind1st(multiplies&lt;double&gt;(), 2.5)); binder2nd类与此类似，只是将常量赋给第二个参数，而不是第一个参数。它有一个名为bind2nd的助手函数，该函数的工作方式类似于bind1st。 程序16.16将一些最近的示例合并成了一个小程序。 程序16.16 funadap.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;iterator&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; void Show(double); const int LIM = 6; int main() { using namespace std; double arr1[LIM] = {28, 29, 30, 35, 38, 59}; double arr2[LIM] = {63, 65, 69, 75, 80, 99}; vector&lt;double&gt; gr8(arr1, arr1+LIM); vector&lt;double&gt; m8(arr2, arr2+LIM); cout.setf(ios_base::fixed); cout.precision(1); cout &lt;&lt; &quot;gr8:\t&quot;; for_each(gr8.begin(), gr8.end(), Show); cout &lt;&lt; endl; cout &lt;&lt; &quot;m8: \t&quot;; for_each(m8.begin(), m8.end(), Show); cout &lt;&lt; endl; vector&lt;double&gt; sum(LIM); transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(), plus&lt;double&gt;()); cout &lt;&lt; &quot;sum:\t&quot;; for_each(sum.begin(), sum.end(), Show); cout &lt;&lt; endl; vector&lt;double&gt; prod(LIM); transform(gr8.begin(), gr8.end(), prod.begin(), bind1st(multiplies&lt;double&gt;(), 2.5)); cout &lt;&lt; &quot;pord:\t&quot;; for_each(prod.begin(), prod.end(), Show); cout &lt;&lt; endl; return 0; } void Show(double v) { std::cout.width(6); std::cout &lt;&lt; v &lt;&lt; &apos; &apos;; } 输出： gr8: 28.0 29.0 30.0 35.0 38.0 59.0 m8: 63.0 65.0 69.0 75.0 80.0 99.0 sum: 91.0 94.0 99.0 110.0 118.0 158.0 pord: 70.0 72.5 75.0 87.5 95.0 147.5 C++提供了函数指针和函数符的替代品——lambda表达式，这将在第18章讨论。 16.6 算法STL包含很多处理容器的非成员函数，前面接受过其中的一些：sort()、copy()、find()、random_ shuffle()、 set_ union()、set_ intersection()、set_ difference()和transform()。可能已经注意到，它们的总体设计是相同的，都是用迭代器来标识要处理的数据区间和结果的放置位置。有些函数还接受一个函数对象参数，并使用它来处理数据。 对于算法函数设计，有两个主要的同样部分。首先，它们都是用模板来提供泛型；其次，它们都是用迭代器来提供访问容器中数据的通用表示。因此，copy()函数可用于将double值存储在数组中的容器、就string值存储在链表中的容器，也可用于将用于定义的对象存储在树结构中（如set所使用）的容器。因此指针是一种特殊的迭代器，因此诸如copy()等STL函数可用于常规数组。 统一的容器设计使得不同类型的容器之间具有明显关系。例如，可以使用copy()将常规数组中的值复制到vector对象中，将vector对象中的值复制到list对象中，将list对象中的值复制到set对象中。可以用==来比较不同类型的容器，如deque和vector。之所以能够这样做，是因为容器重载的==运算符使用迭代器来比较内容，因此如果deque对象和vector对象的内容相同，并且排序顺序也相同，则它们是相等的。 16.6.1 算法组STL将算法库分成4组： 非修改式序列操作； 修改式序列操作； 排序和相关操作； 通用数字运算。 前3组在头文件algorithm中描述，第4组是用专用于数值数据的，有自己的头文件，成为numeric。 非修改方式序列操作对区间中的每个元素进行操作。这些操作不修改容器的内容。例如，find()和for_each()就属于这一类。 修改式序列操作也对区间中的每个元素进行操作。然而，顾名思义，它们可以修改容器的内容。可以修改值，也可以修改值得排序顺序。transform()、random_ shuffle()和copy()属于这一类。 排序和相关操作包括多个排序函数（包括sort()）和其他各种函数，包括集合操作。 数字操作包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此vector是最有可能使用这些操作的容器。 16.6.2 算法的通用特征正如您多次看到的，STL函数使用迭代器和迭代器区间。从函数原型可知有关迭代器的假设。例如，copy()函数的原型如下： template&lt;class InputIterator, class OutputIterator&gt; OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result); 因为标识符InputIterator和OutputIterator都是模板参数，所以它们就像T和U一样。然而，STL文档使用模板参数名称来表示参数模型的概念。因此上述声明告知我们，区间参数必须是输入迭代器或更高级别的迭代器，而指示结果存储位置的迭代器必须是输出迭代器或更高级别的迭代器。 对算法进行分类的方式之一是按结果位置的位置进行分类。有些算法就地完成工资，有些则创建拷贝。例如，在sort()函数完成时，结果被存放在原始数据的位置上，因此sort()是就地算法（in-place algorithm）；而copy()函数将结果发送到另一个位置，所以它是复制算法（copying algorithm）。transform()函数可以以这两种方式完成工作。与copy()相似，它使用输出迭代器指示结果的存储位置；与copy()不同的是，transform()允许输出迭代器指向输入区间，因此它可以用计算结果覆盖原来的值。 有些算法有两个版本：就地版本和复制版本。STL的约定是，复制版本的名称将以_copy结尾。复制版本将接受一个额外的输出迭代器参数，该参数指定结果的放置位置。例如，函数replace()的原型如下； template&lt;class ForwardIterator, class T&gt; void replace(ForwardIterator first, ForwardIterator last, const T &amp; old_value, const T &amp; new_value); 它将所有的old_ value替换为new_value，这是就地发生的。由于这种算法同时读写容器，因此迭代器类型必须是ForwardIterator或更高级的。复制版本的原型如下： template&lt;class InputIterator, class OutputIterator, class T&gt; OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T &amp; old_value, const T &amp; new_value); 在这里，结果被复制到result指定的新位置，因此对于指定区间而言，只读输入迭代器就足够了。 注意replace_copy()的返回类型为OutputIterator。对于复制算法，统一的约定是：返回一个迭代器，该迭代器指向复制的最后一个值后面的一个位置。 另一个常见的变体：有些函数有这样的版本，即根据将函数应用于容器元素得到的结果来执行操作。这些版本的名称通常以_ if结尾的。例如，如果将函数用于旧值时，返回的值为true，则replace_if()将把旧值替换为新的值。下面是该函数的原型： template&lt;class ForwardIterator, class Predicate, class T&gt; void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp; new_value); 如前所述，谓词是返回bool值的一元函数。还有一个replace_copy _if()版本，您不难知道其作用和原型。 与InputIterator一样，Predicate也是模板参数名称，可以为T或U。然而，STL选择用Predicate来提醒用户，实参应模拟Redicate概念。同样，STL使用诸如Generatro和BinaryPredicate等术语来指示必须模拟其他函数对象概念的参数。请记住，虽然文档可指出迭代器或函数符需求，但编译器不会对此进行检查。如果您使用了错误的迭代器，则编译器试图实例化，将显式大量的错误信息。 16.6.3 STL和string类string类虽然不是STL的组成部分，但设计它时考虑到了STL。例如，它包含begin()、end()、rbegin()和rend()等成员，因此可以使用STL接口。程序16.17用STL显示了一个词的字母可以得到的所有排列组合。排列组合就是重新安排容器中元素的顺序。next_permutation()算法将区间内容转换为下一种排列方式。对于字符串，排列按照字母递增的顺序进行。如果成功，该算法返回true；如果区间已经处于最后的序列中，则该算法返回false。要得到区间内容的所有排列组合，应从最初的顺序开始，为此程序使用了STL算法sort()。 程序16.17 strgst1.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; int main() { using namespace std; string letters; cout &lt;&lt; &quot;Enter the letter grouping (quit to quit):&quot;; while (cin &gt;&gt; letters &amp;&amp; letters != &quot;quit&quot;) { cout &lt;&lt; &quot;Permutations of &quot; &lt;&lt; letters &lt;&lt; endl; sort(letters.begin(), letters.end()); cout &lt;&lt; letters &lt;&lt; endl; while (next_permutation(letters.begin(), letters.end())) cout &lt;&lt; letters &lt;&lt; endl; cout &lt;&lt; &quot;Enter next squence (quit to quit): &quot;; } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： Enter the letter grouping (quit to quit):awl Permutations of awl alw awl law lwa wal wla Enter next squence (quit to quit): all Permutations of all all lal lla Enter next squence (quit to quit): quit Done. 注意，算法next_permuatation()自动提供唯一的排列组合，这就是输出中“awl”一词的排列组合比“all”的排列组合要多的原因。 16.6.4 函数和容器方法有时可以选择使用STL方法或STL函数。通常方法是更好的选择。首先，它更适合于特定的容器；其次，作为成员函数，它可以使用模板类的内存管理工具，从而在需要时调整容器的长度。 例如，假设有一个有数字组成的链表，并要删除链表中某个特定值（例如4）的所有实例。如果la是一个list对象，则可以使用链表的remove()方法： la.remove(4); 调用该方法后，链表中所有值为4的元素都将被删除，同时链表的长度将被自动调整。 还有一个名为remove()的STL算法（见附录G），它不是由对象调用，而是接受区间参数。因此，如果lb是一个list对象，则调用函数的代码如下： remove(lb.begin(), lb.end(), 4); 然而，由于该remove()函数不是成员，因此不能调整链表的长度。它将没被删除的元素放在链表的开始位置，并返回一个指向新的超尾值得迭代器。这样，便可以用该迭代器来修改容器的长度。例如，可以使用链表的erase()方法来删除一个区间，该区间描述了链表中不再需要的部分。程序16.18演示了这是如何进行的。 程序16.18 listmv.cpp #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;algorithm&gt; void Show(int); const int LIM = 10; int main() { using namespace std; int ar[LIM] = {4, 5, 4, 2, 2, 3, 4, 8, 1, 4}; list&lt;int&gt; la(ar, ar+LIM); list&lt;int&gt; lb(la); cout &lt;&lt; &quot;Original list contents:\n\t&quot;; for_each(la.begin(), la.end(), Show); cout &lt;&lt; endl; la.remove(4); cout &lt;&lt; &quot;After using the remove() method:\n&quot;; cout &lt;&lt; &quot;la:\t&quot;; for_each(la.begin(), la.end(), Show); cout &lt;&lt; endl; list&lt;int&gt;::iterator last; last = remove(lb.begin(), lb.end(), 4); cout &lt;&lt; &quot;After using the remove() function:\n&quot;; cout &lt;&lt; &quot;lb:\t&quot;; for_each(lb.begin(), lb.end(), Show); cout &lt;&lt; endl; lb.erase(last, lb.end()); cout &lt;&lt; &quot;After using the erase() method:\n&quot;; cout &lt;&lt; &quot;lb:\t&quot;; for_each(lb.begin(), lb.end(), Show); cout &lt;&lt; endl; return 0; } void Show(int v) { std::cout &lt;&lt; v &lt;&lt; &apos; &apos;; } 输出： 4 5 4 2 2 3 4 8 1 4 After using the remove() method: la: 5 2 2 3 8 1 After using the remove() function: lb: 5 2 2 3 8 1 4 8 1 4 After using the erase() method: lb: 5 2 2 3 8 1 从中可知，remove()方法将链表la从10个元素减少到6个元素。但对链表lb应用remove()后，它仍然包含10个元素。最后4个元素可任意处理，因此其中每个元素要么是4，要么与已经移到链表开头的值相同。 尽管方法通常更合适，但非方法函数更通用。正如您看到的，可以将它们用于数组、string对象、STL容器，还可以用它们来处理混合的容器类型，例如，将矢量容器中的数据存储到链表或集合中。 16.5.5 使用STLSTL是一个库，其组成部分被设计成协同工作。STL组件是工具，但也是创建其他工具的基本部件。我们用一个例子说明。假设要编写一个程序，让用户输入单词。希望最后得到一个按输入顺序排列的单词列表、一个按字母顺序排列的单词列表（忽略大小写），并记录每个单词被输入的次数。出于简化的目的，假设输入中不包含数字和标点符号。 输入和保存单词列表很简单。可以按程序16.8和程序16.9那样创建一个vector对象，并用push_back()将输入的单词添加到矢量中： vector&lt;string&gt; words; string input; while (cin &gt;&gt; input &amp;&amp; input != &quot;quit&quot;) words.push_back(input); 如何得到按字母顺序排列的单词列表呢？可以使用sort()，然后使用unique()，但这种方法将覆盖原始数据，因为sort()是就地算法。有一种更简单的方法，可以避免这种问题：创建一个set对象，然后将矢量中的单词复制（使用插入迭代器）到集合中。集合自动对齐内容进行排序，因此无需调用sort()；集合只允许同一个键出现一次，因此无需调用unique()。这里要求忽略大小写，处理这种情况的方法之一是使用transform()而不是copy()，键矢量中的数据复制到集合中。使用一个转换函数键字符串换成小写形式。 set&lt;string&gt; wordset; transform(words.begin(), words.end(), insert_iterator&lt;set&lt;string&gt; &gt; (wordset, wordset.begin()), ToLower); ToLower()函数很容易编写，只需使用transform()将tolower()函数应用于字符串中的各个字符，并将字符串用作源和目标。记住，string对象也可以使用STL函数。将字符串按引用传递和返回意味着算法不必复制字符串，而可以直接操作原始字符串。下面是函数ToLower()的代码实现: string &amp; ToLower(string &amp; st) { transform(st.begin(), st.end(), st.begin(), tolower); return st; } 一个可能出现的问题是：tolower()函数被定义为int tolower(int)，而一些编译器希望函数与元素类型（即char）匹配。一种解决方法是，使用toLower代替tolower，并提供下面的定义： char toLower(char ch) { return tolower(ch); } 要获得每个单词在输入中出现的次数，可以使用count()函数。它将一个区间和一个值作为参数，并返回这个值在区间中出现的次数。可以使用vector对象来提供区间，并使用set对象来提供要计算其出现次数的单词列表。即对于集合中的每个词，都计算它在矢量中出现的次数。要将单词与其出现的次数关联起来，可将单词和计数作为pair对象存储在map对象中。单词将作为键（只出现一次），计数作为值。这可以通过一个循环来完成： map&lt;string, int&gt; wordmap; set&lt;string&gt;::iterator si; for(si = wordset.begin(); si ！= wordset.end(); si++) wordmap.insert(pair&lt;string, int&gt;(*si, count(words.begin(), words.end(), *si))); map类有一个有趣的特征：可以用数组表示法（将键用作索引）来访问存储的值。例如，wordmap[“the”]表示与键”the”相关联的值，这里是字符串“the”出现的次数。因为wordset容器保存了wordmap使用的全部键，所以可以用下面的代码来存储结构，这是一种更具有吸引力的方法： for(si = wordset.begin(); si != wordset.end(); si++) wordmap[*si] = count(words.begin(), words.end(), *si); 因为si指向wordset容器中的一个字符串，所以$\ast$si是一个字符串，可以用作wordmap的键。上述代码将键和值放到wordmap映像中。 同样，也快成使用数组表示法来报告结果： for(si = wordset.begin(); si != wordset.end(); si++) cout &lt;&lt; *si &lt;&lt; &quot;: &quot; &lt;&lt; wordmap[*si] &lt;&lt; endl; 如果键无效，则对应的值将为0。 程序16.19把这些想法组合在一起，同时包含了用于显示3个容器（包含输入内容的矢量、包含单词列表的集合和包含单词计数的映象）内容的代码。 程序16.19 usealgocpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;iterator&gt; #include &lt;algorithm&gt; #include &lt;cctype&gt; using namespace std; char toLower(char ch) { return tolower(ch); } string &amp; ToLower(string &amp; st); void display(const string &amp; s); int main() { vector&lt;string&gt; words; cout &lt;&lt; &quot;Enter words (enter quit to quit):\n&quot;; string input; while (cin &gt;&gt; input &amp;&amp; input != &quot;quit&quot;) words.push_back(input); cout &lt;&lt; &quot;You entered the following words:\n&quot;; for_each(words.begin(), words.end(), display); cout &lt;&lt; endl; set&lt;string&gt; wordset; transform(words.begin(), words.end(), insert_iterator&lt;set&lt;string&gt; &gt; (wordset, wordset.begin()), ToLower); cout &lt;&lt; &quot;\n Alphabetic list of words:\n&quot;; for_each(wordset.begin(), wordset.end(), display); cout &lt;&lt; endl; map&lt;string, int&gt; wordmap; set&lt;string&gt;::iterator si; for (si = wordset.begin(); si != wordset.end(); si++) wordmap[*si] = count(words.begin(), words.end(), *si); cout &lt;&lt; &quot;\n Word frequency:\n&quot;; for (si = wordset.begin(); si != wordset.end(); si++) cout &lt;&lt; *si &lt;&lt; &quot; &quot; &lt;&lt; wordmap[*si] &lt;&lt; endl; return 0; } string &amp; ToLower(string &amp; st) { transform(st.begin(), st.end(), st.begin(), toLower); return st; } void display(const string &amp; s) { cout &lt;&lt; s &lt;&lt; &quot; &quot;; } 输出： Enter words (enter quit to quit): The dog saw the cat and thought the cat fat The cat thought the cat perfect quit You entered the following words: The dog saw the cat and thought the cat fat The cat thought the cat perfect Alphabetic list of words: and cat dog fat perfect saw the thought Word frequency: and 1 cat 4 dog 1 fat 1 perfect 1 saw 1 the 5 thought 2 这里的寓意在于，使用STL时应可能减少要编写的代码。STL通用、灵活的设计将节省大量工作。另外，STL设计者就非常关心效率的算法人员，算法是经过仔细选择的，并且是内联的。 16.7 其他库C++还提供了其他一些类库，它们比本章前面讨论的例子更为专用。例如，头文件complex为复数提供了类模板complex，包含用于float、long和long double的具体化。这个类提供了标准的复数运算及能够处理复数的标准函数。C++11新增的头文件random提供了更多的随机数功能。 第14章介绍了头文件valarray提供的模板类valarray。这个类模板被设计成用于表示数值数组，支持各种数值数组操作，例如将两个数组的内容相加、对数组的每个元素应用数学函数以及对数组进行线性代数运算。 16.7.1 vector、valarray和arry您可能会问，C++为何提供三个数组模板：vector、valarray和array。这些类是由不同的小组开发的。，用于不同的目的。vector模板类是一个容器类和算法系统的一部分，它支持面向容器的操作，如排序、插入、重新排序、搜索、将数据转移到其他容器。而valarray类模板是面向数值计算的，不是STL的一部分。例如，它没有push_back()和insert()方法，但为很多数学运算提供了简单、直观的接口。最后，array是为替代内置数组而设计，它通过提供更好、更安全的接口，让数组更紧凑，效率更高。Array表示长度固定的数组，因此不支持push _back()和insert()，但提供了多个STL方法，包括begin()、end()、rbegin()和rend()，这使得很容易将STL算法用于array对象。 例如，假设有如下声明： vector&lt;double&gt; ved1(10),ved(10),ved3(10); array&lt;double, 10&gt; vod1, vod2, vod3; valarray&lt;double&gt; vad1(10), vad2(10), vad3(10); 同时，假设ved1、ved2、vod1、vod2、vad1和vad2都有合适的值。要将两个数组中第一个元素的和赋给第三个数组的第一个元素，使用vector类时，可以这样做： transform(ved1.begin(), ved1.end(), ved2.begin(), ved3.begin(), plus&lt;double&gt;()); 对于array类，也可以这样做： transform(vod1.begin(), vod1.end(), vod2.begin(), vod3.begin(), plus&lt;double&gt;()); 然而，valarray类重载了所有算术运算符，使其能够用于valarray对象，因此您可以这样做： vad3 = vad1 + vad2; 同样，下面的语句将使vad1和vad2中相应元素的乘积： vad3 = vad1 * vad2; 要将数组中每个元素的值扩大2.5倍，STL方法如下： transform(ved3.begin(), ved3.end(), ved3.begin(), bind1st(multiplies&lt;double&gt;(), 2.5); valarry类重载了将valarry对象乘以一个值的运算符，还重载了各种组合赋值运算符，因此可以采取下列两种方法之一： vad3 = 2.5 * vad3; vad3 *= 2.5; 假设您要计算数组中每个元素的自然对数，并将计算结果存储到另一个数组的相应元素中，STL方法如下： transform(ved1.begin(), ved1.end(), ved3.begin(), log); valarray类重载了这种数学函数，使之接受一个valarray参数，并返回一个valarray对象，因此您可以这样做： vad3 = log(vad1); 也可以使用apply()方法，该方法也适用于非重载函数： vad3 = vad1.appley(log); 方法apply()不修改调用函数，而是返回一个包含结果的新对象。 执行多步计算时，valarry接口的简单性将更为明显： vad3 = 10.0 * ((vad1 + vad2) / 2.0 + vad1 * cos(vad2)); 有关使用STL vector来完成上述计算的代码留给您去完成。 valarray类还提供了方法sum()（计算valarray对象中所有元素的和）、size()（返回元素数）、max()（返回最大的元素值）和min()（返回最小的元素值）。 正如您看到的，对于数学运算而言，valarray类提供了比vector更清晰的表达方式，但通用性更低。valarray类确实有一个resize()方法，但不能像使用vector的push_back时那样自动调整大小。没有支持插入、排序、搜索等操作的方法。总之，与vector类相比，valarray类关注的东西更少，但这使得他的接口更简单。 valarray的接口更简单是否意味者性能更高呢？在大多数情况下，答案是否定的。简单表示法通常是使用类似于您处理常规数组时使用的循环实现的。然而，有些硬件设计在执行矢量操作时，同时将一个数组中的值加载到一组寄存器中，然后并行地进行处理。从原则上说，valarray操作也可以实现成利用这样的设计。 可以将STL功能用于valarray对象吗？通过回答这个问题，可以快速复习一些STL原理。假设有一个包含10元素的valarray对象： valarray&lt;double&gt; vad(10); 使用数字填充该数组后，能够将STL sort()函数用于该数组吗？valarray类没有begin()和end()方法，因此不能将它们用作指定区间的参数： sort(vad.begin(), vad.end()); //错误，没有being(),end() 另外，vad是一个对象，而不是指针，因此不能像处理常规数组那样，使用vad和vad+10作为区间参数，即下面的代码不可行： sort(vad, vad+10); //错误，vad是一个对象，不是地址 但可以使用地址运算符： sort(&amp;vad[0], &amp;vad[10]); 但valarray没有定义下标超过尾部一个元素的行为。这并不一定意味着使用&amp;vad[10]不可行。事实上，使用6种编译器测试上述代码时，都是可行的；但着确实意味者可能不可行。为让上述代码不可行，需要一个不太可能出现的条件，如让数组与预留给堆的内存块相邻。然而，如果3.85亿的交易命悬于您的代码，您可能不想冒代码出问题的风险。 为解决这种问题，C++11提供了接受valarray对象作为参数的模板函数begin()和end()。因此，您将使用begin(vad)而不是vad.begin。这些函数返回的值满足STL区间需求： sort(begin(vad), end(vad)); 程序16.20演示了vector和valarray类各自的优势。它使用vector的push_back()方法和自动调整大小的功能来收集数据，然后对数字进行排序后，将它们从vector对象复制到另一个同样大小的valarray对象中，再执行一些数学运算。 程序16.20 valvect.cpp #include &lt;iostream&gt; #include &lt;valarray&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { using namespace std; vector&lt;double&gt; data; double temp; cout &lt;&lt; &quot;Enter number (&lt;=0 to quit):\n&quot;; while (cin &gt;&gt; temp &amp;&amp; temp &gt; 0) data.push_back(temp); sort(data.begin(), data.end()); int size = data.size(); valarray&lt;double&gt; numbers(size); int i; for (i = 0; i &lt; size; i++) numbers[i] = data[i]; valarray&lt;double&gt; sq_rts(size); sq_rts = sqrt(numbers); valarray&lt;double&gt; result(size); result = numbers + 2.0 * sq_rts; cout.setf(ios_base::fixed); cout.precision(4); for (i = 0; i &lt; size; i++) { cout.width(8); cout &lt;&lt; numbers[i] &lt;&lt; &quot;: &quot;; cout.width(8); cout &lt;&lt; result[i] &lt;&lt; endl; } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： Enter number (&lt;=0 to quit): 3.3 1.8 5.2 10 14.4 21.6 26.9 0 1.8000: 4.4833 3.3000: 6.9332 5.2000: 9.7607 10.0000: 16.3246 14.4000: 21.9895 21.6000: 30.8952 26.9000: 37.2730 Done. 除前面讨论的外，valarray类还有很多其他特性。例如，如果numbers是一个valarray对象，则下面的语句将创建一个bool数组，其中vool[i]被设置为numbers[i]&gt;9的值，即true或false： valarray&lt;bool&gt; vbool = numbers &gt; 9; 还有扩展的下标指定版本，来看其中的一个——slice类。slice类对象可用作数组索引，在这种情况下，它表的不是一个值而是一组值。slice对象被初始化为三个整数值：起始索引、索引数和跨距。起始索引是第一个被选中的元素的索引，索引数指出要选择多个个元素，跨距表示元素之间的间隔。例如，slice(1,4,3)创建的对象表示选择4个元素，它们的索引分别是1、4、7和10。也就是说，从起始索引开始，加上跨距得到下一个元素的索引，依次类推，直到选择了4个元素。如果varint是一个valarray对象，则下面的语句将把第1、4、7、10个元素都设置为10： varint[slice(1,4,3)] = 10; 这种特殊的下标指定功能让您能够使用一个一维valarray对象来表示二维数据。例如，假设要表示一个4行3列的数组，可以将信息存储在一个包含12个元素的valarray对象中，然后使用一个slice(0,3,1)对象作为下表，来表示元素0、1和2，即第一行。同样，下表slice(0,4,3)表示元素0、3、6和9，即第一列。程序16.21演示了slice的一些特性。 程序vslice.cpp #include &lt;iostream&gt; #include &lt;valarray&gt; #include &lt;cstdlib&gt; const int SIZE = 12; typedef std::valarray&lt;int&gt; vint; void show(const vint &amp; v, int cols); int main() { using std::slice; using std::cout; vint valint(SIZE); int i; for (i = 0; i &lt; SIZE; ++i) valint[i] = std::rand() % 10; cout &lt;&lt; &quot;Original array:\n&quot;; show(valint, 3); vint vcol(valint[slice(1,4,3)]); cout &lt;&lt; &quot;Second row:\n&quot;; show(vcol, 1); vint vrow(valint[slice(3,3,1)]); cout &lt;&lt; &quot;Second row:\n&quot;; show(vrow, 3); valint[slice(2,4,3)] = 10; cout &lt;&lt; &quot;Set last column to 10:\n&quot;; show(valint, 3); cout &lt;&lt; &quot;Set first column to sum of next two:\n&quot;; valint[slice(0,4,3)] = vint(valint[slice(1,4,3)]) + vint(valint[slice(2,4,3)]); show(valint, 3); return 0; } void show(const vint &amp; v, int cols) { using std::cout; using std::endl; int lim = v.size(); for (int i = 0; i &lt; lim; ++i) { cout.width(3); cout &lt;&lt; v[i]; if (i % cols == cols -1) cout &lt;&lt; endl; else cout &lt;&lt; &apos; &apos;; } if (lim % cols != 0) cout &lt;&lt; endl; } 输出： Original array: 3 6 7 5 3 5 6 2 9 1 2 7 Second row: 6 3 2 2 Second row: 5 3 5 Set last column to 10: 3 6 10 5 3 10 6 2 10 1 2 10 Set first column to sum of next two: 16 6 10 13 3 10 12 2 10 12 2 10 对于valarray对象（如valint）和单个int元素（如valint[1]），定义了运算符+；但正如程序16.21指出的，对于使用slice下表指定的valarray单元，如valint[slice(1,4,3)]，并没有定义运算符+。因此程序使用slice指定的元素创建一个完整的valint对象，以便能够指定加法运算符： vint(valint[slice(1,4,3)]); //使用一个基于slice的构造函数 valarray类提供了用于这种目的的构造函数。 由于元素值是使用rand(0设置的，因此不同的rand()实现将设置不同的值。 另外，使用gslice类可以表示多维下标，但上述内容应足以让您对valarray有一定了解。 16.7.2 模板initializer_list(C++11)模板initializer_list是C++新增的。您可使用初始化列表语法将STL容器初始化为一系列值： std::vector&lt;double&gt; payments {45.99, 39.23, 19.95, 89.01}; 这将创建一个包含4个元素的容器，并使用列表中的4个值来初始化这些元素。这之所以可行，是因为容器类现在包含将initializer_ list作为参数的构造函数。例如，vector包含一个键initializer_list作为参数的构造函数，因此上述声明与下面的代码等价： std::vector&lt;double&gt; payments( {45.99, 39.23, 19.95, 89.01}); 这里显式地将列表指定为构造函数参数。 通常，考虑到C++11新增的通用初始化语法，可使用表示法{}而不是()来调用类构造函数： shared_ptr&lt;double&gt; pd {new double}; 但如果类也有接受initializer_list作为参数的构造函数，这将带来问题： std::vector&lt;int&gt; vi{10}; 这将调用哪个构造函数呢？ std::vector&lt;int&gt; vi(10); //情形A std::vector&lt;int&gt; vi({10}); //情形B 答案是，如果类有接受initializer_list作为参数的构造函数，则使用语法{}将调用该构造函数。因此，在这个示例中，对应的情形是B。 所有initializer_list元素的类型都必须相同，但编译器将进行必要的转换： std::vector&lt;double&gt; payments {45.99, 39.32, 19, 89}; 在这里，由于vector的元素类型为double，因此列表的类型为initializer_list，所以19和89被转换为ddouble。 但不能进行隐式的窄化转换： std::vector&lt;itn&gt; values = {10, 8, 5.5}; //编译错误 在这里，元素类型为int，不能隐式地将5.5转换为int。 除非类要用于处理长度不同的列表，否则让它提供接受initializer_ list作为参数的构造函数没有意义。例如，对于存储固定数目值得类，您不想提供接受initializer_ list作为参数得构造函数。在下面得声明中，类包含三个数据成员，因此没有提供initializer_list作为参数的构造函数： class Position { private: int x; int y; int z; public: Position(int xx = 0, int yy = 0, int zz =0) : x(xx), y(yy), z(zz) {} ... }; 这样，使用语法{}时将调用构造函数Position(int, int, int): Position A = {20, -3}; //使用构造函数Position(10, -3, 0) 16.7.3 使用initializer_list要在代码中使用initializer_ list对象，必须包含头文件initializer_ list。这个模板类包含成员函数begin()和end()，您可使用这些函数来访问列表元素。它还包含成员函数size()，该函数返回元素数。程序16.22是一个简单的initializer_list使用的示例，它要求编译器支持C++11新增的initializer _list。 程序16.22 list.cpp #include &lt;iostream&gt; #include &lt;initializer_list&gt; double sum(std::initializer_list&lt;double&gt; i1); double average(const std::initializer_list&lt;double&gt; &amp; ri1); int main() { using namespace std; cout &lt;&lt; &quot;List 1: sum = &quot; &lt;&lt; sum({2,3,4}) &lt;&lt; &quot;, ave = &quot; &lt;&lt; average({2,3,4}) &lt;&lt; endl; std::initializer_list&lt;double&gt; dl = {1.1, 2.2, 3.3, 4.4, 5.5}; cout &lt;&lt; &quot;List 2: sum = &quot; &lt;&lt; sum(dl) &lt;&lt; &quot;, ave = &quot; &lt;&lt; average(dl) &lt;&lt; endl; dl = {16.0, 25.0, 36.0, 40.0, 64.0}; cout &lt;&lt; &quot;List 3: sum = &quot; &lt;&lt; sum(dl) &lt;&lt; &quot;, ave = &quot; &lt;&lt; average(dl) &lt;&lt; endl; return 0; } double sum(std::initializer_list&lt;double&gt; i1) { double tot = 0; for (auto p = i1.begin(); p != i1.end(); p++) tot += *p; return tot; } double average(const std::initializer_list&lt;double&gt; &amp; ri1) { double tot = 0; int n = ri1.size(); double ave = 0.0; if (n &gt; 0) { for (auto p = ri1.begin(); p != ri1.end(); p++) tot += *p; ave = tot/ n; } return ave; } 编译： g++ -std=c++11 ilist.cpp ./a.out 输出： List 1: sum = 9, ave = 3 List 2: sum = 16.5, ave = 3.3 List 3: sum = 181, ave = 36.2 程序说明可按值创建initializer_ list对象，也可按引用传递，如sum()和average()所示。这种对象本身很小，通常是两个指针（一个指向开头，一个指向末尾的下一个元素），也可能是一个指针和一个表示元素数的整数，因此采用的传递方式不会带来重大的性能影响。STL按值传递它们。 函数参数可以是initializer_list字面量，如{2，3，4}，也可以是initializer _list变量，如dl。 initializer_list的迭代器类型为const，因此您不能修改initialzer _list中的值： *dl.begin() = 22.6; //不被允许 但正如程序16.22演示的，可以将一个initializer_list赋给另一个initializer _lsit: d1 = {16.0， 25.0， 36.0， 40.0， 64.0}; //合法 然而，提供initializer_list类的初衷旨在让您能够将一系列值创建给构造函数或其他函数。 16.8 总结智能指针： auto_ptr, unique _ptr, shared _ptr 模板类：vector：（头文件vector）长度可变的数组 迭代器: begin() end() rbegin() rend() 迭代器类型： 输入迭代器、输出迭代器、正向迭代器、双向迭代器、随机访问迭代器（层次结构关系，正向迭代器包含输入迭代器和输出迭代器的功能，双向迭代器包括正向迭代器功能，随机访问迭代器具有正向迭代器的功能） 容器： 序列： 7种 deque, forward_ list, lsit, queue, priority_ queue, stack, vector vecotr 可以动态改变长度，并随机访问元素 deque 双端队列 list 双向链表 forwart_list 单链表 queue 队列 priority_queue 优先队列 最大元素被移到队首 关联容器 set 集合 键唯一， map multiset mulitmap 其他库： valarry array vector 疑问： 自适应函数符？]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--C++中的代码重用（十四）]]></title>
    <url>%2F2019%2F02%2F21%2FC%2B%2B%20Primer%20Plus--C%2B%2B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++的一个主要目的是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其一就是本身是另一个类的对象，称为包含、组合或层次化。另一种方法是使用私有或保护继承。最后，还包括类模板。 14.1 包含对象成员的类首先介绍包含对象成员的类。有一些类为表示类中的组件提供了方便的途径。下面来看一个具体的例子： 学生是什么？入学者？参加研究的人？残酷现实社会的避难者？有姓名和一系列考试分数的人？显然，最后一个定义完全没有表示出人的特征，但非常适合于简单的计算机表示。因此，让我们根据该定义来开发Student类。 将学生简化成姓名和一组考试分数后，可以使用一个包含两个成员的类来表示它：一个成员用于表示姓名，另一个成员用来表示分数。对于姓名，可以使用字符数组来表示，但这将限制姓名的长度。当然，也可以使用char指针和动态内存分配，但正如第12章指出的，这将要求提供大量的指出代码。一种更好的方法是，使用一个由他人开发好的类的对象来表示。例如，可以使用一个String类(参见第12章)或标准C++string类的对象来表示姓名。较简单的选择是使用string类，因为C++库提供了这个类的所有实现代码，且其实现更完美。要使用String类，您必须在项目中包含实现文件string1.cpp。 对于考试分数，存在类似的选择。可以使用一个定长数组，这限制了数组的长度；可以使用动态内存分配并提供大量的支持代码；也可以设计一个使用动态内存分配的类来表示该数组；还可以使用标准C++库中查找一个能够表示这种数据的类。 自己开发这样的类一点问题也没有。开发简单的版本并不那么难，因为double数组和char数组有很多相似之处，因此可以根据String类来设计表示double数组的类。 当然，如果C++库提供了合适的类，实现起来更简单。C++库确实提供了一个这样的类，它就是valarray。 14.1.1 valarray类简介valarray类是由头文件valarray支持的。顾名思义，这个类用于处理数值，它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。valarray被定义为一个模板类，以便能够处理不同的数据类型。本章后面将介绍如何定义模板类，但就现在而言，您只需知道如何使用模板类即可。 模板特性意味着声明对象时，必须指定具体的数据类型。因此，使用valarray类声明一个对象时，需要在标识符valarray后面加上一对尖括号，并在其中包含所需的数据类型： valarray&lt;int&gt; q_values; valarray&lt;double&gt; weights; 第4章介绍过vector和array类时，见过这种语法，它非常简单。这样类也用于存储数字，但它们提供的算术支持没有valarray多。 类特性意味着要使用valarray对象，需要了解这个类的构造函数和其他类方法。下面是几个使用其构造函数的例子： double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3}; valarray&lt;double&gt; v1; //一个double类型数组，长度为0 valarray&lt;int&gt; v2(8); //一个包含8个元素的int类型数组 valarray&lt;int&gt; v3&lt;10, 8&gt;; //一个包含8个元素的int类型数组，没有元素初始化为10 valarray&lt;double&gt; v4(gpa, 4); //一个包含4个元素的doublz类型数组，被初始化为gpa数组的前4个元素 从中可知，可以创建长度为零的空数组、指定长度的空数组、所有元素被初始化为指定值的数组、用常规数组中的值进行初始化的数组。在C++11中，也可使用初始化列表： valarray&lt;int&gt; v5 = {20, 32, 17, 9}; 下面这个类的一些方法： operator[]$()$：让您能够访问各个元素。 size()：返回包含的元素数。 sum()：返回所有元素的总和。 max()：返回最大的元素。 min()：返回最小的元素。 还有很多其他方法，其中一些将在第16章介绍。 14.1.1 Student类的设计至此，已经确定了Student类的设计计划：使用string对象来表示姓名，使用一个valarray来表示考试分数。那么如何设计呢？您可能想以公有的方式从这两个类派生出Student类，这将是多重公有继承。C++允许这样做，但在这里并不合适，因为学生与这些类之间不是is-a模型。学生不是姓名，也不是一组考试成绩。这里的关系是has-a，学生有姓名，也有一组考试分数。通常，用于建立has-a关系的C++技术是组合(包含)，即创建一个包含其他类对象的类。例如，可以将Student类声明为如下所示: class Student { private: string name; valarray&lt;double&gt; scores; ... }; 同样，上述类将数据成员为私有的。这意味着Student类的成员函数可以使用string和valarray类的公有接口来访问和修改name和scores对象，但在类的外面不能这样做，而只能通过Student类的公有接口访问name和score（见图14.1）。对于这种情况，通常被描述为Student类获得了其成员对象的实现，但没有继承接口。例如，Student对象使用string的实现，而不是char $\ast$name或char name[26]实现来保存姓名。但Student对象并不是天生就有使用函数string operator+=()的能力。 接口和实现 使用公有继承时，类可以继承接口，可能还有实现(基类的纯虚函数提供接口，但不提供实现)。获得接口是is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。 对于has-a关系来说，类对象不能自动获得被包含对象的接口是一件好事。例如，string类将+运算符重载为将两个字符串连接起来；但从概念上讲，将两个Student对象串接起来是没有意义的。这也是这里不使用公有继承的原因之一。另一方面，被包含的类的接口部分对新类来说可能是有意义的。例如，可能希望使用string接口中的operator&lt;()方法将Student对象按姓名进行排序，为此可以定义Student::operator&lt;()成员函数，它在内部使用函数string::Operator&lt;()。下面介绍一些细节。 14.1.3 Student示例现在需要提供Student类的定义，当然它应包含构造函数和一些用作Student类接口的方法。程序14.1是Student类的定义，其中所有构造函数都被定义为内联函数，它还提供了一些用于输入和输出的友元函数。 程序14.1 studentc.h #ifndef STUDENTC_H_ #define STUDENTC_H_ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;valarray&gt; using namespace std; class Student { private: typedef valarray&lt;double&gt; ArrayDb; string name; ArrayDb scores; ostream &amp; arr_out(ostream &amp; os) const; public: Student() : name(&quot;Null, Student&quot;), scores() {} explicit Student(const string &amp; s) : name(s), scores() {} explicit Student(int n): name(&quot;Null&quot;), scores(n) {} Student(const string &amp; s, int n) : name(s), scores(n) {} Student(const string &amp; s, const ArrayDb &amp; a) : name(s), scores(a) {} Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {} ~Student() {} double Average() const; const string &amp; Name() const; double &amp; operator[](int i); double operator[](int i) const; friend istream &amp; operator&gt;&gt;(istream &amp; is, Student &amp; stu); friend istream &amp; getline(istream &amp; is, Student &amp; stu); friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu); }; #endif 为简化表示，Student类的定义中包含下述typedef: typedef valarray&lt;double&gt; ArrayDb; 这样，在以后的代码中便可以使用ArrayDb，而不是valarray，因此类方法和友元函数可以使用ArrayDb类型。将该tyepdef放在定义的私有部分意味着可以在Student类的实现中使用它，但在Student类外面不能使用。 请注意explicit的用法： explicit Student(const string &amp; s) : name(s), scores() {} explicit Student(int n): name(&quot;Null&quot;), scores(n) {} 在本书前面讲过，可以用一个参数调用的构造函数将用作从参数类型到类类型的隐式转换函数；但这通常不是好注意。在上述第二个构造函数中，第一个参数表示数组的元素个数，而不是数组中的值，因此将一个构造函数用作int到Student的转换函数是没有意义的，所以使用explicit关闭隐式转换。如果省略该关键字，则可以编写如下所示代码： Student doh(&quot;Homer&quot;, 10); //存储&quot;Homer&quot;。并创建10个元素的数组 doh = 5; //重置name为Null，重置数组为5个元素 如果构造函数省略了explicit，则将使用构造函数调用Studnet(5)将5转换为一个临时Student，并使用”Null”来设置成员name的值。因此赋值操作将使用临时对象替换原来的doh值。使用了explicit后，编译器将认为上述赋值运算符是错误的。 C++和约束 C++包含让程序员能够限制程序结构的特性—-使用explicit防止单参数构造函数的隐式转换，使用const限制方法修改数据，等等。这样做的原因是：在编译阶段出现错误优于在运行阶段出现错误。 1. 初始化被包含的对象 构造函数全部使用您熟悉的成员初始化列表语法来初始化name和scores成员对象。在前面的一些例子中，构造函数用这种语法来初始化内置类型的成员： Queue::Queue(int qs) : qsize(qs) {} 上述代码在成员初始化列表中使用的是数据成员的名称(qsize)。另外，前面介绍的示例中构造函数还使用成员初始化列表初始化派生类对象的基类部分： hasDMA::hasDMA(const hasDMA &amp; hs) : baseDMA(hs) {} 对于继承的对象，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数。对于成员对象，构造函数则使用成员名。例如，请看程序14.3的最后一个构造函数： Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {} 因为该构造函数初始化的是成员对象，而不是继承的对象，所以在初始化列表中使用的是成员名，而不是类名。初始化列表中的每一项都调用与之匹配的构造函数，即name(str)调用构造函数string(const char $\ast$)，scores(pd, n)调用构造函数ArrayDb(const double $ast$, int)。 如果不使用初始化列表语法，情况将如何呢？C++要求在构造对象的其他部分之前，先构建继承对象的所有成员对象。因此，如果省略初始化列表，C++将使用成员对象所属类的默认构造函数。 初始化顺序 当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。例如，假设Student构造函数如下： Student(cosnt char * str, const double * pd, int n) : scores(pd, n), name(str) {} 则name成员仍将首先被初始化，因为在类定义中它首先被声明。对于这个例子来说，初始化顺序并不重要，但如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要了。 2. 使用被包含对象的接口 被包含对象的接口不是公有的，但可以在类方法中使用它。例如，下面的代码说明了如何定义一个返回学生平均分数的函数： double Student::Average() const { if (scores.size() &gt; 0) return scores.sum() / scores.size(); else return 0; } 上述代码定义了可由Student对象调用的方法，该方法内部使用了valarray的方法size()和sum()。这是因为scores是一个valarray对象，所以它可以调用valarray类的成员函数。总之，Student对象调用Student的方法，而后者使用被包含的valarray对象来调用valarray类的方法。 同样，可以定义一个使用string版本的&lt;&lt;运算符的友元函数： ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) { os &lt;&lt; &quot;Scores for &quot; &lt;&lt; stu.name &lt;&lt; &quot;:\n&quot;; ... } 因为stu.name是一个string对象，所以它将调用函数operator&lt;&lt;(ostream &amp;, const string &amp;)，该函数位于string类中。注意，operator&lt;&lt;(ostream &amp; os, const Student &amp; stu)必须是Student类的友元函数，这样才能访问name类成员。另一种方法是，在该函数中使用公有方法Name()，而不是私有数据成员name。 同样，该函数也可以使用valarray的&lt;&lt;实现来进行输出，不幸的是没有这样的实现；因此，Student类定义了一个私有辅助方法来处理这种任务: ostream &amp; Student::arr_out(ostream &amp; os) const { int i; int lim = scores.size(); if (lim &gt; 0) { for (i = 0; i &lt; lim; i++) { os &lt;&lt; scores[i] &lt;&lt; &quot; &quot;; if (i % 5 == 4) os &lt;&lt; endl; } if (i % 5 != 0) os &lt;&lt; endl; } else os &lt;&lt; &quot; empty array &quot;; return os; } 通过使用这样的辅助方法，可以将零乱的细节放在一个地方，使得友元函数的编码更为整洁： ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) { os &lt;&lt; &quot;Scores for &quot; &lt;&lt; stu.name &lt;&lt; &quot;:\n&quot;; stu.arr_out(os); return os; } 辅助函数也用作其他用户级输出函数的构建块—如果您选择提供这样的函数的话。 程序14.2是Student类的类方法文件，其中包含了让您能够使用[]运算符来访问Student对象中各项成绩的方法。 程序14.2 studentc.cpp #include &quot;studentc.h&quot; #include &lt;iostream&gt; using namespace std; double Student::Average() const { if (scores.size() &gt; 0) return scores.sum() / scores.size(); else return 0; } const string &amp; Student::Name() const { return name; } double &amp; Student::operator[](int i) { return scores[i]; } double Student::operator[](int i) const { return scores[i]; } ostream &amp; Student::arr_out(ostream &amp; os) const { int i; int lim = scores.size(); if (lim &gt; 0) { for (i = 0; i &lt; lim; i++) { os &lt;&lt; scores[i] &lt;&lt; &quot; &quot;; if (i % 5 == 4) os &lt;&lt; endl; } if (i % 5 != 0) os &lt;&lt; endl; } else os &lt;&lt; &quot; empty array &quot;; return os; } istream &amp; operator&gt;&gt;(istream &amp; is, Student &amp; stu) { is &gt;&gt; stu.name; return is; } istream &amp; getline(istream &amp; is, Student &amp; stu) { getline(is, stu.name); return is; } ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) { os &lt;&lt; &quot;Scores for &quot; &lt;&lt; stu.name &lt;&lt; &quot;:\n&quot;; stu.arr_out(os); return os; } 3. 使用新的Student类 下面编写一个小程序来测试这个Student类。出于简化的目的，该程序使用一个只包含3个Student对象的数组，其中每个对象保存5个考试成绩。另外还将使用一个不复杂的输入循环，该循环不验证输入，也不让用户中途退出。 程序14.3 use_stuc.cpp #include &quot;studentc.h&quot; #include &lt;iostream&gt; using namespace std; void set(Student &amp; sa, int n); const int pupils = 3; const int quizzes = 5; int main() { Student ada[pupils] = {Student(quizzes), Student(quizzes), Student(quizzes)}; int i; for (i = 0; i &lt; pupils; ++i) set(ada[i], quizzes); cout &lt;&lt; &quot;\n Student List:\n&quot;; for (i = 0; i &lt; pupils; ++i) cout &lt;&lt; ada[i].Name() &lt;&lt; endl; cout &lt;&lt; &quot;\nResults:&quot;; for (i = 0; i &lt; pupils; ++i) { cout &lt;&lt; endl &lt;&lt; ada[i]; cout &lt;&lt; &quot;average: &quot; &lt;&lt; ada[i].Average() &lt;&lt; endl; } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } void set(Student &amp; sa, int n) { cout &lt;&lt; &quot;Please enter the student&apos;s name: &quot;; getline(cin, sa); cout &lt;&lt; &quot;Please enter &quot; &lt;&lt; n &lt;&lt; &quot; quiz scores:\n&quot;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; sa[i]; while (cin.get() != &apos;\n&apos; ) continue; } 输出： Please enter the student&apos;s name: Gil Bayts Please enter 5 quiz scores: 92 94 98 96 95 Please enter the student&apos;s name: Pat Roone Please enter 5 quiz scores: 89 96 95 92 91 Please enter the student&apos;s name: Fleur Day Please enter 5 quiz scores: 96 98 92 93 94 Student List: Gil Bayts Pat Roone Fleur Day Results: Scores for Gil Bayts: 92 94 98 96 95 average: 95 Scores for Pat Roone: 89 96 95 92 91 average: 92.6 Scores for Fleur Day: 96 98 92 93 94 average: 94.6 Done. 14.2 私有继承C++还有另一种实现has-a关系的途径—私有继承。使用私有继承，基类的公有成员和保护成员都将称为派生类的私有成员。这意味着基类方法将不会称为派生类对象公有接口的一部分，但可以在派生类的成员函数中使用它们。 下面更深入地探讨接口问题。使用公有继承，基类的公有方法将成为派生类的公有方法。总之，派生类将继承基类的接口；这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法。总之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。 使用私有继承，类将继承实现。例如，如果从String类派生出Student类，后者将有一个String类组件，可用于保存字符串。另外，Student方法可以使用String方法来访问String组件。 包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象来表示通过继承或包含添加的对象。 因此，私有继承提供的特性与包含相同：获得实现，但不获得接口。所以，私有继承也可以用来实现has-a关系。接下来介绍如何使用私有继承来重新设计Student类。 14.2.1 Student类示例（新版本）要进行私有继承，请使用关键字private而不是public来定义类（实际上，private是默认值，因此省略访问限定符也将导致私有继承）。Student类应该从两个类派生而来，因此声明将列出这两个类： class Student : private std::string, private std::valarray&lt;double&gt; { public: ... } 使用多个基类的继承被称为多重继承（MI）。通常，MI尤其是公有MI将导致一些问题，必须使用额外的语法规则来解决它们，它将在本章后面介绍。但在这个示例中，MI不会导致问题。 新的Student类不需要私有数据，因为两个基类已经提供了所需的所有数据成员。包含版本提供了两个被显式命名的对象成员，而私有继承提供了两个无名称的子对象成员。这是这两种方法的第一个主要区别。 1. 初始化基类组件 隐式地继承组件而不是成员对象将影响代码的编写，因为再也不能使用name和scores来描述对象了，而必须使用用于公有继承的技术。例如，对于构造函数，包含将使用这样的构造函数： Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {} 对于继承类，新版本的构造函数将使用成员初始化列表语法，而它使用类名而不是成员名来标识构造函数： Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {} 再这里，ArrayDb是std::valarray的别名。成员初始化列表使用std::string(str)，而不是name(str)。这是包含和私有继承之间的第二个主要区别。 程序14.4列出了新的类定义。唯一不同的地方是，省略了显式对象名称，并在内联构造函数中使用了类名，而不是成员名。 程序14.4 studenti.h #ifndef STUDENTI_H_ #define STIDENTI_H_ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;valarray&gt; class Student : private std::string, private std::valarray&lt;double&gt; { private: typedef std::valarray&lt;double&gt; ArrayDb; std::ostream &amp; arr_out(std::ostream &amp; os) const; public: Student() : std::string(&quot;Null Student&quot;), ArrayDb() {} explicit Student(int n) : std::string(&quot;Null&quot;), ArrayDb(n) {} explicit Student(const std::string &amp; s) : std::string(s), ArrayDb() {} Student(const std::string &amp; s, const ArrayDb &amp; a) : std::string(s), ArrayDb(a) {} Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {} ~Student() {} double Average() const; double &amp; operator[](int i); double operator[](int i) const; const std::string &amp; Name() const; friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Student &amp; stu); friend std::istream &amp; operator&gt;&gt;(std::istream &amp; is, Student &amp; stu); friend std::istream &amp; getline(std::istream &amp; is, Student &amp; stu); }; #endif 2. 访问基类的方法 使用私有继承时，只能在派生类的方法中使用基类的方法。但有时候可能希望其基类工具是公有的。例如，在类声明中提出可以使用average()函数，和包含一个样，要实现这样的目的，可以在公有Student::average()函数中使用私有Student::Average()函数。包含使用对象来调用方法： double Student::Average() const { if (scores.size() &gt; 0) return scores.sum() / scores.size(); else return 0; } 然而，私有继承使得能够使用类名和作用域解析运算符来调用基类的方法： double Student::Average() const { if (ArrayDb::size() &gt; 0) return ArrayDb::sum() / ArrayDb::size(); else return 0; } 总之，使用包含时将使用对象名来调用方法，而使用私有继承时使用类名和作用域解析运算符来调用方法。 3. 访问基类对象 使用作用域解析运算符可以访问基类的方法，但如果要使用基类对象本身，该如何做呢？例如，Student类的包含版本实现了Name()方法，它返回string对象成员name；但使用私有继承时，该string对象没有名称。那么，Student类的代码如何访问内部的string对象呢？ 答案是使用强制类型转换。由于Student类是从string类派生出来的，因此可以通过强制类型转换，将Student对象转换成string对象；结果为继承而来的string对象。本书前面介绍过，指针this指向用来调用方法的对象，因此$\ast$ this为用来调用方法的对象，在这个例子中，为类型为Student的对象。为避免调用构造函数创建新的对象，可使用强制类型转换来创建一个引用： const string &amp; Student::Name() const { return (const string &amp;) *this; } 上述方法返回一个引用，该引用指向调用该方法的Student对象中的继承而来的string对象。 4. 访问基类的友元函数 用类名显式地限定函数名不适合于友元函数，这是因为友元函数不属于类。然而，可以通过显式地强制转换为基类来调用正确的函数。例如，对于下面的友元函数定义： ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) { os &lt;&lt; &quot;Scores for &quot; &lt;&lt; (string &amp;) stu &lt;&lt; &quot;:\n&quot;; ... } 如果plato是一个Student对象，则下面的语句将调用上述函数，stu将是指向plato的引用，而os将是指向cout的引用： cout &lt;&lt; plato; 下面的代码： os &lt;&lt; &quot;Scores for &quot; &lt;&lt; (string &amp;) stu &lt;&lt; &quot;:\n&quot;; 显式地将stu转换为string对象引用，进而调用函数operator&lt;&lt;(ostream &amp;, const string &amp;)。 引用stu不会自动转换为string引用。根本原因在于，在私有继承中，未进行显式类型转换的派生类引用或指针，无法赋值给基类的引用或指针。 然而，即使这个例子使用的是公有继承，也必须使用显式类型转换。原因在于，如果不使用类型转换，下述代码将于友元函数原型匹配，从而导致递归调用： os &lt;&lt; stu; 另一个原因是，由于这个类使用的是多重继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供了函数operator&lt;&lt;()。 程序14.5 studenti.cpp #include &quot;studenti.h&quot; #include &lt;iostream&gt; using namespace std; double Student::Average() const { if (ArrayDb::size() &gt; 0) return ArrayDb::sum() / ArrayDb::size(); else return 0; } const string &amp; Student::Name() const { return (const string &amp;) *this; } double &amp; Student::operator[](int i) { return ArrayDb::operator[](i); } double Student::operator[](int i) const { return ArrayDb::operator[](i); } ostream &amp; Student::arr_out(ostream &amp; os) const { int i; int lim = ArrayDb::size(); if (lim &gt; 0) { for (i = 0; i &lt; lim; i++) { os &lt;&lt; ArrayDb::operator[](i) &lt;&lt; &quot; &quot;; if (i % 5 == 4) os &lt;&lt; endl; } if (i % 5 != 0) os &lt;&lt; endl; } else os &lt;&lt; &quot; empty array &quot;; return os; } istream &amp; operator&gt;&gt;(istream &amp; is, Student &amp; stu) { is &gt;&gt; (string &amp;) stu; return is; } istream &amp; getline(istream &amp; is, Student &amp; stu) { getline(is, (string &amp;) stu); return is; } ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu) { os &lt;&lt; &quot;Scores for &quot; &lt;&lt; (string &amp;) stu &lt;&lt; &quot;:\n&quot;; stu.arr_out(os); return os; } 5. 使用修改后的Student类 接下来也需要测试这个新类。注意到两个版本的Student类的公有接口完全相同，因此可以使用同一个程序测试它们。 程序14.6 use_stui.cpp #include &lt;iostream&gt; #include &quot;studenti.h&quot; using namespace std; void set(Student &amp; sa, int n); const int pupils = 3; const int quizzes = 5; int main() { Student ada[pupils] = {Student(quizzes), Student(quizzes), Student(quizzes)}; int i; for (i = 0; i &lt; pupils; ++i) set(ada[i], quizzes); cout &lt;&lt; &quot;\n Student List:\n&quot;; for (i = 0; i &lt; pupils; ++i) cout &lt;&lt; ada[i].Name() &lt;&lt; endl; cout &lt;&lt; &quot;\nResults:&quot;; for (i = 0; i &lt; pupils; ++i) { cout &lt;&lt; endl &lt;&lt; ada[i]; cout &lt;&lt; &quot;average: &quot; &lt;&lt; ada[i].Average() &lt;&lt; endl; } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } void set(Student &amp; sa, int n) { cout &lt;&lt; &quot;Please enter the student&apos;s name: &quot;; getline(cin, sa); cout &lt;&lt; &quot;Please enter &quot; &lt;&lt; n &lt;&lt; &quot; quiz scores:\n&quot;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; sa[i]; while (cin.get() != &apos;\n&apos; ) continue; } 输出： Please enter the student&apos;s name: Gil Bayts Please enter 5 quiz scores: 92 94 96 98 95 Please enter the student&apos;s name: Pat Roone Please enter 5 quiz scores: 83 89 72 78 95 Please enter the student&apos;s name: Fleur Day Please enter 5 quiz scores: 92 93 96 98 95 Student List: Gil Bayts Pat Roone Fleur Day Results: Scores for Gil Bayts: 92 94 96 98 95 average: 95 Scores for Pat Roone: 83 89 72 78 95 average: 83.4 Scores for Fleur Day: 92 93 96 98 95 average: 94.8 Done. 14.2.2 使用包含还是私有继承由于既可以使用包含，也可以使用私有继承来建立has-a关系，那么应该使用哪种方法？大多数C++程序倾向于使用包含。首先，它易于理解。类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而使用继承将是关系更抽象。其次，继承会引起很多问题，尤其从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或共享祖先的独立基类。总之，使用包含不太可能遇到这样的麻烦。另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。而继承则只能使用一个这样的对象（当对象没有名称时，将难以区分）。 然而，私有继承所提供的特性确实比包含多。例如，假设类包含保护成员（可以是数据成员，也可以是成员函数），则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问包含成员。但通过继承得到的将是派生类，因此它能够访问保护成员。 另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不会公有的。 提示：通常，应使用包含来建立has-a关系；如果新类需要访问原有类的包含成员，或需要重新定义虚函数，则应使用私有继承。 14.2.3 保护继承保护继承是私有继承的变体。保护继承再列出基类时使用关键字protected: class Student : protected std::string, protected std::valarray&lt;double&gt; {...} 使用保护继承，基类的公有成员和保护成员都将称为派生类的保护成员。和公有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别变呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；使用保护继承，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。 表14.1总结了公有、私有和保护继承。隐式向上转换意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。 14.2.4 使用using重新定义访问权限使用保护派生或私有派生时，基类的公有成员将成员保护成员或私有成员。假设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。例如，假设希望Student类能够使用valarray类的sum()方法，可以在Student类的声明中声明一个sum()方法，然后像下面这样定义该方法： double Student::sum() const { return std::valarray&lt;double&gt;::sum(); } 这样Student对象便能够调用Student::sum()，后者进而将valarray::sum()方法应用于被包含的valarray对象。 另一种方法是，将函数调用包装在另一个调用函数中，即使用一个using声明(就像名称空间那样)来指出派生类可以使用特定的基类成员，即使采用的是私有派生。例如，假设希望通过Student类能够使用valarray的min()和max()，可以在studenti.h的公有部分加入using声明： class Student : private std::string, private std::valarray { ... public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max; ... }; 上述using使得valarray::min()和valarray::max()可用，就像它们是Student的公有方法一样： cout &lt;&lt; &quot;high score: &quot; &lt;&lt; ada[i].max() &lt;&lt; endl; 注意，using声明只使用成员名—-没有圆括号、函数特征标和返回类型。例如，为Student类可以使用valarray的operator[]方法，只需在Student类声明的公有部分包含下面的using声明： using std::valarray&lt;double&gt;::operator[]; 这将是两个版本（const和非const）都可用。这样，便可以删除Student::operator90()的原型和定义。using声明只适用于继承，而不适用于包含。 有一种老式方式用于在私有派生类中重新声明基类方法，即将方法名放在派生类的公有部分，如下所示: class Student : private std::string, private std::valarray { ... public: std::valarray&lt;double&gt;::operator[]; ... }; 这样看起来像不包含关键字using声明的using声明。这种方法已被摒弃，即将停止使用。因此，如果编译器支持using声明，应使用它来使派生类可以使用私有基类中的方法。 14.3 多重继承MI描述的是有多个直接基类的类。与单继承一样，公有MI表示的也是is-a关系。例如，可以从Waiter类和Singer类派生出一个SingingWaiter类： class SingingWaiter : public Waiter, pulic Singer {...}; 请注意，必须使用关键字public来限定每一个基类。这是因为，除非特别指出，否则编译器将认为是私有派生： class SingingWaiter : public Waiter, Singer {...}; 正如本章前面讨论的，私有MI和保护MI可以表示has-a关系。Student类的studenti.h实现就是一个这样的示例。下面将重点介绍公有MI。 MI可能会给程序员带来很多新问题。其中两个主要的问题是：从两个不同的基类继承同名方法；从两个或更多相关基类那里继承同一个类的多个实例。为解决这些问题，需要使用一些新规则和不同的语法。因此，与使用单继承相比，使用MI更困难，也更容易出现问题。由于这个原因，很多C++用户强烈反对使用MI，一些人甚至希望删除MI；而喜欢MI的人则认为，对一些特殊的工程来说，MI很有用，甚至是必不可少的。 下面来看一个例子，并介绍有哪些问题以及如何解决它们。要使用MI，需要几个类。我们将定义一个抽象基类Worker，并使用它派生出Waiter类和Singer类。然后，便可以使用MI从Waiter类和Singer类派生出SingingWaiter类（见图14.3）。这里使用两个独立的派生类来使基类Worker被继承，这将导致MI的大多数玛法。首先，声明Worker、Waiter和Singer类，如程序14.7所示： 程序14.7 worker0.h #ifndef WORKER0_H_ #define WORKER0_H_ #include &lt;string&gt; class Worker { private: std::string fullname; long id; public: Worker() : fullname(&quot;no one&quot;), id(0L) {} Worker(const std::string &amp; s, long n) : fullname(s), id(n) {} virtual ~Worker() = 0; virtual void Set(); virtual void Show() const; }; class Waiter : public Worker { private: int panache; public: Waiter() : Worker(), panache(0) {} Waiter(const std::string &amp; s, long n, int p = 0) : Worker(s,n), panache(p) {} Waiter(const Worker &amp; wk, int p = 0) : Worker(wk), panache(p) {} void Set(); void Show() const; }; class Singer : public Worker { protected: enum {other, alto, contralto, soprano, bass, baritone, tenor}; enum {Vtypes = 7}; private: static char *pv[Vtypes]; int voice; public: Singer() : Worker() {} Singer(const std::string &amp; s, long n, int v = other) : Worker(s, n), voice(v) {} Singer(const Worker &amp; wk, int v = other) : Worker(wk), voice(v) {} void Set(); void Show() const; }; #endif 程序14.7的类声明中包含一些表示声音类型的内部常量。一个美剧符号常量alto等表示声明类型，静态数组pv存储了指向相应C-风格字符串的指针，程序14.8初始化了该数组。 程序14.8 worker0.cpp #include &quot;worker0.h&quot; #include &lt;iostream&gt; using namespace std; Worker::~Worker() {} void Worker::Set() { cout &lt;&lt; &quot;Enter worker&apos;s name: &quot;; getline(cin, fullname); cout &lt;&lt; &quot;Enter worker;s ID: &quot;; cin &gt;&gt; id; while (cin.get() != &apos;\n&apos;) continue; } void Worker::Show() const { cout &lt;&lt; &quot;Name: &quot; &lt;&lt; fullname &lt;&lt; endl; cout &lt;&lt; &quot;Employee ID: &quot; &lt;&lt; id &lt;&lt; endl; } void Waiter::Set() { Worker::Set(); cout &lt;&lt; &quot;Enter waiter&apos;s panache rating: &quot;; cin &gt;&gt; panache; while (cin.get() != &apos;\n&apos;) continue; } void Waiter::Show() const { cout &lt;&lt; &quot;Category: waiter\n&quot;; Worker::Show(); cout &lt;&lt; &quot;Panache rating: &quot; &lt;&lt; panache &lt;&lt; endl; } char * Singer::pv[] = {&quot;ohter&quot;, &quot;alto&quot;, &quot;contralto&quot;, &quot;soprano&quot;, &quot;brass&quot;, &quot;baritone&quot;, &quot;tenor&quot;}; void Singer::Set() { Worker::Set(); cout &lt;&lt; &quot;Enter number for singer&apos;s vocal range:\n&quot;; int i; for (i = 0; i &lt; Vtypes; i++) { cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; pv[i] &lt;&lt; &quot; &quot;; if (i % 4 == 3) cout &lt;&lt; endl; } if (i % 4 != 0) cout &lt;&lt; endl; while (cin &gt;&gt; voice &amp;&amp; (voice &lt; 0 || voice &gt;= Vtypes) ) cout &lt;&lt; &quot;Please enter avalue &gt;= 0 and &lt; &quot; &lt;&lt; Vtypes &lt;&lt; endl; while (cin.get() != &apos;\n&apos;) continue; } void Singer::Show() const { cout &lt;&lt; &quot;Category: singer\n&quot;; Worker::Show(); cout &lt;&lt; &quot;Vocal range: &quot; &lt;&lt; pv[voice] &lt;&lt; endl; } 程序14.9是一个简短的程序，它使用了多态指针数组对这些类进行测试。 程序14.9 worktest.cpp #include &lt;iostream&gt; #include &quot;worker0.h&quot; const int LIM = 4; int main() { Waiter bob(&quot;Bob Apple&quot;, 314L, 5); Singer bev(&quot;Beverly Hills&quot;, 522L, 3); Waiter w_temp; Singer s_temp; Worker * pv[LIM] = {&amp;bob, &amp;bev, &amp;w_temp, &amp;s_temp}; int i; for (i = 2; i &lt; LIM; i++) pv[i]-&gt;Set(); for (i = 0; i &lt; LIM; i++) { pv[i]-&gt;Show(); std::cout &lt;&lt; std::endl; } return 0; } 输出： Enter worker&apos;s name: Waldo Dropmaster Enter worker;s ID: 442 Enter waiter&apos;s panache rating: 3 Enter worker&apos;s name: Sylvie Sirenne Enter worker;s ID: 555 Enter number for singer&apos;s vocal range: 0: ohter 1: alto 2: contralto 3: soprano 4: brass 5: baritone 6: tenor 3 Category: waiter Name: Bob Apple Employee ID: 314 Panache rating: 5 Category: singer Name: Beverly Hills Employee ID: 522 Vocal range: soprano Category: waiter Name: Waldo Dropmaster Employee ID: 442 Panache rating: 3 Category: singer Name: Sylvie Sirenne Employee ID: 555 Vocal range: soprano 这种设计看起来是可行的；使用Waiter指针来调用Waiter::Show()和Waiter::Set()。然后，添加一个从Singer和Waiter类派生出来的SingingWaiter类后，将带来一些问题。具体来说，出现以下问题： 有多少个Worker？ 哪个方法？ 14.3.1 有多少个Worker假设首先从Singer和Waiter公有派生出SingingWaiter: class SingingWaiter : public Singer, public Waiter {...}; 因为Singer和Waiter都继承了一个Worker组件，因此SingingWaiter将包含两个Worker组件（参见图14.4）。 正如预期的e，这将引起问题。例如，通常可以将派生类对象的地址赋给基类指针，但现在将出现二义性： SingingWaier ed; Worker * pw = &amp;ed; //存在二义性 通常，这种赋值将把基类指针设置为派生对象中的基类对象的地址。但ed中包含两个Worker对象，有两个地址可供选择，所以应使用类型转换来指定对象： Worker * pw1 = (Waiter *) &amp;ed; Worker * pw2 = (Singer *) &amp;ed; 这将使得使用基类指针来引用不同的对象（多态性）复杂化。 包含两个Worker对象拷贝还会导致其他问题。然而，真正的问题是：为什么需要Worker对象的两个拷贝？唱歌的侍者和其他Worker对象一样，也应只有一个姓名和一个ID。C++引入多重继承的同时，引入了一种新技术—虚基类，使MI成为可能。 1. 虚基类 虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。例如，通过在类声明中使用关键字virtual，可以使Worker被用作Singer和Waiter的虚基类（virtual和public的次序无关紧要）： class Singer : virtual public Worker {}; class Waiter : public virtual Worker {}; 然而，SingingWaiter对象将只包含Worker对象的一个副本。从本质上说，继承的Singer和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象副本（参见图14.5）。因为SingingWaiter现在只包含了一个Worker子对象，所可以使用多态。 您可能会有这样的疑问？ 为什么使用术语“虚”？ 为什么不抛弃将基类声明为虚的这种方法，而使虚行为成为多MI的准则呢？ 是否存在麻烦呢？ 首先，为什么使用术语虚？毕竟，在虚函数和虚基类之间并不存在明显的联系。C++用户强烈反对引入的新的关键字，因为这将给他们带来很大的压力。例如，如果新的关键字与重要程序的重要函数或变量的名称相同，这将非常麻烦。因此，C++对这种特性也使用关键字virtual—有点像关键字重载。 其次，为什么不抛弃基类声明为虚的这种方式，而使虚行为成为MI的准则呢？第一，在一些情况下，可能需要基类的多个拷贝；第二，将基类作为虚的要求程序完成额外的计算，为不需要的工具付出代价是不应当的；第三，这样做有其缺点，将在下一段介绍。 最后，是否存在麻烦？是的。为使基类能够工作，需要对C++规则进行调整，必须以不同的方式编写一些代码。另外，使用虚基类还可能需要修改已有的代码。例如，将SingingWaiter类添加到Worker继承层次中，需要在Singer和Waiter类中添加关键字vritual。 2. 新的构造函数规则 使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，唯一可以出现在初始化列表中的构造函数是即时基类构造函数。但这些构造函数可能需要将信息传递给其基类。例如，可能有下面一组构造函数： class A { int a; public: A(int n = 0) : a(n) {} ... }; class B : public A { int b; public: B(int m = 0, int n = 0) : A(n), b(m) {} ... }; class C : public B { int c; C(int q = 0, int m = 0, int n = 0) : B(m, n), c(q) {} ... }; C类的构造函数只能调用B类的构造函数，而B类的构造函数只能调用A类的构造函数。这里，C类的构造函数使用值q，并将值m和n传递给B类的构造函数；而B类的构造函数使用值m，并将值n传递给A类的构造函数。 如果Worker是虚基类，则这种信息自动传递将不起作用。例如，对于下面的MI构造函数： SingingWaiter(const Worker &amp; wk, int p = 0, int v = Singer::other) : Waiter(wk, p), Singer(wk, v) {} 存在的问题是，自动传递信息时，将通过2条不同的途径（Waiter和Singer）将wk传递给Worker对象。为避免这种冲突，C++在基类是虚的时，禁止信息通过中间类自动传递给基类。 因此，上述构造函数将初始化成员panache和voidce，但wk参数中的信息将不会传递给子对象Work。然而，编译器必须在构造派生类对象之前构造基类对象组件；在上述情况下，编译器将使用Worker的默认构造函数。 如果不希望默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。因此，构造函数应该是这样的： SingingWaiter(const Worker &amp; wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {} 上述代码将显式地调用构造函数Worker(const Worker &amp;)。请注意，这种用法是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。 警告：如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。 14.3.2 哪个方法 除了修改类构造函数规则外，Mi通常还要调整其他代码。假设要在SingingWaiter类中扩展Show()方法。因为SingingWaiter对象没有新的数据成员，所以可能会认为它只需要使用继承的方法即可。这引出了第一个问题。假设没有在SingingWaiter类中重新定义Show()方法，并试图使用SingWaiter对象调用及继承的Show()方法： SingingWaiter newhire(&quot;Elise Hawks&quot;, 2005, 6, soprano); newhire.Show(); //存在二义性 对于单继承，如果没有重新定义Show()，则将使用最近祖先中的定义。而在多继承中，每个直接祖先都有一个Show()函数，这使得上述调用是二义性的。 警告:多重继承可能可能导致函数调用的二义性。 可以使用作用域解析运算符来澄清编程者的意图： SingingWaiter newhire(&quot;Elise Hawks&quot;, 2005, 6, soprano); newhire.Singer::Show(); 然而，更好的办法是在SingingWaiter中重新定义Show()，并指出使用哪个Show()。例如，如果希望SingingWaiter对象使用Singer版本的Show()，则可以这样做： void SingingWaiter::Show() { Singer::Show(); } 对于单继承来说，让派生类方法调用基类的方法是可以的。例如，假设HeadWaiter类是从Waiter类派生而来的，则可以使用下面的定义序列，其中每个派生类使用其基类显示信息，并添加自己的信息： void Worker::Show() const { cout &lt;&lt; &quot;Name: &quot; &lt;&lt; fullname &lt;&lt; endl; cout &lt;&lt; &quot;Employee ID: &quot; &lt;&lt; id &lt;&lt; endl; } void Waiter::Show() const { Worker::Show(); cout &lt;&lt; &quot;Panache rating: &quot; &lt;&lt; panache &lt;&lt; endl; } void HeadWaiter::Show() const { Waiter::Show(); cout &lt;&lt; &quot;Presence rating: &quot; &lt;&lt; presence &lt;&lt; endl; } 然而，这种递增的方式对SingingWaiter示例无效。下面的方法将无效，因为它忽略了Waiter组件： void SingingWaiter::Show() { Singer::Show(); } 可以通过同时调用Waiter版本的Show()来补救： void SingingWaiter::Show() { Singer::Show(); Waiter::Show(); } 然而，这显示姓名和ID两次，因此Singer::Show()和Waiter::Show()都调用了Worker::Show()。 一种办法是使用模块化方式，而不是递增方法，即提供一个只显示Worker组件的方法和一个只显示Waiter组件和Singer组件（而不是Waiter和Worker组件）的方法。然而，在SingingWaiter::Show()方avs将组件组合起来。例如，可以这样做： void Worker::Data() const { cout &lt;&lt; &quot;Name: &quot; &lt;&lt; fullname &lt;&lt; endl; cout &lt;&lt; &quot;Employee ID: &quot; &lt;&lt; id &lt;&lt; endl; } void Waiter::Data() const { cout &lt;&lt; &quot;Panache rating: &quot; &lt;&lt; panache &lt;&lt; endl; } void Singer::Data() const { cout &lt;&lt; &quot;Vocal range: &quot; &lt;&lt; pv[voice] &lt;&lt; endl; } void SingingWaiter::Show() const { cout &lt;&lt; &quot;Category: singing waiter\n&quot;; Worker::Data(); Data(); } 与此相似，其他Show()方法可以组合适当的Data()组件。 采用这种方式，对象仍可以使用Show()方法。而Data()方法只在类内部可用，作为协助公有接口的辅助方法。然而，使Data()方法成为私有的将阻止Waiter中的代码使用Worker::Data()，这正是保护访问类的用武之地。如果Data()方法是保护的，则只能在继承层次结构中的类中使用它，在其他地方则不能使用。 另一种方法是将所有的数据组件都设置为保护的，而不是私有的，不过使用保护方法（而不是保护数据）将可以更严格地控制对数据的访问。 Set()方法取得数据，以设置对象值，该方法也有类似的问题。例如，SingingWaiter::Set()应请求Worker信息一次，而不是两次。对此，可以使用前面的解决办法。可以提供一个受保护的Get()方法，该方法只请求一个类的信息，然后将使用Get()方法作为构造块的Set()方法来集合起来。 总之，在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。另外，如果在编写这些类时没有考虑到MI，则还可能需要重新编写他们。程序14.10列出了修改后的类声明。 程序14.10 workermi.h #ifndef WORKERMI_H_ #define WORKERMI_H_ #include &lt;string&gt; using namespace std; class Worker { private: string fullname; long id; protected: virtual void Data() const; virtual void Get(); public: Worker() : fullname(&quot;no one&quot;), id(0L) {} Worker(const string &amp; s, long n) : fullname(s), id(n) {} virtual ~Worker() = 0; virtual void Show() const = 0; virtual void Set() = 0; }; class Waiter : virtual public Worker { private: int panache; protected: void Data() const; void Get(); public: Waiter() : Worker(), panache(0) {} Waiter(const string &amp; s, long n, int p = 0) : Worker(s, n), panache(p) {} Waiter(const Worker &amp; wk, int p = 0) : Worker(wk), panache(p) {} void Set(); void Show() const; }; class Singer : virtual public Worker { protected: enum {other, alto, contralto, soprano, bass, baritone, tenor}; enum {Vtypes = 7}; void Data() const; void Get(); private: static char *pv[Vtypes]; int voice; public: Singer() : Worker(), voice(0) {} Singer(const string &amp; s, long n, int v = other) : Worker(s, n), voice(v) {} Singer(const Worker &amp; wk, int v = other) : Worker(wk), voice(v) {} void Show() const; void Set(); }; class SingingWaiter : public Waiter, public Singer { protected: void Data() const; void Get(); public: SingingWaiter() {} SingingWaiter(const string &amp; s, long n, int p = 0, int v = other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {} SingingWaiter(const Worker &amp; wk, int p = 0, int v = other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {} SingingWaiter(const Waiter &amp; wt, int v = other) : Worker(wt), Waiter(wt), Singer(wt, v) {} SingingWaiter(const Singer &amp; wt, int p = 0) : Worker(wt), Waiter(wt, p), Singer(wt) {} void Set(); void Show() const; }; #endif 程序14.11 workermi.cpp #include &lt;iostream&gt; #include &quot;workermi.h&quot; using namespace std; Worker::~Worker() {} void Worker::Data() const { cout &lt;&lt; &quot;Name: &quot; &lt;&lt; fullname &lt;&lt; endl; cout &lt;&lt; &quot;Employee ID: &quot; &lt;&lt; id &lt;&lt; endl; } void Worker::Get() { getline(cin, fullname); cout &lt;&lt; &quot;Enter worker;s ID: &quot;; cin &gt;&gt; id; while (cin.get() != &apos;\n&apos;) continue; } void Waiter::Set() { cout &lt;&lt; &quot;Enter waiter&apos;s name: &quot;; Worker::Get(); Get(); } void Waiter::Show() const { cout &lt;&lt; &quot;Category: waiter\n&quot;; Worker::Data(); Data(); } void Waiter::Data() const { cout &lt;&lt; &quot;Panache rating: &quot; &lt;&lt; panache &lt;&lt; endl; } void Waiter::Get() { cout &lt;&lt; &quot;Enter waiter&apos;s panache rating: &quot;; cin &gt;&gt; panache; while (cin.get() != &apos;\n&apos;) continue; } char * Singer::pv[Singer::Vtypes] = {&quot;ohter&quot;, &quot;alto&quot;, &quot;contralto&quot;, &quot;soprano&quot;, &quot;brass&quot;, &quot;baritone&quot;, &quot;tenor&quot;}; void Singer::Set() { cout &lt;&lt; &quot;Enter singer&apos;s name: &quot;; Worker::Get(); Get(); } void Singer::Show() const { cout &lt;&lt; &quot;Category: singer\n&quot;; Worker::Data(); Data(); } void Singer::Data() const { cout &lt;&lt; &quot;Vocal range: &quot; &lt;&lt; pv[voice] &lt;&lt; endl; } void Singer::Get() { cout &lt;&lt; &quot;Enter number for singer&apos;s vocal range:\n&quot;; int i; for (i = 0; i &lt; Vtypes; i++) { cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; pv[i] &lt;&lt; &quot; &quot;; if (i % 4 == 3) cout &lt;&lt; endl; } if (i % 4 != 0) cout &lt;&lt; endl; while (cin &gt;&gt; voice &amp;&amp; (voice &lt; 0 || voice &gt;= Vtypes) ) cout &lt;&lt; &quot;Please enter avalue &gt;= 0 and &lt; &quot; &lt;&lt; Vtypes &lt;&lt; endl; while (cin.get() != &apos;\n&apos;) continue; } void SingingWaiter::Data() const { Singer::Data(); Waiter::Data(); } void SingingWaiter::Get() { Singer::Get(); Singer::Get(); } void SingingWaiter::Show() const { cout&lt;&lt; &quot;Category: singing waiter\n&quot;; Worker::Data(); Data(); } void SingingWaiter::Set() { cout &lt;&lt; &quot;Enter singing waiter&apos;s name: &quot;; Worker::Get(); Get(); } 程序14.12提供了测试代码。注意，该程序使用了多态属性，将各种类型的地址赋给基类指针。另外，该程序还在下面的检测中使用了C-风格字符串库函数strchr(): while (strchr(&quot;wstq&quot;, choice) == NULL) 该函数返回参数choice指定的字符在字符串“wstq”中第一次出现的地址，如果没有这和的字符，则返回NULL地址。十三亿这种检测比使用if语句将choice指定的字符同每个字符进行比较简单。 程序14.12 workmi.cpp #include &quot;workermi.h&quot; #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; const int SIZE = 5; int main() { Worker * lolas[SIZE]; int ct; for (ct = 0; ct &lt; SIZE; ct++) { char choice; cout &lt;&lt; &quot;Enter the employee category:\n&quot; &lt;&lt; &quot;W: waiter s: singer &quot; &lt;&lt; &quot;t: singing waiter q: quit\n&quot;; cin &gt;&gt; choice; while(strchr(&quot;wstq&quot;, choice) == NULL) { cout &lt;&lt; &quot;Please enter a w, s, t or q:&quot;; cin &gt;&gt; choice; } if (choice == &apos;q&apos;) break; switch(choice) { case &apos;w&apos;: lolas[ct] = new Waiter; break; case &apos;s&apos;: lolas[ct] = new Singer; break; case &apos;t&apos;: lolas[ct] = new SingingWaiter; break; } cin.get(); lolas[ct]-&gt;Set(); } cout &lt;&lt; &quot;\nHere is your staff:\n&quot;; int i; for (i = 0; i &lt; ct; i++) { cout &lt;&lt; endl; lolas[i]-&gt;Show(); } for (i = 0; i &lt; ct; i++) delete lolas[i]; cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } 输出： Enter the employee category: W: waiter s: singer t: singing waiter q: quit w Enter waiter&apos;s name: Wally Slipshod Enter worker;s ID: 1040 Enter waiter&apos;s panache rating: 4 Enter the employee category: W: waiter s: singer t: singing waiter q: quit s Enter singer&apos;s name: Sinclair Parma Enter worker;s ID: 1044 Enter number for singer&apos;s vocal range: 0: ohter 1: alto 2: contralto 3: soprano 4: brass 5: baritone 6: tenor 5 Enter the employee category: W: waiter s: singer t: singing waiter q: quit t Enter singing waiter&apos;s name: Natasha Bargalova Enter worker;s ID: 1021 Enter number for singer&apos;s vocal range: 0: ohter 1: alto 2: contralto 3: soprano 4: brass 5: baritone 6: tenor 6 Enter number for singer&apos;s vocal range: 0: ohter 1: alto 2: contralto 3: soprano 4: brass 5: baritone 6: tenor 3 Enter the employee category: W: waiter s: singer t: singing waiter q: quit q Here is your staff: Category: waiter Name: Wally Slipshod Employee ID: 1040 Panache rating: 4 Category: singer Name: Sinclair Parma Employee ID: 1044 Vocal range: baritone Category: singing waiter Name: Natasha Bargalova Employee ID: 1021 Vocal range: soprano Panache rating: 0 Bye. 下面介绍其他一些有关MI的问题。 1. 混合使用虚基类和非虚基类 再来看一下通过多种途径继承一个基类的派生类的情况。如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。当虚基类和非虚基类混合时，情况将如何呢？ 例如，假设类B被用作类C和D的虚基类，同时用作类X和Y的非虚基类，而类M从C、D、X和Y中派生而来。在这种情况下，类M从虚派生祖先(即类C和D)那里共继承了一个B类子对象，并从每一个非虚派生祖先（即类X和Y）分别继承了一个B类子对象。因此，它包含三个B类子对象。当类通过多条虚途径和非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示个条非虚途径的多个基类子对象。 2. 虚基类和支配 使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单。如果类从不同的类那里继承了两个或更多的同名成员(数据或方法)，则使用该成员名时，如果没有用类名进行限定，将导致二义性。但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于其他所有名称，则使用它，即便不使用限定符，也不会导致二义性。 那么，一个成员如何优先于另一个成员呢？在派生类中的名称优先于直接或间接祖先类中的相同名称。例如，在下面的定义中： class B { public: short q(); ... }; class C : virtual public B { public: long q(); int omg(); ... }; class D : public C { ... }; class E : virtual public B { private: int omg(); ... }; class F : public D, public E { ... }; 类C中的q()定义优先于B中的q()定义，因为类C是从类B派生而来的。因此，F中的方法可以使用q()来表示C::q()。另一方面，任何一个omg()定义都不优先于其他omg()定义。因为C和E都不是对象的基类。所以，在F中使用非限定的omg()将导致二义性。 虚二义性规则与访问规则无法，也就是说，即使E::omg()是私有的，不能再F类中直接访问，但使用omg()仍将导致二义性。同样，即使C::q()是私有的，它也将优先于D::q()。在这种情况下，可以在类F中调用B::q()，但如果不限定q()，则将意味者调用不可访问的C::q()。 14.3.3 MI小结首先复习一下不使用虚基类的MI。这种形式的MI不会引入新的规则。然后，如果一个类从两个不同的类哪里继承了两个同名的成员，则需要在派生类中使用类限定符来区分它们。即在从GunSlinger和PokerPlayer派生而来的BadDude类中，将分别使用Gunslinger::draw()和PokerPlayer::draw()来区分从两个类那里继承的draw()方法。否则，编译器将指出二义性。 如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例。在某些情况下，这可能正是所希望的，但通常情况下，多个基类实例都是问题。 接下来看一看使用虚基类的MI。当派生类使用关键字virtual来指示派生时，基类就成为虚基类： class marketing : public virtual reality {...}; 主要变化（同时也是使用虚基类的原因）是，从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。为实现这种特性，必须满足其他要求： 有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚函数来说是非法的； 通过有线规则解决名称二义性。 正如您看到的，MI会增加编程的复杂程度。然而，这种复杂主要是由于派生类通过多态途径继承同一个基类引起的。避免这种情况后，唯一需要注意的是，在必要时对继承的名称进行限定。 14.4 类模板继承（公有、私有或保护）和包含并不总是能够满足重用代码的需要。例如，Stack类（见第10章）和Queue类（见第12章）都是容器类（container class），容器类设计用来存储其他对象或数据类型。例如，第10章的Stack类设计用于存储unsigned long值。可以定义专门用于存储double值或string对象的Stack类，除了保存的对象类型不同外，这两种Stack类的代码是相同的。然而，与其编写新的类声明，不如编写一个泛型栈，然后将具体的类型作为参数传递给这个类。这样做可以使用通用的代码生成存储不同类型值得栈。第10章得Stack实例使用typedef处理这种需求。然而，这种方法有两个缺点：首先，每次修改类型时都需要编辑头文件；其次，在每个程序中只能使用这种技术生成一种栈，即不能让typedef同时代表两种不同得类型，因此不能使用这种方法在同一程序中同时定义int栈和string栈。 C++的类模板为生成通用的类声明提供了一种更好的办法（C++最初不支持模板，但模板被引入后，就一直在演化，因此有的编译器可能不支持这里介绍的所所有特性）。模板提供参数化类型，即能够将类型名作为参数传递给接受方来建立类或函数。例如，将类型名int传递给Queue模板，可以让编译器构造一个对int进行排队的Queue类。 C++库提供了多个模板类，本章前面介绍了模板类valarray，第4章介绍了模板类vector和array，而第16章将讨论的C++标准模板库（STL）提供了几个功能强大而灵活的容器类模板实现。本章将介绍如何设计一些基本的特性。 14.4.1 定义类模板下面以第10章的Stack类为基础来建立模板。原来的类声明如下： typedef unsigned long Item; class Stack { private: enum {MAX = 10}; Item items[MAX]; int top; public: Stack(); bool isempty() const; bool isfull() const; bool push(const Item &amp; item); bool pop(Item &amp; item); }; 采用模板类时，将使用模板定义替换Stack声明，使用模板成员函数替换Stack的成员函数。和模板函数一样，模板类以下面这样的代码开头： template &lt;class Type&gt; 关键字template告诉编译器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。可以把关键字class看作是变量的类型名，该变量接受类型作为其值，把Type看作是该变量的名称。 这里使用class并不意味着Type必须是一个类；而只是表明Type是一个通用的类型说明符，在使用模板时，将使用实际的类型替换它。较新的C++实现允许在这种情况下使用不太容易混淆的关键词typename代替class: template&lt;typename Type&gt; 可以使用自己的泛型名代替Type，其命名规则与其他标识符相同。当前流行的选项包括T和Type，我们将使用后者。当模板被调用时，Type将被具体的类型值（如int或string）取代。在模板定义中，可以使用泛型名来标识要存储在栈中的类型。对于Stack来说，这意味应将声明中所有的typedef标识符Item替换为type。例如： Item items[MAX]; 应改为： Type items[MAX]; 同样，可以使用模板成员函数来替换原有类的类方法。每个函数头都将以相同的模板声明打头： template &lt;class Type&gt; 同样应使用泛型名Type替换typedef标识符Item。另外，还需将类限定符从Stack::改为Stack::。例如： bool Stack::push(const Item &amp; item) { ... } 应改为： template &lt;class Type&gt; bool Stack&lt;Type&gt;::push(const Type &amp; item) { ... } 如果在类声明中定义了方法（内联定义），则可以省略模板前缀和类限定符。 程序14.13列出了类模板和成员函数模板。知道这些模板不是类和成员函数定义至关重要。它们是C++编译器指令，说明了如何生成类和成员函数定义。模板的具体实现—如用来处理string对象的栈类—–被称为实例化或具体化。不能将模板成员函数放在独立的实现文件中（以前，C++标准确实提供了关键字export，让您能够将模板成员函数放在独立的实现文件中，但支持该关键字的编译器不多；C++不再这样使用关键字export，而将其保留用于其他用途）。由于模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。为此，最简单的办法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。 程序14.13 stacktp.h #ifndef STACKTP_H_ #define STACKTP_H_ template &lt;class Type&gt; class Stack { private: enum {MAX = 10}; Type items[MAX]; int top; public: Stack(); bool isempty(); bool isfull(); bool push(const Type &amp; item); bool pop(Type &amp; item); }; template &lt;class Type&gt; Stack&lt;Type&gt;::Stack() { top = 0; } template &lt;class Type&gt; bool Stack&lt;Type&gt;::isempty() { return top == 0; } template &lt;class Type&gt; bool Stack&lt;Type&gt;::isfull() { return top == MAX; } template &lt;class Type&gt; bool Stack&lt;Type&gt;::push(const Type &amp; item) { if (top &lt; MAX) { items[top++] = item; return true; } else return false; } template &lt;class Type&gt; bool Stack&lt;Type&gt;::pop(Type &amp; item) { if (top &gt; 0) { item = items[--top]; return true; } else return false; } #endif 14.4.2 使用模板类仅在程序包含模板并不是生成模板类，而必须请求实例化。 为此，需要声明一个类型为模板类的对象，方式是使用所需的具体类型替换泛型名。例如，下面的代码创建两个栈，一个用于存储int，另一个用于存储string对象： Stack&lt;int&gt; kernels; Stack&lt;string&gt; 看到上述声明后，编译器讲按Stack模板来生成两个独立的类声明和两组独立的类方法。类声明Stack将使用int替换模板中所有的Type，而类声明Stack将用string替换Type。当然，使用的算法必须与类型一致。例如，StacK类假设可以将一个项目赋给另一个项目。这种假设对于基本类型、结构和类来说是成立的（除非将复制运算符设置为私有的），但对于数组则不成立。 泛型标识符—-例如这里的Type—-称为类型参数，这意味着它们类似于变量，但赋给它们的不能是数字，而只能是类型。因此，在kernel声明中，类型参数Type的值为int。 注意，必须显式地提供所需的类型，这与常规的函数模板是不同的，因为编译器可以根据函数的参数类型来确定要生成哪种函数： template &lt;class T&gt; void simple&lt;T t&gt; { cout &lt;&lt; t &lt;&lt; &apos;\n&apos;; } ... simple(2); simple(&quot;two&quot;); 程序14.14修改了原来的栈测试程序，使用字符串而不是unsigned long值作为订单ID。 程序14.14 stacktem.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cctype&gt; #include &quot;stacktp.h&quot; using std::cin; using std::cout; int main() { Stack&lt;std::string&gt; st; char ch; std::string po; cout &lt;&lt; &quot;Please ener A to add a purchase order,\n&quot; &lt;&lt; &quot;P to process a PO, or Q to quit.\n&quot;; while (cin &gt;&gt; ch &amp;&amp; std::toupper(ch) != &apos;Q&apos;) { while (cin.get() != &apos;\n&apos;) continue; if (!std::isalpha(ch)) { cout &lt;&lt; &apos;\a&apos;; continue; } switch(ch) { case &apos;A&apos;: case &apos;a&apos;: cout &lt;&lt; &quot;Enter a PO number to add: &quot;; cin &gt;&gt; po; if (st.isfull()) cout &lt;&lt; &quot;stack already full\n&quot;; else st.push(po); break; case &apos;p&apos;: case &apos;P&apos;: if (st.isempty()) cout &lt;&lt; &quot;stack already empty\n&quot;; else { st.pop(po); cout &lt;&lt; &quot;PO #&quot; &lt;&lt; po &lt;&lt; &quot; popped\n&quot;; } break; } cout &lt;&lt; &quot;Please enter A to add a purchase order,\n&quot; &lt;&lt; &quot;P to process a PO, or Q to quit.\n&quot;; } cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } 输出： Please ener A to add a purchase order, P to process a PO, or Q to quit. A Enter a PO number to add: red911porsche Please enter A to add a purchase order, P to process a PO, or Q to quit. A Enter a PO number to add: silver747boeing Please enter A to add a purchase order, P to process a PO, or Q to quit. A Enter a PO number to add: blueR8audi Please enter A to add a purchase order, P to process a PO, or Q to quit. P PO #blueR8audi popped Please enter A to add a purchase order, P to process a PO, or Q to quit. P PO #silver747boeing popped Please enter A to add a purchase order, P to process a PO, or Q to quit. P PO #red911porsche popped Please enter A to add a purchase order, P to process a PO, or Q to quit. P stack already empty Please enter A to add a purchase order, P to process a PO, or Q to quit. Q Bye. 14.4.3 深入探讨模板类可以将内置类型或类对象用作模板Stack的在新。指针可以吗？例如，可以使用char指针替换程序14.14中的string对象吗？毕竟，这种指针是处理C-风格字符串的内置方式。答案是可以创建指针栈，但如果不对程序做重大修改，将无法很好地工作。编译器可以创建类，但使用效果如何就因人而异。下面解释程序14.14不太合适使用指针栈的原因，然后介绍一个指针栈很好用的例子。 1. 不正确地使用指针栈 我们将简要地介绍3个试图对程序14.14进行修改，使之使用指针栈的简单（但有缺陷的）示例。这几个示例揭示了设计模板时应牢记的一些教训，切记盲目使用模板。这3个示例都以完全正确的Stack&lt;Type模板为基础： Stack&lt;char *&gt; st; 版本一将程序14.14中的： string po; 替换为： char * po; 这旨在用char指针而不是string对象来接受键盘输入。这种方法很快就失败了，因为仅仅创建指针，没有创建用于保存输入字符串的空间（程序通过编译，但在cin试图将输入保存在某些不合适的内存单元时崩溃）。 版本二将： string po; 替换为： char po[40]; 这为输入的字符串分配了空间。另外，po的类型为char$\ast$，因此可以被放在栈中。但数组完全与pop()方法的假设相冲突： template &lt;class Type&gt; bool Stack&lt;Type&gt;::pop(Type &amp; item) { if (top &gt; 0) { item = items[--top]; return true; } else return false; } 首先，引用变量item必须引用某种类型的左值，而不是数组名。其次，代码假设可以给item赋值。即使item能够引用数组，也不能给数组名赋值。因此这种方法失败了。 版本三将： string po; 替换为： char * po = new char[40]; 这为输入的字符串分配了空间。另外，po是变量，因此与pop()的代码兼容。然而o，这里将会遇到最基本的问题：只有一个po变量，该变量总是指向相同的内存单元。确实，在每当读取新字符串时，内存的内容都将发生改变，但每次执行压入操作时，加入到栈中的地址就相同。因此，对栈执行弹出操作时，得到的地址总是相同的，它总是指向读入的最后一个字符串。具体来说，栈并没有保存每一个新字符串，因此没有任何用途。 2. 正确使用指针栈 使用指针栈的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。把这些指针放在栈中是有意义的，因为每个指针都将指向不同的字符串。注意，创建不同指针是调用程序的职责，而不是栈的职责。栈的任务是管理指针，而不是创建指针。 例如，假设我们要模拟下面的情况。某人将一车文件交付给Plodson。如果Plodson的收取蓝（in-basket）是空的，他将取出车中最上面的文件夹，将其放入收取蓝；如果收取蓝是满的，Plodson将取出蓝中最上面的文件，对它进行处理，然后放入发出蓝（out-basked）中。如果收取蓝既不是空的也不是忙的，Plodson将处理收取蓝中最上面的文件，也可能取出车中的下一文件，把它放入收取蓝。他采取了自认为是比较鲁莽的行动—扔硬币来决定采取的措施。下面来讨论他的方法对原始文件处理顺序的影响。 可以用一个指针数组来模拟这种情况，中其的指针指向表示车中文件的字符串。每个字符串都包含文件所描述的人的姓名。可以用栈表示收取蓝，并使用第二个指针数组来表示发出蓝。通过将指针从输入数组压入到栈中来表示将文件添加到收取蓝中，同时通过从栈中弹出项目，并将它添加到发出蓝中来表示处理文件。 应考虑该问题的各个方面，因此栈的大小必须是可变的。程序14.15重新定义了Stack类，使Stack构造函数能够接受一个可选大小的参数。这涉及到在内部使用动态数组，因此，Stack类需要包含一个析构函数、一个赋值运算符和一个复制构造函数。另外，通过将多个方法作为内联函数，精简了代码。 程序14.15 stcktp1.h #ifndef STCKTP_H_ #define STCKTP_H_ template &lt;class Type&gt; class Stack { private: enum {SIZE = 10}; int stacksize; Type * items; int top; public: explicit Stack(int ss = SIZE); Stack(const Stack &amp; st); ~Stack() { delete [] items; } bool isempty() { return top == 0; } bool isfull() { return top == stacksize; } bool push(const Type &amp; item); bool pop(Type &amp; item); Stack &amp; operator=(const Stack &amp; st); }; template &lt;class Type&gt; Stack&lt;Type&gt;::Stack(int ss) : stacksize(ss), top(0) { items = new Type[stacksize]; } template &lt;class Type&gt; Stack&lt;Type&gt;::Stack(const Stack &amp; st) { stacksize = st.stacksize; items = new Type[stacksize]; top = st.top; for (int i = 0; i &lt; top; i++) items[i] = st.items[i]; } template &lt;class Type&gt; bool Stack&lt;Type&gt;::push(const Type &amp; item) { if (top &lt; stacksize) { items[top] = item; top++; return true; } else return false; } template &lt;class Type&gt; bool Stack&lt;Type&gt;::pop(Type &amp; item) { if (top &gt; 0) { item = items[--top]; return true; } else return false; } template &lt;class Type&gt; Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::operator=(const Stack&lt;Type&gt; &amp; st) { if (this == &amp;st) return *this; delete [] items; top = st.top; stacksize = st.stacksize; items = new Type [stacksize]; for (int i = 0; i &lt; top; i++) items[i] = st.items[i]; return *this; } #endif 原型将复制运算符函数的返回类型声明为Stack引用，而实际的模板函数定义将类型定义为Stack。前者是后者的缩写，但只能在类中使用。既可以在模板声明或模板定义内使用Stack，但在类的外面，即指定返回类型或使用作用域解析运算符时，必须使用完整的Stack。 程序14.6使用新的栈模板来实现Plodson模拟，它像以前介绍的模式那样使用rand()、srand()和time()来生成随机数。 程序14.16 stkoptr1.cpp #include &quot;stcktp1.h&quot; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; const int Num = 10; int main() { std::srand(std::time(0)); std::cout &lt;&lt; &quot;Please enter stack size: &quot;; int stacksize; std::cin &gt;&gt; stacksize; Stack&lt;const char *&gt; st(stacksize); const char * in[Num] { &quot;1: Hank gilgamesh&quot;, &quot;2: Kiki Ishtar&quot;, &quot;3: Betty Rocker&quot;, &quot;4: Ian Flagranti&quot;, &quot;5: Wolfgang Kibble&quot;, &quot;6: Portia Koop&quot;, &quot;7: Joy Almondo&quot;, &quot;8: Xaverie Paprika&quot;, &quot;9: Juan Moore&quot;, &quot;10: Misha Mache&quot; }; const char * out[Num]; int processed = 0; int nextin = 0; while (processed &lt; Num) { if (st.isempty()) st.push(in[nextin++]); else if (st.isfull()) st.pop(out[processed++]); else if (std::rand() % 2 &amp;&amp; nextin &lt; Num) st.push(in[nextin++]); else st.pop(out[processed++]); } for (int i = 0; i &lt; Num; i++) std::cout &lt;&lt; out[i] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } 两次输出： Please enter stack size: 5 1: Hank gilgamesh1: Hank gilgamesh 2: Kiki Ishtar 3: Betty Rocker 7: Joy Almondo 8: Xaverie Paprika 6: Portia Koop 5: Wolfgang Kibble 10: Misha Mache 9: Juan Moore 4: Ian Flagranti Bye. Please enter stack size: 5 1: Hank gilgamesh1: Hank gilgamesh 6: Portia Koop 7: Joy Almondo 8: Xaverie Paprika 5: Wolfgang Kibble 4: Ian Flagranti 3: Betty Rocker 2: Kiki Ishtar 9: Juan Moore 10: Misha Mache Bye. 程序说明： 在程序14.16中，字符串本身永远不会移动。把字符串压入栈实际上是新建一个指向该字符串的指针，即创建一个指针，该指针的值是现有字符串的地址。从栈弹出字符串将把地址复制到cout数组中。 该程序使用的类型是const char $\ast$，因为指针数组将被初始化为一组字符串常量。 栈的析构函数对字符串有何影响？没有。构造函数使用new创建一个用于保存指针的数组，析构函数删除该数组，而不是数组元素指向的字符串。 14.4.4 数组模板示例和非类型参数模板常用作容器类，这是因为类型参数的概念非常适用于将相同的存储方法用于不同的类型。确实，为容器类提供可重用代码是引入模板的主要动机，所以我们来看看另一个例子，深入探讨模板涉及和使用的其他几个方面。具体来说，将探讨一些非类型（或表达式）参数以及如何使用数组来处理继承族。 首先介绍一个允许指定数组大小的简单数组模板。一种方法是在类中使用动态数组和构造函数参数来提供元素数目，最后一个版本的Stack模板采用的就是这种方法。另一种方法是使用模板参数来提供常规的数组的大小，C++新增的模板array就是这样做的。程序14.17演示了如何做： 程序14.17 arraytp.h #ifndef ARRAYTP_H_ #define ARRAYTP_H_ #include &lt;iostream&gt; #include &lt;cstdlib&gt; template &lt;class T, int n&gt; class ArrayTP { private: T ar[n]; public: ArrayTP() {}; explicit ArrayTP(const T &amp; v); virtual T &amp; operator[](int i); virtual T operator[](int i) const; }; template &lt;class T, int n&gt; ArrayTP&lt;T, n&gt;::ArrayTP(const T &amp; v) { for (int i = 0; i &lt; n; i++) ar[i] = v; } template &lt;class T, int n&gt; T &amp; ArrayTP&lt;T, n&gt;::operator[](int i) { if (i &lt; 0 || i &gt;= n) { std::cerr &lt;&lt; &quot;Error is array limits: &quot; &lt;&lt; i &lt;&lt; &quot; is out of range.\n&quot;; std::exit(EXIT_FAILURE); } return ar[i]; } template &lt;class T, int n&gt; T ArrayTP&lt;T, n&gt;::operator[](int i) const { if (i &lt; 0 || i &gt;= n) { std::cerr &lt;&lt; &quot;Error is array limits: &quot; &lt;&lt; i &lt;&lt; &quot; is out of range.\n&quot;; std::exit(EXIT_FAILURE); } return ar[i]; } #endif 请注意程序14.17中的模板头： template &lt;class T, int n&gt; 关键字class（或在这种上下文中等价的关键字typename）指出T为类型参数，int指出n的类型为int。这种参数（指出特殊的类型而不是作为泛型名）称为非类型或表达式参数。假设有下面的声明： ArrayTP&lt;double, 12&gt; eggweights; 这将导致编译器定义名为ArrayTP的类，并创建一个类型为ArrayTP&lt;double, 12&gt;的eggweights对象。定义类时，编译将使用double替换T，使用12替换n。 表达式参数有一些限制。表达式参数可以是整型、枚举、引用或指针。因此double m是不合法的，但double $\ast$rm是合法的。另外，模板代码不能修改参数的值，也不能使用参数的地址。所以，在ArrayTP模板中不能使用诸如n++和&amp;n等表达式。另外，实例化模板时，用作表达式参数的值必须是常量表达式。 与Stack中使用的构造函数方法相比，这种改变数组大小的方法有一个优点。构造函数方法使用的是通过new和delete管理的堆内存，而表达式参数方法使用的是为自动变量维护的内存栈。这样，执行速度将更快，尤其是在使用了很多小型数组时。 表达式参数方法的主要缺点是，每个数组大小都将生成自己的模板。也就是说，下面的声明将生成两个独立的类声明： ArrayTP&lt;double, 12&gt; eggweights; ArrayTP&lt;double, 13&gt; donuts; 但下面的声明只生成一个类声明，并将数组大小信息传递给类的构造函数： Stack&lt;int&gt; eggs(12); Stack&lt;int&gt; dunkers(13); 另一个区别是，构造函数方法更通用，这是因为数组大小是作为类成员存（而不是硬编码）储在定义中的。这样可以将一种尺寸的数组赋给另一种尺寸的数组，也可以创建允许数组大小可变的类。 14.4.5 模板多功能性可以将用于常规类的技术用于模板类。模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数。例如，可以使用数组模板实现栈模板，也可以使用数组模板来构造数组—-数组元素是基于栈模板的栈。既可以编写下面的代码： template &lt;typename T&gt; class Array { private: T entry; ... }; template &lt;typename Type&gt; class GrowArray : public Array&lt;Type&gt; {...}; tempalte &lt;typename Tp&gt; class Stack { Array&lt;Tp&gt; ar; }; Array&lt; Stack&lt;int&gt; &gt; asi; 在最后一条语句中，C++98要求使用至少一个空白字符将两个&gt;符号分开，以免与运算符&gt;&gt;混淆。C++11不要求这样做。 1. 递归使用模板另一个模板多功能性的例子是，可以递归使用模板。例如，对于前面的数组模板定义，可以这样使用它： ArrayTP&lt; ArrayTP&lt;int, 5&gt;, 10&gt; twodes; 这使得twodes是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组。与之等价的常规数组声明如下： int twodes[10][5]; 请注意，在模板语法中，维的顺序与等价的二位数组相反。程序14.18使用了这种方法，同时使用ArrayTP模板创建了一维数组，来分别保存着10个组的总数和平均值。方法调用cout.width(2)以两个字符的宽度显式下一个条目（如果整个数字的宽度不超过两个字符）。 程序14.18 twod.cpp #include &quot;arraytp.h&quot; #include &lt;iostream&gt; int main() { using std::cout; using std::endl; ArrayTP&lt;int, 10&gt; sums; ArrayTP&lt;double, 10&gt; aves; ArrayTP&lt;ArrayTP&lt;int, 5&gt;, 10&gt; twodes; int i, j; for (i = 0; i &lt; 10; i++) { sums[i] = 0; for (j = 0; j &lt; 5; j++) { twodes[i][j] = (i + 1) * (j + 1); sums[i] += twodes[i][j]; } aves[i] = (double) sums[i] / 10; } for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 5; j++) { cout.width(2); cout &lt;&lt; twodes[i][j] &lt;&lt; &apos; &apos;; } cout &lt;&lt; &quot;: sum = &quot;; cout.width(3); cout &lt;&lt; sums[i] &lt;&lt; &quot;, average = &quot; &lt;&lt; aves[i] &lt;&lt; endl; } cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： 1 2 3 4 5 : sum = 15, average = 1.5 2 4 6 8 10 : sum = 30, average = 3 3 6 9 12 15 : sum = 45, average = 4.5 4 8 12 16 20 : sum = 60, average = 6 5 10 15 20 25 : sum = 75, average = 7.5 6 12 18 24 30 : sum = 90, average = 9 7 14 21 28 35 : sum = 105, average = 10.5 8 16 24 32 40 : sum = 120, average = 12 9 18 27 36 45 : sum = 135, average = 13.5 10 20 30 40 50 : sum = 150, average = 15 Done. 2. 使用多个类型参数模板可以包含多个类型参数。例如，希望类可以保存两种值，则可以创建并使用Pair模板来保存两个不同的值。程序14.19的小程序是一个这样的示例。其中，方法first() const和second() const报告存储的值，由于这两个方法返回Pair数据成员的引用，因此让您能够通过复制重新设置存储的值。 程序14.19 pairs.cpp #include &lt;iostream&gt; #include &lt;string&gt; template &lt;class T1, class T2&gt; class Pair { private: T1 a; T2 b; public: T1 &amp; first(); T2 &amp; second(); T1 first() const { return a;} T2 second() const { return b; } Pair(const T1 &amp; aval, const T2 &amp; bval) : a(aval), b(bval) {} Pair() {} }; template &lt;class T1, class T2&gt; T1 &amp; Pair&lt;T1, T2&gt;::first() { return a; } template &lt;class T1, class T2&gt; T2 &amp; Pair&lt;T1, T2&gt;::second() { return b; } int main() { using std::cout; using std::endl; using std::string; Pair&lt;string, int&gt; rating[4] = { Pair&lt;string, int&gt;(&quot;The Purpled Duck&quot;, 5), Pair&lt;string, int&gt;(&quot;Jaquie&apos;s Frisco Al Fresco&quot;, 4), Pair&lt;string, int&gt;(&quot;Cafe Souffle&quot;, 5), Pair&lt;string, int&gt;(&quot;Bertie&apos;s Eats&quot;, 3) }; int joints = sizeof(rating) / sizeof(Pair&lt;string, int&gt;); cout &lt;&lt; &quot;Rating:\tEatery\n&quot;; for (int i = 0; i &lt; joints; i++) cout &lt;&lt; rating[i].second() &lt;&lt; &quot;:\t&quot; &lt;&lt; rating[i].first() &lt;&lt; endl; cout &lt;&lt; &quot;Oops! Revised rating:\n&quot;; rating[3].first() = &quot;Bertie&apos;s Fab Eats&quot;; rating[3].second() = 6; cout &lt;&lt; rating[3].second() &lt;&lt; &quot;:\t&quot; &lt;&lt; rating[3].first() &lt;&lt; endl; return 0; } 需要注意一点的是，在main()函数中必须使用Pair&lt;string, int&gt;来调用构造函数，并将它用作sizeof的参数。这是因为类名是Pair&lt;string, int&gt;，而不出Pair。另外，Pair是另一个完全不同的类的名称。 输出： Rating: Eatery 5: The Purpled Duck 4: Jaquie&apos;s Frisco Al Fresco 5: Cafe Souffle 3: Bertie&apos;s Eats Oops! Revised rating: 6: Bertie&apos;s Fab Eats 3. 默认类型模板参数类模板的另一项特性是，可以为类型参数提供默认值： template &lt;class T1, class T2 = int&gt; class Topo {...}; 这样，如果省略T2的值，编译器将使用int： Topo&lt;double, double&gt; m1; Topo&lt;double&gt;m2; 第16章将讨论的标准模板库经常使用该特定，将默认类型设置为类。 虽然可以为类模板参数提供默认值，但不能为函数模板参数提供默认值。然而，可以为非类型参数提供默认值，这对于类模板和函数模板都是使用的。 14.4.6 模板的具体化类模板和函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化，它们统称为具体化。模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。 1. 隐式实例化到目前位置，本章所有的模板示例使用的都是隐式实例化，即它们声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的处方生成具体的类定义： ArrayTP&lt;int, 100&gt; stuff; 编译器在需要对象之前，不会生成类的隐式实例化： ArrayTP&lt;double 30&gt; * pt; //指针，还不需要对象 pt = new ArrayTP&lt;double, 30&gt;; //需要对象 底儿掉语句导致编译器生成类定义，并根据该定义创建一个对象。 2. 显式实例化但使用关键字template并指出所需类型声明类时，编译器将生成类声明的显式实例化。声明必须位于模板定义所在的名称空间中。例如，下面的声明将ArrayTP&lt;string, 100&gt;声明为一个类： template class ArrayTP&lt;string, 100&gt;; 在这种情况下，虽然没有创建或提及类对象，编译器也将生成类声明（包括方法定义）。和隐式实例化一样，也将根据通用模板来生成具体化。 3. 显式具体化显式具体化是特定类型（用于替换模板中的泛型）的定义。有时候，可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同。在这种情况下，可以创建显式具体化。例如，假设已经为用于表示排序后数组的类（元素在加入时被排序）定义了一个模板： template &lt;typename T&gt; class SortedArray { ... }; 另外，假设模式使用&gt;运算符来对值进行比较。对于数字，这管用；如果T表示一个类，则只要定义了T::operator&gt;()方法，这也管用；但如果T是有const char $\ast$表示的字符串，这将不管用。实际上，模板倒是可以正常工作，但字符串按地址（按照字母顺序）排序。这要求类定义使用strcmp()，而不是&gt;来对值进行比较。在这种情况下，可以提供一个显式模板具体化，这将采用具体类型定义的模板，而不是为泛型定义的模板。当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。 具体化模板定义的格式如下： template &lt;&gt; class Classname&lt;specialized-type-name&gt; {...}; 早期的编译器可能只能识别早期的格式，这种格式包含前缀template&lt;&gt;: class Classname&lt;specialized-type-name&gt; {...}; 要使用新的表示法提供一个专供const char $\ast$类型使用的SortedArray模板，可以使用类似下面的代码： template &lt;&gt; class SortedArray&lt;const char *&gt; {...}; 其中的实现代码将使用strcmp()（而不是&gt;）来比较数组值。现在，当请求const char $\ast$类型的SortedArray模板时，编译器将使用上述专用的定义，而不是通用的模板定义： SortedArray&lt;int&gt; scores; //使用一般定义 SortedArray&lt;const char *&gt; dates;//使用专用的定义 4. 部分具体化C++还允许部分具体化，即部分限制模板的通用性。例如，部分具体化可以给类型之一指定具体的类型： //一般模板 template &lt;class T1, class T2&gt; class Pair {...}; //T2设置为int的特殊模板 template &lt;class T1&gt; class Pair&lt;T2, int&gt; {...}; 关键字template后面的&lt;&gt;声明的是没有被具体化的类型参数。因此，上述第二个声明将T2具体化为int，但T1保持不变。注意，如果指定所有的类型，则&lt;&gt;内将为空，这将导致显式具体化： //T1和T2都被设置为int template&lt;&gt; class Pair&lt;int, int&gt; {...}; 如果有多个模板可供选择，编译器将使用具体化程度最高的模板。给定上述三个模板，情况如下： Pair&lt;double, double&gt; p1; //使用一般模板 Pair&lt;double, int&gt; p2; //使用Pair&lt;T1, int&gt;部分具体化模板 Pair&lt;int, int&gt; p3; //使用Pair&lt;int, int&gt;显式具体化模板 也可以通过为指针提供特殊版本来部分具体化现有的版本： template&lt;class T&gt; //一般版本 class Feeb { ... }; teamplate&lt;class T*&gt; //指针部分具体化 class Feeb {...}; 如果提供的类型不是指针，则编译器将使用通用版本；如果提供的是指针，则编译器将使用指针具体化版本： Feeb&lt;char&gt; fb1; //使用一般模板, T是char Feeb&lt;char *&gt; fb2; //使用Feeb T*具体化， T是char 如果没有进行部分具体化，则第二个声明将使用通用模板，将T转换为char $\ast$类型。如果进行类了部分具体化，则第二个声明将使用具体化模板，将T转换为char。 部分具体化特性使得能够设置各种限制。例如，可以这样做： //通用模板 template &lt;class T1, class T2, class T3&gt; class Trio {}; //使用T2具体化T3 template &lt;class T1, class T2&gt; class Trio&lt;T1, T2, T2&gt; {}; //使用T1*初始化T2和T3 template &lt;class T1&gt; class Trio&lt;T1, T1*, T1*&gt; {}; 给定上述声明，编译器将做出如下选择： Trio&lt;int, short, char *&gt; t1; //使用通用模板 Trio&lt;int, short&gt; t2; //使用Trio&lt;T1, T2, T2&gt; Trio&lt;char, char *, char *&gt; t3; //使用Trio&lt;T1, T1*, T1*&gt; 14.4.7 成员模板模板可用作结构、类或模板类的成员。要完全实现STL的涉及，必须使用这项特性。程序14.20是一个简短的模板类示例，该模板类将另一个模板类和模板函数作为其成员。 程序14.20 tempmemb.cpp #include &lt;iostream&gt; using std::cout; using std::endl; template &lt;typename T&gt; class beta { private: template &lt;typename V&gt; class hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { cout &lt;&lt; val &lt;&lt; endl; } V Value() const { return val; } }; hold&lt;T&gt; q; hold&lt;int&gt; n; public: beta(T t, int i) : q(t), n(i) {} template&lt;typename U&gt; U blab(U u, T t) {return (n.Value() + q.Value()) * u / t; } void Show() const { q.show(); n.show(); } }; int main() { beta&lt;double&gt; guy(3.5, 3); cout &lt;&lt; &quot;T was set to double\n&quot;; guy.Show(); cout &lt;&lt; &quot;V was set to T, which is double, then V was set to int\n&quot;; cout &lt;&lt; guy.blab(10, 2.3) &lt;&lt; endl; cout &lt;&lt; &quot;U was set to int\n&quot;; cout &lt;&lt; guy.blab(10.0, 2.3) &lt;&lt; endl; cout &lt;&lt; &quot;U was set to double\n&quot;; cout &lt;&lt; &quot;Done\n&quot;; return 0; } 输出： T was set to double 3.5 3 V was set to T, which is double, then V was set to int 28 U was set to int 28.2608 U was set to double Done 在程序14.20中，hold模板是在私有部分声明的，因此只能在beta类中访问它。beta类使用hold模板声明了两个数据成员： hold&lt;T&gt; q; hold&lt;int&gt; n; n是基于int类型的hold对象，而q成员是基于T类型（beta模板参数）的hold对象。在main()中，下述声明使得T表示的是double，因此q的类型为hold： beta&lt;double&gt; guy(3.5, 3); blab()方法的U类型由该方法被调用时的参数值显式确定，T类型由对象的实例化类型确定。在这个例子中，guy的声明将T的类型设置为double，而下述方法调用的第一个参数将U的类型设置为int（参数10对应的类型）： cout &lt;&lt; guy.blab(10, 2.5) &lt;&lt; endl; 因此，虽然混合类型引起的自动类型转换导致blab()中的计算以double类型进行，但返回值的类型为U(即int)，因此它被截断为28。 注意到调用guy.blab()时，使用10.0代替了10，因此U被设置为double，这使得返回类型为double，因此实施为28.2608。 正如前面指出的，guy对象的声明将第二个参数的类型设置为double。与第一个参数不同的是，第二个参数的类型不是由函数调用设置的。例如，下面的语句仍将blah()实现为blah(int, double)，并根据常规函数原型规则将3转换为类型double： cout &lt;&lt; guy.blab(10, 3) &lt;&lt; end; 可以在beta模板中声明hold类和blah方法，并在beta模板的外面定义它们。然而，很好的编译器根本不接受模板成员，而另一些编译器接受模板成员，但不接受类外面的定义。然而，如果所有的编译器接受外面的定义，则在beta模板之外定义模板方法的代码如下： template &lt;typename T&gt; class beta { private: template &lt;typename V&gt; class hold; hold&lt;T&gt; q; hold&lt;int&gt; n; public: beta(T t, int i) : q(t), n(i) {} template&lt;typename U&gt; U blab(U u, T t) {return (n.Value() + q.Value()) * u / t; } void Show() const { q.show(); n.show(); } }; //模板成员定义 template &lt;typename T&gt; template &lt;typename V&gt; class beta&lt;T&gt;::hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { cout &lt;&lt; val &lt;&lt; endl; } V Value() const { return val; } }; template &lt;typename T&gt; template &lt;typename U&gt; U beta&lt;T&gt;::blab(U u, T, t) { return (n.Value() + q.Value()) * u / t; } 上述定义将T、V和U用作模板参数。因为模板是嵌套的，因此必须使用下面的语法： template &lt;typename T&gt; template &lt;typename V&gt; 而不能使用下面的语法： template &lt;typename T, typename V&gt; 定义还必须指出hold和blab是beta类的成员，这是通过使用作用域解析运算符来完成的。 14.4.8 将模板用作参数您知道，模板可以包含类型参数（如typename T）和非类型参数（如int n）。模板还可以包含本身就是模板的参数，这种参数是模板新增的特性，用于实现STL。 在程序14.21所示的示例中，开头的代码如下： template &lt;template &lt;typename T&gt; class Thing&gt; class Crab 模板参数是templateclass Thing, 其中templateclass 是类型，Thing是参数。这意味着什么？假设有下面的声明： Crab&lt;King&gt; legs; 为使上述声明被接受，模板参数King必须是一个模板类，其声明与模板参数Thing的声明匹配： template &lt;typename T&gt; class King {...}; 在程序清单14.21中，Crab的声明声明了两个对象： Thing&lt;int&gt; s1; Thing&lt;double&gt; s2; 前面的legs声明将用King替换Thing，用King替换Thing。然而，程序14.21包含下面的声明： Crab&lt;Stack&gt; nebula; 因此，Thing将被实例化为Stack，而Thing将被实例化为Stack。总之，模板参数Thing将被替换为声明Crab对象时被用作模板参数的模板类型。 Crab类的声明对Thing代表的模板类做了另外3个假设，即这个类包含一个push()方法，包含一个pop()方法，且这些方法有特定的接口。Crab类可以使用任何与Thing类型声明匹配，并包含方法push()和pop()的模板类。本章恰巧有一个这样的类—-stacktp.h中定义的Stack模板，因此这个例子将使用它。 程序14.21 tempparm.cpp #include &lt;iostream&gt; #include &quot;stacktp.h&quot; template &lt;template &lt;class T&gt; class Thing&gt; class Crab { private: Thing&lt;int&gt; s1; Thing&lt;double&gt; s2; public: Crab() {} bool push (int a, double x) { return s1.push(a) &amp;&amp; s2.push(x); } bool pop (int &amp; a, double &amp; x) { return s1.pop(a) &amp;&amp; s2.pop(x); } }; int main() { using std::cout; using std::cin; using std::endl; Crab&lt;Stack&gt; nebula; int ni; double nb; cout &lt;&lt; &quot;Enter int double pairs, souch as 4.3 5 (0 0 to end): \n&quot;; while (cin &gt;&gt; ni &gt;&gt; nb &amp;&amp; ni &gt; 0 &amp;&amp; nb &gt; 0) { if (!nebula.push(ni, nb)) break; } while (nebula.pop(ni, nb)) cout &lt;&lt; ni &lt;&lt; &quot;, &quot; &lt;&lt; nb &lt;&lt; endl; cout &lt;&lt; &quot;Done.\n&quot;; return 0; } 输出： Enter int double pairs, souch as 4.3 5 (0 0 to end): 50 22.48 25 33.87 30 19.12 0 0 30, 19.12 25, 33.87 50, 22.48 Done. 可以混合使用模板参数和常规参数，例如，Crab类的声明可以像下面的打头： template &lt;template &lt;typename T&gt; class Thing, typename U, typename V&gt; class Crab { private: Thing&lt;U&gt; s1; Thing&lt;V&gt; s2; ... }; 现在，成员s1和成员s2可存储的数据类型为泛型，而不是用硬编码指定的类型。这要求程序中的nebula的声明修改成下面这样: Crab&lt;Stack, int, double&gt; nebula; 模板参数T表示一种模板类型，而类型参数U和V表示非模板类型。 14.4.9 模板类和友元模板类声明也可以有友元。模板的友元分3类： 非模板友元 约束(bound)模板友元，即友元的类型取决于类被实例化时的类型； 非约束(bound)模板友元，即友元的所有具体化都是类的每一个具体化的友元。 下面分别介绍它们。 1. 模板类的非模板友元函数在模板类中将一个常规函数声明为友元： template &lt;class T&gt; class HasFriend { public; friend void counts(); ... }; 上述声明使counts()函数成为模板所有实例化的友元。例如，它将是类HasFriend和HasFriend的友元。 counts()函数不是通过对象调用的（它是友元，不是成员函数），也没有对象参数，那么它如何访问HasFriend对象呢？有很多种可能性。它可以访问全局对象；可以使用全局指针访问非全局对象；可以创建自己的对象；可以访问独立于对象的模板类的静态数据成员。 假设要为友元函数提供模板类参数，可以如下所示来进行友元声明吗？ friend void report(HasFriend &amp;); 答案是不可以的。原因是不存在HasFriend这样的对象，而只有特定的具体和，如hasFriend。要提供模板类参数，必须知名具体化。例如，可以这样做： template &lt;class T&gt; class HasFriend { friend void report(HasFriend&lt;T&gt; &amp;); }; 为理解上述代码的功能，想想声明一个特定类型的对象时，将生成的具体化： HasFriend&lt;int&gt; hf; 编译器将用int替代模板参数T，因此友元声明的格式如下： class HasFriend&lt;int&gt; { friend void report(HasFriend&lt;int&gt; &amp;); } 也就是说，带HasFriend参数的report()将成为HasFriend类的友元。同样，带HasFriend参数的report()将是report()的一个重载版本—-它是HasFriend类的友元。 注意，report()本身并不是模板函数，而只是使用一个模板作为参数。这意味着必须为要使用的友元定义显式具体和： void report(HasFriend&lt;short&gt; &amp;) {} void report(HasFriedn&lt;int&gt; &amp;) {} 程序14.12说明了上面几点。HasFriend模板有一个静态成员ct。这意味着这个类的每一个特定的具体化都将有自己的静态成员。count()方法是所有HasFriend具体化的友元，它报告两个特定的具体化（HasFriend和HashFriend）的ct的值。该程序还提供两个report()函数，它们分别是某个特定HasFriend具体化的友元。 程序14.22 frnd2tmp.cpp #include &lt;iostream&gt; using std::cout; using std::endl; template &lt;typename T&gt; class HasFriend { private: T item; static int ct; public: HasFriend(const T &amp; i) : item(i) { ct++; } ~HasFriend() { ct--; } friend void counts(); friend void reports(HasFriend&lt;T&gt; &amp;); }; template &lt;typename T&gt; int HasFriend&lt;T&gt;::ct = 0; void counts() { cout &lt;&lt; &quot;int count: &quot; &lt;&lt; HasFriend&lt;int&gt;::ct &lt;&lt; &quot;; &quot;; cout &lt;&lt; &quot;double count: &quot; &lt;&lt; HasFriend&lt;double&gt;::ct &lt;&lt; endl; } void reports(HasFriend&lt;int&gt; &amp; hf) { cout &lt;&lt; &quot;HasFriend&lt;int&gt;: &quot; &lt;&lt; hf.item &lt;&lt; endl; } void reports(HasFriend&lt;double&gt; &amp; hf) { cout &lt;&lt; &quot;HasFriend&lt;double&gt;: &quot; &lt;&lt; hf.item &lt;&lt; endl; } int main() { cout &lt;&lt; &quot;No objects declared: &quot;; counts(); HasFriend&lt;int&gt; hfi1(10); cout &lt;&lt; &quot;After hfi1 declared: &quot;; counts(); HasFriend&lt;int&gt; hfi2(20); cout &lt;&lt; &quot;After hfi2 declared: &quot;; counts(); HasFriend&lt;double&gt; hfdb(10.5); cout &lt;&lt; &quot;After hfdb declared: &quot;; counts(); reports(hfi1); reports(hfi2); reports(hfdb); return 0; } 输出： No objects declared: int count: 0; double count: 0 After hfi1 declared: int count: 1; double count: 0 After hfi2 declared: int count: 2; double count: 0 After hfdb declared: int count: 2; double count: 1 HasFriend&lt;int&gt;: 10 HasFriend&lt;int&gt;: 20 HasFriend&lt;double&gt;: 10.5 2. 模板类的约束模板友元函数可以修改前一个示例，使友元函数本身成为模板。具体来说，为约束模板友元作准备，要使类的每一个具体化都获得于友元匹配的具体化。这比模板友元复杂些，包含以下3步： 首先，在类定义的前面声明每个模板函数。 template void counts();template void report(T &amp;); 然后，在函数中再次将模板声明为友元。这些语句根据类模板参数的类型声明具体化： template &lt;class TT&gt; class HasFriendT { ... friend void counts&lt;TT&gt;(); friend void report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;); }; 声明中的&lt;&gt;指出这是模板具体化。对于report()，&lt;&gt;可以为空，因为可以从函数参数推断出如下模板类型参数： HasFriendT&lt;TT&gt; 然而，也可以使用： report&lt;HasFriendT&lt;TT&gt; &gt;(HasFriendT&lt;TT&gt; &amp;) 但counts()函数没有参数，因此必须使用模板参数语法（）来指明其具体化。还需要注意的是TT是HasFriendT类的参数类型。 同样，理解这些声明的最佳方式也是设想声明一个特定具体化的对象时，它们将变成什么样。例如，假设声明了这样一个对象： HasFriendT&lt;int&gt; squack; 编译器将用int替换TT，并生成下面的类定义： class HasFriendT&lt;int&gt; { ... friend void counts&lt;int&gt; (); friend void report&lt;&gt;(HasFriendT&lt;int&gt; &amp;); }; 基于TT的具体化将变为int，基于HasFriendT的具体化将变为HasFriendT。因此，模板具体化counts和report&lt;HasFriendT &gt;()被声明为HasFriendT类的友元。 程序必须满足的第三个要求是，为友元提供模板定义。该程序14.23说明了这3个方面。请注意，程序14.22包含1个count()函数，它是所有HasFriend类的友元；而程序14.23包含两个count()函数，它们分别是某个被实例化的类类型的友元。因为count()函数调用没有可被编译器用来推断出所需具体化的函数参数，所以这些调用使用count和count来指明具体化。但对于report()调用，编译器可以从参数类型推断出要使用的具体化。使用&lt;&gt;格式也能获得同样的效果： report&lt;HasFriendT&lt;int&gt; &gt;() 程序14.23 temp2temp.cpp #include &lt;iostream&gt; using std::cout; using std::endl; template &lt;typename T&gt; void counts(); template &lt;typename T&gt; void report(T &amp;); template &lt;typename TT&gt; class HasFriendT { private: TT item; static int ct; public: HasFriendT(const TT &amp; i) : item(i) { ct++; } ~HasFriendT() { ct--; } friend void counts&lt;TT&gt;(); friend void report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;); }; template &lt;typename T&gt; int HasFriendT&lt;T&gt;::ct = 0; template &lt;typename T&gt; void counts() { cout &lt;&lt; &quot;template size: &quot; &lt;&lt; sizeof(HasFriendT&lt;T&gt;) &lt;&lt; &quot;; &quot;; cout &lt;&lt; &quot;template counts(): &quot; &lt;&lt; HasFriendT&lt;T&gt;::ct &lt;&lt; endl; } template &lt;typename T&gt; void report(T &amp; hf) { cout &lt;&lt; hf.item &lt;&lt; endl; } int main() { counts&lt;int&gt;(); HasFriendT&lt;int&gt; hfi1(10); HasFriendT&lt;int&gt; hfi2(20); HasFriendT&lt;double&gt; hfdb(10.5); report(hfi1); report(hfi2); report(hfdb); cout &lt;&lt; &quot;counts&lt;int&gt;() output:\n&quot;; counts&lt;int&gt;(); cout &lt;&lt; &quot;counts&lt;double&gt;() output:\n&quot;; counts&lt;double&gt;(); return 0; } 输出： template size: 4; template counts(): 0 10 20 10.5 counts&lt;int&gt;() output: template size: 4; template counts(): 2 counts&lt;double&gt;() output: template size: 8; template counts(): 1 正如您看到的，counts和counts报告的模板大小不同，这表明每种T类型都有自己的友元函数count()。 3. 模板类的非约束模板友元函数前一节的约束模板友元函数是在类外面声明的模板的具体化。int类具体化获得int函数具体化，依此类推。通过在类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元。对于非约束友元，友元模板类型参数与模板类类型参数是不同的： template &lt;typename T&gt; class ManyFriend { ... template &lt;typename C, typename D&gt; friend void show2(C &amp;, D &amp;); }; 程序12.24是一个使用非约束友元的例子。其次，函数调用show2(hfi1, hfi2)与下面的具体化匹配： void show2&lt;ManyFriend&lt;int&gt; &amp;, ManyFriend&lt;int&gt; &amp;&gt;(ManyFriend&lt;int&gt; &amp;, ManyFriend&lt;int&gt; &amp;); 因为它是所有ManyFriend具体化的友元，所以能够访问所有具体化的item成员，但它只访问了ManyFriend对象。 同样，show2(hfdb, hfi2)与下面具体化匹配： void show2&lt;ManyFriend&lt;double&gt; &amp;, ManyFriend&lt;int&gt; &amp;&gt;(ManyFriend&lt;double&gt; &amp;, ManyFriend&lt;int&gt; &amp;); 它也是所有ManyFriend具体化的友元，并访问了ManyFriend和ManyFriend的item成员。 程序12.24 manyfrnd.cpp #include &lt;iostream&gt; using namespace std; template &lt;class T&gt; class ManyFriend { private: T item; public: ManyFriend(const T &amp; i) : item(i) {} template &lt;typename C, typename D&gt; friend void show2(C &amp;, D &amp;); }; template &lt;typename C, typename D&gt; void show2(C &amp; c, D &amp; d) { cout &lt;&lt; c.item &lt;&lt; &quot;, &quot; &lt;&lt; d.item &lt;&lt; endl; } int main() { ManyFriend&lt;int&gt; hfi1(10); ManyFriend&lt;int&gt; hfi2(20); ManyFriend&lt;double&gt; hfdb(10.5); cout &lt;&lt; &quot;hfi1, hfi2: &quot;; show2(hfi1, hfi2); cout &lt;&lt; &quot;hfdb, hfi2: &quot;; show2(hfdb, hfi2); return 0; } 输出： hfi1, hfi2: 10, 20 hfdb, hfi2: 10.5, 20 14.4.10 模板别名（c++11）如果能为类型指定别名，将很方面，在模板设计种尤其如此。可使用typedef为模板具体化指定别名： typedef std::array&lt;double, 12&gt; arrd; typedef std::array&lt;int, 12&gt; arri; typedef std::array&lt;std::string, 12&gt; arrst; arrd gallons; arri days; arrst months; 但如果您经常编写类似于上述typedef的代码，您可能怀疑要么自己忘记了可简写化这项任务的C++功能，要么C++没有提供这样的功能。C++新增了一项功能—使用模板提供一系列别名，如下所示： template&lt;typename T&gt; using arrtype = std::array&lt;T, 12&gt;; 这将array定义为一个模板别名，可使用它来指定类型，如下所示： arrtype&lt;double&gt; gallons; arrtype&lt;int&gt; days; arrtype&lt;std::string&gt; months; 总之，arrtype表示类型std::array&lt;T, 12&gt;。 C++允许将语法using=用于非模板。用于模板时，这种语法与常规typedef等价： typedef const char * pc1; using pc2 = const char *; typedef const int *(*pa1)[10]; using pa2 = const int *(*)[10]; 习惯这种语法后，可能发现其可读性更强，因为它让类型名和类型信息更清晰。 C++新增的另一项模板功能是可变参数模板，让您能够定义这样的模板类和模板函数，即可接受可变数量的参数。这个主题将在第18章介绍。 14.5 总结代码重用手段：]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--类继承（十三）]]></title>
    <url>%2F2019%2F02%2F18%2FC%2B%2B%20Primer%20Plus--%E7%B1%BB%E7%BB%A7%E6%89%BF%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象编程的主要目的之一是提供可重用的代码。C++类提供了更多层次的重用性。目前，很多厂商提供了类库，类库由类声明和类实现构成。因为类组合了数组表示和类方法，因此提供了比函数库更加完整的程序包。类库是以源代码的方式提供，这意味着可以对其进行修改，以满足需要。然而，C++提供了比修改代码更好的方式来扩展和修改类。这种方法叫作类继承。它能够从已有的类派生出新的类，而派生类继承了原有类(称为基类)的特征，包括方法。 当然，可以通过复制原始代码，并对其进行修改来完成上述工作，但继承机制只需要提供新特性，甚至不需要访问源代码就可以派生出类。因此，如果购买的类库只提供了头文件和编译后代码，仍可以使用库中的类派生出新的类。而且可以在不公开实现的情况下将自己的类分发给其他仍，同时允许他们在类中添加新特性。 13.1 一个简单的基类从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。为说明继承，首先需要一个基类。Webtown俱乐部决定跟踪乒乓球会会员。作为俱乐部的首席程序员，需要设计一个简单的TableTennisPlayer类。如程序13.1和13.2所示。 程序13.1 tabtenn0.h #ifndef TABTENN0_H_ #define TABTENN0_H_ #include &lt;string&gt; using std::string; class TableTennisPlayer { private: string firstname; string lastname; bool hasTable; public: TableTennisPlayer(const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false); void Name() const; bool HasTable() const {return hasTable;} void ResetTable(bool v) {hasTable = v;} }; #endif 程序13.2 tabtenn0.cpp #include &quot;tabtenn0.h&quot; #include &lt;iostream&gt; TableTennisPlayer::TableTennisPlayer(const string &amp; fn, const string &amp; ln, bool ht):firstname(fn), lastname(ln),hasTable(ht) {} void TableTennisPlayer::Name() const { std::cout &lt;&lt; lastname &lt;&lt; &quot;, &quot; &lt;&lt; firstname; } 构造函数使用了第12章介绍的初始化列表语法，但也可以像下面这样做： TableTennisPlayer::TableTennisPlayer(const string &amp; fn, const string &amp; ln, bool ht) { firstname = fn; lastname = ln; hasTable = ht; } 这将首先为firstname调用string的默认构造函数，再调用string的赋值运算符将fitstname设置为fn，但初始化列表语法可以减少一个步骤，它直接使用string的复制构造函数将firstname初始化为fn。 程序13.3 usett0.cpp #include &lt;iostream&gt; #include &quot;tabtenn0.h&quot; int main() { using std::cout; TableTennisPlayer player1(&quot;Chuck&quot;, &quot;Blizzard&quot;, true); TableTennisPlayer player2(&quot;Tara&quot;, &quot;Boomdea&quot;, false); player1.Name(); if (player1.HasTable()) cout &lt;&lt; &quot;: has a table.\n&quot;; else cout &lt;&lt; &quot;: hasn&apos;t a table.\n&quot;; player2.Name(); if (player2.HasTable()) cout &lt;&lt; &quot;: has a table.\n&quot;; else cout &lt;&lt; &quot;: hasn&apos;t a table.\n&quot;; return 0; } 输出： Blizzard, Chuck: has a table. Boomdea, Tara: hasn&apos;t a table. 注意到该程序实例化对象将C-风格字符串作为参数： TableTennisPlayer player1(&quot;Chuck&quot;, &quot;Blizzard&quot;, true); TableTennisPlayer player2(&quot;Tara&quot;, &quot;Boomdea&quot;, false); 但构造函数的形参类型被声明为const string &amp;。这导致类型不匹配，但与第12章创建的String类一样，string类有一个将const char *作为参数的构造函数，使用C-风格字符串初始化string对象，将自动调用这个构造函数。总之，可见string对象或C-风格字符串作为构造函数TableTennisPlayer的参数；将前者作为参数时，将调用接受const string &amp;作为参数的string构造函数，而将后者作为参数，将调用接受const char $\ast$作为参数的string构造函数。 13.1.1 派生一个类Webtown俱乐部的一些成员曾经参加过当地的乒乓球锦标赛，需要这样一个类，它能包括成员在比赛中的比分。与其从零开始，不如从TableTennisPlayer类派生出一个类。首先将RatedPlayer类声明为TableTennisPlayer类派生而来的： class RatedPlayer : public TableTennisPlayer { ... }; 冒号指出RatePlayer类的基类是TableTennisPlayer类。上述特殊的声明头表明TableTennisPlayer是一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成员派生类的一部分，但只能通过基类的公有和保护方法访问。 RatedPlayer对象具有如下特征： 派生类对象存储了基类的数据成员(派生类继承了基类的实现)； 派生类对象可以使用基类的方法(派生类继承了基类的接口)。 因此，RatedPlayer对象可以存储运动员的姓名及其是否有球桌。另外，RatedPlayer对象还可以使用TableTennisPlayer类的Name()、hasTable()和ResetTable()方法(见图13.1)。 需要在继承特性中添加什么呢？ 派生类需要自己的构造函数。 派生类可以根据需要添加额外的数据成员和成员函数。 在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。因此，类声明与下面类似： class RatedPlayer() : public TableTennisPlyaer { private: unsigned int rating; public: RatedPlayer(unsigned int r = 0, const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false); RatedPlayer(unsigned int r = 0, const TableTennisPlayer &amp; tp); unsigned int Rating() const { return rating; } void ResetRating(unsigned int r) { rating = r; } }; 构造函数必须给新成员(如果有的话）和继承的成员提供数据。在第一个RatedPlayer构造函数中，每个成员对应一个形参；而第二个RatedPlayer构造函数中使用一个TableTennisPlayer参数，该参数包括firstname, lastname和hasTable。 13.1.2 构造函数：访问权限的考虑派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，RatePlayer构造函数不能直接设置继承的成员(firstname, lastname和hasTable)，而必须使用基类的公有方法来访问私有的基类成员。具体来说，派生类构造函数必须使用基类构造函数。 创建派生对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表语法来完成这种工作。例如，下面是第一个RatedPlayer构造函数的代码： RatedPlayer(unsigned int r = 0, const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false) : TableTennisPlayer(fn, ln, ht) { rating = r; } 其中 TableTennisPlayer(fn, ln, ht)是成员列表初始化列表。它是可执行的代码，调用TableTennisPlayer构造函数。例如，假设程序包含如下声明： RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); 则RatedPlayer构造函数将把实参”Mallory”、”Duck”和true赋给形参fn、ln和ht，然后，将这些形参作为实参传递给TableTennisPlayer构造函数，后者将创建一个嵌套TableTennisPlayer对象，并将数据”Mallory”、”Duck”和true存储在对象中。然后，程序进入RatedPlayer构造函数体，完成RatedPlayer对象的创建，并将参数r赋给rating成员。 如果省略成员初始化列表，情况将如何？ RatedPlayer(unsigned int r = 0, const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false) { rating = r; } 必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数，因此上述代码与下面等效：、 RatedPlayer(unsigned int r = 0, const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false) : TableTennisPlayer() { rating = r; } 除非要使用默认构造函数，否则应显式调用正确的基类构造函数。 下面看第二个构造函数的代码： RatedPlayer(unsigned int r = 0, const TableTennisPlayer &amp; tp) : TableTennisPlayer(tp) { rating = r; } 这里也将TableTennisPlayer的信息传递给了TableTennisPlayer构造函数： TableTennisPlayer(tp) 由于tp的类型为TableTennisPlayer &amp;，因此将调用基类的复制构造函数。基类没有定义复制构造函数，但第12章介绍过，如果需要使用复制构造函数但没有定义，编译器将自动生成一个。在这种情况下，执行成员复制的隐式复制构造函数是合适的，因为这个类没有使用动态内存分配(string成员确实使用了动态内存分配，但本书前面讲过，成员复制将使用string类的复制构造函数来复制string成员)。 如果愿意，也可以对派生类成员使用初始化列表语法。在这种情况下，应在列表中使用成员名，而不是类名。所以，第二个构造函数可以按照下述方式编写： RatedPlayer(unsigned int r = 0, const TableTennisPlayer &amp; tp) : TableTennisPlayer(tp), rating(r) { } 有关派生类构造函数的要点如下： 首先创建基类对象； 派生类构造函数通过成员初始化列表将基类信息传递给基类构造函数； 派生类构造函数应初始化派生类新增的数据成员。 这个例子没有提供显式析构函数，因此将使用隐式析构函数。释放对象的顺序与创建对象顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。 注意: 创建派生类对象时，程序首先调用基类的构造函数，然后再调用派生类的构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数负责初始化新增的数据成员。派生类的构造函数总是调用一个基类的构造函数。可以使用初始化列表语法知名要使用的基类构造函数，否则使用默认的基类构造函数。 成员初始化列表 派生类构造函数可以使用初始化列表机制将值传递给基类构造函数。请看下面的例子： derived::derived(type1 x, type2 y)::base(x, y) { ... } 其中derived是派生类，base是基类，x和y是基类构造函数使用的变量。例如，如果派生类构造函数接收到参数10和12，则这种机制将把10和12传递给被定义为接受这些类型参数的基类构造函数。除虚基类外(第14章)，类只能将值传递给相邻的基类，方后者可以使用相同的机制将信息传递给相邻的基类，依此类推。 13.1.3 使用派生类要使用派生类，程序必须要能够访问基类声明。程序13.4将这两个类置于同一头文件中，也可以将每个类放在独立的头文件中，但这两个类是相关的，所以把其类声明放在一起更合适。 程序13.4 tabtenn1.h #ifndef TABTENN1_H_ #define TABTENN1_H_ #include &lt;string&gt; using std::string; class TableTennisPlayer { private: string firstname; string lastname; bool hasTable; public: TableTennisPlayer(const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false); void Name() const; bool HasTable() const {return hasTable;} void ResetTable(bool v) {hasTable = v;} }; class RatedPlayer : public TableTennisPlayer { private: unsigned int rating; public: RatedPlayer(unsigned int r = 0, const string &amp; fn = &quot;none&quot;, const string &amp; ln = &quot;none&quot;, bool ht = false); RatedPlayer(unsigned int r, const TableTennisPlayer &amp; pt); unsigned int Rating() const { return rating; } void ResetRating(unsigned int r) { rating = r; } }; #endif 程序13.5 tabtenn1.cpp #include &lt;iostream&gt; #include &quot;tabtenn1.h&quot; TableTennisPlayer::TableTennisPlayer(const string &amp; fn, const string &amp; ln, bool ht):firstname(fn), lastname(ln),hasTable(ht) {} void TableTennisPlayer::Name() const { std::cout &lt;&lt; lastname &lt;&lt; &quot;, &quot; &lt;&lt; firstname; } RatedPlayer::RatedPlayer(unsigned int r, const string &amp; fn, const string &amp; ln, bool ht) : TableTennisPlayer(fn, ln, ht) { rating = r; } RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &amp; pt) : TableTennisPlayer(pt), rating(r) { } 程序13.6 usett1.cpp #include &lt;iostream&gt; #include &quot;tabtenn1.h&quot; int main() { using std::cout; using std::endl; TableTennisPlayer player1(&quot;Tara&quot;, &quot;Boomdea&quot;, false); RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); rplayer1.Name(); if (rplayer1.HasTable()) cout &lt;&lt; &quot;: has a table.\n&quot;; else cout &lt;&lt; &quot;: hasn&apos;t a table.\n&quot;; player1.Name(); if (player1.HasTable()) cout &lt;&lt; &quot;: has a table.\n&quot;; else cout &lt;&lt; &quot;: hasn&apos;t a table.\n&quot;; cout &lt;&lt; &quot;Name: &quot;; rplayer1.Name(); cout &lt;&lt; &quot;; Rating: &quot; &lt;&lt; rplayer1.Rating() &lt;&lt; endl; RatedPlayer rplayer2(1212, player1); cout &lt;&lt; &quot;Name: &quot;; rplayer2.Name(); cout &lt;&lt; &quot;; Rating: &quot; &lt;&lt; rplayer2.Rating() &lt;&lt; endl; return 0; } 输出： Duck, Mallory: has a table. Boomdea, Tara: hasn&apos;t a table. Name: Duck, Mallory; Rating: 1140 Name: Boomdea, Tara; Rating: 1212 13.1.4 派生类和基类之间的特殊关系派生类与基类之间有一些特殊关系。其中之一是派生类对象可以使用基类的方法，条件是方法不是私有的： RatedPlayer rplayer(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); rplayer.Name(); 另外两个重要的关系是：基类指针可以在不进行显示类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生对象： RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); TableTennisPlayer &amp; rt = rplayer; TableTennisPlayer * pt = &amp;rplayer; rt.Name(); rt-&gt;Name(); 然而，基类指针或引用只能用于调用基类方法，因此，不能使用rt或pt调用派生类的ResetRating方法。 通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类应用和指针。 上述规则是有道理的。例如，如允许基类引用隐式地派生类对象，则可以使用基类引用派生类对象调用基类的方法。因为派生类继承了基类的方法，所以这样做不会出现问题。如果可以将基类对象赋给派生类引用，将发生什么情况呢？派生类引用能够为基对象调用派生类方法，这样做将出现问题。例如，将RatedPlayer::Rating()方法用于TableTennisPlayer对象是没有意义的，因为TableTennisPlayer对象没有rating成员。 如果基类引用和指针指向派生类对象，将出现一些有趣的结果。其中之一是基类引用定义的函数或参数可用基类对象或派生对象。例如，下面的函数中： void Show(cosnt TableTennisPlayer &amp; rt) { using std::cout; cout &lt;&lt; &quot;Name: &quot;; rt.Name(); cout &lt;&lt; &quot;\nTable: &quot;; if (rt.HasTable()) cout &lt;&lt; &quot;yes\n&quot;; else cout &lt;&lt; &quot;no\n&quot;; } 形参rt是一个基类的引用，它可以指向基类对象或派生类对象，所以可以在Show()中使用TableTennis参数或RatedPlayer参数： TableTennisPlayer player1(&quot;Tara&quot;, &quot;Boomdea&quot;, false); RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); Show(player1); Show(rplayer1); 对于形参为指向基类的指针的函数，也存在相似的关系。它可以使用基类对象的地址或派生类对象的地址作为实参： void Wohs(const TableTennisPlayer * pt); TableTennisPlayer player1(&quot;Tara&quot;, &quot;Boomdea&quot;, false); RatedPlayer rplayer1(1140, &quot;Mallory&quot;, &quot;Duck&quot;, true); Wohs(&amp;player1); Wohs(&amp;rplayer1); 引用兼容属性也让您能够将基类对象初始化为派生类对象，尽管不那么直接。假设有这样的代码： RatedPlayer olaf1(1840, &quot;Olaf&quot;, &quot;Loaf&quot;, true); TableTennisPlayer olaf2(olaf1); 要初始化olaf，匹配的构造函数的原型如下： TableTennisPlayer(const RatedPlayer &amp;); //没有定义 类定义中没有这样的构造函数，但存在隐式复制构造函数： TableTennisPlayer(const TableTennisPlayer &amp;); 形参是基类的引用，因此它可以引用派生类。这样，将olaf2初始化olaf1时，将要使用该构造函数，它复制firstname、lastname和hasTable成员。即，它将olaf2初始化为嵌套在RatedPlayer对象olaf1中的TableTennisPlayer对象。 同样，也可以将派生对象赋给基类对象： RatedPlayer olaf1(1840, &quot;Olaf&quot;, &quot;Loaf&quot;, true); TableTennisPlayer winner; winner = olaf1; 在这种情况下，程序将使用隐式重载复制运算符： TableTennisPlayer &amp; operator=(const TableTennisPlayer &amp;) const; 基类引用指向也是派生类对象，因此olaf1的基类部分被复制给winner。 13.2 继承：is-a关系派生类和基类之间的特殊关系是基于C++继承的底层模型。实际上，C++有3种继承方式：公有继承、保护继承和私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何对象，也可以对派生类执行。因为派生类可以添加特性，所以，将这种关系成为is-a-kind-of(是一种)关系可能更准确，但通常使用属于is-a。 为阐明is-a关系，来看一些与该模型不符的例子。公有继承不建立is-a关系。例如，午餐可能包括水果，但通常午餐并不是水果。所以，不能通过从Fruit派生出Lunch类来在午餐中添加水果。在午餐中加入水果的正确做法是将其作为一种has-a关系：午餐有水果。正如将在第14章介绍的，最容易的建模方式是，将Fruit对象作为Lunch类的数据成员。参见图13.3。 公有继承不能建立is-like-a关系，即，它不采用明喻。人们通常说律师像鲨鱼，但律师并不是鲨鱼。例如，鲨鱼可以在水下生活。所以，不应从Shark类派生出Lawyer类。继承可以在基类的基础上添加属性，但不能删除基类的属性。在有些情况下，可以设计一个包含共有特征的类，然后，以is-a或has-a关系，在这个类的基础上定义相关的类。 公有类继承不讲理is-implemented-as-a(作为……来实现)关系。例如，可以使用数组来实现栈，但从Array类派生出Stack类是不合适的，因为栈不是数组。例如，数组索引不是栈的属性。另外，可以以其他方式实现栈，如链表。正确的做法是，通常让栈包含一个私有Array对象来隐藏数组实现。 公有继承不见uses-a关系。例如，计算机可以使用激光打印机，但从computer类派生出Priter类(或反过来)是没有意义的。然而，可以使用友元函数或类来处理Printer对象和Computer对象之间的通信。 在C++中，完全可以使用公有继承来建立has-a、is-implemented-as-a或uses-a关系；然而，这样做通常导致编程方面的问题。因此，还是坚持使用is-a关系吧。 13.3 多态公有继承RatedPlayer继承示例很简单。派生类对象使用基类对象的方法，而未做任何修改。然而，可能会遇到这样的情况，即希望同一个方法在派生类和基类中的行为是不同的。即，方法的行为应取决于调用该方法的对象。这种较复杂的行为称为多态—具有多种形参，即同一个方法的行为随上下文而异。有两种重要的机制可用于实现多态公有继承： 在派生类中重新定义基类的方法。 使用虚方法。 现在来看一个例子。由于Webtown俱乐部的工作经历，您成了Pontoon银行的首席程序员。银行要求您完成的第一项开发工作是开发两个类。一个类用于表示基本支票账户—Brass Acccount，另一个类用于表示Brass Plus支票账户，它添加了透支保护特性。即，如果用户签出一张超出其存储余额的支票—但是超出的数额并不是很大，银行将支付这张支票，对超出的部分收取额外的费用，并追加罚款。可以根据要保存的数据以及允许执行的操作来确定这两种账户的特征。 下面是用于Brass Account支票账户的信息： 客户姓名 账户 当前结余 下面是可以执行的操作： 创建账户 存款 取款 显式账户信息 Pontoon银行希望Brass Plus支票账户包含Brass Account的所有信息及如下信息： 透支上限 透支贷款利率 当前的透支总额 不需要新增操作，但有两种操作的实现不同： 对于取款操作，必须考虑透支保护； 显式操作必须显式Brass Plus账户的其他信息。 假设将第一个类命名为Brass，第二个类为BrassPlus。应从Brass公有派生出BrassPlus吗？要回答这个问题，必须先回答另一个问题：BrassPlus类是否满足is-a条件？当然满足。对于Brass对象是正确的事情，对于BrassPlus对象也是正确的。它们都将保存客户姓名、账户以及余额。使用这两个类都可以存款、取款和显式账户信息。请注意，is-a关系通常是不可逆的。也就是说，水果不是香蕉；同样，Brass对象不具备BrassPlus对象的所有功能。 13.3.1 开发Brass类和BrassPlus类Brass Account类的信息很简单，但是银行没有告诉您有关透支系统的细节。仅提供了如下信息： Brass Plus账户限制了客户的透支额度。默认为500元，但有些客户的额度可能不同； 银行可以修改客户的透支限额； Brass Plus账户对贷款收取利息。默认为11.125%，但有些客户的利率可能不同； 银行可以修改客户的利率； 银行记录客户所欠银行的金额(透支数额加利息)。用户不能通过常规存款或从其他账户转账的方式偿付，而必须以现金的方式交给特定的银行工作人员。如果有必要，工作人员可以找到该客户。欠款还清后，欠款金额归零。 最后一种特性是银行处于做生意的考虑而采用的，这种方法有它有利的一面—-使编程更简单。 上述列表表明，新的类需要构造函数，而且构造函数应提供账户信息，设置透支上限和利率。另外，还应有重新设置透支限额、利率和当前欠款的方法。要添加到Brass类中的就这些信息，这将在Brass Plus类声明中声明。 有关这两个类的信息声明，类声明应类似于程序13.7。 程序13.7 brass.h #ifndef BRASS_H_ #define BRASS_H_ #include &lt;string&gt; class Brass { private: std::string fullName; long acctNum; double balance; public: Brass(const std::string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0); void Deposit(double amt); virtual void Withdraw(double amt); double Balance() const; virtual void ViewAcct() const; virtual ~Brass() {} }; class BrassPlus : public Brass { private: double maxLoan; double rate; double owesBank; public: BrassPlus(const std::string &amp; s = &quot;Null&quot;, long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125); BrassPlus(const Brass &amp; ba, double ml = 500, double r = 0.11125); virtual void ViewAcct() const; virtual void Withdraw(double amt); void ResetMax(double m) { maxLoan = m; } void ResetRate(double r) { rate = r; } void ResetOwes() { owesBank = 0; } }; #endif 对于程序13.7，需要说明如下几点： BrassPlus类在Brass类的基础上添加了3个私有成员和3个公有成员函数； Brass类和BrassPlus类都声明了ViewAcct()和Withdraw()方法，但BrassPlus对象和Brass对象的这些方法的行为是不同的； Brass类声明ViewAcct()和Withdraw()使用了新关键字vitual，这些方法被称为虚方法； Brass类还声明了一个虚析构函数，虽然该析构函数不执行任何操作。 第二点，介绍了声明如何指出方法在派生类的行为的不同。两个ViewAcct()原型表明将有2个独立的方法定义。基类版本的限定为Brass::ViewAcct()，派生类版本的限定名为BrassPlus::ViewAcct()。程序将使用对象类型来确定使用哪个版本： Brass dom(&quot;Porcelot Pigg&quot;, 381299, 4000.00); BrassPlus dot(&quot;Horatio Hogg&quot;, 382288, 3000.00); dom.ViewAcct(); dot.ViewAcct(); 第三点，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字vitual，程序将根据引用类型或指针类型选择方法；如果使用了virtua，程序将根据引用或指针指向的对象的类型来选择方法。如果ViewAcct()不是虚函数，则程序的行为如下： Brass dom(&quot;Porcelot Pigg&quot;, 381299, 4000.00); BrassPlus dot(&quot;Horatio Hogg&quot;, 382288, 3000.00); Brass &amp; b1_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct(); b2_ref.ViewAcct(); 引用变量的类型为Brass，所以都选择了Brass::ViewAccount()。使用Brass指针代替引用时，行为将与此类似。 如果ViewAcct()是虚函数，则行为如下： Brass dom(&quot;Porcelot Pigg&quot;, 381299, 4000.00); BrassPlus dot(&quot;Horatio Hogg&quot;, 382288, 3000.00); Brass &amp; b1_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct(); b2_ref.ViewAcct(); 这里两个引用的类型都是Brass，但b2_ref引用的是一个BrassPlus对象，所以使用的是BrassPlus::ViewAcct()。使用Brass指针代替引用时，行为将类似。 稍后会发现，虚函数的这种行为非常方便。因此，经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚方法后，它在派生类中将自动变成虚方法。然而，在派生类中声明中使用关键字virtual来指出哪些方法是虚方法也是一个好办法。 第四点，基类中声明了一个虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。本章后面将介绍这个问题。 注意：如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚方法。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。 1. 类实现 关键字virtual只用于类声明的方法原型中。 程序13.8 brass.cpp #include &quot;brass.h&quot; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; typedef std::ios_base::fmtflags format; typedef std::streamsize precis; format setFormat(); void restore(format f, precis p); Brass::Brass(const string &amp; s, long an, double bal) { fullName = s; acctNum = an; balance = bal; } void Brass::Deposit(double amt) { if (amt &lt; 0) cout &lt;&lt; &quot;Negative deposit not allowed; &quot; &lt;&lt; &quot;deposit is cancelled.\n&quot;; else balance += amt; } void Brass::Withdraw(double amt) { format initialState = setFormat(); precis prec = cout.precision(2); if (amt &lt; 0) cout &lt;&lt; &quot;Withdrawal amount must be positive; &quot; &lt;&lt; &quot;withdrawal canceled.\n&quot;; else if (amt &lt;= balance) balance -= amt; else cout &lt;&lt; &quot;Withdrawal amount of $&quot; &lt;&lt; amt &lt;&lt; &quot; exceeds your balance.\n&quot; &lt;&lt; &quot;Withdrawal canceled.\n&quot;; restore(initialState, prec); } double Brass::Balance() const { return balance; } void Brass::ViewAcct() const { format initialState = setFormat(); precis prec = cout.precision(2); cout &lt;&lt; &quot;Client: &quot; &lt;&lt; fullName &lt;&lt; endl; cout &lt;&lt; &quot;Account Number: &quot; &lt;&lt; acctNum &lt;&lt; endl; cout &lt;&lt; &quot;Balance: $&quot; &lt;&lt; balance &lt;&lt; endl; restore(initialState, prec); } BrassPlus::BrassPlus(const string &amp; s, long an, double bal, double ml, double r): Brass(s, an, bal) { maxLoan = ml; owesBank = 0.0; rate = r; } BrassPlus::BrassPlus(const Brass &amp; ba, double ml, double r) : Brass(ba) { maxLoan = ml; owesBank = 0.0; rate = r; } void BrassPlus::ViewAcct() const { format initialState = setFormat(); precis prec = cout.precision(2); Brass::ViewAcct(); cout &lt;&lt; &quot;Maximum loan: $&quot; &lt;&lt; maxLoan &lt;&lt; endl; cout &lt;&lt; &quot;Owed to bank: $&quot; &lt;&lt; owesBank &lt;&lt; endl; cout.precision(3); cout &lt;&lt; &quot;Loan Rate: &quot; &lt;&lt; 100 * rate &lt;&lt; &quot;%\n&quot;; restore(initialState, prec); } void BrassPlus::Withdraw(double amt) { format initialState = setFormat(); precis prec = cout.precision(2); double bal = Balance(); if (amt &lt;= bal) Brass::Withdraw(amt); else if ( amt &lt;= bal + maxLoan - owesBank) { double advance = amt - bal; owesBank += advance * (1.0 + rate); cout &lt;&lt; &quot;Bank advance: $&quot; &lt;&lt; advance &lt;&lt; endl; cout &lt;&lt; &quot;Finance charge: $&quot; &lt;&lt; advance * rate &lt;&lt; endl; Deposit(advance); Brass::Withdraw(amt); } else cout &lt;&lt; &quot;Credit limit exceeded. Transaction cancelled.\n&quot;; restore(initialState, prec); } format setFormat() { return cout.setf(ios_base::fixed,ios_base::floatfield); } void restore(format f, precis p) { cout.setf(f, ios_base::floatfield); cout.precision(p); } 首先，看一下与继承相关的方面。记住，派生类并不能访问基类的私有成员，而必须通常使用基类的公有方法才能访问这些数据。访问的方式取决于方法。构造函数使用一种技术，而其他成员函数使用另一种技术u 派生构造函数在初始化基类私有数据时，采用的是成员初始化列表语法。RatedPlayer和BrassPlus构造函数都使用了这种技术: BrassPlus::BrassPlus(const string &amp; s, long an, double bal, double ml, double r): Brass(s, an, bal) { maxLoan = ml; owesBank = 0.0; rate = r; } BrassPlus::BrassPlus(const Brass &amp; ba, double ml, double r) : Brass(ba) { maxLoan = ml; owesBank = 0.0; rate = r; } 这几个构造函数都使用成员初始化列表语法，将基类信息传递给基类构造函数，然后使用构造函数体初始化BrassPlus类新增的数据成员。 非构造函数不能使用成员初始化类别语法，但派生类可以调用公有的基类方法。例如，BrassPlus版本的ViewAcct()核心内容如下: void BrassPlus::ViewAcct() const { ... Brass::ViewAcct(); cout &lt;&lt; &quot;Maximum loan: $&quot; &lt;&lt; maxLoan &lt;&lt; endl; cout &lt;&lt; &quot;Owed to bank: $&quot; &lt;&lt; owesBank &lt;&lt; endl; cout &lt;&lt; &quot;Loan Rate: &quot; &lt;&lt; 100 * rate &lt;&lt; &quot;%\n&quot;; ... } 换句话说，BrassPlus::ViewAcct()显式新增的BrassPlus数据成员，并调用基类方法Brass::ViewAcct()来显示基类数据成员。在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法。 如果代码没有使用作用域解析运算符，编译器将认为ViewAcct()是BrassPlus::ViewAcct()，这将创建一个不会终止的递归函数—这可不好。 接下来看BrassPlus::Withdraw()方法。如果客户提取的金额超过了结余，该方法将安排贷款。它可以使用Brass::Withdraw()来访问balance成员，但如果提取的金额超过了结余，Brass::Withdraw()将发出一个错误消息。这种实现使用Deposit()进行放贷，然后在得到了足够的结余后，调用Brass::Withdraw()，从而避免了错误信息。 void BrassPlus::Withdraw(double amt) { ... double bal = Balance(); if (amt &lt;= bal) Brass::Withdraw(amt); else if ( amt &lt;= bal + maxLoan - owesBank) { double advance = amt - bal; owesBank += advance * (1.0 + rate); cout &lt;&lt; &quot;Bank advance: $&quot; &lt;&lt; advance &lt;&lt; endl; cout &lt;&lt; &quot;Finance charge: $&quot; &lt;&lt; advance * rate &lt;&lt; endl; Deposit(advance); Brass::Withdraw(amt); } else cout &lt;&lt; &quot;Credit limit exceeded. Transaction cancelled.\n&quot;; ... } 该方法使用基类的Balance()函数来确定结余。因为派生类没有重新定义该方法，代码不必对Balance()使用作用域解析运算符。 方法ViewAcct()和Withdraw()使用格式化方法setf()和precision()将浮点值的输出模式设置为定点，即包含两位小数。设置模式后，输出的模式将保持不变，因此该方法将格式模式重置为调用前的模式。这与程序8.8和程序10.5类似。为避免代码重复，该程序将设置格式的代码放在辅助函数中： typedef std::ios_base::fmtflags format; typedef std::streamsize precis; format setFormat(); void restore(format f, precis p); 函数setFormat()设置定点表示法并返回以前的标记设置： format setFormat() { return cout.setf(ios_base::fixed,ios_base::floatfield); } 而函数restore()重置格式和进度： void restore(format f, precis p) { cout.setf(f, ios_base::floatfield); cout.precision(p); } 有关设置输出格式的更详细信息，参阅第17章。 2. 使用Brass和BrassPlus类 程序13.9 usebrass1.cpp #include &quot;brass.h&quot; #include &lt;iostream&gt; int main() { using std::cout; using std::endl; Brass Piggy(&quot;Porcelot Pigg&quot;, 381299, 4000.00); BrassPlus Hoggy(&quot;Horatio Hogg&quot;, 382288, 3000.00); Piggy.ViewAcct(); cout &lt;&lt; endl; Hoggy.ViewAcct(); cout &lt;&lt; endl; cout &lt;&lt; &quot;Depositing $1000 into the Hogg Account:\n&quot;; Hoggy.Deposit(1000.00); cout &lt;&lt; &quot;New balance: $&quot; &lt;&lt; Hoggy.Balance() &lt;&lt; endl; cout &lt;&lt; &quot;Withdrawing $4200 from the pigg Account:\n&quot;; Piggy.Withdraw(4200.00); cout &lt;&lt; &quot;Pigg account balance: $&quot; &lt;&lt; Piggy.Balance() &lt;&lt; endl; cout &lt;&lt; &quot;Withdrawing $4200 from the Hogg Account:\n&quot;; Hoggy.Withdraw(4200.00); Hoggy.ViewAcct(); return 0; } 输出： Client: Porcelot Pigg Account Number: 381299 Balance: $4000.00 Client: Horatio Hogg Account Number: 382288 Balance: $3000.00 Maximum loan: $500.00 Owed to bank: $0.00 Loan Rate: 11.125% Depositing $1000 into the Hogg Account: New balance: $4000 Withdrawing $4200 from the pigg Account: Withdrawal amount of $4200.00 exceeds your balance. Withdrawal canceled. Pigg account balance: $4000 Withdrawing $4200 from the Hogg Account: Bank advance: $200.00 Finance charge: $22.25 Client: Horatio Hogg Account Number: 382288 Balance: $0.00 Maximum loan: $500.00 Owed to bank: $222.25 Loan Rate: 11.125% 3. 演示虚方法的行为 在程序13.9中，方法是通过对象调用的，没有使用虚方法特性。下面来看一个使用了虚方法的例子。假设要同时管理Brass和BrassPlud账户，如果能使用同一个数组来保存Brass和BrassPlus对象，将很有帮助，但这是不可能的。数组中所有元素的类型必须相同，而Brass和BrassPlus是不同的类型。然而，可以创建指向Brass的指针数组。这样，每个元素的类型都是相同的，但由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。因此，可以使用一个数组来表示多种类型的对象。这就是多态。 程序13.10 usebrass2.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;brass.h&quot; using namespace std; const int CLIENTS = 4; int main() { Brass * p_clients[CLIENTS]; string temp; long tempnum; double tempbal; char kind; for (int i = 0; i &lt; CLIENTS; i++) { cout &lt;&lt; &quot;Enter client&apos;s name: &quot;; getline(cin, temp); cout &lt;&lt; &quot;Enter client&apos;s account number: &quot;; cin &gt;&gt; tempnum; cout &lt;&lt; &quot;Enter opening balance: $&quot;; cin &gt;&gt; tempbal; cout &lt;&lt; &quot;Enter 1 for Brass Account or &quot; &lt;&lt; &quot;2 for BrassPlus Account: &quot;; while (cin &gt;&gt; kind &amp;&amp; (kind != &apos;1&apos; &amp;&amp; kind != &apos;2&apos;)) cout &lt;&lt; &quot;Enter either 1 or 2: &quot;; if (kind == &apos;1&apos;) p_clients[i] = new Brass(temp, tempnum, tempbal); else { double tmax, trate; cout &lt;&lt; &quot;Enter the overdraft limit: $&quot;; cin &gt;&gt; tmax; cout &lt;&lt; &quot;Enter the interest rate &quot; &lt;&lt; &quot;as a decimal fraction: &quot;; cin&gt;&gt; trate; p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate); } while (cin.get() != &apos;\n&apos;) continue; } cout &lt;&lt; endl; for (int i = 0; i &lt; CLIENTS; i++) { p_clients[i]-&gt;ViewAcct(); cout &lt;&lt; endl; } for (int i = 0; i &lt; CLIENTS; i++) { delete p_clients[i]; } cout &lt;&lt; &quot;Done!\n&quot;; return 0; } 程序13.10根据用户输入来确定要添加的账户类型，然后使用new创建并初始化相应类型的对象。getline(cin, temp)从cin读取一行输入，并将其存储到string对象temp中。 输出： Enter client&apos;s name: Harry Enter client&apos;s account number: 112233 Enter opening balance: $1500 Enter 1 for Brass Account or 2 for BrassPlus Account: 1 Enter client&apos;s name: Dinah Enter client&apos;s account number: 121213 Enter opening balance: $1800 Enter 1 for Brass Account or 2 for BrassPlus Account: 2 Enter the overdraft limit: $350 Enter the interest rate as a decimal fraction: 0.12 Enter client&apos;s name: Brenda Enter client&apos;s account number: 212118 Enter opening balance: $5200 Enter 1 for Brass Account or 2 for BrassPlus Account: 2 Enter the overdraft limit: $800 Enter the interest rate as a decimal fraction: 0.10 Enter client&apos;s name: Tim Enter client&apos;s account number: 233255 Enter opening balance: $688 Enter 1 for Brass Account or 2 for BrassPlus Account: 1 Client: Harry Account Number: 112233 Balance: $1500.00 Client: Dinah Account Number: 121213 Balance: $1800.00 Maximum loan: $350.00 Owed to bank: $0.00 Loan Rate: 12.000% Client: Brenda Account Number: 212118 Balance: $5200.00 Maximum loan: $800.00 Owed to bank: $0.00 Loan Rate: 10.000% Client: Tim Account Number: 233255 Balance: $688.00 Done! 多态性是由下述代码提供： for (int i = 0; i &lt; CLIENTS; i++) { p_clients[i]-&gt;ViewAcct(); cout &lt;&lt; endl; } 如果书谁说成员指向的是Brass对象，则调用Brass::ViewAcct()；如果指向的是BrassPlus对象，则调用BrassPlus::ViewAcct()。如果Brass::ViewAcct()没有被声明为虚的，则在任何情况下都将调用Brass::ViewAcct()。 4. 为何需要虚析构函数 在程序13.10中，使用delete释放由new分配的对象的代码说明了为何基类应包含一个虚析构函数，虽然有时好像并不需要析构函数。如果析构函数不是虚的，则将调用对应于指针类型的析构函数。对于程序13.10，这意味着只有Brass的析构函数被调用，即使指针指向的是BrassPlus对象。如果析构函数是虚的，将调用相应对象类型的析构函数。因此，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。 因此十三亿虚析构函数可以确保正确的析构函数序列被调用。对于程序13.10，这种正确的行为并不重要，因为析构函数没有任何操作。然而，如果BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使该析构函数不执行任何操作。 13.4 静态联编和动态联编程序调用函数时，将使用哪个可执行代码块呢？编译器将负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。在C语言中，这非常简单，因为每个函数名都对应一个不同的函数。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而，C/C++编译器可以在编译过程中完成这种联编。在编译过程中进行联编被称为静态联编，又称为早期联编。然而，虚函数使这项工作变得更困难。正如程序13.10所示的那样，使用哪一个函数不能在编译时确定的，因为编译器不知道用户将选择哪种类型。所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这被称为动态联编，又称为晚期联编。 知道虚方法的行为后，下面深入地探讨这一过程，首先介绍C++如何处理指针和引用类型的兼容性。 13.4.1 指针和引用类型的兼容性在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上来说，这是由继承控制的。公有继承建立is-a关系的一种方法是如何处理指向对象的指针和引用。通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型。 然而，指向基类的引用或指针可以引用派生类对象，而不必进行显示转换。例如，下面的初始化是允许的： BrassPlus dilly(&quot;Annie&quot;, 226554, 3000); Brass * pb = &amp;dilly; Brass &amp; pb = dilly; 将派生类引用或指针指向基类引用或指针被称为向上强制转换，这使公有继承不需要进行显示类型转换。该规则是is-a关系的一部分。BrassPlus对象都是Brass对象，因为它继承了Brass对象所有的数据成员和成员函数。所以，对Brass对象执行的任何操作，都适用于BrassPlus对象。因此，为处理Brass引用而设计的函数可以对BrassPlus对象执行同样的操作，而不必担心会导致任何问题。将指向对象的指针作为函数参数时，也是如此。向上强制转换是可以传递的。即，如果BrassPlus派生出BrassPlusPlus类，则Brass指针或引用可以引用Brass对象、BrassPlus对象和BrassPlusPlus对象。 相反的过程—将基类指针或引用转换为派生类指针或引用—称为向下强制转换。如果不使用显式类型转换，则向下强制类型转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能用于基类。例如，假设从Employee类派生出Singer类，并添加了表示歌手音域的数据成员和用于报告音域的成员函数range()，则将range()方法用于Employee对象是没有意义的。但允许隐式向下强制转换，则可能无意间将指向Singer的指针设置为一个Employee对象的指针，并使用该指针来调用range()方法。参见图13.4 对于使用基类引用或指针作为参数的函数调用，将进行向上转换。请看下面的代码，这里假设每个函数都调用虚方法ViewAcct(): void fr(Brass &amp; rb); void fp(Brass * pb); void fv(Brass b); int main() { Brass b(&quot;Billy bee&quot;, 123456, 100.0); BrassPlus bp(&quot;Betty beep&quot;, 232313, 200.0); fr(b); //使用Brass::ViewAcct() fr(bp); //使用BrassPlus::ViewAcct() fp(b); //使用Brass::ViewAcct() fp(bp); //使用BrassPlus::ViewAcct() fv(b); //使用Brass::ViewAcct() fv(bp); //使用Brass::ViewAcct() } 按值传递导致之间BrassPlus对象Brass部分传递给函数fv()。但按引用和指针发生的隐式向上转换导致函数fr()和fp()分别为Brass对象和BrassPlus对象使用Brass::ViewAcct()和BrassPlus::ViewAcct()。 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。 13.4.2 虚成员函数和动态联编来回顾一个使用引用或指针调用方法的过程。请看下面的代码： BrassPlus ophelia; Brass * bp; bp = &amp;ophelia; bp-&gt;ViewAcct(); 正如前面指出的，如果基类中没有将ViewAcct()声明为虚函数，则bp-&gt;ViewAcct()将根据指针类型(Brass $\ast$)调用Brass::ViewAcct()。指针类型在编译时已知，因此编译器在编译时，可以将ViewAcct()关联到Brass::ViewAcct()。总之，编译器对非虚方法使用静态联编。 然而，如果在基类中将ViewAcct()声明为虚函数，则bp-&gt;ViewAcct()根据对象类型(BrassPlus)调用BrassPlus::ViewAcct()。在这个例子中，对象类型为BrassPlus，但通常(如程序13.10)只有在运行程序时才能确定对象的类型。所以编译器生成的代码将在程序执行时，根据对象类型将ViewAcct()关联到Brass::ViewAcct()或BrassPlus::ViewAcct()。总之，编译器对虚方法使用动态联编。 在大多数情况下，动态联编很好，因为它让程序能够选择为特定类型设计的方法。 1. 为什么有两种类型的联编以及为什么默认为静态联编 如果动态联编让您能够重新定义类方法，而静态联编在这方面很差，为何不摒弃静态联编呢？原因有两个—效率和概念模型。 首先来看效率。为使程序能够在运行阶段进行决策，必须采用一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的出实力开销。例如，如果类不会用作基类，则不需要动态联编。同样，如果派生类不重新定义基类的任何方法，也不需要动态联编。在这些情况下，使用静态联编更合理，效率也更高。由于静态联编的效率更高，因为被设置为默认选择。 接下来看概念模型。在设计类时，可能包含一些不在派生类重新定义的成员函数。例如，Brass::Balance()函数返回账户结余，不应该重新定义。不将该函数设置为虚函数，有两方面的好处：首先效率更高，其次，指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的方法声明为虚方法。 提示：如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。 2. 虚函数工作原理 C++规定了虚函数的行为，但将实现方法留给了编译器作者。不需要知道实现方法就可以使用虚函数，但了解虚函数的工作原理有助于更好地理解概念，因此，这里对其进行介绍。 通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table, vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该虚函数表将保存原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到虚函数表(见图13.5)。注意，无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。 调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组的第一个函数地址，并执行具有该地址的函数。依此类推。 总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括： 每个对象都将增大，增大量为存储地址的空间； 对于每个类，编译器都创建一个虚函数地址表(数组)； 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。 虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。 13.4.3 有关虚函数注意事项虚函数的一些要点： 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚方法。 如果使用指向对象的引用或指针来调用虚方法，程序使用为对象类型定义的方法，而不使用为引用或指向类型定义的方法。这称为动态联编。基类指针或引用可以指向派生类对象。 如果定义的类被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚方法。 对于虚方法，还需了解的内容： 1. 构造函数 构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不能继承类的构造函数，所以将类构造函数声明为虚函数没有意义。 2. 析构函数 析构函数应当是虚函数，除非类不用做基类。例如，Employee是基类，Singer是派生类，并添加了一个char $\ast$成员，该成员指向有new分配的内存。但Singer对象过期时，必须调用~Singer()析构函数来释放内存。 请看下面代码： Employee * pe = new Singer; ... delete pe; 如果使用默认的静态联编，delete语句将调用~Employee()析构函数。这将释放由Singer对象中的Employee部分指向的内盘，但不会释放新的类成员指向的内存。但如果析构函数是虚函数，则上述代码将先调用~Singer()析构函数释放由Singer组件指向的内存，然后调用~Employee()析构函数来释放由Employee组件指向的内存。 这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作： virtual ~BaseClass() {} 给类定义一个虚析构函数并非错误，即使这个类不用做基类；这只是一个效率方面的问题。 提示：通常应给基类提供一个虚析构函数，即使它并不需要析构函数。 3. 友元 友元函数不能是虚函数，因为友元函数不是成员函数，而只有成员函数才能是虚函数。如果由于这个原因引起设计问题，可以通常让友元函数使用虚成员函数来解决。 4. 没有重新定义类 如果派生类没有重新定义类，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。 5. 重新定义将隐藏方法 假设创建了如下所示的代码： class Dwelling { public: virtual void showperks(int a) const; }; class Hovel : public Dwelling { public: virtual void showperks() const; }; 这将导致问题，可能会出现类似于下面这样的编译器警告： Warning: Hovel::showperks(void) hides Dwelling::showperks(int) 也可能不会出现警告。但不管结果怎样，代码将具有如下含义： Hovel trump; trump.showperks(); trump.showperks(5); //无效 新定义将showperks()定义为一个不接任何参数的函数。重新定义不会生成函数的两个重载版本，而是隐藏了接受一个int参数的基类版本。总之，重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类的声明，而是隐藏同名的基类方法，不管参数特征标如何。 这引出了两条经验规则： 第一，如果重新定义继承的方法，应确保与原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变，因为允许返回类型随类类型的变化而变化。 class Dwelling { public: virtual Dwelling &amp; build(int n); }; class Hovel : public Dwelling { public: virtual Hovel &amp; build(int n); } 注意，这种例外只适用于返回值，而不适用于参数。 第二，如果基类声明被重载了，则应该派生类中重新定义所有的基类版本。 class Dwelling { public: virtual void showperks(int n) const; virtual void showperks(double x) const; virtual void showperks() const; }; class Hovel : public Dwelling { public: virtual void showperks(int n) const; virtual void showperks(double x) const; virtual void showperks() const; } 如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义课只调用基类版本： void Hovel::showperks() const { Dwelling::showperks(); } 13.5 访问控制： protected但目前位置，已经使用了关键字public和private来控制对类成员的访问。还存在另一个访问类别。这种类别使用关键字protected表示。关键字protected与private类似，在类外只能用公有类成员来访问protected部分中的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，单手能直接访问基类的私有成员。因此，对于外部来说，保护成员的行为和私有成员的行为相似；但对于派生类来说，保护成员的行为与公有成员类似。 例如，假如Brass类将balance成员声明为保护的： class Brass { protected: double balance; }; 在这种情况下，BrassPlus类可以直接访问balance，而不需要使用Brass方法。例如，可以这样编写BrassPlus::Withdraw()的核心： void BrassPlus::Withdraw(double amt) { if (amt &lt; 0) cout &lt;&lt; &quot;Withdrawal amount must be positive; with drawal canceled.\n&quot; else if (amt &lt;= balance) balance -= amt else if ( amt &lt;= balance + maxLoan - owesBank) { double advance = amt - balance; owesBank += advance * (1.0 + rate); cout &lt;&lt; &quot;Bank advance: $&quot; &lt;&lt; advance &lt;&lt; endl; cout &lt;&lt; &quot;Finance charge: $&quot; &lt;&lt; advance * rate &lt;&lt; endl; Deposite(advance); balance -= amt; } else cout &lt;&lt; &quot;Credit limit exceed. Transaction cancelled.\n&quot;; } 使用保护数据成员可以简化代码的编写工作，但存在设计缺陷。例如，继续以BrassPlus为例，如果balance是受保护的，则可以按下面的方式编写代码： void BrassPlus::Reset(double amt) { balance = amt; } Brass类被设计成只能通过Deposit()和Withdraw()才能修改修改balance。但对于BrassPlusd对象，Reset()方法将忽略Withdraw()中的保护措施，实际上使balance称为公有变量。 警告：最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通常基类方法使派生类能够访问基类数据。 然而，对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。 13.6 抽象基类至此，介绍了简单继承和较为复杂的多态。接下来更为复杂的是抽象基类(abstract base class, ABC)。来看一些使用ABC的编程情况。 有时候，使用is-a规则并不是看上去的那样简单。例如，假设您正在开发一个图形程序，该程序会显式圆和椭圆。圆是椭圆的一个特殊情况—长轴等于短轴的椭圆。因此，所有的圆都是椭圆，可以从Ellipse类派生出Circle类。但设计细节时，发现很多问题。 首先，考虑Ellipse类包含的内容。数据成员可以包括椭圆中心的坐标、半长轴、短半轴以及方向角(水平坐标轴与长轴之间的角度)。另外，还可以包括一些移动椭圆、返回椭圆面积、旋转椭圆以及缩放长半轴和短半轴的方法： class Ellipse { private: double x; double y; double a; double b; double angle; ... public: void Move(int nx, ny) {x = nx; y = ny;} virtual double Area cosnt { return 3.14159 * a *b; } virtual void Rotate(double nang) { angle += nang; } virtual void Scale(double sa, double sb) { a *= sa; b *= sb; } ... }; 现在假设从Ellipse派生出一个Circle类： class Circle : public Ellipse { ... }; 虽然，圆是一种椭圆，但这种派生是笨拙的。例如，圆只需要一个值(半径)就可以描述大小和形状，并不需要长半轴和短半轴。Circle构造函数可以通过将同一个值赋给成员a和b来照顾这种情况，但将导致信息荣誉。angle参数和Rotate()方法对圆来说是没有实际意义的；而Scale()方法会将两个轴不同的缩放，将圆变成椭圆。可以使用一些技巧来修改这些问题，例如在Circle类中的私有成员部分包含重新定义的Rotate()方法，使Rotate()不能以公有方式用于圆。但总的来说，不是使用继承，直接定义Circle更简单： class Circle { private: double x; double y; double r; ... public: void Move(int nx, ny) { x = nx; y = ny; } double Area() const { return 3.14159 * r *r; } void Scale(double sr) { r *= sr; } ... }; 现在，类只包含所需的成员。但这种解决方法的效率也不高。Circle和Ellipse类有很多共同点，将它们分别定义则忽略了这一事实。 还有一种解决办法是，即从Ellipse和Circle类中抽象出它们的共性，将这些特性放到一个ABC中。然后从该ABC派生出Circle和Ellipse类。这样，便可以使用基类指针数组同时管理Circle和Ellipse对象，即可以使用多态方法。 在这个例子中，这两个类的共同点是中心坐标、Move方法(对于两个类来说是相同的)和Area方法(对于两个类来说，是不同的)。确实，甚至不能再ABC中实现Area()方法，因此它没有包含必要的数据成员。C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾出为=0，参见Area()方法： class BaseEllipse { private: double x; double y; ... public: BaseEllipse(double x0 = 0; double y0 =0) : x(x0), y(y0) {} virtual ~BaseEllipse() {} void Move(int nx, ny) { x = nx; y = ny; } virtual double Area() const = 0; //纯虚函数 ... }; 当类声明包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只用作基类。__要成为真正的ABC，必须至少包含一个纯虚函数。__原型中的=0使虚函数成为纯虚函数。这里的方法Area()没有定义，但C++甚至允许纯虚函数没有定义。例如，也许所有的基类方法都与Move()一样，可以在基类中进行定义，但您仍需要将这个声明为抽象的。在这种情况下，可以将原型声明为虚的： void Move(int nx, ny) = 0; 这将使基类成为抽象的，但您仍可以实现文献中提供的方法： void BaseEllipse::Move(int nx, ny) {x = nx, y =ny; } 总之，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。 现在，可以从BaseEllipse类派生出Ellipse类和Circle类，添加所需的成员来完成每个类。需要注意的一点是，Circle类重视表示圆，而Ellipse类总是表示椭圆—也可以表示圆。然而，Ellipse类圆可以被重新缩放为非圆，而Circle类圆必须始终为圆。 使用这些类的程序将能够创建Ellipse对象和Circle对象，但是不能创建BaseEllipse对象。由于Circle和Ellipse对象的基类相同，因此可以使用BaseEllipse指针数组同时管理这两种对象。像Circle和Ellipse这样的类有时被称为具体类，这表示可以创建这些类型的对象。 总之，ABc描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。 13.6.1 应用ABC概念将ABC概念用于Brass和BrassPlus账户。首先定义一个名为AcctABC的ABC。这个类包含Brass和BrassPlus类共有的所有方法和数据成员，而那些在BrassPlus类和Brass类中的行为不同的方法应被声明为虚函数。至少应有一个虚函数是纯虚函数，这样才能使AcctABC称为抽象类。 程序13.11的头文件声明了AcctABC类、Brass类和BrassPlus类。为帮助派生类访问基类数据，AcctABc提供了一些保护方法：派生类方法可以调用这些方法，但它们并不是派生类对象的公有接口的组成部分。AcctABC还提供一个保护成员函数，用于处理格式化。另外，AcctABC类还有两个纯虚函数，所以它确实是抽象类。 程序13.11 acctabc.h #ifndef ACCTABC_H_ #define ACCTABC_H_ #include &lt;string&gt; #include &lt;iostream&gt; using std::string; class AcctABC { private: string fullName; long acctNum; double balance; protected: struct Formatting { std::ios_base::fmtflags flag; std::streamsize pr; }; const string &amp; FullName() const { return fullName; } long AcctNum() const { return acctNum; } Formatting SetFormat() const; void Restore(Formatting &amp; f) const; public: AcctABC(const string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0); void Deposit(double amt); virtual void Withdraw(double amt) = 0; double Balance() const { return balance; } virtual void ViewAcct() const = 0; virtual ~AcctABC() {} }; class Brass : public AcctABC { public: Brass(const string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0) : AcctABC(s, an, bal) {} virtual void Withdraw(double amt); virtual void ViewAcct() const; virtual ~Brass() {} }; class BrassPlus : public AcctABC { private: double maxLoan; double rate; double owesBank; public: BrassPlus(const string &amp; s = &quot;Nullbody&quot;, long an = -1, double bal = 0.0, double ml = 500, double r = 0.10); BrassPlus(const Brass &amp; ba, double ml = 500, double r = 0.10); virtual void Withdraw(double amt); virtual void ViewAcct() const; void ResetMax(double m) { maxLoan = m; } void ResetRate(double r) { rate = r; } void ResetOwes() { owesBank = 0; } }; #endif 程序13.12 acctabc.cpp #include &quot;acctabc.h&quot; #include &lt;iostream&gt; using namespace std; AcctABC::AcctABC(const string &amp; s, long an, double bal) { fullName = s; acctNum = an; balance = bal; } void AcctABC::Deposit(double amt) { if ( amt &lt; 0 ) cout &lt;&lt; &quot;Negative deposit not allowed; deposite is cancelled.\n&quot;; else balance += amt; } AcctABC::Formatting AcctABC::SetFormat() const { Formatting f; f.flag = cout.setf(ios_base::fixed, ios_base::floatfield); f.pr = cout.precision(2); return f; } void AcctABC::Restore(Formatting &amp; f) const { cout.setf(f.flag, ios_base::floatfield); cout.precision(f.pr); } void Brass::Withdraw(double amt) { if (amt &lt; 0) cout &lt;&lt; &quot;Withdrawal amount must be positive; &quot; &lt;&lt; &quot;withdrawal cancelled.\n&quot;; else if (amt &lt;= Balance()) Withdraw(amt); else cout &lt;&lt; &quot;Withdrawal amount of $&quot; &lt;&lt; amt &lt;&lt; &quot; exceeds your balance.\n&quot; &lt;&lt; &quot;Withdrawal cancelled.\n&quot;; } void Brass::ViewAcct() const { Formatting f = SetFormat(); cout &lt;&lt; &quot;Barss client: &quot; &lt;&lt; FullName() &lt;&lt; endl; cout &lt;&lt; &quot;Account Number: &quot; &lt;&lt; AcctNum() &lt;&lt; endl; cout &lt;&lt; &quot;Balance: $&quot; &lt;&lt; Balance() &lt;&lt; endl; Restore(f); } BrassPlus::BrassPlus(const string &amp; s, long an, double bal, double ml, double r): AcctABC(s, an ,bal) { maxLoan = ml; rate = r; owesBank = 0.0; } BrassPlus::BrassPlus(const Brass &amp; ba, double ml, double r) : AcctABC(ba) { maxLoan = ml; rate = r; owesBank = 0.0; } void BrassPlus::ViewAcct() const { Formatting f = SetFormat(); cout &lt;&lt; &quot;BrassPlus Client: &quot; &lt;&lt; FullName() &lt;&lt; endl; cout &lt;&lt; &quot;Account Number: &quot; &lt;&lt; AcctNum() &lt;&lt; endl; cout &lt;&lt; &quot;Balance: $&quot; &lt;&lt; Balance() &lt;&lt; endl; cout &lt;&lt; &quot;Maximum loan: $&quot; &lt;&lt; maxLoan &lt;&lt; endl; cout &lt;&lt; &quot;Owed to bank: $&quot; &lt;&lt; owesBank &lt;&lt; endl; cout.precision(3); cout &lt;&lt; &quot;Loan Rate: &quot; &lt;&lt; 100 * rate &lt;&lt; &quot;%\n&quot;; Restore(f); } void BrassPlus::Withdraw(double amt) { Formatting f = SetFormat(); double bal = Balance(); if (amt &lt;= bal) Withdraw(amt); else if (amt &lt;= bal + maxLoan - owesBank) { double advance = amt - bal; owesBank += advance * (1.0 + rate); cout &lt;&lt; &quot;Bank advance: $&quot; &lt;&lt; advance &lt;&lt; endl; cout &lt;&lt; &quot;Finance charge: $&quot; &lt;&lt; advance * rate &lt;&lt; endl; Deposit(advance); Withdraw(amt); } else cout &lt;&lt; &quot;Credit limit exceeded. Transaction cancelled.\n&quot;; Restore(f); } 保护方法FullName()和AcctNum()提供了对数据成员fullName和acctNum的只读访问，使得可以进一步定制每个派生类的ViewAcct()。 这个版本在设置输出格式方面做了两项改进。前一个版本使用两个函数调用来设置输出格式，并使用一个函数调用来恢复格式： format initialState = setFormat(); precis prec = cout.precision(2); ... restore(initialState, prec); 这个版本定义了一个结构，用于存储两项格式设置；并使用该结构来设置和恢复格式，因此只需要两个函数调用： struct Formatting { std::ios_base::fmtflags flag; std::streamsize pr; }; Formatting f = SetFormat(); ... Restore(f); 因此代码更整洁。 旧版本存在的问题是，setFormat()和restore()都是独立的函数，这些函数与客户定义的同名函数发生冲突。解决这种问题的方式有多种，一种方式是将这些函数声明为静态的，这样它们将归文件brass.cpp及其继任acctabc.cpp私有。另一种方式是，将这些函数以及结构Formatting放在一个独立的名称空间中。但这个示例探讨的主题之一是保护访问权限，因此将这些结构和函数放在了类定义的保护部分。这使得它们对基类和派生类可用，同时向外隐藏了它们。 对于Brass和BrassPlus账户的这种实现，使用方式与旧实现相同，因为类方法的名称和接口都与以前一样。例如，为程序13.10能够使用新的实现，需要采取下面的步骤将usebrass2.cpp转换为usebrass3.cpp 使用acctabc.cpp而不是brass.cpp来连接usebrass.cpp 包含文件acctabc.h，而不是brass.h 将下面的代码替换 Brass * p_clients[CLIENTS]; 替换为： AcctABC * p_clients[CLIENTS]; 程序13.13usebrass3.cpp #include &lt;iostream&gt; #include &quot;acctabc.h&quot; #include &lt;string&gt; const int CLIENTS = 4; using namespace std; int main() { AcctABC * p_clients[CLIENTS]; string temp; long tempnum; double tempbal; char kind; for (int i = 0; i &lt; CLIENTS; i++) { cout &lt;&lt; &quot;Enter client&apos;s name: &quot;; getline(cin, temp); cout &lt;&lt; &quot;Enter client&apos;s account number: &quot;; cin &gt;&gt; tempnum; cout &lt;&lt; &quot;Enter opening balance: $&quot;; cin &gt;&gt; tempbal; cout &lt;&lt; &quot;Enter 1 for Brass Account or &quot; &lt;&lt; &quot;2 for BrassPlus Account: &quot;; while (cin &gt;&gt; kind &amp;&amp; (kind != &apos;1&apos; &amp;&amp; kind != &apos;2&apos;)) cout &lt;&lt; &quot;Enter either 1 or 2: &quot;; if (kind == &apos;1&apos;) p_clients[i] = new Brass(temp, tempnum, tempbal); else { double tmax, trate; cout &lt;&lt; &quot;Enter the overdraft limit: $&quot;; cin &gt;&gt; tmax; cout &lt;&lt; &quot;Enter the interest rate &quot; &lt;&lt; &quot;as a decimal fraction: &quot;; cin&gt;&gt; trate; p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate); } while (cin.get() != &apos;\n&apos;) continue; } cout &lt;&lt; endl; for (int i = 0; i &lt; CLIENTS; i++) { p_clients[i]-&gt;ViewAcct(); cout &lt;&lt; endl; } for (int i = 0; i &lt; CLIENTS; i++) { delete p_clients[i]; } cout &lt;&lt; &quot;Done!\n&quot;; return 0; } 该程序的行为与非抽象基类版本相同，因此如果输入与给程序13.10提供的输入相同，输出也将相同。 13.6.2 ABC理念在处理继承的问题上，RatePlayer示例使用的方法比较随意，而ABC方法比它更具系统性、更规范。设计ABC之前，首先应开发一个模型—指出编程问题所需的类以及它们之间的相互关系。一种学院派思想认为，如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类。这种方法的设计更清晰，复杂程度更低。 可以将ABC看作是一种必须实施的接口。ABC要求具体派生类覆盖其纯虚函数—迫使派生类遵循ABC设置的接口规则。这种模型在基于组件的编程模式中很常见，在这种情况下，使用ABC使得组件设计人员能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持ABC制定的功能。 13.7 继承和动态分配继承是怎样与动态内存分配(使用new和delete)进行互动的呢？例如，如果基类使用动态内存分配，并重新定义赋值运算符或复制构造函数，这将怎么影响派生类的实现呢？这个问题的答案取决于派生类的属性。如果派生类也使用动态内存分配，那么就需要学习几个新的小技巧。下面来看看这两种情况。 13.7.1 第一种情况：派生类不使用new假设基类使用了动态内存分配： class baseDMA { private: char * label; int rating; public: baseDMA(const char * l = &quot;null&quot;, int r = 0); baseDMA(const baseDMA &amp;);j virtual ~baseDMA(); baseDMA &amp; operator=(cosnt baseDMA &amp; rs); ... }; 声明中包含了构造函数使用new时需要的特殊方法：析构函数、复制构造函数和重载赋值运算符。 现在，从baseDMA派生出lackDMA类，而后者不使用new，也未包含其他一些不常用的、需要特殊处理的设计特性： class lackDMA : pulic baseDMA { private: char color[40]; public: ... } 是否需要为lackDMA类定义显式析构函数、复制构造函数和赋值运算符呢？不需要。 首先，来看是否需要析构函数。如果没有定义析构函数，编译器将定义一个不执行任何操作的默认构造函数。实际上，派生类的默认构造函数总是要进行一些操作的：执行自身的代码后调用基类析构函数。因为我们假设lackDMA成员不执行任何特殊操作，所以默认析构函数是合适的。 接着来看赋值构造函数。第12章介绍过，默认复制构造函数执行成员复制，这对于动态内存分配来说是不合适的。但对于新的lackDMA成员来说是合适的。因此只需考虑继承的basedDMA对象。要知道，成员复制将根据数据类型采用相应的复制方式，因此，将long复制到long中通过使用常规复制完成的；但复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以，lackDMA类的默认复制构造函数使用显式baseDMA复制构造函数来复制lackDMA对象的baseDMA部分。因此，默认复制构造函数对于新的lackDMA成员来说是合适的，同时对于继承的baseDMA对象来说也是合适的。 对于赋值来说，也是如此。类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。因此，默认赋值运算符也是合适的。 派生类对象的这些属性也适用于本身对象的类成员。例如，第10章介绍过，实现Stock类时，可以使用string对象而不是char数组来存储公司名称。标准string类和本书前面创建的String类一样，也采用动态内存分配。现在，读者知道了为何这不会引发问题。Stock的默认复制构造函数将使用string的复制构造函数来复制对象company成员；Stock的默认赋值运算符将使用strig的赋值运算符来给对象的company成员赋值；而Stock的析构函数将自动调用string的析构函数。 12.7.2 第二种情况：派生类使用new假设派生类使用了new: class hasDMA : public baseDMA { private: char * style; public: ... }; 在这种情况下，必须为派生类定义显式析构函数、赋值用品认识和复制构造函数。下面依次考虑这些方法。 派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行的工作进行清理。因此hasDMA析构函数必须释放指针style管理的内存，并依赖于basdDMA的析构函数来释放指针label管理的内存。 baseDMA::~baseDMA() { delete [] label; } hasDMA::~hasDMA() { delete [] style; } 接下来看复制构造函数。BaseDMA的复制构造函数遵循用char数组的常规模式，即使用strlen()来获悉存储C-风格字符串所需的空间、分配足够的内存（字符数加上存储空字符所需的1字节）并使用函数strcpy()将原始字符串赋值到目的地： baseDMA::baseDMA(const baseDMA &amp; rs) { label = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating; } hasDMA复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来处理共享的baseDMA数据： hasDMA::hasDMA(const hasDMA &amp; hs) : baseDMA(hs) { style = new char[std::strlen(hs.style + 1)]; stdJ::strcpy(style, hs.style); } 需要注意的一点是，成员初始化列表将一个hasDMA引用传递给baseDMA构造函数。没有参数类型为hasDMA引用的base构造函数，也不需要这样的构造函数。因为复制构造函数baseDMA有一个baseDMA引用参数，而基类可以指向派生类型。因此baseDMA复制构造函数将使用hasDMA参数的baseDMA部分来构造新对象的baseDMA部分。 接下来看赋值运算符。BaseDMA赋值运算符遵循下述常规模式： baseDMA &amp; baseDMA::operator(const baseDMA &amp; rs) { if (this == &amp;rs) return *this; delete [] label; label = new char[std::strlen(rs.label) + r]; std::strcpy(label, rs.label); rating = rs.rating; return *this; } 由于hasDMA也使用动态内存分配，所以它需要一个显式赋值运算符。作为hasDMA的方法，它只能直接访问hasDMA的数据。然而，派生类的显式赋值运算符必须负责所有的baseDMA基类对象的赋值，可以通过显式调用基类赋值运算符来完成这项工作，如下所示： hasDMA &amp; hasDMA::operator=(cosnt hasDMA &amp; hs) { if ( this == &amp;hs) return *this; baseDMA::operator=(hs); delete [] style; style = new char [std::strlen(hs.style) + 1]; std::strcpy(style, hs.style); return *this; } 下述语句看起来有点奇怪： baseDMA::operator=(hs); 但是通过使用函数表示法，而不是运算符表示法，可以使用作用域解析运算符。实际上，该语句的含义如下： *this = hs; //使用baseDMA::operator=(); 当然，编译器将忽略注释，所以使用后面的代码时，编译器将使用hasDMA::operator=()，从而形程递归调用。使用函数表示使得赋值运算符被正确调用。 总之，当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数和赋值运算符都必须使用相应的基类方法来处理基类元素。这种要求通过三种不同的方式来满足。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于赋值运算符，这是通过使用作用域解析运算符乡试第调用基类的赋值运算符来完成的。 13.7.3 使用动态内存分配和友元的继承示例为演示这些有关继承和动态分配的概念，我们将刚才介绍过的baseDMA、lackDMA和hasDMA类集成到一个示例中。程序13.14是这些类的头文件。除前面介绍的内容外，这个头文件还包含一个友元函数，以说明派生类如何访问基类的友元。 程序13.14 dma.h #ifndef DMA_H_ #define DMA_H_ #include &lt;iostream&gt; class baseDMA { private: char * label; int rating; public: baseDMA(const char * l = &quot;null&quot;, int r = 0); baseDMA(const baseDMA &amp; rs); virtual ~baseDMA(); baseDMA &amp; operator=(const baseDMA &amp; rs); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const baseDMA &amp; rs); }; class lackDMA : public baseDMA { private: enum {COL_LEN = 40}; char color[COL_LEN]; public: lackDMA(const char * c = &quot;blank&quot;, const char * l = &quot;null&quot;, int r = 0); lackDMA(const char * c, const baseDMA &amp; rs); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const lackDMA &amp; rs); }; class hasDMA : public baseDMA { private: char * style; public: hasDMA(const char * c = &quot;none&quot;, const char * l = &quot;null&quot;, int r = 0); hasDMA(const char * c, const baseDMA &amp; rs); hasDMA(const hasDMA &amp; hs); hasDMA &amp; operator=(const hasDMA &amp; hs); ~hasDMA(); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; rs); }; #endif 程序13.15 dma.cpp #include &lt;iostream&gt; #include &quot;dma.h&quot; #include &lt;cstring&gt; using namespace std; baseDMA::baseDMA(const char * l, int r) { label = new char[strlen(l) + 1]; strcpy(label, l); rating = r; } baseDMA::baseDMA(const baseDMA &amp; rs) { label = new char[strlen(rs.label) + 1]; strcpy(label, rs.label); rating = rs.rating; } baseDMA::~baseDMA() { delete [] label; } baseDMA &amp; baseDMA::operator=(const baseDMA &amp; rs) { if (this == &amp;rs) return *this; delete [] label; label = new char[strlen(rs.label) + 1]; strcpy(label, rs.label); rating = rs.rating; return *this; } ostream &amp; operator&lt;&lt;(ostream &amp; os, const baseDMA &amp; rs) { os &lt;&lt; &quot;Label: &quot; &lt;&lt; rs.label &lt;&lt; endl; os &lt;&lt; &quot;Rating: &quot; &lt;&lt; rs.rating &lt;&lt; endl; return os; } lackDMA::lackDMA(const char * c, const char * l, int r) : baseDMA(l, r) { strncpy(color, c, COL_LEN-1); color[COL_LEN-1] = &apos;\0&apos;; } lackDMA::lackDMA(const char * c, const baseDMA &amp; rs) : baseDMA(rs) { strncpy(color, c, COL_LEN-1); color[COL_LEN-1] = &apos;\0&apos;; } ostream &amp; operator&lt;&lt;(ostream &amp; os, const lackDMA &amp; rs) { os &lt;&lt; (const baseDMA &amp;) rs; os &lt;&lt; &quot;Color: &quot; &lt;&lt; rs.color &lt;&lt; endl; return os; } hasDMA::hasDMA(const char * s, const char * l, int r) : baseDMA(l, r) { style = new char[strlen(s) + 1]; strcpy(style, s); } hasDMA::hasDMA(const char * s, const baseDMA &amp; hs) : baseDMA(hs) { style = new char[strlen(s) + 1]; strcpy(style, s); } hasDMA::hasDMA(const hasDMA &amp; hs) : baseDMA(hs) { style = new char[strlen(hs.style) + 1]; strcpy(style, hs.style); } hasDMA::~hasDMA() { delete [] style; } hasDMA &amp; hasDMA::operator=(const hasDMA &amp; hs) { if (this == &amp;hs) return *this; baseDMA::operator=(hs); delete [] style; style = new char[strlen(hs.style) + 1]; strcpy(style, hs.style); return *this; } ostream &amp; operator&lt;&lt;(ostream &amp; os, const hasDMA &amp; rs) { os &lt;&lt; (const baseDMA &amp;) rs; os &lt;&lt; &quot;Style: &quot; &lt;&lt; rs.style &lt;&lt; endl; return os; } 在程序13.14和13.15中，需要注意的特性是，派生类如何使用基类的友元。例如，请考虑下面这个hasDMA类的友元： friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const hasDMA &amp; rs); 作为hasDMA类的友元，该函数能够访问style成员。然而，还存在一个问题：该函数如不是baseDMA类的友元，那它如何访问成员label和rating呢？答案是使用baseDMA类的友元函数operator&lt;&lt;()。 下一个问题是，因为友元不是成员函数，所以不能使用作用域解析运算符指出使用哪个函数。这个问题的解决办法是使用强制类型转换，以便匹配原型能够选择正确的函数。因此代码将参数const hasDMA &amp; 转换成类型const baseDMA &amp;的参数： ostream &amp; operator&lt;&lt;(ostream &amp; os, const hasDMA &amp; rs) { os &lt;&lt; (const baseDMA &amp;) rs; os &lt;&lt; &quot;Style: &quot; &lt;&lt; rs.style &lt;&lt; endl; return os; } 程序13.16是一个测试小程序。 程序13.16 usedma.cpp #include &quot;dma.h&quot; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { baseDMA shirt(&quot;Portabelly&quot;, 8); lackDMA balloon(&quot;red&quot;, &quot;Blimpo&quot;, 4); hasDMA map(&quot;Mercator&quot;, &quot;Buffalo Keys&quot;, 5); cout &lt;&lt; &quot;Display baseDMA object:\n&quot;; cout &lt;&lt; shirt &lt;&lt; endl; cout &lt;&lt; &quot;Display lackDMA object:\n&quot;; cout &lt;&lt; balloon &lt;&lt; endl; cout &lt;&lt; &quot;Display hasDMA object:\n&quot;; cout &lt;&lt; map &lt;&lt; endl; lackDMA balloon2(balloon); cout &lt;&lt; &quot;Result of lackDMA copy:\n&quot;; cout &lt;&lt; balloon2 &lt;&lt; endl; hasDMA map2; map2 = map; cout &lt;&lt; &quot;Resutl of hasDMA assignment:\n&quot;; cout &lt;&lt; map2 &lt;&lt; endl; return 0; } 输出： Display baseDMA object: Label: Portabelly Rating: 8 Display lackDMA object: Label: Blimpo Rating: 4 Color: red Display hasDMA object: Label: Buffalo Keys Rating: 5 Style: Mercator Result of lackDMA copy: Label: Blimpo Rating: 4 Color: red Resutl of hasDMA assignment: Label: Buffalo Keys Rating: 5 Style: Mercator 13.8 类设计回顾C++可用于解决各种类型的编程问题，但不能将类设计简化成带编号的例程。然而，有些常用的知道原则，下面复习并拓展前面的讨论。 13.8.1 编译器生成的成员函数第12章介绍过，编译器会自动生成一些公有的成员函数—特殊成员函数。这表明这些特殊成员函数很重要，下面回顾中其的一些。 1. 默认构造函数 默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，编译器将制定默认构造函数，让您能够创建对象。例如，假设Star类是一个类，则下述代码需要使用默认构造函数： Star rigel; Star pleiades[6]; //创建一个对象数组 自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属的类的默认构造函数。 另外，如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。在这种情况下，如果基类没有构造函数，将导致编译阶段错误。 如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。 提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。 2. 复制构造函数 复制构造函数接受其所属的对象作为参数。例如，Star类的复制构造函数的原型如下： Star(const star &amp;); 在下述情况下，将使用复制构造函数： 将新对象初始化为一个同类对象； 按值将对象传递给函数； 函数按值返回对象； 编译器生成临时对象。 如果程序没有使用(隐式或显式)复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。即，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象，则初始化该成员时，将使用相应类的复制构造函数。 在某些情况下，成员初始化是不合适的。例如，使用new初始化的成员指针通常要求执行深度复制，或者类可能包含需要修改的静态变量。在上述情况下，需要定义自己的复制构造函数。 3. 赋值运算符 默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值和初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有的对象的值，则是赋值： Star sirius; Star alpha = sirius; //初始化 Star dogstar; dogstar = sirius; //赋值 默认赋值为成员赋值。如果成员为类对象，则默认成员赋值将使用相应类的赋值运算符。如果需要显式定义复制构造函数，则基于相同的原因，也需要显式定义赋值运算符。Star类的赋值运算符的原型如下： Star &amp; operator=(const Star &amp;); 赋值运算符函数返回一个Star对象的引用。baseDMA类演示了一个典型的显式赋值运算函数示例。 编译器将不会生成一种类型赋给另一种类型的赋值运算符。如果希望能够将字符串赋给Star对象，则方法之一是显式定义下面的运算符: Star &amp; Star::operator=(const char * c) {...} 另一种方法是使用转换函数将字符串转换成Star对象，然后使用将Star赋给Star的赋值函数。第一种方法的运行速度快，但代码较复杂，而是用转换函数可能导致编译器出现混乱。 第18章将讨论C++新增的两种特殊方法： 移动构造函数和移动赋值运算符。 13.8.2 其他的在方法定义类时，还需要注意几点。 1. 构造函数 构造函数不同其他类方法，因为它创建新的对象，而其他方法只是被现有的对象调用。这是构造函数不能被继承的原因之一。继承意味着派生对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在。 2. 析构函数 一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于，基类，即使它不需要析构函数，也应提供一个虚析构函数。 3. 转换 使用一个参数就可以调用的构造函数定义了参数类型到类类型的转换。例如，下述Star类的构造函数原型： Star(const char *); //转换char为Star Star(const Spectral &amp;, int members = 1); //转换Spectral为Star 将可转换的类型传递给类为参数的函数时，将调用转换构造函数。例如，在如下的代码中： Star north; north = &quot;polaris&quot;; 第二条语句将调用Star::operator=(const star $\ast$)函数，使用Star::star(const char $\ast$)生成一个Star对象，该对象将被用作上述赋值运算符函数的参数。这里假设没有定义char$\ast$赋给Star的赋值运算符。 在带一个参数的构造函数原型中使用explicict将禁止进行隐式转换，但仍允许显式转换： class Star { ... public: explicit Star(const char *); ... }; Star north; north = &quot;polaris&quot;; //禁止 north = Star(&quot;polaris&quot;); 要将类对象转换为其他类型，应定义转换函数(参见第11章)。转换函数可以是没有参数的类成员函数，也可以是返回类型被声明为目标类型的类成员函数。即使没有声明返回类型，函数也应该返回所需的转换值。下面是一些示例： Star::operator double() {} //转换Star为double Star::operator const char * {} //转换Star为const char 应理智地使用这样函数，仅当它们有帮助时才使用。另外，对于某些类，包含转换函数将增加代码的二义性。例如，假设已经为第11章的Vector类型定义了double转换函数，并编写了下面的代码： Vector ius(6.0, 0.0); Vector lus = ius + 20.2; //二义性 编译器可以将ius转换成double并使用double加法，或将20.2转换成Vector（使用构造函数之一）并使用Vector加法。但除了二义性外，它什么也不做。 C++11支持关键字explicit用于转换函数。于构造函数一样，explicit允许使用强制类型转换进行显示转换，但不允许隐式转换。 4. 按值传递对象与传递引用 通常，编写使用算真相作为参数的函数时，应按引用而不是按值来传递对象。这样做的原因之一是为了提供效率。按值传递对象涉及到生成临时对象拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为const引用。 按引用传递对象的另一个原因，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。这在本章前面介绍过。 5. 返回对象和返回引用 有些类方法返回对象。可能注意到了，有些成员函数直接返回对象，而另一些则返回引用。有时必须返回对象，但如果可以不返回对象，则应返回引用。 首先，在编码方面，直接返回对象与返回引用之间唯一的区别在于函数原型和函数头： Star noval(const char &amp;); Star &amp; noval(const char &amp;); 其次，应返回引用而不是返回对象的原因在于，返回对象涉及生成返回对象的临时副本，这是调用函数的程序可以使用的副本。因此，返回对象的时间成本包括调用复制构造函数生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可节省时间和内存。直接返回对象与按值传递对象相似：它们都生成临时副本。同样，返回引用和按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。 然而，并不总是可以返回引用。函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。 通常的规则是，如果函数返回在函数中创建的临时对象，则不要使用引用。例如，下面的方法使用构造函数来创建一个新对象，然后返回对象的副本： Vector Vector::operator+(const Vector &amp; b) const { return Vector(x+b.x, y+b,y); } 如果函数返回的是通过引用或指针传递给它的对象，则应按引用返回对象。例如，下面的代码按引用返回调用函数的对象或作为参数传递给函数对象： const Stock &amp; Stock::topval(const Stock &amp; s) const { if (s.total_val &gt; total_val) return s; else return *this; } 6. 使用const 使用const时应特别注意。可以用它来确保方法不修改参数： Star::Star(const char * s) {} 可以使用const来确保方法不修改调用它的对象： void Star::Show() const {} 这里const表示const Star $\ast$this，而this指向调用的对象。 通常，可以将返回引用的函数放在赋值语句的左侧，实际上意味着可以将赋值给引用的对象。但可以使用const来确保引用或指针返回的值不能用于修改对象的数据: const Stock &amp; Stock::topval(const Stock &amp; s) const { if (s.total_val &gt; total_val) return s; else return *this; } 该方法返回对this或s的引用。因为thi和s都被声明为const，所以函数不能对它们进行修改，这意味着返回的引用也必须被声明为const。 注意，如果函数将参数声明为指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。 13.8.3 公有继承的考虑因素通常，在程序中使用继承时，有很多问题需要注意。 1. is-a关系 要遵循is-a关系。如果派生类不是一种特殊的基类，则不用使用公有派生。例如，不应从Brain类派生出Programer类。如果要指出程序员有大脑，应将Brain类对象作为Programmer类的成员。 在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。 请记住，表示is-a关系的方式之一是，无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。另外，返回来是行不通的。这种显式类型转换(向下强制转换)可能有意义，也可能没有，这取决于类声明(参见图13.4)。 2. 什么不能被继承 构造函数是不能继承的，即，创建派生类对象时，必须调用派生类对象构造函数。然而，派生类对象构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生类对象的基类部分。如果派生类对象没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都可以使用成员初始化列表将信息传递给相邻的基类。 析构函数也是不能继承的。然而，在释放对象时，程序首先调用派生类的析构函数，然后调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常，对于基类，其析构函数应设置为虚的。 赋值运算符是不能继承的，原因很简单。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，这是因为它包含一个类型为其所属类的形参。 3. 赋值运算符 如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。这个运算符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。然而，如果对象属于派生类，编译器将使用基类赋值运算符来处理派生类对象中基类部分的赋值。如果显式地为基类提供了赋值运算符，将使用该运算符。与此相似，如果成员是另一个类的对象，则对于该成员，将使用其所属的赋值运算符。 如果类构造函数使用new来初始化指针，则需要提供一个显式赋值运算符。因为它对于派生对象的基类部分，C++将使用基类的赋值运算符，所以不需要派生类重新定义赋值运算符，除非它添加了需要特别注意的数据成员。例如，baseDMA类显式地定义了赋值，但派生类lackDMA使用它生成的隐式赋值运算符。 然而，如果派生类使用了new，则必须提供显式赋值运算符。必须给类的每个成员提供赋值运算符，而不仅仅是新成员。hasDMA类演示了如何完成这项工作： hasDMA &amp; hasDMA::operator=(const hasDMA &amp; hs) { if (this == &amp;hs) return *this; baseDMA::operator=(hs); delete [] style; style = new char[strlen(hs.style) + 1]; strcpy(style, hs.style); return *this; } 将派生类对象赋给基类对象将如何呢？（注意，这不同于将基类引用初始化为派生类对象）请看下面的例如： Brass blips; BrassPlus snips(&quot;Raf Plosh&quot;, 911912, 600.0, 0.13); blips = snips; 这将使用哪个赋值运算符呢？赋值语句将被转换成左边的对象调用的一个方法： blips.operator(snips); 其中做表面的对象是Brass对象，因此它将调用Brass::operator=(const Brass &amp;)函数。is-a关系允许Brass引用指向派生类对象，如snips。赋值运算符值处理基类成员，所以上述赋值操作将忽略snips的maxLoan成员和其他BrassPlus成员。总之，可以将派生类对象赋给基类对象，但这只涉及基类的成员。 相反的操作将如何呢？即可以将基类对象赋给派生类对象吗？请看下面的例如： Brass gp(&quot;Griff Hexbait&quot;, 21234&quot;, 1200); BrassPlus temp; temp = gp; 上述赋值语句将被转换为如下所示： temp.operator=(gp); 左边的对象是BrassPlus对象，所以它调用BrassPlus::operator=(const BrassPlus &amp;)函数。然而，派生类引用不能自动引用基类对象，因此上述代码不能云三星，除非有下面的转换构造函数： BrassPlus(const Brass &amp;); 与BrassPlus类的情况类似，转换构造函数可以接受一个类型为基类的参数或其他参数，条件是其他参数有默认值： BrassPlus(const Brass &amp; ba, double ml = 500, double r = 0.1); 如果有转换构造函数，程序将通过它根据gp创建一个临时BrassPlus对象，然后将它用作赋值运算符的参数。 另一种方法是，顶一个用于基类赋给派生类的赋值运算符： BrassPlus &amp; BrassPlus::operator=(const Brass &amp; ba) {} 该赋值运算符的类型与赋值语句完全匹配，因此无需进行类型转换。 总之，问题“是否可以将基类对象赋给派生类对象？”的答案是“也许”。如果派生类包含了这样的构造函数，即对将基类转换为派生类对象进行了定义，则可以将基类对象赋给派生类对象。如果派生类定义了用于将基类对象赋给派生类对象的赋值运算符，则也可以这样做。如果上述两个条件都不满足，则不能这样做，除非使用显式强制类型转换。 4. 私有成员和保护成员 对于派生类对象，保护成员与类似于公有成员；但对于外部而言，保护成员与重游成员类似。派生类可以直接访问基类的保护成员，但只能通过记载的成员函数访问私有成员。因此，将基类成员设置为私有的可以提供安全性，而将它们设置为保护成员则可简化代码的编写工作，并提供访问速度。 5. 虚方法 设计基类时，必须确定是否将类声明为虚的。如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚方法，这样可以启用晚期联编（动态联编）；如果不希望重新定义方法，则不必将其声明为虚的，这样虽然无法禁止他人重新定义方法，但表达了这样的意思：您不希望它被重新定义。 请注意，不适当的代码将阻止动态联编。例如，请看下面的两个函数： void Show(const Brass &amp; rba) { rba.ViewAcct(); cout &lt;&lt; endl; } void inadequate(Brass ba) { ba.ViewAcct(); cout &lt;&lt; endl; } 第一个函数按引用传递对象，第二个按值传递对象。现在，假设将派生类对象传递给上述两个函数： BrassPlus buzz(&quot;Buzz Parsec&quot;, 111122, 3300); show(buzz); inadequate(buzz); show()函数调用使用rba参数成员BrassPlus对象buzz的引用，因此rba.ViewAcct()被解释为：BrassPlus版本，正如应该的那样。但在inadequate()函数中（按值传递对象），ba是Brass(const Brass&amp;)构造函数函数创建的一个Brass对象（自动向上强制类型转换使得构造函数参数可以引用一个BrassPlus对象）。因此，在inadequate()中，ba.ViewAcct()是Brass版本，所以只有buzz的Brass部分被显示。 6. 析构函数 基类的析构函数应该是虚的。这样，当通过指向对象的基类指针或引用来删除派生对象时，程序将首先调用派生类对象的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。 7. 友元函数 由于由于函数并非类成员，因此不能继承。然而，您可能希望派生类的友元函数能够使用基类的友元函数。为此，可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数： ostream &amp; operator&lt;&lt;(ostream &amp; os, const hasDMA &amp; rs) { os &lt;&lt; (const baseDMA &amp;) rs; os &lt;&lt; &quot;Style: &quot; &lt;&lt; rs.style &lt;&lt; endl; return os; } 也可以使用第15章将讨论的运算符dynamic_cast&lt;&gt;来进行强制类型转换： os &lt;&lt; dynamic_cast&lt;const baseDMA &amp;&gt; (rs); 鉴于第15章将讨论的原因，这是更佳的强制类型转换方式。 8. 有关使用基类方法的说明 以公有方式派生的类的对象可以通过多种方式来使用基类的方法： 派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法。 派生类的构造函数自动调用基类的构造函数。 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。 派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。 9. 类函数小结 13.9 总结is-a关系 不能继承基类的构造函数、析构函数和赋值运算符。 派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类的私有成员。 抽象基类ABC 虚函数 纯虚函数]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰SQL教程--关系模型(二)]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%BB%96%E9%9B%AA%E5%B3%B0SQL%E6%95%99%E7%A8%8B--%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[关系数据库是建立在关系模型上的，而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。 表的每一行称为记录，记录是一个逻辑意义上的数据。 表的每一列称为字段，同一个表的每一行记录都拥有相同的若个字段。 字段定义了数据类型，以及是否允许为空(NULL)。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0。 和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。 主键在关系数据库中，一张表中的每一列数据被称为一条记录。一条记录就是由多个字段组成的。例如，students表的两行记录： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。 对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。 例如，假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。 对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。 所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8ab2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 对于大部分应用来说，通常自增类型的主键就能满足需求。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 联合主键关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 对于联合主键，允许一列有重复，只要不是所有主键列都重复即可： id_num id_type other columns… 1 A … 2 A … 2 B … 如果我们把上述表的id_num和id_type这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 外键当我们用主键唯一标识记录时，我们就可以在students表中确定任意一个学生的记录： id name other columns… 1 小明 … 2 小红 … 我们还可以在classes表中确定任意一个班级记录： id name other columns… 1 一班 … 2 二班 … 但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？ 由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个classes的记录可以对应多个students表的记录。 为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应： id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 例如： 小明的class_id是1，因此，对应的classes表的记录是id=1的一班；小红的class_id是1，因此，对应的classes表的记录是id=1的一班；小白的class_id是2，因此，对应的classes表的记录是id=2的二班。 在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。 外键并不是通过列名实现的，而是通过定义外键约束实现的： ALTER TABLE students ADD CONSTRAINT fk_class_id FOREIGN KEY (class_id) REFERENCES classes (id); 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 要删除一个外键约束，也是通过ALTER TABLE实现的： ALTER TABLE students DROP FOREIGN KEY fk_class_id; 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 多对多通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系： teachers表： id name 1 张老师 2 王老师 3 李老师 4 赵老师 classes表： id name 1 一班 2 二班 中间表teacher_class关联两个一对多关系： id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 5 3 1 6 4 2 通过中间表teacher_class可知teachers到classes的关系： id=1的张老师对应id=1,2的一班和二班；id=2的王老师对应id=1,2的一班和二班；id=3的李老师对应id=1的一班；id=4的赵老师对应id=2的二班。 同理可知classes到teachers的关系： id=1的一班对应id=1,2,3的张老师、王老师和李老师；id=2的二班对应id=1,2,4的张老师、王老师和赵老师； 因此，通过中间表，我们就定义了一个“多对多”关系。 一对一一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 例如，students表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表contacts，我们就可以得到一个“一对一”关系： id student_id mobile 1 1 135xxxx6300 2 2 138xxxx2209 3 5 139xxxx8086 有细心的童鞋会问，既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？ 如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，一对一关系准确地说，是contacts表一对一对应students表。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 索引在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 例如，对于students表： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引： ALTER TABLE students ADD INDEX idx_score (score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如： ALTER TABLE students ADD INDEX idx_name_score (name, score); 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 唯一索引在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复： ALTER TABLE students ADD UNIQUE INDEX uni_name (name); 通过UNIQUE关键字我们就添加了一个唯一索引。 也可以只对某一列添加一个唯一约束而不创建唯一索引： ALTER TABLE students ADD CONSTRAINT uni_name UNIQUE (name); 这种情况下，name列没有索引，但仍然具有唯一性保证。 无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--类和动态内存分配（十二）]]></title>
    <url>%2F2019%2F02%2F13%2FC%2B%2B%20Primer%20Plus--%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍对类使用new和delete以及如何处理由于动态内存所引起的一些微妙问题。 12.1 动态内存和类C++在分配内存时，希望程序在运行时决定内存分配，而不是在编译时决定。这样，可根据程序的需要，而不是根据一系列严格的存储类型来使用内存。C++使用new和delete运算符来动态控制内存。遗憾的时，在类中使用这些运算符将导致许多新的编程问题。在这种情况下，析构函数将时必不可少的，而不再是可有可无的。 12.1.1 复习示例和静态成员首先，通过一个小程序复习一下new和delete的使用。这个程序使用了一个新的存储类型：静态类成员。首先，设计一个StringBad类，然后设计一个功能稍强的String类(前面介绍过的C++标准String类，在第16章将更深入讨论它；本章的StringBad和String类将介绍这个类的底层结构)。 StringBad和String类都将包含一个字符串指针和一个表示字符串长度的值。这里使用StringBad和String类，主要是为了更深入了解new和delete和静态类成员的工作原理。因此构造函数和析构函数调用时将显示一些消息，以便能够安全提示来完成操作。另外，将省略一些有用的成员和友元函数，以简化类接口。 为什么将它命名为StringBad呢？这是为了表示提醒，StringBad是一个还没有开发好的示例。这是使用动态内存分配来开发类的第一步，它正确第完成了一些显而易见的工作。例如，它在构造函数和析构函数种正确地使用了new和delete。它其实不会执行有害操作，但省略了一些有益的功能。 程序12.1 stringbad.h #ifndef STRINGBAD_H_ #define STRINGBAD_H_ class StringBad { private: char * str; int len; static int num_strings; public: StringBad(const char * s); StringBad(); ~StringBad(); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const StringBad &amp; st); }; #endif StringBad类是一个不太完整的类，通过了解这个存在的问题，将有助于您理解和记住后面将其转换为功能更强大的String类时，所做的不明显的修改。 对这个声明，需要注意两点。首先，它使用char指针来表示姓名。这意味着类声明没有字符串本身分配存储空间，而是在构造函数种使用new来为字符串分配空间。这避免了在类声明中预先定义字符串的长度。 其次，将num_strings成员声明为静态类成员。静态类成员有一个特点：无论创建多少个对象，程序都只创建一个静态类变量副本。即，类的所有对象共享同一个静态类成员，就像家中的电话可供全体家庭成员共享一样。假设创建了10个StringBad对象，将有10个str成员和10个len成员，但只有一个共享的num_strings成员。这对于所有类对象都具有相同的类私有数据非常方便。例如，num_strings成员可以记录所创建的对象数目。 注意，程序12.1使用num_strings成员，只是为了方便说明静态数据成员，并指出潜在的编程问题，字符串通常并不需要这样的成员。 程序12.2中类方法实现，演示了如何使用指针和静态成员。 程序12.2 stringbad.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; #include &quot;stringbad.h&quot; using std::cout; int StringBad::num_strings = 0; StringBad::StringBad(const char * s) { len = std::strlen(s); str = new char[len+1]; std::strcpy(str, s); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; object created\n&quot;; } StringBad::StringBad() { len = 4; str = new char[4]; std::strcpy(str, &quot;C++&quot;); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \&quot;&quot; &lt;&lt; str &lt;&lt; &quot; \&quot; default object created\n&quot;; } StringBad::~StringBad() { cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; object deleted, &quot;; --num_strings; cout &lt;&lt; num_strings &lt;&lt; &quot; left\n&quot;; delete [] str; } std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const StringBad &amp; st) { os &lt;&lt; st.str; return os; } 首先，注意程序12.2中的下面一条语句： int StringBad::num_strings = 0; 这条语句将静态成员num_strings的值初始化为零。注意，不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。可以使用这种格式来创建对象，从而分配和初始化内存。对于静态成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。 初始化在方法文件中，而不是在类声明文件中进行，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引起错误。 对于不能再类声明中初始化静态数据成员的一种例外情况(将第10章)是，静态成员为const整数类型或枚举类型。 注意：静态数据成员再类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是const整数类型或枚举类型，则可以在类声明中初始化。 接下来，注意到每个构造函数都包含表达式num_strings++，这确保程序每创建一个新对象，共享变量num_strings的值都增加1，从而记录StringBad对象的总数。另外，析构函数包含表达式–num_strings，因此StringBad类也将跟踪对象被删除的情况，从而使num_strings成员的值是最新的。 现在来看程序12.2中的第一个构造函数，它使用一个常规C字符串来初始化String对象： StringBad::StringBad(const char * s) { len = std::strlen(s); str = new char[len+1]; std::strcpy(str, s); num_strings++; cout &lt;&lt; num_strings &lt;&lt; &quot;: \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; object created\n&quot;; } 类成员str是一个指针，因此构造函数必须提供内存来存储字符串。初始化对象时，可以给构造函数创建一个字符串指针： String boston(&quot;Boston&quot;); 构造函数必须分配足够的内存来存储字符串，然后将字符串复制到内存中，下面介绍其中的每一个步骤： 首先，使用strlen()函数计算字符串的长度，并对len成员进行初始化。接着，使用new分配足够的空间来保存字符串，然后将新内存的地址赋给str成员。(strlen()返回字符串长度，但不包括末尾的空字符，因此构造函数将len加1，是分配的内存能够存储包含空字符的字符串。) 接着，构造函数使用strcpy()函数将传递的字符串赋值到新的内存中，并更新对象技术。最后，构造函数显示当前的对象数目和当前对象中存储的字符串。 要理解这种方法，必须知道字符串并不保存在对象中。字符串单独保存在堆内存中，对象仅保存了指出哪里去查找字符串的信息。 不能这样做： str = s; 这只保存了地址，没有创建字符串副本。 默认构造函数与此相似，但它提供了一个默认字符日：”C++”。 析构函数中包含了示例中对处理类来说重要的东西： StringBad::~StringBad() { cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; object deleted, &quot;; --num_strings; cout &lt;&lt; num_strings &lt;&lt; &quot; left\n&quot;; delete [] str; } 该析构函数首先指出自己何时被调用。这部分包含了丰富的信息，但并不是必不可少的。然而，delete语句确实至关重要的。str成员指向new分配的内存。当StrinBad对象过期时，str指针也将过期。但str指向的内存仍被分配，除非使用delete将其释放。删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中出用delete语句可确保对象过期时，由构造函数使用new分配的内存被释放。 警告：在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存。如果使用new[]来分配内存，则应使用delete[]来释放内存。 程序12.3演示了StringBad的构造函数和析构函数何时运行及如何运行。该程序将对象放在一个内部代码块中，因为析构函数将在定义对象的代码块执行完毕时调用。如果不这样做，析构函数将在mian()函数执行完毕时调用，导致您无法在执行窗口关闭时看到析构函数显示的信息。 程序12.3 vegnews.cpp #include &lt;iostream&gt; #include &quot;stringbad.h&quot; using namespace std; void callme1(StringBad &amp;); void callme2(StringBad); int main() { { cout &lt;&lt; &quot;Starting an inner block.\n&quot;; StringBad headline1(&quot;Celery Stalks at Midnight&quot;); StringBad headline2(&quot;Lettuce Prey&quot;); StringBad sports(&quot;Spinach Leaves Bowl for Dollars&quot;); cout &lt;&lt; &quot;headline1: &quot; &lt;&lt; headline1 &lt;&lt; endl; cout &lt;&lt; &quot;headline2: &quot; &lt;&lt; headline2 &lt;&lt; endl; cout &lt;&lt; &quot;sports: &quot; &lt;&lt; sports &lt;&lt; endl; callme1(headline1); cout &lt;&lt; &quot;headline1: &quot; &lt;&lt; headline1 &lt;&lt; endl; callme2(headline2); cout &lt;&lt; &quot;headline2: &quot; &lt;&lt; headline2 &lt;&lt; endl; cout &lt;&lt; &quot;Initialize one object to anoither:\n&quot;; StringBad sailor = sports; cout &lt;&lt; &quot;sailor: &quot; &lt;&lt; sailor &lt;&lt; endl; cout &lt;&lt; &quot;Assign one object to another:\n&quot;; StringBad knot; knot = headline1; cout &lt;&lt; &quot;knot: &quot; &lt;&lt; knot &lt;&lt; endl; cout &lt;&lt; &quot;Exiting the block.\n&quot;; } cout &lt;&lt; &quot;End fo main()\n&quot;; return 0; } void callme1(StringBad &amp; rsb) { cout &lt;&lt; &quot;String passed by reference:\n&quot;; cout &lt;&lt; &quot; \&quot;&quot; &lt;&lt; rsb &lt;&lt; &quot;\&quot;\n&quot;; } void callme2(StringBad sb) { cout &lt;&lt; &quot;String passed by value:\n&quot;; cout &lt;&lt; &quot; \&quot;&quot; &lt;&lt; sb &lt;&lt; &quot;\&quot;\n&quot;; } 程序输出： Starting an inner block. 1: &quot;Celery Stalks at Midnight&quot; object created 2: &quot;Lettuce Prey&quot; object created 3: &quot;Spinach Leaves Bowl for Dollars&quot; object created headline1: Celery Stalks at Midnight headline2: Lettuce Prey sports: Spinach Leaves Bowl for Dollars String passed by reference: &quot;Celery Stalks at Midnight&quot; headline1: Celery Stalks at Midnight String passed by value: &quot;Lettuce Prey&quot; &quot;Lettuce Prey&quot; object deleted, 2 left headline2: Initialize one object to anoither: sailor: Spinach Leaves Bowl for Dollars Assign one object to another: 3: &quot;C++ &quot; default object created knot: Celery Stalks at Midnight Exiting the block. &quot;Celery Stalks at Midnight&quot; object deleted, 2 left &quot;Spinach Leaves Bowl for Dollars&quot; object deleted, 1 left &quot;&quot; object deleted, 0 left *** Error in `./file&apos;: double free or corruption (fasttop): 0x0000000001e94060 *** ======= Backtrace: ========= 注意：StringBad的第一个版本有许多故意留下的缺陷，这些缺陷使得输出是不确定的。例如，有些编译器无法编译它等等文件。 输出中出现的各种非标准字符随系统而异，这些字符表明，StringBad类是一个糟糕的类。另一种迹象是对象计数为负(本文中由于编译器不同原因，没有出现负数，就出现异常)。在使用较新的编译器和操作系统的机器上运行时，该程序通常会在显示还有-1之前对象的信息之前中断，而有些这样的机器将报告通用保护存储(GPF)。GPF表明程序试图访问禁止它访问的内存单元。 程序说明 之前所有运行正常，直到执行到如下代码： callme2(headline2); cout &lt;&lt; &quot;headline2: &quot; &lt;&lt; headline2 &lt;&lt; endl; 这里，callme2()按值(而不是按引用)创建headline2，结果表明这是一个严重的问题！ String passed by value: &quot;Lettuce Prey&quot; &quot;Lettuce Prey&quot; object deleted, 2 left headline2: 首先，将headline2作为函数参数来传递从而导致析构函数被调调用。其次，虽然按值传递可以防止原始参数被修改，但实际上函数已使用原始字符串无法识别，导致显示一些非标准字符(在此没有显示任何字符)。 因为自动存储对象被删除的顺序与创建顺序相反，所以最先删除的3个对象是knots、sailor和sports。删除knots和sailor时是正常的，但在删除sports时，字符串变成空了。对于sports，程序只使用它来初始化sailor，但这种操作修改了sports。最后被删除的两个对象(headline2和headline1)已经无法识别。这些字符串在被删除之前，有些操作将它们搞乱了。 对象计数也会出错，这是因为如下代码； StringBad sailor = sports; 等效于如下的语句： StringBad sialor = StringBad(sports); 因为sports的类型为StringBad，因此相应的构造函数原型如下：】 StringBad(const StringBad &amp;); 当您使用一个对象来初始化另一个对象时，编译器自动生成上述构造函数(称为复制构造函数，因为它们创建对象的一个副本)。自动生成的构造函数不知道需要更新静态类成员num_strings，因此会将计数方案搞乱。 12.1.2 特殊成员函数StringBad类的问题是由于特殊成员函数引起的。这些成员函数是自动定义的，就StringBad而言，这些函数的行为与类设计不符。具体来说，C++自动提供了下面这样成员函数： 默认构造函数，如果没有定义构造函数； 默认析构函数，如果没有定义； 复制构造函数，如果没有定义； 赋值运算符，如果没有定义； 地址运算符，如果没有定义。 更准确地说，编译器将生成上述最后三个函数的定义—如果程序使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。 结果表明，StringBad类中的问题是由隐式赋值构造函数和隐私赋值运算符引起的。 隐式地址运算符返回调用对象的地址(即this指针的值)。这与我们的初衷是一致的。 C++提供了另外两个特殊成员函数：移动构造函数和移动赋值运算符，这将在第18章讨论。 1. 默认构造函数 如果没有提供任何构造函数，C++将创建默认构造函数。假设，定义了一个Klunk类，但没有提供任何构造函数，则编译器将提供下述默认构造函数： Klunk::Klunk() {} 即，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数。这是因为创建对象时，总是会调用构造函数。 Klunk lunk; 默认构造函数使lunk类似一个常规的自动变量，即，它的值在初始化时是未知的。 如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象是不显示地对它进行初始化，则必须显示地定义默认构造函数。这种构造函数没有任何参数，但可以使用它来设置特定的值： Klunk::Klunk(){ klunk_ct = 0; ... } 带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。例如，Klunk类可以包含下述内联构造函数： Klink(int n = 0) {klunk_ct = n;} 但只能有一个默认构造函数。即，不能这样做: Klunk(){klunk_ct = 0;} //#1 Klink(int n = 0) {klunk_ct = n;} //#2 存在二义性，因为： Klunk kar(10); Klunk bus; 第二个声明既与构造函数#1匹配，也与构造函数#2匹配。这导致编译器发出一条错误信息。 2. 复制构造函数 复制构造函数用于将一个对象复制到新创建的对象中，即，它用于初始化过程中(包括按值创建参数)，而不是常规的赋值过程中。类的复制构造函数原型通常如下： class_name(const Class_name &amp;); 它接受一个指向类对象的常量引用作为参数。例如，String类的复制构造函数的原型如下： StringBad(const String &amp;); 对于复制构造函数，需要知道两点：何时调用和有何功能。 3. 何时调用复制构造函数 新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数： StringBad ditto(motto); StringBad metoo = motto; StringBad also = StringBad(motto); String * pStringBad = new StringBad(motto); 其中中间的2个声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pstring指针。 每当程序生成了对象副本，编译器都将使用复制构造函数。具体来说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。具体来说，程序12.3中的函数调用将调用复制构造函数： callme2(headline2); 程序使用复制构造函数初始化sb — callme2()函数的StringBad型形参。 由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储对象的空间。 4. 默认的复制构造函数的功能 默认的复制构造函数逐个复制非静态成员(成员赋值也称为浅赋值)，复制的是成员的值。在程序12.3中，下述的语句： StringBad sailor = sports; 与下面的代码等效(只是由于私有成员是无法访问的，因此这些代码不能通过编译)： StringBad sailor; sailor.str = sports.str; sailor.len = sports.len; 如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态成员(如num_strings)不受影响，因为它们属于整个类，而不是各个对象。 12.1.3 回到StringBad：复制构造函数的哪里出了问题现在介绍程序12.3的两个异常之处。首先，程序的输出表明，析构函数的调用次数比构造函数的调用次数多2(本文由于编译器不同所以出现异常终止，没有多2)，原因可能是程序确实使用默认的复制构造函数另外创建了两个对象。当callme2()被调用时，复制构造函数被用来初始化callme2()的形参，还被用来将对象sailor()初始化为对象sports。默认的复制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将被调用，而不管对象是如何创建的。这是一个问题，因为这意味者程序无法准确地记录对象计数。解决办法是提供一个对计数进行更新的显式复制构造函数： StringBad：：StringBad(const StringBad &amp; s) { num_strings++; ... } 第二个异常之处更微妙，也更危险，其症状之一是字符串内容出现乱码(本文中为空)： headline2: 原因在于英石复制构造函数是按值进行复制的。例如，程序12.3，隐式复制构造函数的功能相当于： sailor.str = sports.str; 这里复制的并不是字符串，而是一个指向字符串的指针。即，将sailor初始化为sports后，得到的是两个指向同一个字符串的指针。当operator&lt;&lt;()函数使用指针来显式字符串时，并不会出现问题。但当析构函数被调用时，这将引发问题。析构函数~StringBad释放str指针指向的内存，因此释放sailor的效果如下： delete [] sailor.str; sailor.str指针指向 “Spinach Leaves Bowl for Dollars”，因为它被赋值为sports.str，而sports.str指向的正是上述字符串。所以delete语句将释放字符串 “Spinach Leaves Bowl for Dollars”占用的内存。 然后，释放sports的效果如下： delete [] sports.str; sports.str指向的内存已经被sailor的析构函数释放，这将导致不确定的、可能有害的后果。程序12.3中的程序生成受损的字符串，这通常是内存管理不善的表现。 另一个症状是，试图释放内存两次可能导致程序异常终止。例如，在Linux中，g++4.4.1显式消息“double free or corruption”并终止程序运行。，Microsoft Visual C++ 2010（调式模式）显示一个错误消息窗口，指出“Debug Assertion Failed!”。 1. 定义一个显示赋值构造函数以解决问题 解决类设计中这种问题的方法是进行深度复制(deep copy)。即，复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅复制字符串地址。这样，每个对象都有自己的字符串，而不是引用另一个对象的字符串。调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。可以这样编写复制构造函数： StringBad::StringBad(const StringBad &amp; st) { num_string++; len = st.len; str = new char[len+1]; std::strcpy(str, st.str); cout &lt;&lt; num_strings &lt; &quot;: \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; object createed\n&quot;; } 必须定义复制构造函数的原因在于：一些类成员是使用new初始化的、指向数据的指针，而不是数据本身。 警告：如果类中包含了使用new初始化的指针成员，应当定义个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一个形式(成员赋值或浅复制)只是复制指针值。浅复制仅仅浅浅复制指针信息，而不会深入“挖掘”以复制指针引用的结构。 12.1.4 StringBad的其他问题： 赋值运算符并不是程序12.3的所有问题都可以归咎于默认的复制构造函数，还需要看一看默认的赋值运算符。ANSI C允许结构赋值，而C++允许对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下： Class_name &amp; Class_name::operator=(const Class_name &amp;); 它接受并返回一个指向类对象的引用。例如，StringBad类的赋值运算符的原型如下： StringBad &amp; StringBad::operator=(const StringBad &amp;); 1. 赋值运算符的功能以及何时使用它 将已有的对象赋给另一个对象，将使用重载的赋值运算符： StringBad headline1(&quot;Celery Stalks at Midnight&quot;); ... StringBad knot; knot = headline1; 初始化对象时，并不一定使用赋值运算符： StringBad metoo = knot; 这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。然而，正如前面指出的，实现时可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。即，初始化总是会在调用复制构造函数，而是用=运算符时也允许调用赋值运算符。 与赋值构造函数相似，赋值运算符的隐式实现也对成员进行逐个赋值。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。 2. 赋值的问题出现在哪里 程序12.3将headline1赋给knot: knot = headline1; 为knot调用析构函数时，将显示下面的消息： &quot;Celery Stalks at Midnight&quot; object deleted, 2 left 为Headline1调用析构函数时，显示如下消息(本文中在此之前就异常终止了)： &quot;-|&quot; object deleted, -2 left 出现的问题与隐式赋值构造函数相同： 数据受损。这也是成员复制的问题，即导致headline1.str和knot.str指向相同的地址。因此，当对knot调用析构函数时，将删除字符串”Celery Stalks at Midnight”；当对headline1调用析构函数时，将试图删除前面已经删除的字符串。正如前面指出的，试图删除已经删除的数据导致的结果是不确定的，因此可能改变内存中的内容，导致程序异常终止。要指出的是，如果操作结果不确定的，则执行的操作将随编译器而异，包括显示独立声明或释放隐藏文件占用的硬盘空间。当然，编译器开发人员通常不会花时间添加这样的行为。 3. 解决赋值的问题 对于由于默认赋值运算符不适合而导致的问题，解决办法是提供赋值运算符(进行深度复制)定义。其实现与复制构造函数相似，但也有一些差别： 由于目标对象可能引用了以前分配的数据，所以函数应使用delete []来释放这些数据。 函数应当避免将对象赋给自身；否则给对象重新赋值前，释放内存操作可能删除对象的内容。 函数返回一个指向调用对象的引用。 通过返回一个对象，函数可以像通常赋值操作那样，连续进行赋值，即如果S0、S1和S2都是StringBad对象，则可以编写这样的代码： S0 = S1 = S2; 使用函数表示法，上述代码为： S0.operator=(S1.operator=(S2)); 因此S1.operator=(S2)的返回值是函数S0.operator=()的参数。 因为返回值是一个指向StringBad对象的引用，因此参数类型是正确的。 上述的代码说明了如何为StringBad类编写赋值运算符： StringBad &amp; StringBad::operator=(const StringBad &amp; st) { if (this == &amp;st) return * this; delete [] str; len = st.len; str = new char[len+1]; str::strcpy(str, st.str); return *this; } 代码首先自我检查，这是通过查看赋值运算符右边的地址(&amp;st)是否与接受对象(this)的地址相同来完成的。如果相同，程序将返回$\ast$this，然后结束。 如果地址不同，函数将释放str指向的内存，这是因为稍后将把一个新字符串的地址赋给str。如果不首先使用delete运算符，则上述字符串将保留字符串将保留在内存中。由于程序中不再包含指向该字符串的指针，因此这些内存被浪费掉。 接下来的操作与复制构造函数相似，即为新字符串分配足够的内存空间，然后将赋值运算符右边的对象中的字符串赋值到新的内存单元中。 上述操作完成后，程序返回$\ast$this并结束。 赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值。 将前面介绍的复制构造函数和赋值运算符添加到StringBad类中后，所有的问题都解决了。例如，下面是在完成上述修改后，程序输出的最后几行： Exiting the block. &quot;Celery Stalks at Midnight&quot; object deleted, 4 left &quot;Spinach Leaves Bowl for Dollars&quot; object deleted, 3 left &quot;Spinach Leaves Bowl for Dollars&quot; object deleted, 2 left &quot;Lettuce Prey&quot; object deleted, 1 left &quot;Celery Stalks at Midnight&quot; object deleted, 0 left End fo main() 12.2 改进后的新String类有了更丰富的知识后，可以对StringBad类进行修订，将它重命名为String。首先，添加前面介绍过的赋值构造函数和赋值运算符，使类能够正确管理类对象使用的内存。其次，由于您已经知道对象何时被创建和释放，因此可以让类构造函数和析构函数保持默认，不再在每次被调用时都显示消息。另外，也不用再监视构造函数的工作情况，因此可以简化默认构造函数，使之创建一个空字符串，而不是”C++”。 接下来，可以在类中添加一些新功能。String类应该包含标准字符串函数库cstring的所有功能，才会比较有用，但这里只添加足以说明其工作原理的功能(注意，String类只是一个用作说明的示例，而C++标准String类的内容丰富得多)。具体地说，将添加以下方法： int length() const {return len;} friend bool operator&lt;(const String &amp; st1, const String &amp; st2); friend bool operator&gt;(const String &amp; st1, const String &amp; st2); friend bool operator==(const String &amp; st1, const String &amp; st2); friedn opperator&gt;&gt;(istream &amp; is, String &amp; st); char &amp; operator[](int i); const char &amp; operator[](int i) const; static int HowMany(); 第一个新方法返回被存储得字符串长度。接下来的3个友元函数能够对字符串进行比较。operator&gt;&gt;()函数提供了简单的输入功能；两个operator$[]$()函数提供了以数组表示法访问字符串中各个字符的功能。静态类方法Howmany()将补充静态类数据成员num_string。下面来看一看具体情况： 12.2.1 修订后的默认构造函数请注意新的默认构造函数，它与下面类似： String::String(0 { len = 0; str = new char[1]; str[0] = &apos;\0&apos;; } 可能会问，为什么代码为： str = new char[1]; 而不是： str = new char; 上面两种方式分配的内存量相同，区别在于前者与类析构函数兼容，而后者不兼容。析构函数中包含如下代码； delete [] str; delete[]与使用new[]初始化的指针和空指针都兼容。因此对上述代码： str = new char[1]; str[0] = &apos;\0&apos;; 可修改为： str = 0; //将str设置为空指针 对于以其他方式初始化的指针，使用delete[]使，结果将是不确定的： char words[15] = &quot;bad idea&quot;; char * p1 = words; char * p2 = new char; char * p3; delete [] p1; //没有定义，不会执行 delete [] p2; //没有定义，不会执行 delete [] p3; //没有定义，不会执行 C++11空指针 在C++98中，字面值0有两种含义：可以表示数字值零，也可以表示空指针，这使得阅读程序的人和编译器难以区分。在有些程序员使用(void *)0来标识空指针(空指针本身的内部表示可能不是零)，还有些程序员使用NULL，这是一个表示空指针的C语言宏。 C++11提供了更好的解决方案：引入新关键字nullptr，用于表示空指针。您仍可像以前一样使用0—-否定大量现有的代码将非法，但建议您使用nullptr: str = nullptr； 12.2.2 比较成员函数在String类中，执行比较操作的方法有3个。如果按字母顺序，第一个字符串在第二个字符日之间，则operator&lt;()函数将返回true。要实现字符串比较函数，最简单的方法是使用标准的strcmp()函数，如果依照字母顺序，第一个参数位于第二参数之前，则该函数返回一个负值；如果两个字符串相等，则返回0；如果第一个参数位于第二参数之后，则返回一个正值。因此，可以这样使用strcmp(): bool operator&lt;(const String &amp; st1, const String &amp; st2) { if (std::strcmp(st1.str, st2,str) &lt; 0) return ture; else return false; } 因为内置&gt;运算符返回的是一个布尔值，所以可以将代码进一步简化为： bool operator&lt;(const String &amp; st1, const String &amp; st2) { return (std::strcmp(st1.str, st2,str) &lt; 0); } 同样，可以按照上面的方式来编写另外两个比较函数： bool operator&gt;(const String &amp; st1, const String &amp; st2) { return st2 &lt; st1; } bool operator==(const String &amp; st1, const String &amp; st2) { return (std::strcmp(st1.str, st2,str) == 0); } 第一个定义了利用&lt;运算符来表示&gt;运算符，对于内联函数，这是一种很好的选择。 将比较函数左右友元，有助于String对象与常规的C字符串进行比较。例如，假设answer是String对象，则下面的代码： if (&quot;love&quot; == answer) 将被转换为： if(operator==(&quot;love&quot;, answer)) 然后，编译器将使用某个构造函数将代码转换为： if(operator==(String(&quot;love&quot;), answer)) 这与原型匹配。 12.2.3 使用中括号表示法访问字符对于标准C-风格字符串来说，可以使用中括号来访问其中的字符： char city[40] = &quot;Amsterdam&quot;; cout &lt;&lt; city[0] &lt;&lt; endl; 在C++中，两个括号组成一个运算符—中括号运算符，可以使用方法operator$[]$()来重载该运算符。通常，二元运算符(带有两个操作数)位于两个操作数之间，例如2+5。但对于中括号运算符，一个操作数位于第一个中括号的前面，另一个操作数位于中括号之间。因此，表达式city[0]中，city是第一个操作数，[]是运算符，0是第二个操作数。 假设opera是一个String对象： String opera(“The Magic Flute”); 则对于表达式opera[4]，C++将查找名称和特征标与此相同的方法： String::operator[](int i) 如果找到匹配的原型，编译器将使用下面的函数调用来替代表达式opera[4]: opera.operator[](4); opera对象调用该方法，数组下标4成为该函数的参数。 下面是该方法的简单实现： char &amp; String::operator[](int i) { return str[i]; } 有了上述定义后，语句： cout &lt;&lt; opera[4]; 将被转换为： cout &lt;&lt; operat.operator[4]; 返回值是opera.str[4]（字符M）。由此，公有方法可以访问私有数据。 将返回类型声明为char &amp;, 便可以给特定元素赋值。例如，可以编写这样的代码： String means(&quot;might&quot;); means[0] = &apos;r&apos;; 第二条语句将被转换为一个重载运算符函数调用： means.operator[][0] = &apos;r&apos;; 这里将r赋给方法的返回值，而函数返回的是指向means.str[0]的引用，因此上述代码等同于下面的代码： means.str[0] = &apos;r&apos;; 代码的最后遗憾访问的是私有数据，但由于operator[]$()$是类的一个藩a，因此能够修改数据的内容。最后的结果是”might”被修改为”right”。 假设有下面的常量对象： const String answer(&quot;futile&quot;); 如果只有上述operator[]$()$定义，则下面的代码将出错： cout &lt;&lt; answer[1]； //编译出错 原因是answer是常量，而上述方法确保不修改数据(实际上，有时该方法的工作就是修改数据，因此无法确保不修改数据)。 但在重载是，C++将区分常量和非常量的特征标，因此可以通过另一个仅供const String对象使用的operator$[]$()版本： const char &amp; String::operator[](int i) const { return str[i]; } 有了上述定义，就可以读/写常规String对象了：而对于const String对象，则只能读取数据： String text(&quot;Once upon a time&quot;); const String answer(&quot;futile&quot;); cout &lt;&lt; text[1]; cout &lt;&lt; answer[1]; cin &gt;&gt; text[1]; cin &gt;&gt; answer[1]; //编译错误，常量不可修改 12.2.4 静态类成员函数可以将成员函数声明为静态的(函数声明必须包含关键字static，但如果函数定义是独立的，则其中不能包含关键字static)，这样做两个重要的后果。 首先，不能通过对象调用静态成员函数：实际上，静态成员函数甚不能使用this指针。如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。例如，可以给String类添加一个名为HowMany()的静态成员函数，方法是在类声明中添加如下原型/定义： static int HowMany(){ return num_strings;} 调用它的方式如下： int count = String::HowMany(); 其次，由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。例如，静态方法HowMany()可以访问静态成员num_strings，但不能访问str和len。 同样，也可以使用静态成员函数设置类级(classwide)标记，以控制某些类接口的行为。例如，类级标记可以控制显示类内容的方法所使用的格式。 12.2.5 进一步重载赋值运算符介绍针对String类来的程序之前，先来考虑另一个问题。假设要将常规字符串复制到String对象中。例如，假设使用getline()读取了一个字符串，并要将这个字符串放置到String对象中，前面定义的类方法让您能够这样编写代码： String name; char temp[40]; cin.getline(temp, 40); name = temp; 但如果经常需要这样做，这将不是一种理想的解决方案。为解释其原因，先来回顾一下最后一条语句是怎样工作的： 程序使用构造函数String(const char *)创建一个临时对象String，其中包含temp中的字符串副本。 本章后面的程序12.6中中使用String &amp; String::operator=(const String &amp;)函数将临时对象中的信息赋值到name对象中。 程序调用析构函数~String()删除临时对象。 为了提供效率，最简单的方法是重载赋值运算符，使之能够直接使用常规字符串，这样就不用创建和删除临时对象了。下面是一种可能的实现： String &amp; String::operator=(const char * s) { delete [] str; len = std::strlen(s); str = new char[len+1]; std::strcpy(str, s); return *this; } 一般来说，必须释放str指向的内存，并为新字符串分配足够的内存。 程序12。4列出了修改后的类声明。除了前面提到过的修改之外，这里还定义了一个CINLIM常量，用于实现operator&gt;&gt;()。 程序12.4 string1.h #ifndef STRING1_H_ #define STRING1_H_ #include &lt;iostream&gt; using std::ostream; using std::istream; class String { private: char * str; int len; static int num_strings; static const int CINLIM = 80; //cin input limit public: String(const char *); String(const String &amp;); String(); ~String(); int length() const {return len;} String &amp; operator=(const String &amp;); String &amp; operator=(const char *); char &amp; operator[](int i); const char &amp; operator[](int i) const; friend bool operator&lt;(const String &amp; st1, const String &amp; st2); friend bool operator&gt;(const String &amp; st1, const String &amp; st2); friend bool operator==(const String &amp; st1, const String &amp; st2); friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const String &amp; st); friend istream &amp; operator&gt;&gt;(istream &amp; is, String &amp; st); static int HowMany(); }; #endif 程序12.5给出了修订后的方法定义。 程序12.5 string1.cpp #include &lt;cstring&gt; #include &quot;string1.h&quot; using std::cin; using std::cout; int String::num_strings = 0; int String::HowMany() { return num_strings; } String::String(const char * s) { len = std::strlen(s); str = new char[len+1]; std::strcpy(str, s); num_strings++; } String::String() { len = 0; str = 0; num_strings++; } String::String(const String &amp; st) { len = st.len; str = new char[len + 1]; std::strcpy(str, st.str); num_strings++; } String::~String() { delete [] str; } String &amp; String::operator=(const String &amp; st) { if (this == &amp;st) return *this; delete [] str; len = st.len; str = new char[len + 1]; std::strcpy(str, st.str); return *this; } String &amp; String::operator=(const char * s) { delete [] str; len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); return *this; } char &amp; String::operator[](int i) { return str[i]; } const char &amp; String::operator[](int i) const { return str[i]; } bool operator&lt;(const String &amp; st1, const String &amp; st2) { return (std::strcmp(st1.str, st2.str) &lt; 0); } bool operator&gt;(const String &amp; st1, const String &amp; st2) { return st2 &lt; st1; } bool operator==(const String &amp;st1, const String &amp; st2) { return (std::strcmp(st1.str, st2.str) == 0); } ostream &amp; operator&lt;&lt;(ostream &amp; os, const String &amp; st) { os &lt;&lt; st.str; return os; } istream &amp; operator&gt;&gt;(istream &amp; is, String &amp; st) { char temp[String::CINLIM]; is.get(temp, String::CINLIM); if (is) st = temp; while (is &amp;&amp; is.get() != &apos;\n&apos;) continue; return is; } 重载&lt;&lt;运算符提供了一种将键盘输入行读入到String对象中的简单方法。它假定输入的字符数不多于String::CINLIM的字符数，并丢弃多余的字符。在if条件下，如果由于某种原因导致输入失败（如到达文件尾或get(char *, int)读取的是一个空行），istream对象的值将设置为false。 程序12.6通过一个小程序来使用这个类，该程序允许输入几个字符串。程序首先提示用户输入，然后将用户输入的字符串存储到String对象中，并显示它们，最后指出哪个字符串最短、哪个字符串按字母排序在最前面。 程序12.6 saying1.cpp #include &lt;iostream&gt; #include &quot;string1.h&quot; const int ArSize = 10; const int MaxLen = 81; int main() { using std::cout; using std::endl; using std::cin; String name; cout &lt;&lt; &quot;Hi, what&apos;s your name?\n&quot;; cin &gt;&gt; name; cout &lt;&lt; name &lt;&lt; &quot;, please enter up to &quot; &lt;&lt; ArSize &lt;&lt; &quot; short sayings &lt;empty line to quit&gt;:\n&quot;; String sayings[ArSize]; //对象数组 char temp[MaxLen]; int i; for (i = 0; i &lt; ArSize; i++) { cout &lt;&lt; i+1 &lt;&lt; &quot;: &quot;; cin.get(temp, MaxLen); while (cin &amp;&amp; cin.get() != &apos;\n&apos;) continue; if (!cin || temp[0] == &apos;\0&apos;) //输入是否为空行 break; else sayings[i] = temp; } int total = i; if (total &gt; 0) { cout &lt;&lt; &quot;Here are your sayings:\n&quot;; for (i = 0; i &lt; total; i++) cout &lt;&lt; sayings[i][0] &lt;&lt; &quot;: &quot; &lt;&lt; sayings[i] &lt;&lt; endl; int shortest = 0; int first = 0; for (i = 1; i &lt; total; i++) { if (sayings[i].length() &lt; sayings[shortest].length()) shortest = i; if (sayings[i] &lt; sayings[first]) first = i; } cout &lt;&lt; &quot;Shortest saying:\n&quot; &lt;&lt; sayings[shortest] &lt;&lt; endl; cout &lt;&lt; &quot;First alphabetically:\n&quot; &lt;&lt; sayings[first] &lt;&lt; endl; cout &lt;&lt; &quot;This program used &quot; &lt;&lt; String::HowMany() &lt;&lt; &quot; String objects. Bye.\n&quot;; } else cout &lt;&lt; &quot;No input! Bye.\n&quot;; return 0; } 注意:较早的get(char *, int)版本在读取空行后，返回的值不为false。然而，对于这些版本来说，如果读取了一个空行，则字符串中第一个字符将是一个空字符。这个示例使用了下述代码： if (!cin || temp[0] == &apos;\0&apos;) break; 如果实现遵循了最新的C++标准，则if语句的第一个条件将检测到空行，第二个条件用于旧版本实现中检测空行。 程序12.6中程序要求用户输入最多10条谚语。每条谚语都被读到一个临时字符数组，然后被复制到String对象中。如果用户输入空行，break语句终止输入循环。显示用户的输入后，程序使用成员函数length()和operator&lt;()来确定最短的字符串以及按字母顺序排列在最前面的字符串。程序还是用下标运算符[]提出每条谚语的第一个字符，并将其放在谚语的最前面。 输出： Hi, what&apos;s your name? Misty Gutz Misty Gutz, please enter up to 10 short sayings &lt;empty line to quit&gt;: 1: a fool and his money are soon parted 2: penny wise, pound foolish 3: the love of money is the root of much evil 4: out of sight, out of mind 5: absence makes the heart grow fonder 6: absinthe makes the hart grow fonder 7: Here are your sayings: a: a fool and his money are soon parted p: penny wise, pound foolish t: the love of money is the root of much evil o: out of sight, out of mind a: absence makes the heart grow fonder a: absinthe makes the hart grow fonder Shortest saying: penny wise, pound foolish First alphabetically: a fool and his money are soon parted This program used 11 String objects. Bye. 12.3 在构造函数中使用new时应注意的事项至此，您知道使用new初始化对象的指针成员时必须特别小型。具体来说，应当这样做： 如果在构造函数中使用new来初始化指针成员，则应该在析构函数中使用delete。 new和delete必须相互兼容。new对应于delete，new[]对应于delete[]。 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空(0和C++11中nullptr)，这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。 应定义一个复制构造函数，通过深度复制将一个对象初始化另一个对象。通常，这样的构造函数与下面类似： String::String(const String &amp; st) { len = st.len; str = new char[len + 1]; std::strcpy(str, st.str); num_strings++; } 具体来说，复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅时是数据的地址。另外，还应该更新所有影响的静态类成员。 应当定义一个赋值运算符，通过深度赋值将一个对象复制另一个对象。通常，该类方法与下面类似： String &amp; String::operator=(const String &amp; st) { if (this == &amp;st) return *this; delete [] str; len = st.len; str = new char[len+1]; std::strcpy(str, st.str); return *this; } 具体来说，该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。 12.3.1 应该和不应该下面的摘要包含了两个不正确的示例(指出什么是不应当做的)以及一个良好的构造函数示例： String::String() { str = &quot;default string&quot;; len = std::strlen(str); } String::String(const char * s) { len = std::strlen(s); str = new char; std::strcpy(str, s); } String::String(const String &amp; st) { len = st.len; str = new char[len + 1]; std::strcpy(str, st.str); } 第一个构造函数没有使用new来初始化str。对默认对象调用析构函数时，析构函数使用delete来释放str。对不是使用new初始化的指针使用delete时，结果是不确定的，并可能有害。可将该构造函数修改为下面的任何一种形式： String::String() { len = 0; str = new char[1]; str[0] = &apos;\0&apos;; } String::String() { len = 0; str = 0; } String::String() { static const char * s = &quot;C++&quot;; len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); } 摘录中的第二个构造函数，使用了new，但分配的内存量不正确。因此，new返回的内存块只能保存一个字符。试图将更长的字符串赋值到该内存块单元中，将导致内存问题。另外，这里使用的new不带中括号，这与另一个构造函数的正确格式不一致。 第三个构造函数是正确的。 最后，下面的析构函数无法与前面的构造函数正常地协同工作： String::~String() { delete str; } 该析构函数未能正确地使用delete。由于构造函数创建的是一个字符数组，因此析构函数应该删除一个数组。 12.3.2 包含类成员的类逐成员复制假设类成员的类型为String类和标准string类： class Magazine { private: String title; string publisher; ... }; String和string都是用动态内存分配，这意味着需要为Magazine类编写复制构造函数和赋值运算符？不，至少对这个类本身来说不需要。默认的逐成员赋值和复制行为有一定的智能。如果您将一个Magazine对象复制或赋值给另一个Magazing对象，逐成员复制将是成员类型定义的复制构造函数和赋值运算符。即，复制成员时，将使用String的复制构造函数，而将成员title赋给另一个Magazine对象时，将使用String的赋值运算符，依此类推。然而，如果Magazine类因其他成员需要定义复制构造函数和赋值运算符，情况将更复杂；在这种情况下，这些函数必须显式地调用String和string的复制构造函数和赋值运算符，这将在第13章介绍。 12.4 有关返回对象的说明当成员函数或独立的函数返回对象时，有几种返回方式可供选择。可以返回指向对象的引用、指向对象的const引用或const对象。到目前为止，介绍了前两种方式，但没有介绍最后一种方式。现在是复习这些方式的好时机： 12.4.1 返回指向const对象的引用使用const引用的常见的原因是旨在提供效率，但对于何时采用这种方式存在一些限制。如果函数返回(通过调用对象的方法或将对象作为参数)传递给它的对象，可以通过返回引用来提供效率。例如，假设要编写函数Max()，它返回两个Vector对象中较大的一个，其中Vector是第11章开发的一个类。该函数将以下面的方式被调用： Vector force1(50, 60); Vector force2(10, 70); Vector max; max = Max(force1, force2); 下面两种实现都是可行的： Vector Max(const Vector &amp; v1, const Vector &amp; v2) { if (v1.magval() &gt; v2.magval()) return v1; else return v2; } const Vector &amp; Max(const Vector &amp; v1, const Vector &amp; v2) { if (v1.magval() &gt; v2.magval()) return v1; else return v2; } 这里有三点需要说明。首先，返回对象将调用复制构造函数，而返回引用不会。因此，第二个版本所做的工作更少，效率更高。其次，引用指向的对象应该在调用函数执行时存在。在这个例子中，引用指向force1和force2，它们都是在调用函数中定义的，因此满足这种条件。第三，v1和v2都被声明为const引用，因此返回类型必须为const，这样才匹配。 12.4.2 返回指向非const对象的引用两种常见的返回非const对象的情形是，重载赋值运算符以及重载与cout一起使用的&lt;&lt;运算符。前者这样做旨在提供效率，而后者必须这样做： operator=()的返回值用于连续赋值： String s1(&quot;Good stuff&quot;); String s2, s3; s3 = s2 = s1; 返回String对象或String对象的引用都是可行的，但与Vector示例中一样，通过使用引用，可避免该调用String的赋值构造函数来创建一个新的String对象。在这个例子中，返回类型不是const，因为方法operator=()返回一个指向s2的引用，可以对其进行修改。 operator&lt;&lt;()返回值用于串接输出： String s1(&quot;Good stuff&quot;); cout &lt;&lt; s1 &lt;&lt; &quot; is coming&quot;; 在上述的代码中，operator&lt;&lt;(cout,s1)的返回值成为一个用于显示字符串”is coming”的对象。返回对象必须是ostream &amp;，而不能仅仅是ostream。如果使用返回类型ostream，将要求调用ostream类的赋值构造函数，而ostream没有公有的复制构造函数。幸运的是，返回一个指向cout的引用不会带来任何问题，因为cout已经在调用函数的作用域内。 12.4.3 返回对象如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部变量将调用其析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。通常，被重载的运算符属于这一类。请看下述示例，它再次使用了Vector类： Vector force1(50, 60); Vector force2(10, 70); Vector net; net = force1 + force2; 返回的不是force1，也不是force2，force1和force2在这个过程中应该保持不变。因此，返回值不能是指向在调用函数中已经存在的对象的引用。相反，在Vector::operator+()中计算得到的两个矢量的和被存储在一个新的临时对象中，该函数也不应该返回指向该临时对象的引用，而应该返回实际的Vector对象，而不是引用： Vector Vector::operator+(const Vector &amp; b) const { return Vector(x + b.x, y + b.y); } 在这种情况下，存在调用复制构造函数来创建被返回的对象的开销，然而这是无法避免的。 在上述示例中，构造函数调用Vector(x+b.x, y+b.y)创建一个方法operator+()能够访问的对象；而返回语句引发的对复制构造函数的隐式调用创建一个调用程序能够访问的对象。 12.4.4 返回const对象前面的Vector::operator+()定义有一个奇异的属性，它旨在让您能够以下面这样的方式调用它： net = force1 + force2; //语句1 然而，这种定义也允许您这样使用它： force1 + force2 = net; //语句2 cout &lt;&lt; (force1 + force2 = net).magval() &lt;&lt; endl; //语句3 这提出了三个问题。为何编写这样的语句？这些语句为何可行？这些语句有何功能？ 首先，没有要编写这种语句合理理由，但并非所有代码都是合理的。即使程序员也会犯错。例如，为Vector类定义operator==()时，您可能错误地输入这样的代码： if (force1 + force2 = net) 而不是： if (force1 + force2 == net) 另外，程序员通常很有创意，这可能导致错误。 其次，这种代码之所以可行，是因为复制构造函数将创建一个临时对象来表示返回值。因此，在前面的代码中，表达式force1 + force2的结果为一个临时对象。在语句1中，该临时对象被赋给net；语句2和3中，net被赋给临时对象。 第三，使用完临时对象后，把他丢弃。例如，对于语句2，程序计算force1+force2之和，将结果复制到临时返回对象中，再用net的内容覆盖临时对象的内容，然后将该临时对象丢弃。原来的矢量全部保持不变。语句3显示临时对象的长度，然后将其删除。 如果担心这种行为可能引发的误用，有一种简单的解决办法：将返回类型声明为const Vector。例如，如果Vector::operator+()的返回类型被声明为const Vector，则语句1仍然合法，但语句2和语句3将是非法的。 总之，如果方法和函数要返回局部变量，则应返回对象，而不是指向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对象。如果方法和函数要返回一个没有公有复制构造函数的类的对象(如ostream)，它必须返回一个指向这种对象的引用。最后，有些方法和函数(如重载的复制运算符)可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率高。 12.5 使用指向对象的指针这里练习使用指向对象的指针。程序12.6使用数组索引值来跟踪最短的字符串和按字母顺序排在最前面的字符串。另一种方法是使用指针指向这些类别的开始位置，程序12.7使用两个指向String的指针实现了这种方法。 最初，shortest指针指向数组的第一个对象。每当程序找到比指向的字符串更短的对象时，就把shortest重新设置为指向该对象。同样，first指针跟踪按字母顺序排在最前面的字符串。这两个指针并不创建新的对象，而只是指向已有的对象。因此，这些指针并不要求使用new来分配内存。 除此之外，程序12.7中的程序还使用一个指针来跟踪新对象： String * favorite = new String(sayings[choice]); 这里指针favorite指向new创建的未被命名对象。这种特殊的语法意味者使用对象sayings[choice]来初始化新的String对象，这将调用复制构造函数，因为复制构造函数(const String &amp;)的参数类型与初始化值(sayings[choice])匹配。程序使用srand(),rand(),time()随机选择一个值。 程序12.7 sayings.cpp #include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; #include &quot;string1.h&quot; const int ArSize = 10; const int MaxLen = 81; int main() { using namespace std; String name; cout &lt;&lt; &quot;Hi, what&apos;s your name?\n&quot;; cin &gt;&gt; name; cout &lt;&lt; name &lt;&lt; &quot;, please enter up to &quot; &lt;&lt; ArSize &lt;&lt; &quot; short sayings &lt;empty line to quit&gt;:\n&quot;; String sayings[ArSize]; //对象数组 char temp[MaxLen]; int i; for (i = 0; i &lt; ArSize; i++) { cout &lt;&lt; i+1 &lt;&lt; &quot;: &quot;; cin.get(temp, MaxLen); while (cin &amp;&amp; cin.get() != &apos;\n&apos;) continue; if (!cin || temp[0] == &apos;\0&apos;) //输入是否为空行 break; else sayings[i] = temp; } int total = i; if (total &gt; 0) { cout &lt;&lt; &quot;Here are your sayings:\n&quot;; for (i = 0; i &lt; total; i++) cout &lt;&lt; sayings[i][0] &lt;&lt; &quot;: &quot; &lt;&lt; sayings[i] &lt;&lt; endl; String * shortest = &amp;sayings[0]; String * first = &amp;sayings[0]; for (i = 1; i &lt; total; i++) { if (sayings[i].length() &lt; shortest-&gt;length()) shortest = &amp;sayings[i]; if (sayings[i] &lt; *first) first = &amp;sayings[i]; } cout &lt;&lt; &quot;Shortest saying:\n&quot; &lt;&lt; *shortest &lt;&lt; endl; cout &lt;&lt; &quot;First alphabetically:\n&quot; &lt;&lt; *first &lt;&lt; endl; srand(time(0)); int choice = rand()%total; String * favorite = new String(sayings[choice]); cout &lt;&lt; &quot;My favorite saying: \n&quot; &lt;&lt; * favorite &lt;&lt; endl; delete favorite; } else cout &lt;&lt; &quot;No input! Bye.\n&quot;; return 0; } 输出： Hi, what&apos;s your name? Kirt Rood Kirt Rood, please enter up to 10 short sayings &lt;empty line to quit&gt;: 1: a friend in need is a friend indeed 2: neither a borrower nor a lender be 3: a stitch in time saves nine 4: a niche in time saves stine 5: it takes a croook to catch a crook 6: cold hands, warm heart 7: Here are your sayings: a: a friend in need is a friend indeed n: neither a borrower nor a lender be a: a stitch in time saves nine a: a niche in time saves stine i: it takes a croook to catch a crook c: cold hands, warm heart Shortest saying: cold hands, warm heart First alphabetically: a friend in need is a friend indeed My favorite saying: cold hands, warm heart 使用new初始化对象 通常，如果Class_name是类，value的类型为Type_name，则下面的语句： Class_name * pclass = new Class_name(value); 将调用如下构造函数： Class_name(Type_name); 这里可能还有一些琐碎的转换，例如： Class_name(const Type_name &amp;); 另外，如果不存在二义性，则将发生由原型匹配导致的转换(如从int到double)。下面的初始化方式将调用默认构造函数： Class_name * ptr = new Class_name; 12.5.1 再谈new和delete程序12.4、程序12.5和程序12.7组成的程序在两个层次上使用了new和delete。首先，它使用new为创建的每一个对象的名称字符串分配存储空间，这是在构造函数中进行的，因此析构函数使用delete来释放这些内存。因为字符串是一种字符数组，所以析构函数使用的是带括号的delete。这样，但对象被释放时，用于存储字符串内容的内存将被自动释放。其次，程序12.7中的代码使用new来为整个对象分配存储空间： String * favorite = new String(sayings[choice]); 这不是为要存储的字符串分配内存，而是为对象分配内存：即，为保存字符串地址的str指针和len成员分配内存（程序并没有给num_strings成员分配内存，这是因为num_strings成员是静态成员，它独立于对象被保存）。创建对象将调用构造函数，后者分配用于保存字符串的内存，并将字符串的地址赋给str。然后，当程序不再需要该对象时，使用delete删除它。对象是单个的，因此，程序使用不带中括号的delete。与前面介绍的相同，这将只释放用于保存str指针和len成员的空间，并不释放str指针的内存，而该任务将由析构函数来完成。 在下述情况下析构函数将被调用： 如果对象是动态变量，则当执行完定义该对象的程序块是，将调用该对象的析构函数。 如果对象是静态变量（外部、静态、静态外部或来自名称空间），则在程序程序结束时将调用对象的析构函数。 如果对象是用new创建的，则仅当您显式地使用delete删除对象时，其析构函数才会被调用。 12.5.2 指针和对象小结使用对象指针时，需要注意几点： 使用常规表示法来声明指向对象的指针： String * glamour; 可以将指针初始化为指向已有对象： String * first = &amp;sayings[0]; 可以使用new来初始化指针，这将创建一个新的对象： String * favorite = new String(sayings[choice]); 对类使用new将调用相应的构造函数来初始化新创建的对象： String * gleep = new String; //调用默认构造函数 String glop = String(“my my my”); //调用构造函数String(const char ) String * favorite = new String(sayings[choice]); //调用构造函数String(const String &amp;) 可以使用-&gt;运算符通过指针访问方法类： if (sayings[i].length() &lt; shortest-&gt;length()) 可以将对象指针应用解除引用运算符(*)来获得对象： if (sayings[i] &lt; *first) first = &amp;sayings[i]; 12.5.3 再谈定位new运算符定位new运算符让您能够在分配内存时能够指定内存位置。第9章从内置类型的角度讨论了定位new运算符，将这种运算符用于对象时情况有些不同，程序12.8使用了定位new运算符和常规new运算符给对象分配内存，其中定义的类的构造函数和析构函数都会显式一些信息，让用户能够了解对象的历史。 程序12.8 placenew1.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;new&gt; using namespace std; const int BUF = 512; class JustTesting { private: string words; int number; public: JustTesting(const string &amp; s = &quot;Just Testing&quot;, int n = 0 ) { words = s; number = n; cout &lt;&lt; words &lt;&lt; &quot; constructed\n&quot;; } ~JustTesting() {cout &lt;&lt; words &lt;&lt; &quot; destroyed\n&quot;; } void show() const {cout &lt;&lt; words &lt;&lt; &quot;, &quot; &lt;&lt; number &lt;&lt; endl; } }; int main() { char * buffer = new char[BUF]; JustTesting *pc1, *pc2; pc1 = new(buffer) JustTesting; pc2 = new JustTesting(&quot;Heap1&quot;, 20); cout &lt;&lt; &quot;Memory block addresses:\n&quot; &lt;&lt; &quot;buffer: &quot; &lt;&lt; (void *) buffer &lt;&lt; &quot; heap: &quot; &lt;&lt; pc2 &lt;&lt; endl; cout &lt;&lt; &quot;Memory contents:\n&quot;; cout &lt;&lt; pc1 &lt;&lt; &quot;: &quot;; pc1-&gt;show(); cout &lt;&lt; pc2 &lt;&lt; &quot;: &quot;; pc2-&gt;show(); JustTesting *pc3, *pc4; pc3 = new(buffer) JustTesting(&quot;Bad Idea&quot;, 6); pc4 = new JustTesting(&quot;Heap2&quot;, 10); cout &lt;&lt; &quot;Memory contents:\n&quot;; cout &lt;&lt; pc3 &lt;&lt; &quot;: &quot;; pc3-&gt;show(); cout &lt;&lt; pc4 &lt;&lt; &quot;: &quot;; pc4-&gt;show(); delete pc2; delete pc4; delete [] buffer; cout &lt;&lt; &quot;Done\n&quot;; return 0; } 该程序使用new运算符创建了一个512字节的内存缓存区，然后使用new运算符在堆中创建两个JustTesting对象，并试图使用定位new运算符在内存缓存区中创建两个JustTesting对象。最后，它使用delete来释放使用new分配的内存。 输出： Just Testing constructed Heap1 constructed Memory block addresses: buffer: 0x1522010 heap: 0x1522280 Memory contents: 0x1522010: Just Testing, 0 0x1522280: Heap1, 20 Bad Idea constructed Heap2 constructed Memory contents: 0x1522010: Bad Idea, 6 0x1522300: Heap2, 10 Heap1 destroyed Heap2 destroyed Done 和往常一样，内存地址的格式和值随系统而异。 程序12.8在使用定位new运算符时存在两个问题。首先，在创建第二对象时，定位new运算符使用一个新对象来覆盖用于第一个对象的内存单元。显然，如果类动态地为其成员分配内存，这将引发问题。 其次，将delete用于pc2和pc4，这将自动调用为pc2和pc4指向的对象调用析构函数；然而，delete[]用于buffer，不会为使用定位new运算符创建的对象调用析构函数。 这里的经验教训与第9章相同：程序员必须负责管理定位new运算符用从中使用的缓冲区内内存单元。要使用不同的内存单元，程序员需要提供两个位于缓冲区的不同地址，并确保这两个内存单元不要重叠。例如，可以这样做： pc1 = new(buffer) JustTesting; pc3 = new(buffer + sizeof(JustTesting)) JustTesting(&quot;Better Idea&quot;, 6); 其中指针pc3相当于pc1的偏移量为JustTesting对象的大小。 第二教训是，如果使用定位new运算符来为对象分配内存，必须确保其析构函数被调用。当如何确保呢？对于堆中创建的对象，可以这样做： delete pc2; 但不能下面这样做： delete pc1; delete pc3; 原因在于delete可与常规new运算符配合使用，但不能与定位运算符配合使用。例如，指针pc3没有收到new运算符返回的地址，因此delete pc3将导致运行阶段错误。另一方面，指针pc1指向的地址与buffer相同，但buffer是使用new[]初始化的，因此必须使用delete []而不是delete来释放。即使buffer使用new而不是new []初始化的，delete pc1也将释放buffer，而不是pc1。这是因为new/delete系统知道已分配的512字节块buffer，但对定位new运算符对该内存块做了何种操作一无所知。 该程序确实释放了buffer: delete [] buffer; 正如上述注释指出的，delete [] buffer，释放使用常规new运算符分配的整个内存块，但它没有为定位new运算符在该内存块中创建的对象调用析构函数。您之所以知道这一点，是因为该程序使用了一个显式信息的析构函数，该析构函数宣布了“Heap”和“Heap2”的死亡，但却没有宣布“Just Testing”和“Bad Idea”的死亡。 这种问题的解决方案时，显式地为使用定位new运算符创建的对象调用析构函数。正常情况下将自动调用析构函数，这是需要显式调用析构函数的少数情况之一。: pc1-&gt;~JustTesging(); pc3-&gt;~JustTesting(); 程序12.9对定位new运算符使用的内存进行管理，加入何时的delete和显式析构函数调用。需要注意的一点是正确的删除顺序。对于使用new定位符创建的对象，应以创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象被销毁后，才能释放用于存储这些对象的缓冲区。 程序12.9 placenew2.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;new&gt; using namespace std; const int BUF = 512; class JustTesting { private: string words; int number; public: JustTesting(const string &amp; s = &quot;Just Testing&quot;, int n = 0 ) { words = s; number = n; cout &lt;&lt; words &lt;&lt; &quot; constructed\n&quot;; } ~JustTesting() {cout &lt;&lt; words &lt;&lt; &quot; destroyed\n&quot;; } void show() const {cout &lt;&lt; words &lt;&lt; &quot;, &quot; &lt;&lt; number &lt;&lt; endl; } }; int main() { char * buffer = new char[BUF]; JustTesting *pc1, *pc2; pc1 = new(buffer) JustTesting; pc2 = new JustTesting(&quot;Heap1&quot;, 20); cout &lt;&lt; &quot;Memory block addresses:\n&quot; &lt;&lt; &quot;buffer: &quot; &lt;&lt; (void *) buffer &lt;&lt; &quot; heap: &quot; &lt;&lt; pc2 &lt;&lt; endl; cout &lt;&lt; &quot;Memory contents:\n&quot;; cout &lt;&lt; pc1 &lt;&lt; &quot;: &quot;; pc1-&gt;show(); cout &lt;&lt; pc2 &lt;&lt; &quot;: &quot;; pc2-&gt;show(); JustTesting *pc3, *pc4; pc3 = new(buffer + sizeof(JustTesting)) JustTesting(&quot;Bad Idea&quot;, 6); pc4 = new JustTesting(&quot;Heap2&quot;, 10); cout &lt;&lt; &quot;Memory contents:\n&quot;; cout &lt;&lt; pc3 &lt;&lt; &quot;: &quot;; pc3-&gt;show(); cout &lt;&lt; pc4 &lt;&lt; &quot;: &quot;; pc4-&gt;show(); delete pc2; delete pc4; pc1-&gt;~JustTesting(); pc3-&gt;~JustTesting(); delete [] buffer; cout &lt;&lt; &quot;Done\n&quot;; return 0; } 输出： Just Testing constructed Heap1 constructed Memory block addresses: buffer: 0x1394010 heap: 0x1394280 Memory contents: 0x1394010: Just Testing, 0 0x1394280: Heap1, 20 Bad Idea constructed Heap2 constructed Memory contents: 0x1394020: Bad Idea, 6 0x1394300: Heap2, 10 Heap1 destroyed Heap2 destroyed Just Testing destroyed Bad Idea destroyed Done 该程序使用定位new运算符在相邻的内存单元中创建两个对象的，并调用了合适的析构函数。 12.6 复习各种技术至此，介绍了多种用于处理各种与类有关的问题的编程技术。下面对它们进行总结，并介绍合适使用它们。 12.6.1 重载&lt;&lt;运算符要重新定义&lt;&lt;运算符，以便将它和cout一起用来显式对象的内容，请定义下面的友元运算符函数： ostream &amp; operator&lt;&lt;(ostream &amp; os, const c_name &amp; obj) { os &lt;&lt; ...; return os; } 其中c_name 是类名。如果该类提供了能够返回所需内容的公有函数，则可在运算符函数中使用这些方法，这样便不用将它们设置为友元函数。 12.6.2 转换函数要将单个值转换为类类型，需要创建原型如下所示的构造函数： c_name(type_name value); 其中c_name为类名，type_name为要转换的类型的名称。 要将类转换为其他类型，需要创建如下所示的类成员函数： operator type_name(); 虽然，该函数没有声明返回类型，但应返回所需类型的值。 使用转换函数时要小心。可以在声明构造函数时使用关键字explicit，以防止它被用于隐式转换。 12.6.3 其构造函数使用new的类如果类使用new运算符来分配类成员指向的内存，在设计时应采取一些预防措施： 对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存。 如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。 构造函数中要么使用new []，要么使用new，而不能混用。如果构造函数使用的是new []，则析构函数应使用delete []；如果构造函数使用的new，则析构函数应使用delete。 应定义一个分配内存的复制构造函数，这样程序将能够将类对象初始化为另一个类对象。这种构造函数的原型通常如下： class_name(const class_name &amp;); 应定义一个重载赋值运算符的类成员函数，其函数定义如下（其中c_pointer是c_name的类成员，类型为指向type_name的指针）。下面的示例假设使用new[]来初始化变量c_pointer: c_name &amp; c_name operator=(const c_name &amp; cn) { if (this == &amp;cn) return * this; delete [] c_pointer; c_pointer = new type_name[size]; ... return *this; } 12.7 队列模拟进一步了解类，可将这方面的知识用于解决编程问题。Heather银行打算在Food Heap超市开设一个自动柜员机(ATM)。Food Heap超市的管理员担心排队等待使用ATM的人流会干扰超市的交通，希望限制排队等待的人数。Heather银行希望对顾客拍等待的时间进行预估。要编写一个程序来模拟这种情况，让超市的管理者可以了解ATM可能造成的影响。 对于这种问题，最自然的方法是使用顾客队列。队列是一种抽象的数据类型(Abstract Data Type, ADT)，可以存储有序的项目序列。新项目被添加在队尾，并可以删除队首的项目。队列有点像栈，但栈在同一端进行添加和删除。这使得栈是一种后进先出(LIFO)的结构，而队列是先进先出(FIFO)的。从概念上讲，队列就好比ATM前面排的队。因此，工程的任务之一就是定义一个Queue类（第16章将介绍标准模板库类queue）。 队列中的项目就是顾客。Heather银行的代表介绍：通常，三分之一的顾客只需要一分钟便可获得服务，三分之一的顾客需要两分钟，另外三分之一的顾客需要三分钟。另外，顾客到达的时间是随机的，但每个小时使用自动柜员机的顾客数量相当稳定。工程的另外两项任务是：设计一个表示顾客的类；编写一个程序来模拟顾客和队列之间的交互。 12.7.1 队列类首先，需要设计一个Queue类。这里先列出队列的特征： 队列存储有序的项目序列； 队列所能容纳的项目数有一定的限制； 应当能够创建空队列； 应当能够检查队列是否为空； 应当能够检查队列是否为满； 应当能够在队尾添加项目； 应当能够从队首删除项目； 应当能够确定队列中项目数。 设计类时，需要开发公有接口和私有实现。 1. Queue类的接口 从队列的特征可以，Queue类的公有接口应该如下： class Queue { enum {Q_SIZE = 10} pirvate: //后面介绍 public: Queue(int qs = Q_SIZE); ~Queue(); bool isempty() const; bool isfull() const; int queuecount() const; bool enqueue(cont Item &amp; item); //添加项目 bool dequeue(Item &amp;item); //删除项目 } ; 构造函数创建一个空队列。默认情况下，队列最多可存储10个项目，但是可以用显式初始化参数覆盖默认参数值。 Queue line1; Queue line2(20); 使用队列时，可以使用typedef 来定义Item（第14章介绍如何使用类模板）。 2. Queue类的实现 确定接口后，便可以实现它。首先，需要确定如何表示队列数据。一种方法是使用new动态分配一个数组，它包含所需的元素数。然而，这对于队列操作而言，数组并不太合适。例如，删除数组的第一个元素后，需要将余下的所有元素向前移动一位；否则需要作一些更费力的工作，如将数组视为循环的。然而，链表能够很好地满足队列的要求。链表由节点序列组成。每一个节点中都包含要保存到链表中的信息以及一个指向下一个节点的指针。对于这里的队列来说，数据部分都是一个Item类型的值，因此可以使用下面的结构来表示节点： struct Node { Item item; struct Node * next; } 图12.8所示是一张单向链表，因为每个节点都只包含一个指向其他节点的指针。知道第一个节点的地址后，就可以沿着指针找到后面的每一个节点。通常，链表最后一个节点中的指针被设置为NULL（或0或nullptr），以指出后面没有节点了。要跟踪链表，必须知道第一个节点的地址。可以让Queue类的一个数据成员指向链表的起始位置。具体来说，这是所需要的全部信息，有了这种信息后，就可以沿节点链找到任何节点。然而，由于队列总是将新项目添加到队尾，因此包含一个指向最后一个节点的数据成员将非常方便(参见图12.9)。此外，还可以使用数据成员来跟踪队列可存储的最大项目数以及当前的项目数。所以，类声明的私有部分与下面类似： class Queue { private: Struct Node {Item item; sturct Node * next; }; enum {Q_SIZE = 10}; Node * front; //指向队列第一个项目 Node * rear; //指向队列最后一个项目 int items; //当前队列中项目数量 const int qsize; //队列最大项目数量 ... public: ... }; 上述声明使用了C++的一项特性：在类中嵌套结构或类声明。通过将Node声明放在Queue类中，可以使其作用域为整个类。即，Node是这样一种类型：可以使用它来声明类成员，也可以将它作为类方法中的类型名称，但只能在类中使用。这样，就不必担心该Node声明与某些局部声明或其他类中声明的Node发生冲突。有些老的编译器不支持嵌套的结构和类，这样，必须将Node结构定义为全局。 嵌套结构和类 在类声明中声明的结构、类或枚举被称为是在嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是在类的私有部分，则只能在这个类使用被声明的类型；如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型。例如，如果Node是在Queue类的公有部分声明的，则可以在类的外面声明Queue::Node类型的变量。 3. 类方法 类构造函数应提供类成员的值。由于在这个例子中，队列最初是空的，因此队首和队尾指针都设置为NULL(0或nullptr)，并将items设置为0。另外，还应将队列最大长度qsize设置为构造函数参数qs的值。 Queue::Queue(int qs) { front = rear = NULL; item = 0; qsize = qs; //错误 } 问题在于qsize是常量，所以可以对它进行初始化，但不能给它赋值。从概念上说，调用构造函数时，对象将在括号中的代码执行之前创建。因此，调用Queue(int qs)构造函数将导致首先给4个成员变量分配内存。然后，程序流程进入括号中，使用常规的赋值方式将值存储到内存中。因此，对于const数据成员，必须在执行构造函数体之前，即创建对象时进行初始化。C++提供了一种特殊的语法来完成上述工作，它叫做成员初始化列表。成员初始化列表由逗号分隔的初始化列表组成(前面带冒号)。它位于参数列表的右括号之后、函数体左括号之前。如果数据成员的名称为mdata，并需要将它初始化为val，则初始化器为mdata(val)。使用这种表示法，可以这样编写Queue的构造函数： Queue::Queue(int qs)：qsize(qs) { front = rear = NULL; item = 0; } 通常，初值可以是常量或构造函数的参数列表中的参数。这种方法并不限于初始化常量，可以将Queue构造函数写成如下所示： Queue::Queue(int qs): qsize(qs), front(NULL), rear(NULL), items(0) { } 只有构造函数可以使用这种初始化列表语法。如上所示，对于const类成员，必须使用这种语法。 另外，对于被声明为引用的类成员，也必须使用这种语法： class Agency {...} class Agent { private: Agency &amp; belong; ... }; Agent::Agent(Agency &amp; a): belong(a){...} 这是因为引用与const数据类似，只能在被创建时进行初始化。对于简单数据成员(例如front和items)使用成员初始化列表和在函数体中使用赋值没有什么区别。然而，正如第14章介绍的，对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。 成员初始化列表的语法 如果Classy是一个类，而mem1、mem2和mem3都是这个类的数据成员，则类构造函数可以使用如下语法来初始化数据成员： Classy::Classy(int n, int m): mem1(n), mem2(0), mem3(n*m + 2) {} 上述代码将mem1初始化为n，将mem2初始化为0,将mem3初始化m*n+2。从概念上说，这些初始化工作在对象创建时完成的，此使还未执行括号中的任何代码。请注意以下几点： 这种格式只能用于构造函数； 必须使用这种格式来初始化非静态const数据成员； 必须使用这种格式来初始化引用数据成员。 数据成员初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。 成员初始化泪飙使用的括号方式也可用于常规初始化。即,可以将下述代码： int games = 162; double talk = 2.144; 替换为： int games(162); double talk(2.144); 这使得初始化内置类型就像初始化类对象一样。 C++中的类初始化 C++允许您以更直观的方式进行初始化： class Classy { int mem1 = 10; const int mem2 = 20; ... }; 这与在构造函数使用成员初始化列表等价： Classy::Classy(): mem1(10), mem2(20) {...} 成员mem1和mem2将分别给初始化为10和20，除非调用了使用成员初始化列表的构造函数，在这种情况下，实际列表将覆盖这些默认初始值： Classy::Classy(int n): mem1(n) {...} 在这里，构造函数将使用n来初始化mem1，但mem2仍被设置为20。 isempty()、isfull()和queuecount()的代码都非常简单。如果items为0，则队列是空的；如果items等于qsize，则队列是满的。要知道列表中的项目数，只需返回items的值。 将项目添加到队尾(入队)比较梦见。下面是一种方法： bool Queue::enqueue(const Item &amp; item) { if (isfull) return false; Node * add = new Node; add-&gt;item = item; add-&gt;next = NULL; items++; if (front == NULL) front = add; else rear-&gt;next = add; rear = add; retrun true; } 总之，方法需要经过下面几个阶段(见图12.10)。 删除队首项目(出队)也需要多个步骤才能完成。下面是一种方式： bool Queue::dequeue(Item &amp; item) { if (front == NULL) return false; item = front-&gt;item; items--; Node * temp = front; //保存front的地址，供后面删除 front = temp-&gt;next; delete temp; if (items == 0) //如果链表为空，将rear设置为NULL，front指针被设置为front-&gt;next，它已经为NULL rear = NULL; return true; } 总之，方法需要经过下面几个阶段(见图12.11)。 4. 是否需要其他类方法 是否需要其他方法呢？类构造函数没有使用new，所以乍一看，好像不用理会由于构造函数中使用new给类带来的特殊要求。当然，这种印象是错误的，因为队列中添加对象将调用new来创建新的节点。通过删除节点的方式，dequeue()方法确实可以清除节点，但这并不能保证队列在到期时为空。因此，类需要一个显式析构函数—-该函数删除剩余的所有节点。下面是一种实现，它从链表头开始，依次删除其中的节点： Queue::~Queue() { Node * temp; while (front != NULL) { temp = front; front = temp-&gt;next; delete front; } } 您知道，使用new的类通常需要包含显式复制构造函数和执行深度复制的赋值运算符，这个例子也是如此。复制Queue对象的成员将生成一个新的对象，该对象指向链表原来的头和尾。因此，将项目添加到复制的Queue对象中，将修改共享的链表。这样做将造成非常严重的后果。更糟的是，只有副本的尾指针得到了更新，从原始对象的角度看，这将损坏链表。显然，要克隆或复制队列，必须提供复制构造函数和执行深度复制的赋值运算符。 当然，这提出了这样一个问题：为什么需要复制队列？也许是希望在模拟的不同阶段保存队列的瞬像，也可能是希望为两个不同的策略提供相同的输入。实际上，拥有拆分队列的操作是非常有用的，超市在开设额外的收款台时经常这样做。同样，也可能希望将两个队列合成一个或者截断一个队列。 但假设这里的模拟不实现上述功能。难道不能忽略这些问题，而是用已有的方法吗？当然可以。然而，在将来的某个时候，可能需要再次使用队列且需要复制。另外，您可能会忘记没有为复制提供适当的代码。在这种情况下，程序将能编译和运行，但结果却是混乱的，甚至会崩溃。因此，最好还是提供复制构造函数和赋值运算符，尽管目前并不需要它们。 幸运的是，有一种小小的技巧可以避免这些额外的工作，并确保程序不会崩溃。这就是将所需的方法定义为伪私有方法： class Queue { private: Queue(cosnt Queue &amp; q): qsize(0); Queue &amp; operator=(const Queue &amp; q) {return *this;} ... } 这样做有两个作用：第一它避免了本来将自动生成的默认方法定义。第二，因为这些方法是私有的，所以不能广泛使用。即，如果nip和tuck是Queue对象，则编译器就不允许这样做： Queue snick(nip);//不允许 tuck = nip; //不允许 所以，与其将来面对无法预料的运行故障，不如得到一个容易跟踪的编译错误，指出这些方法是不可访问的。另外，在定义器对象不允许被复制的类时，这种方法也是很有用的。 C++11提供了另一种禁用方法—-使用关键字delete，这将在第18章介绍。 还需要注意，当对象被按值传递(或返回)时，复制构造函数将被调用。然而，如果没有遵循优先采用按引用传递对象的惯例，将不会有任何问题。另外，复制构造函数还被用于创建其他的临时对象，但Queue定义并没有导致创建临时对象的操作，例如重载加法运算符。 12.7.2 Customer类接下来需要设计客户类。这里的模拟需要使用唯一一个属性时客户何时进入队列以及客户交易所需的时间。当模拟生成新客户时，程序将创建一个新的客户对象，并在其中存储客户的到达时间以及一个随机生成的交易时间。当客户到达队首时，程序将记录此时的时间，并将其与进入队列的时间相减，得到客户的等候时间。下面的示例演示了如何定义和实现Customer类： class Customer { private: long arrive; int processtime; public: Customer() {arrive = processtime = 0;} void set(long when); long when() const {return arrive; } int ptime () const {return processtime; } }; void Customer::set(long when) { processtime = std::rand() % 3 + 1; arrive = when; } 默认构造函数创建一个空客户。set()成员函数将到达时间设置为参数，并将处理时间设置为1~3中的一个随机数。 程序12.10将Queue和Customer类声明放到一起。 程序12.10 queue.h #ifndef QUEUE_H_ #define QUEUE_H_ class Customer { private: long arrive; int processtime; public: Customer() {arrive = processtime = 0;} void set(long when); long when() {return arrive;} int ptime() {return processtime;} }; typedef Customer Item; class Queue { private: struct Node {Item item; struct Node * next;}; enum {Q_SIZE = 10}; Node * front; Node * rear; int items; const int qsize; Queue(const Queue &amp; q):qsize(0) {} Queue &amp; operator=(const Queue &amp; q) {return *this;} public: Queue(int qs = Q_SIZE); ~Queue(); bool isempty() const; bool isfull() const; int queuecount() const; bool enqueue(const Item &amp; item); bool dequeue(Item &amp; item); }; #endif 程序12.11 queue.cpp #include &quot;queue.h&quot; #include &lt;cstdlib&gt; Queue::Queue(int qs): qsize(qs) { front = rear = NULL; items = 0; } Queue::~Queue() { Node * temp; while (front != NULL) { temp = front; front = temp-&gt;next; delete front; } } bool Queue::isempty() const { return items == 0; } bool Queue::isfull() const { return items == qsize; } int Queue::queuecount() const { return items; } bool Queue::enqueue(const Item &amp; item) { if (isfull()) return false; Node * add = new Node; add-&gt;item = item; add-&gt;next = NULL; items++; if (front == NULL) front = add; else rear-&gt;next = add; rear = add; return true; } bool Queue::dequeue(Item &amp; item) { if (isempty()) return false; item = front-&gt;item; items--; Node * temp = front; front = front-&gt;next; delete temp; if (items == 0) rear = NULL; return true; } void Customer::set(long when) { processtime = std::rand() % 3 + 1; arrive = when; } 12.7.3 ATM模拟现在已经拥有模拟ATM的工具。程序允许用户输入3个数字：队列的最大长度、程序模拟的持续时间(单位为小时)以及平均每小时的客户数。程序将使用循环—每次循环代表一分钟。在每分钟的循环中，程序将完成下面的工作。 判断是否来了新的客户。如果来了，并且此时队列未满，则将它添加到队列中，否则拒绝客户入队。 如果没有客户进行交易，则选取队列的第一个客户。确定该客户的已等候时间，并将wait_time计数器设置为新客户所需的处理时间。 如果客户正在处理中，则将wait_time计数器减1。 记录各种数据，如获得服务的客户数、被拒绝的客户数目、排队等候的累积时间以及累积队列长度等等。 当模拟循环结束时，程序将报告各种统计结果。 一个有趣的问题是，程序如何确定是否有新的客户到来。假设平均每小时有10名客户到达，则相当于每6分钟有一名客户。程序将计算这个值，并将它保存在min_per_cust变量中。然而，刚好每6分钟来一名客户不太显式，我们真正(至少大部分时间内)希望的是一个更随机的过程—但平均每6分钟来一名客户。程序使用下面的函数来确定是否在循环期间有客户到来： bool newcustomer(double x) { return (std::rand() * x / RAND_MAX &lt; 1); } 其工作原理如下：值RAND_MAX是在cstblib头文件中定义的，是rand()函数可能返回的最大值(0是最小值)。假设客户到达的平均间隔时间x为6，则rand()*x/RAND_MAX的值将位于0到6之间。具体来说，平均每隔6次，这个值会有1次小于1。然而，这个函数可能会导致客户到达的时间间隔有时为1分钟，有时为20分钟。这种方法虽然很笨拙，但可使实际情况不同于有规则地每6分钟到来一个客户。如果客户到达的平均时间间隔小于1分钟，则上述方法将无效，但模拟并不是针对这种情况设计的。如果确实需要处理这种情况，最好提供时间分辨率，比如每次循环代表10秒。 程序12.12给出了模拟的细节。长时间运行该模拟程序，可知道长期的平均值。 #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &quot;queue.h&quot; const int MIN_PER_HR = 60; bool newcustomer(double x); int main() { using namespace std; srand(time(0)); cout &lt;&lt; &quot;Case Study: Bank of Heather Automatic Teller\n&quot;; cout &lt;&lt; &quot;Enter maximum size of queue: &quot;; int qs; cin &gt;&gt; qs; Queue line(qs); cout &lt;&lt; &quot;Enter the number of simulation hours: &quot;; int hours; cin &gt;&gt; hours; long cyclelimit = MIN_PER_HR * hours; cout &lt;&lt; &quot;Enter the average number of customers per hour: &quot;; double perhour; cin &gt;&gt; perhour; double min_per_cust; min_per_cust = MIN_PER_HR / perhour; Item temp; long turnaways = 0; long customers = 0; long served = 0; long sum_line = 0; int wait_time = 0; long line_wait = 0; for (int cycle = 0; cycle &lt; cyclelimit; cycle++) { if (newcustomer(min_per_cust)) { if (line.isfull()) turnaways++; else { customers++; temp.set(cycle); line.enqueue(temp); } } if (wait_time &lt;= 0 &amp;&amp; !line.isempty()) { line.dequeue(temp); wait_time = temp.ptime(); line_wait += cycle -temp.when(); served++; } if (wait_time &gt; 0) wait_time--; sum_line += line.queuecount(); } if (customers &gt; 0) { cout &lt;&lt; &quot;customers accepted: &quot; &lt;&lt; customers &lt;&lt; endl; cout &lt;&lt; &quot; customers served: &quot; &lt;&lt; served &lt;&lt; endl; cout &lt;&lt; &quot; turnaways: &quot; &lt;&lt; turnaways &lt;&lt; endl; cout &lt;&lt; &quot;average queue size: &quot;; cout.precision(2); cout.setf(ios_base::fixed, ios_base::floatfield); cout &lt;&lt; (double) sum_line / cyclelimit &lt;&lt; endl; cout &lt;&lt; &quot;average wait time: &quot; &lt;&lt; (double) line_wait / served &lt;&lt; &quot; minutes\n&quot;; } else cout &lt;&lt; &quot;No customers!\n&quot;; cout &lt;&lt; &quot;Done!\n&quot;; return 0; } bool newcustomer(double x) { return (std::rand() * x / RAND_MAX &lt; 1); } 运行的几个例子： Case Study: Bank of Heather Automatic Teller Enter maximum size of queue: 10 Enter the number of simulation hours: 100 Enter the average number of customers per hour: 15 customers accepted: 1527 customers served: 1527 turnaways: 0 average queue size: 0.18 average wait time: 0.69 minutes Done! Case Study: Bank of Heather Automatic Teller Enter maximum size of queue: 10 Enter the number of simulation hours: 100 Enter the average number of customers per hour: 30 customers accepted: 2866 customers served: 2864 turnaways: 117 average queue size: 4.35 average wait time: 9.11 minutes Done! Case Study: Bank of Heather Automatic Teller Enter maximum size of queue: 20 Enter the number of simulation hours: 100 Enter the average number of customers per hour: 30 customers accepted: 2951 customers served: 2947 turnaways: 29 average queue size: 7.64 average wait time: 15.54 minutes Done! 注意，每小时到达的客户数从15增加到30名时，等候时间并不是加倍，而是增加了15倍。如果允许队列更长，情况更糟糕。然而，模拟没有考虑这个事实—许多客户由于不愿意排很长的队而离开。 下面是该程序的另外几个运行示例。从中可知，即使平均每小时到达的客户数不变，也会出现短期变化。 Case Study: Bank of Heather Automatic Teller Enter maximum size of queue: 10 Enter the number of simulation hours: 4 Enter the average number of customers per hour: 30 customers accepted: 119 customers served: 111 turnaways: 0 average queue size: 3.14 average wait time: 6.35 minutes Done! Case Study: Bank of Heather Automatic Teller Enter maximum size of queue: 10 Enter the number of simulation hours: 4 Enter the average number of customers per hour: 30 customers accepted: 119 customers served: 111 turnaways: 2 average queue size: 3.31 average wait time: 6.51 minutes Done! Case Study: Bank of Heather Automatic Teller Enter maximum size of queue: 10 Enter the number of simulation hours: 4 Enter the average number of customers per hour: 30 customers accepted: 121 customers served: 115 turnaways: 0 average queue size: 2.62 average wait time: 5.15 minutes Done! 12.8 总结复制构造函数 赋值运算符 类中使用new动态分配内存需要注意的问题 定位new运算符为类对象分配内存，必须显式调用该对象析构函数 深度复制 初始化列表—构造函数特有的]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7使用yum安装提示cannot find a valid baseurl for repo:base/7/x86_64 的解决方法]]></title>
    <url>%2F2019%2F02%2F12%2FCentos7%E7%94%A8yum%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BAcannot%20find%20a%20valid%20baseurl%20for%20rep%2F</url>
    <content type="text"><![CDATA[*无法联网的明显表现会有： 1、yum install出现 Error: cannot find a valid baseurl or repo:base 2、ping host会提示unknown host 方法一、 1、打开 vi /etc/sysconfig/network-scripts/ifcfg-eth0（每个机子都可能不一样，但格式会是“ifcfg-eth数字”，也有些时ifcfg-ens数字），把ONBOOT=no，改为ONBOOT=yes 2、重启网络：service network restart 方法二、 1、打开 vi /etc/resolv.conf，增加 nameserver 8.8.8.8 2、重启网络: service network restart]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰SQL教程--关系数据库概述(一)]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%BB%96%E9%9B%AA%E5%B3%B0%E6%95%99%E7%A8%8B--%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[数据库作为一种专门管理数据的软件。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心。 ┌──────────────┐ │ application │ └──────────────┘ ▲│ ││ read││write ││ │▼ ┌──────────────┐ │ database │ └──────────────┘ 这样一来，编写应用程序的时候，数据读写的功能就大大被简化了。 数据模型数据库安全数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型： 层次模型 网状模型 关系模型 层次模型就是以“上下级”的层次关系组织数据的一种方式，层次模型的数据数据结构看起来像一棵树： ┌─────┐ │ │ └─────┘ │ ┌───────┴───────┐ │ │ ┌─────┐ ┌─────┐ │ │ │ │ └─────┘ └─────┘ │ │ ┌───┴───┐ ┌───┴───┐ │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ │ │ │ │ │ │ │ │ └─────┘ └─────┘ └─────┘ └─────┘ 网状模型把每个节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网： ┌─────┐ ┌─────┐ ┌─│ │──────│ │──┐ │ └─────┘ └─────┘ │ │ │ │ │ │ └──────┬─────┘ │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ │ │─────│ │─────│ │ └─────┘ └─────┘ └─────┘ │ │ │ │ ┌─────┴─────┐ │ │ │ │ │ │ ┌─────┐ ┌─────┐ │ └──│ │─────│ │──┘ └─────┘ └─────┘ 关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来像一个Excel表: ┌─────┬─────┬─────┬─────┬─────┐ │ │ │ │ │ │ ├─────┼─────┼─────┼─────┼─────┤ │ │ │ │ │ │ ├─────┼─────┼─────┼─────┼─────┤ │ │ │ │ │ │ ├─────┼─────┼─────┼─────┼─────┤ │ │ │ │ │ │ └─────┴─────┴─────┴─────┴─────┘ 关系数据库得到广泛应用的原因： 因为相比层次模型和网状模型，关系模型理解和使用起来最简单。 基于数学理论的关系模型虽然讲起来挺复杂，但是，基于日常生活的关系模型却十分容易理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下： ID 姓名 班级ID 性别 年龄 1 小明 201 M 9 2 小红 202 F 8 3 小军 202 M 8 4 小白 201 F 9 其中，班级ID对应着另一个班级表： ID 名称 班主任 201 二年级一班 王老师 202 二年级二班 李老师 数据类型对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等： 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 主流数据库商用数据库： Oracle SQL server DB2 开源数据库： MySQL PostgreSQL 桌面数据库： 微软Access为代表 嵌入式数据库： Sqlite为代表 SQLSQL是结构化查询语言Structured Query Language的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新、删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。 虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。 现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。 总的来说，SQL语言定义了这么几种操作数据库的能力： DDL：Data Definition Language DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 DML：Data Manipulation Language DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 DQL：Data Query Language DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--使用类（十一）]]></title>
    <url>%2F2019%2F01%2F23%2FC%2B%2B%20Primer%20Plus--%E4%BD%BF%E7%94%A8%E7%B1%BB%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章首先介绍运算符重载，它允许将标准C++运算符(如+和=)用于类对象。然后介绍友元，这种C++机制使得非成员函数可以访问私有数据。最后，介绍如何命令C++对类执行自动类型转换。 11.1 运算符重载运算符重载是一种形式的C++多态。第8章介绍了C++是如何使用户能够定义多个名称相同但特征标（参数列表）不同的韩剧是。这被称为函数重载或函数多态，旨在让您能过用同名的函数来完成相同的基本操作，即使这种操作被用于不同的数据类型。运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。实际上，很多C++运算符已经被重载。例如，将$\ast$运算符用于地址，将得到存储在这个地址中的值；但将它用于两个数字时，得到的将是它们的乘积。C++根据操作数的数目和类型来决定采用哪种操作。 C++允许将运算符重载扩展到用户定义的类型，例如，允许使用+将两个对象相加。编译器将根据操作数的数目和类型决定使用哪种加法定义。重载运算符可使代码看起来更自然。例如，将两个数组相加是一种常见的运算。通常，需要使用下面这样的for循环来实现： for (int i = 0; i &lt; 20; i++) evening[i] = sam[i] + janet[i]; 但在C++中，可以定义一个表示数组的类，并重载+运算符。于是便可以由这样的语句： evenig = sam + janet; 这种简单的加法表示隐藏了内部机理，并强调了实质，这是OOP的另一个目标。 要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下： opeartor op (argument-list) 例如，operator+()重载+运算符，operator$\ast$()重载$\ast$运算符。op必须是有效的C++运算符，不能虚构一个新的符号。例如，不能有operator@()这样的函数，因为C++中没有@运算符。然而，operator【】()函数重载[]运算符，因为[]运算符是数组索引运算符。 例如，假设有一个Salesperson类，并为它定义了一个opeartor+()成员函数，以重载+运算符，以便能够将两个Saleperson对象的销量相加，则如果district2、sid和sara都是Salesperson类对象，便可以编写这样的等式： district2 = sid + sara; 编译发现，操作数是Salesperson类对象，因此使用相应的运算符函数替换上述运算符： district2 = sid.operator+(sara); 该函数将隐式地使用sid（因为它强调了方法），而显式地使用sara（因为他被作为参数传递），来计算总和，并返回这个值。当然最重要的是，可以使用简便的+运算符表示法，而不必使用笨拙的函数表示法。 11.2 计算时间：一个运算符重载示例如果今天早上在Priggs的账户上花费了2个小时35分钟，下午又花费了2小时40分钟，则总共花了多少时间？这个示例与加法的概念很吻合，但要相加的单位(小时与分钟的混合)与内置的类型不匹配。第7章通过定义一个travel_time结构和将这种结构相加的sum()函数来处理类似的情况。现在将其推广，采用一个使用方法来处理加法的Time类。首先使用一个名为Sum()的常规方法，然后介绍如何将其转换为重载运算符。程序11.1列出了这个类声明。 程序11.1 mytime0h #ifndef MYTIME0_H_ #define MYTIME0_H_ class Time { private: int hours; int minutes; public: Time(); Time(int h, int m = 0); void AddMin(int m); void AddHr(int h); void Reset(int h = 0, int m = 0); Time Sum(const Time &amp; t) const; void Show() const; }; #endif 程序11.2 mytime0.cpp #include &lt;iostream&gt; #include &quot;mytime0.h&quot; Time::Time() { hours = minutes = 0; } Time::Time(int h, int m) { hours = h; minutes = m; } void Time::AddMin(int m) { minutes += m; hours = minutes / 60; minutes = minutes % 60; } void Time::AddHr(int h) { hours += h; } void Time::Reset(int h, int m) { hours = h; minutes = m; } Time Time::Sum(const Time &amp; t) const { Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum; } void Time::Show() const { std::cout &lt;&lt; hours &lt;&lt; &quot; hours, &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes.&quot;; } 来看一下Sum()函数。注意参数是引用，但返回类型却不是引用。将参数声明为引用的目的是为了提供效率。如果直接传递Time对象，代码的功能将相同，但传递引用的速度更快，使用的内存将更少。 然而，返回值不是引用。因为函数将创建一个新的Time对象(sum)，来表示另两个Time对象的和。返回对象(如代码所做的那样)将创建副本对象，而调用函数可以使用它。然而，如果返回类型是为Time &amp;，则引用的将是sum对象。但由于sum是局部变量，在函数结束时将被函数，因此引用将指向一个不存在的对象。使用返回类型Time意味着程序将在删除sum之前构造它的拷贝，调用函数将得到该拷贝。 注意：不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。 程序11.3 usetime0.cpp #include &lt;iostream&gt; #include &quot;mytime0.h&quot; int main() { using std::cout; using std::endl; Time planning; Time coding(2, 40); Time fixing(5, 55); Time total; cout &lt;&lt; &quot;planning time = &quot;; planning.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;coding time = &quot;; coding.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;fixing time = &quot;; fixing.Show(); cout &lt;&lt; endl; total = coding.Sum(fixing); cout &lt;&lt; &quot;coding.Sum(fixing) = &quot;; total.Show(); cout &lt;&lt; endl; return 0; } 输出： [root@localhost ~]# g++ mytime0.cpp usetime0.cpp -o file [root@localhost ~]# ./file planning time = 0 hours, 0 minutes. coding time = 2 hours, 40 minutes. fixing time = 5 hours, 55 minutes. coding.Sum(fixing) = 8 hours, 35 minutes. 11.2.1 添加加法运算将Time类转换为重载的加法运算符很容易，只要将Sum()的名称改为operator + ()即可。这样做是对的。只要把运算符(这里为+)放到operator的后面，并将结果用作方法名即可。在这里，可以在标识符中使用字母、数字或下划线之外的其他支付。程序11.4和程序11.5反映了这些细微的修改。 程序11.4 mytime1.h #ifndef MYTIME1_H_ #define MYTIME1_H_ class Time { private: int hours; int minutes; public: Time(); Time(int h, int m = 0); void AddMin(int m); void AddHr(int h); void Reset(int h = 0, int m = 0); Time operator+(const Time &amp; t) const; void Show() const; }; #endif 程序11.5 mytime1.cpp #include &lt;iostream&gt; #include &quot;mytime1.h&quot; Time::Time() { hours = minutes = 0; } Time::Time(int h, int m) { hours = h; minutes = m; } void Time::AddMin(int m) { minutes += m; hours = minutes / 60; minutes = minutes % 60; } void Time::AddHr(int h) { hours += h; } void Time::Reset(int h, int m) { hours = h; minutes = m; } Time Time::operator+(const Time &amp; t) const { Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum; } void Time::Show() const { std::cout &lt;&lt; hours &lt;&lt; &quot; hours, &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes.&quot;; } 程序11.6 usetime1.cpp #include &lt;iostream&gt; #include &quot;mytime1.h&quot; int main() { using std::cout; using std::endl; Time planning; Time coding(2, 40); Time fixing(5, 55); Time total; cout &lt;&lt; &quot;planning time = &quot;; planning.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;coding time = &quot;; coding.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;fixing time = &quot;; fixing.Show(); cout &lt;&lt; endl; total = coding + fixing; cout &lt;&lt; &quot;coding + fixing = &quot;; total.Show(); cout &lt;&lt; endl; Time morefixing(3, 28); cout &lt;&lt; &quot;more fixing time = &quot;; morefixing.Show(); cout &lt;&lt; endl; total = morefixing.operator+(total); cout &lt;&lt; &quot;morefixing.operator+(total) = &quot;; total.Show(); cout &lt;&lt; endl; return 0; } 输出： planning time = 0 hours, 0 minutes. coding time = 2 hours, 40 minutes. fixing time = 5 hours, 55 minutes. coding + fixing = 8 hours, 35 minutes. more fixing time = 3 hours, 28 minutes. morefixing.operator+(total) = 12 hours, 3 minutes. 总之，operator+()函数的名称使得可以使用函数表示法或运算符表示法来调用它。编译器根据操作的类型来确定如何做： int a, b, c; Time A, B, C; c = a + b; //使用整型加法 C = A + B; //使用为Time对象定义的加法 可以将两个以上的对象相加吗？例如，如果t1,t2,t3,t4都是Time对象，可以这样做吗： t4 = t3 + t2 + t1; 为回答这个问题，来看一些上述语句将如何被转换为函数调用。由于+是从左向右的运算符，因此上述语句首先被转换成如下这样： t4 = t3.operator+(t2+t1); 然后，函数参数本身被转换成一个函数调用，如下： t4 = t3.operator(t2.operator+(t1)); 上述语句合法。函数调用t2.operator+(t1)返回一个Time对象，后者是t2和t1的和。然而，该对象成为函数调用t3.operator+()的参数，该调用返回t3与表示t2和t1之和的Time对象的和。总之，最后的返回值为t1、t2和t3之和。 11.2.2 重载限制多数C++运算符都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。下面详细介绍C++对用户定义的运算符重载的限制。 重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符(-)重载为计算两个doulbe值的和，而不是它们的差。虽然，这种限制将对创造性有所影响，但可以确保程序正常运行。 使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符(%)重载成使用一个操作数： int x; Time shiva; % x; //错误语法 % shiva; //错误语法 同样，不能修改运算符的优先级。因此，如果将加法运算符重载成为两个类相加，则新的运算符与原来的加号具有相同的优先级。 不能创建新运算符。例如，不能定义operator$\ast\ast$()函数来表示求幂。 不能重载下面的运算符： sizof sizeof运算符。 . 成员运算符。 .$\ast$ 成员指针运算符。 :: 作用域解析运算符 ?: 条件运算符 typeid 一个RTTI运算符 const_cast 强制类型转换运算符 dynamic_cast 强制类型转换运算时 reinterpret_cast 强制类型转换运算符 static_cast 强制类型转换运算符 然而表11.1中所有的运算符都可以重载。 表11.1中的大多数运算生都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。 = 赋值运算符 () 函数调用运算符 [] 下表运算符 -&gt; 通过指针访问类成员的运算符 表11.1 可重载的运算符 | + | - | | / | % | ^ || &amp; | $|$ | ~= | ! | = | &lt; || &gt; | += | -= | = | /= | %= || ^= | &amp;= | $|=$ | &lt;&lt; | &gt;&gt; | &gt;&gt;= || &lt;&lt;= | == | != | &lt;= | &gt;= | &amp;&amp; || $||$ | ++ | – | , | -&gt;* | -&gt; || () | [] | new | delete | new[] | delete[] | 除了这些限制外，还应在重载运算符时遵循一些明智的限制。例如，不要将$\ast$运算符重载成交换两个Time对象的数据成员。表示法中没有任何内容可以表明交换对象的运算符完成的工作，因此最好定义一个其名称具有说明性的类方法，如Swap()。 11.2.3 其中重载运算符还有一些其他的操作对Time类来说是有意义的。例如，可能要将两个时间相减或将时间乘以一个因子，这需要重载减法和乘法运算符。这和重载加法运算符的技术相同，即创建operator-()和operator$\ast$()方法。即，将下面的原型添加到类声明中： Time operator-(const Time &amp; t) const; Time operator*(const Time &amp; t) const; 程序11.7 mytime2.h #ifndef MYTIME2_H_ #define MYTIME2_H_ class Time { private: int hours; int minutes; public: Time(); Time(int h, int m = 0); void AddMin(int m); void AddHr(int h); void Reset(int h = 0, int m = 0); Time operator+(const Time &amp; t) const; Time operator-(const Time &amp; t) const; Time operator*(double mult) const; void Show() const; }; #endif 程序11.8 mytime2.cpp #include &lt;iostream&gt; #include &quot;mytime2.h&quot; Time::Time() { hours = minutes = 0; } Time::Time(int h, int m) { hours = h; minutes = m; } void Time::AddMin(int m) { minutes += m; hours = minutes / 60; minutes = minutes % 60; } void Time::AddHr(int h) { hours += h; } void Time::Reset(int h, int m) { hours = h; minutes = m; } Time Time::operator+(const Time &amp; t) const { Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum; } Time Time::operator-(const Time &amp; t) const { Time diff; int tot1, tot2; tot1 = t.minutes + 60 * t.hours; tot2 = minutes + 60 * hours; diff.minutes = (tot2 - tot1) % 60; diff.hours = (tot2 - tot1) / 60; return diff; } Time Time::operator*(double mult) const { Time result; long totalminutes = (minutes + hours * 60) * mult; result.minutes = totalminutes % 60; result.hours = totalminutes / 60; return result; } void Time::Show() const { std::cout &lt;&lt; hours &lt;&lt; &quot; hours, &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes.&quot;; } 程序11.9 usetime2.cpp #include &lt;iostream&gt; #include &quot;mytime2.h&quot; int main() { using std::cout; using std::endl; Time weeding(4, 35); Time waxing(2, 47); Time total; Time diff; Time adjusted; cout &lt;&lt; &quot;weeding time = &quot;; weeding.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;waxing time = &quot;; waxing.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;total work time = &quot;; total = weeding + waxing; total.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;weeding time - waxing time = &quot;; diff = weeding - waxing; diff.Show(); cout &lt;&lt; endl; cout &lt;&lt; &quot;adjusted work time = &quot; ; adjusted = total * 1.5; adjusted.Show(); cout &lt;&lt; endl; return 0; } 输出： [root@localhost ~]# g++ mytime1.cpp usetime2.cpp -o file [root@localhost ~]# ./file weeding time = 4 hours, 35 minutes. waxing time = 2 hours, 47 minutes. total work time = 7 hours, 22 minutes. weeding time - waxing time = 1 hours, 48 minutes. adjusted work time = 11 hours, 3 minutes. 11.3 友元C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径，但有时候这种限制太严格，以至于不适合特定的编程问题。在这种情况下，C++提供了另一种形式的访问权限：友元。友元有3种： 友元函数； 友元类； 友元成员函数。 通过让函数成员类的友元，可以赋予该函数与类成员函数相同的权限。下面介绍友元函数，其他两种友元将在15章介绍。 首先，介绍为何需要友元。在为类重载二元运算符符时（带有两个参数的运算符）常常需要友元。将Time对象乘以实数就属于这种情况。 在前面的Time类示例中，重载的乘法运算符与其他两种重载运算符的差别在于，它使用了两种不同的类型。即，加法和减法运算符都结合两个Time值，而乘法运算符将一个Time值与一个doulbe值结合在一起。这限制了该运算符的使用方式。记住，左侧的操作数是调用对象。即，下面的语句： A = B * 2.75; 被转换为下面的成员函数调用： A = B.operatore*(2.75); 但下面的语句又如何呢？ A = 2.75 * B; 从概念上讲，2.75$\ast$B和B$\ast$2.75相同。当地一个表达是不对应与成员函数，因为2.75不是Time类型的对象。记住，左侧的操作数应是调用对象，但2.75不是对象。因此，编译器不能使用成员函数来替换该表达式。 解决这个难题的一种方式是，告知每个人(包括程序员自己)，只能按B$\ast$2.75这种格式编写，不能写成2.75$\ast$B。这是一种对服务器友好-客户警惕的解决方法，与OOP无关。 然而，另一中解决方式是非成员函数(记住，大多数运算符都可以通过成员函数或非成员函数来重载)。非成员函数不是由对象调用，它使用的所有制(包括对象)都是显式参数。这样，编译器能够将下面的表达式： A = 2.75 * B; 与下面的非成员函数调用匹配： A = operator*(2.75, B); 该函数的原型如下： Time operator(double m, const Time &amp; t); 对于非成员重载运算符函数来说，运算符表达式左侧的操作数对应于运算符函数的第一个参数，运算符表达式右侧的操作数对应于运算符函数的第二个参数。而原来的成员函数则按相反的顺序处理操作数，即double值乘以Time值。 使用非成员函数可以按所需的顺序获取操作数，但引发一个问题：非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问。然而，有一类特殊的非成员函数可以访问类的私有成员，它们被成为友元函数。 11.3.1 创建友元函数创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend： friend Time operator*(double m, const Time &amp; t); 该原型意味着如下两点： 虽然operator*()函数在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用。 虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同。 第二步，编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。另外，不要再定义中使用关键字friend，定义应该如下： Time operator*(double m, const Time &amp; t) { Time result; long totalminutes = t.hours * 60 * m + t.minutes * m; result.hours = totalminutes / 60; result.minutes = totalminutes % 60; return result; } 友元是否有悖于OOP 乍一看，可能会认为友元违反了OOP数据隐藏的原则，因为友元机制允许非成员函数访问私有数据。然而，这个观点太片面。相反，应将友元函数看作类的扩展接口的组成部分。只有类声明可以决定哪一个函数是友元函数，因此类声明仍然控制了哪些函数可以访问私有数据。总之，类方法和友元知识表达类接口的两种不同机制。 实际上，按上面的方式定义进行修改（交换乘法操作的顺序），可以将这个友元函数编写为非友元函数： Time operator*(double m, const Time &amp; t) { return t * m; } 原来的版本显式地访问t.minutes和t.hours，所以他必须是友元。这个版本Time对象t作为一个整体使用，让成员函数来处理私有制，因此不必是友元函数。然而，将该版本作用友元也是一个好主意。最重要的是，他将该作为正式类接口的组成部分。其次，如果以后发现需要函数直接访问私有数据，则只要修改函数定义即可，而不必修改类原型。 提示：如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺寻。 11.3.2 常用的友元： 重载&lt;&lt;运算符一个很有用的特性，可以对&lt;&lt;运算符进行重载，使之能与cout一起来显式对象的内容。与前面介绍的示例相比，这个重载要复杂些，因为我们分两步来完成。 假设trip是一种Time对象。为显式Time的值，前面使用的是Show()。然而，如果可以像下面这样操作将更好： cout &lt;&lt; trip; 之所以可以这样做，是因为&lt;&lt;是可被重载的C++运算符之一。实际上，它已经被重载很多次了。最初，&lt;&lt;运算符是C和C++的位运算符，将值中的位左移。ostream类对该运算符进行了重载，将其转换为一个输出工具。前面讲过，cout是一个ostream对象，它是智能的，能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream中都包含了相应的重载的operator&gt;&gt;()定义。即，一个定义使用int参数，一个定义使用double参数等等。因此要使cout能够识别cout对象，一种方法是将一个新的函数运算符定义添加到ostream类声明中。但修改ostream文件是个危险的注意，这样做会在标准接口上浪费时间。相反，通过Time类声明来让Time类知道如何使用cout。 1. &lt;&lt;的第一种重载版本 要使Time类知道使用cout，必须使用友元函数。这是因为下面这样的语句使用两个对象，其中第一个是ostream对象(cout): cout &lt;&lt; trip; 如果使用一个Time成员函数来重载&lt;&lt;,Time对象将是第一个操作数，就像使用成员函数重载$\ast$运算符那样。这意味着必须这样使用&lt;&lt;: trip &lt;&lt; cout; 这样会令人迷惑。但通过使用友元函数，可以像下面这样重载运算符： void operator&lt;&lt;(ostream &amp; os, const Time &amp; t) { os &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.minutes &lt;&lt; &quot; minutes&quot;; } 这样做可以使用下面的语句： cout &lt;&lt; trip; 友元还是非友元 新的Time类声明使operator&lt;&lt;()函数成为Time类的一个友元函数。但该函数不是ostream类的友元。operator&lt;&lt;()函数接受一个ostream参数和一个Time参数，因此表面看起来它必须同时是两个类的友元。然而，看看代码会发现，尽管该函数访问了Time对象的各个成员，但从始至终都将ostream对象看作一个整体使用。因为operator&lt;&lt;()访问了Time对象的私有成员，所以它必须是Time的友元。但由于它并不直接访问ostream对象的私有成员，所以并不一定必须是ostream类的友元。这样，就不需要修改ostream的定义。 不知道其他ostream函数? 另一个ostream对象是cerr，它将输出发送到标准输出流—默认为显示器，但在UNIX、Linux和Windows命令行环境中，可以标准错误流重定向到文件中。另外，第6章介绍的ofstream对象将输出写入文件中。通过继承(参见第13章），ofstream对象可以使用ostream的方法。这样，便可以使用operator&lt;&lt;()定义来将Time的数据写入到文件和屏幕上，为此，只需传递一个经过适当初始化的ofstream对象(而不是cout对象)。 调用cout &lt;&lt; trip应使用cout对象本身，而不是它的拷贝，因此该函数按引用来传递该对象。这样，表达式cout&lt;&lt;trip将导致ost成员cout的一个别名；而表达式cerr&lt;&lt;trip将导致os成为cerr的一个别名。Time对象可以按值或按引用来创建，因为这两种形式都使函数能够使用对象的值。按引用传递使用的内存和时间都比按值传递少。 2. &lt;&lt;的第二种重载版本 前面介绍的实现存在一个问题。就像下面这样的语句可以正常工作： cout &lt;&lt; trip; 但这种实现不允许像通常那样将重新定义的&lt;&lt;运算符与cout一起使用： cout &lt;&lt; &quot;Trip time: &quot; &lt;&lt; trip &lt;&lt; &quot;(Tuesday)\n&quot;; //错误 要理解这样做不可行的原因及必须如何做才能使其可行，首先需要了解关于cout操作的一点知识。请看下面的语句： int x = 5; int y = 8; cout &lt;&lt; x &lt;&lt; y; C++从左到右读取输出语句，意味着它等同于： (cout &lt;&lt; x) &lt;&lt; y; 正如iostream中定义的那样，&lt;&lt;运算符要求左边是一个ostream对象。显然，因为cout是ostream对象，所以表达式cout&lt;&lt;x满足这种要求。然而，因为表达式cout&lt;&lt;x位于&lt;&lt;y的左侧，所以输出语句也要求该表达式是一个ostream对象。因此，ostream类将operator&lt;&lt;()函数实现为返回一个指向ostream对象的引用。具体说，它返回一个指向调用对象(这里是cout)的引用。因此，表达式(cout&lt;&lt;x)本身就是ostream对象cout，从而可以位于&lt;&lt;运算符的左侧。 可以对友元函数采用相同的方法。只要修改operator&lt;&lt;()函数，让它返回ostream对象的引用即可： ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t) { os &lt;&lt; t.hours &lt;&lt; &quot; hours. &quot; &lt;&lt; t.minutes &lt;&lt; &quot; minutes.&quot;; return os; } 注意返回类型是ostream &amp;。这意味着该函数返回ostream对象的引用。因为函数开始执行时，程序传递了一个转向引用给它，这样做的最终结果时，函数的返回值就是传递给它的对象。及，下面的入局： cout &lt;&lt; trip; 将被转换为下面的调用： operator&lt;&lt;(cout, trip); 而该调用函数返回cout对象。因此，下面的语句可以正常工作： cout &lt;&lt; &quot;Trip time: &quot; &lt;&lt; trip &lt;&lt; &quot;(Tuesday)\n&quot;; 有趣的是，这个operator&lt;&lt;()版本还可用于将输出写入文件中： #include &lt;fstream&gt; ofstream fout; fout.open(&quot;savetime.txt&quot;); Time trip(12, 40); fout &lt;&lt; trip; 其中最后一条语句将转换为这样： operator&lt;&lt;(fout, trip); 另外，正如第8章指出的，类继承属性让ostream引用能够指向ostream对象和ofstream对象。 提示：一般来说，要重载&lt;&lt;运算符来显式c_name对象，可使用一个友元函数，其定义如下： ostream &amp; operator&lt;&lt;(ostream &amp; os, const c_name &amp; obj) { os &lt;&lt; ...; return os; } 程序11.10列出了修改后的类定义，其中包括operator*()和operator&lt;&lt;()这两个友元函数。他将一个友元函数作为内联函数。 程序11.10 mytime3.h #ifndef MYTIME3_H_ #define MYTIME3_H_ #include &lt;iostream&gt; class Time { private: int hours; int minutes; public: Time(); Time(int h, int m = 0); void AddMin(int m); void AddHr(int h); void Reset(int h = 0, int m = 0); Time operator+(const Time &amp; t) const; Time operator-(const Time &amp; t) const; Time operator*(double mult) const; friend Time operator*(double mult, const Time &amp; t) { return t * mult;} friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Time &amp; t); }; #endif 程序11.11 mytime3.cpp #include &lt;iostream&gt; #include &quot;mytime3.h&quot; Time::Time() { hours = minutes = 0; } Time::Time(int h, int m) { hours = h; minutes = m; } void Time::AddMin(int m) { minutes += m; hours = minutes / 60; minutes = minutes % 60; } void Time::AddHr(int h) { hours += h; } void Time::Reset(int h, int m) { hours = h; minutes = m; } Time Time::operator+(const Time &amp; t) const { Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum; } Time Time::operator-(const Time &amp; t) const { Time diff; int tot1, tot2; tot1 = t.minutes + 60 * t.hours; tot2 = minutes + 60 * hours; diff.minutes = (tot2 - tot1) % 60; diff.hours = (tot2 - tot1) / 60; return diff; } Time Time::operator*(double mult) const { Time result; long totalminutes = (minutes + hours * 60) * mult; result.minutes = totalminutes % 60; result.hours = totalminutes / 60; return result; } std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Time &amp; t) { os &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.minutes &lt;&lt; &quot;minutes.&quot;; return os; } 程序11.12 usetime3.cpp #include &lt;iostream&gt; #include &quot;mytime3.h&quot; int main() { using std::cout; using std::endl; Time aida(3, 35); Time tosca(2, 46); Time temp; cout &lt;&lt; &quot;Aida and Tosca: \n&quot;; cout &lt;&lt; aida &lt;&lt; &quot;; &quot; &lt;&lt; tosca &lt;&lt; endl; temp = aida + tosca; cout &lt;&lt; &quot;Aida + Tosca: &quot; &lt;&lt; temp &lt;&lt; endl; temp = aida * 1.17; cout &lt;&lt; &quot;Aida * 1.17: &quot; &lt;&lt; temp &lt;&lt; endl; cout &lt;&lt; &quot;10.0 * Tosca: &quot; &lt;&lt; 10.0 * tosca &lt;&lt; endl; return 0; } 输出： Aida and Tosca: 3 hours, 35minutes.; 2 hours, 46minutes. Aida + Tosca: 6 hours, 21minutes. Aida * 1.17: 4 hours, 11minutes. 10.0 * Tosca: 27 hours, 40minutes. 11.4 重载运算符：作为成员函数还是非成员函数对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。一般来说，非成员函数应该是友元函数，这样它才能直接访问类的私有数据。例如，Time类的加法运算符在Time类声明中的原型如下： Time operator+(const Time &amp; t) const; 这个类也可以使用下面的原型： friend Time operator(const Time &amp;t1, const Time &amp; t2); 加法运算符需要两个操作数。对于成员函数版本来说，一个操作数通过this指针隐式地传递，另一个通过操作数作为函数参数显式地传递；对于友元版本来说，两个操作数都作为参数传递。 记住两个格式必须选择一种格式，而不能同时选择两种格式。因为这两种格式都与同一个表达式匹配，同时定义这两种格式将被视为二义性，导致编译错误。 11.5 再谈重载：一个矢量类描述矢量需要两个数： 可以用大小(长度)和方向(角度)描述矢量； 可以用分量x和y表示矢量。 程序11.13列出了这个类的声明。为复习名称空间，该清单见类声明放在VECTOR名称空间中。另外，该程序使用枚举创建了两个常量(RECT和POL)，用于标识两种表示法。 程序11.13 vector.h #ifndef VECTOR_H_ #define VECTOR_H_ #include &lt;iostream&gt; namespace VECTOR { class Vector { public: enum Mode {RECT, POL}; private: double x; double y; double mag; double ang; Mode mode; void set_mag(); void set_ang(); void set_x(); void set_y(); public: Vector(); Vector(double n1, double n2, Mode form = RECT); void reset(double n1, double n2, Mode form = RECT); ~Vector(); double xval() const {return x;} double yval() const {return y;} double magval() const {return mag;} double angval() const {return ang;} void polar_mode(); void rect_mode(); Vector operator+(const Vector &amp; b) const; Vector operator-(const Vector &amp; b) const; Vector operator-() const; Vector operator*(double n) const; friend Vector operator*(double n, const Vector &amp; a); friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector &amp; v); }; } #endif 注意，程序中4个报告分量值的函数是在类中声明的，因此自动成为内联函数。 程序14利用名称空间的开放性，将方法定义添加到VECTOR名称空间中。另外，C++的内置数学函数在使用角度时以弧度为单位，所以函数在度和弧度之间进行转换。 程序11.14 vector.cpp #include &lt;iostream&gt; #include &lt;cmath&gt; #include &quot;vector.h&quot; using std::sqrt; using std::sin; using std::cos; using std::atan; using std::atan2; using std::cout; namespace VECTOR { const double Rad_to_deg = 45.0 / atan(1.0); //private methods; void Vector::set_mag() { mag = sqrt(x * x + y * y); } void Vector::set_ang() { if (x == 0.0 &amp;&amp; y == 0.0) ang = 0.0; else ang = atan2(y, x); } void Vector::set_x() { x = mag * cos(ang); } void Vector::set_y() { y = mag * sin(ang); } //public methods; Vector::Vector() { x = y = mag = ang = 0.0; mode = RECT; } Vector::Vector(double n1, double n2, Mode form) { mode = form; if (form == RECT) { x = n1; y = n2; set_mag(); set_ang(); } else if (form == POL) { mag = n1; ang = n2 / Rad_to_deg; set_x(); set_y(); } else { cout &lt;&lt; &quot;Incorrect 3rd argument to Vector() -- &quot;; cout &lt;&lt; &quot;vector set to 0\n&quot;; x = y = mag = ang = 0.0; mode = RECT; } } void Vector::reset(double n1, double n2, Mode form) { mode = form; if (form == RECT) { x = n1; y = n2; set_mag(); set_ang(); } else if (form == POL) { mag = n1; ang = n2 / Rad_to_deg; set_x(); set_y(); } else { cout &lt;&lt; &quot;Incorrect 3rd argument to Vector() -- &quot;; cout &lt;&lt; &quot;vector set to 0\n&quot;; x = y = mag = ang = 0.0; mode = RECT; } } Vector::~Vector() {} void Vector::polar_mode() { mode = POL; } void Vector::rect_mode() { mode = RECT; } Vector Vector::operator+(const Vector &amp; b) const { return Vector(x + b.x, y + b.y); } Vector Vector::operator-(const Vector &amp; b) const { return Vector(x - b.x, y - b.y); } Vector Vector::operator-() const { return Vector(-x, -y); } Vector Vector::operator*(double n) const { return Vector(x*n ,y*n); } Vector operator*(double n, const Vector &amp; a) { return a * n; } std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector &amp; v) { if (v.mode == Vector::RECT) os &lt;&lt; &quot;(x, y) = (&quot; &lt;&lt; v.x &lt;&lt; &quot;, &quot; &lt;&lt; v.y &lt;&lt; &quot;)&quot;; else if (v.mode == Vector::POL) { os &lt;&lt; &quot;(m, a) = (&quot; &lt;&lt; v.mag &lt;&lt; &quot;, &quot; &lt;&lt; v.ang &lt;&lt; &quot;)&quot;; } else os &lt;&lt; &quot;Vector object mode is invalid!&quot;; return os; } } reset方法并非必不可少。假设shove是一个Vector对象，您编写了如下代码： shove.reset(100, 300); 可以使用构造函数来得到相同的结果： shove = Vector(100, 300); 然而，reset()直接修改shove的内容，而使用构造函数将增加额外的步骤：创建一个临时对象，然后将其赋值给shove。 11.5.1 使用状态成员Vectore类存储了矢量的直角坐标和极坐标。它使用名为mode的成员来控制使用构造函数、reset()方法和重载operator&lt;&lt;()函数使用哪种形式，其中枚举RECT表示直角坐标模式(默认值)，POL表示极坐标模式。这样的成员被称为状态成员，因为这种成员描述的是对象所处的状态。 由构造函数的代码可知，第三个参数RECT或省略了，则将输入解释为直角坐标；如果为POL，则将输入解释为极坐标： Vector folly(3.0, 4.0); Vector foolery(20.0, 30.0, VECTOR::Vector::POL); 标识符POL的作用域为类，因此类定义可使用未限定的名称。但全限定名为VECTOR::Vector::POL，因为POL是在Vector类中定义的，而Vector是在名称空间VECTOR中定义的。 operator&lt;&lt;()函数也是用模式来确定如何显式值。由于operator&lt;&lt;()是一个友元函数，而不在作用域内，因此必须使用Vector::RECT，而不能直接使用RECT。因为友元函数在名称空间VECTOR中，因此无需使用全限定名VECTOR::Vector::RECT。 11.5.2 为Vector类重载算术运算符在使用x,y坐标时，将两个矢量相加将非常简单，只要将两个x分量相加，得到最终的x分量，将两个y分量相加得到y分量即可。根据描述，可以使用如下代码： Vector Vector::operator+(const Vector &amp; b) const { Vector sum; sum.x = x + b.x; sum.y = y + b.y; return sum; } 如果对象只存储x和y分量，则这很好。遗憾的是，上述代码无法设置极坐标值。可以通过添加另外一些代码来解决这个问题： Vector Vector::operator+(const Vector &amp; b) const { Vector sum; sum.x = x + b.x; sum.y = y + b.y; sum.set_ang(sum.x, sum.y); sum.set_mag(sum.x, sum.y); return sum; } 然而，使用构造函数来完成这种工作，将更简单，更可靠： Vector Vector::operator+(const Vecotr &amp; b) const { return Vector(x + b.x, y + b.y); } 上述的代码将新的x和y分量传递给Vector构造函数是，而后者将使用这些值来创建无名的新对象，并返回这个对象的副本。这确保了新的Vector对象是根据构造函数的标准规则创建的。 提示：如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数来完成这种工作。 1. 乘法 将矢量与一个数相乘，将使该矢量加长或缩短。因此，将矢量乘以3得到的矢量的长度为原来的三倍，而角度不变。要在Vector类中实现矢量的这种行为很容易。对于极坐标，只要将长度进行伸缩，并保持角度不变；对于直角坐标，只需要将x和y分量进行伸缩。 Vector Vector::operator*(double n) const { return Vector(x * n, y * n); } 和重载加法一样，上述代码允许构造函数使用新的x和y分量来创建正确的Vector对象。上述函数用于处理Vector值和double相乘。可以像Time示例那样，使用一个内联友元函数来处理double与Vector相乘： friend Vector Vector::operator*(double n, const Vector &amp; a) { return a * n; } 2. 对已重载的运算符进行重载 在C++中，-(负号)运算符有两种函数。首先，使用两个操作数，它是减法运算符。其次，使用一个操作数时，它是负号运算符。对于矢量来说，这两种操作都是有意义的，因此Vector类有这两种操作。 要从矢量A中减去矢量B，只要将分量相减即可，因此重载减法与重载加法相似。 操作的顺序非常重要。下面的语句： diff = v1 - v2; 将转换为下面的成员函数调用： diff = v1.operator-(v2); 这意味着将从隐私矢量参数减去显式参数创建的矢量。 接下来，看一元负号运算符，它只有一个操作数。下面时定义： Vector Vector::operator-() const { return Vector(-x, -y); } 现在，operator-()有两种不同的定义，这是可行的，因为它们的特征标(参数)不同。 11.5.3 对于实现的说明 Vector类中，所有接口都只要能够显示这两种表示，并返回各个值。内部实现可以完全不同。因此，可以只存储x和y分量，而返回矢量的长度的magval()方法可以根据x和y的值来计算出长度，而不是查找对象中存储的这个值。这种方法改变了实现，但用户接口没有改变。将接口和实现分离时OOP的目标之一。 这两种实现各有利弊。存储数据意味着对象将占据更多的内存；但查找数据的速度比较快。如果应用经常访问矢量的这两种表示，则这个例子采用的实现比较合适。 11.5.4 使用Vector来模拟随机漫步 程序11.15是一个小程序，它使用了Vector类。该程序模拟了著名的醉鬼走路问题。实际上，醉鬼被认为是一个有许多健康问题的人，而不是大家娱乐消遣的谈资，因此这个问题通常被成为随机漫步问题。其意思，将一个领到街灯柱下。这个人开始走动，但没走一部的方向都是随机的。这个问题的一种表述时，这个人走到离灯柱50英尺的地方需要多少步。从矢量的角度，这相当于不断将方向随机的矢量相加，直到长度超过50英尺。 程序11.15 randwalk.cpp #include &lt;iostream&gt; #include &quot;vector.h&quot; #include &lt;cstdlib&gt; // rand(), srand() #include &lt;ctime&gt; // time() int main() { using namespace std; using VECTOR::Vector; srand(time(0)); double direction; Vector step; Vector result(0.0, 0.0); unsigned long steps = 0; double target; double dstep; cout &lt;&lt; &quot;Enter target distance (q to quit):&quot;; while (cin &gt;&gt; target) { cout &lt;&lt; &quot;Ener step length: &quot;; if (!(cin &gt;&gt; dstep)) break; while(result.magval() &lt; target) { direction = rand() % 360; step.reset(dstep, direction, Vector::POL); result = result + step; steps++; } cout &lt;&lt; &quot;After &quot; &lt;&lt; steps &lt;&lt; &quot;steps, the subject &quot; &quot;has the following location:\n&quot;; cout &lt;&lt; result &lt;&lt; endl; result.polar_mode(); cout &lt;&lt; &quot;or\n&quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Average outward distance per step = &quot; &lt;&lt; result.magval() / steps &lt;&lt; endl; steps = 0; result.reset(0.0, 0.0); cout &lt;&lt; &quot;Enter target distance (q to quit):&quot;; } cout &lt;&lt; &quot;Bye!\n&quot;; cin.clear(); while (cin.get() != &apos;\n&apos;) continue; return 0; } 输出： Enter target distance (q to quit):100 Ener step length: 5 After 246steps, the subject has the following location: (x, y) = (85.9784, 54.1236) or (m, a) = (101.596, 0.56183) Average outward distance per step = 0.41299 Enter target distance (q to quit):200 Ener step length: 5 After 1087steps, the subject has the following location: (x, y) = (-57.2303, 193.208) or (m, a) = (201.506, 1.85877) Average outward distance per step = 0.185378 Enter target distance (q to quit):q Bye! 程序说明 首先，需要指出的时，在程序11.15中使用VECTOR名称空间非常方便。下面using声明使Vector类的名称可用： using VECTOR::Vector; 接下来谈谈随机数。标准ANSI C库(C++也有)中有一个rand()函数，它返回一个从0到某个值(取决于实现)之间的随机数。该程序使用求模运算来获得一个0~359的角度值。 rand()函数将一种算法用于一个初始种子值来获得随机数，该随机数用在下一次函数调用的种子，以此类推。这些数实际上使伪随机数，因此10次连续的调用通常生成10个同样的随机数。然而，srand()函数允许覆盖默认的种子值，重新启动另一个随机序列。该程序使用time(0)的返回值来设置种子。time(0)返回当前时间，通常从某一个日期开始的秒数。因此，下面的语句在每次运行程序时，都将设置不同的种子，是随机数看上去更为随机： srand(time(0)); 头文件cstdlib包含了srand()和rand()的原型，而ctime包含了time()的原型。 顺便说一句，在将一系列位置存储到文件中很容易。首先包含头文件fstream，声明一个ofstream对象，将其同一个文件关联起来： #include &lt;fstream&gt; ofstream fout; fout.open(&quot;thewalk.txt&quot;); four &lt;&lt; resutl &lt;&lt; endl; 这将调用友元函数operator&lt;&lt;(fout, result)，导致引用参数os指向fout，从而将输出写入文件中。 11.6 类的自动转换和强制转换本节讨论如何处理用户定义类型的转换。首先，复习一下C++如何处理内置类型转换的。将一个标准类型变量的值赋给另一个标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。例如，下面的语句都将导致类型转换： long count = 8; double time = 11; int side = 3.33; 上述赋值语句是可行的，因为在C++看来，各种数据类型都表示相同的东西—-一个数字，同时C++包含用于转换的内置规则。这些转换将降低精度。 C++语言不自动转换不兼容的类型。例如，下面的语句是非法的，因为左边是指针类型，而右边是数字： int *p = 10; 虽然计算机内部可能使用证数来表示地址，但从概念上，整数和指针完全不同。例如，不能计算指针的平方。然而，在无法自动转换是，可以使用强制类型转换： int *p = (int *) 10; 上述语句将10强制转换为int指针类型，将指针设置为地址10。 可以将类定义成为与基本类型或另一个类相关，使得从一个类型转换为另一个类型是有意义的。在这种情况下，程序员可以指示C++如何自动进行转换，或通过强制类型转换来完成。 为了说明这个如何进行的，我们将第3章的磅转换为英石的程序改写为类形式。首先，设计一个合适的类型，我们基本上是以两种方式(磅和英石)来表示重量。对于在一个实体中包含一个概念的两种表示来说，类提供了一种非常好的方式。因此可以将重量的两种方法表示放在同一个类中，然后提供以这两种方式表达重量的类方法。 程序11.16 stonewt.h #ifndef STONEWT_H_ #define STONEWT_H_ class Stonewt { private: enum {Lbs_per_stn = 14}; int stone; double pds_left; double pounds; public: Stonewt(double lbs); Stonewt(int stn, double lbs); Stonewt(); ~Stonewt(); void show_lbs() const; void show_stn() const; }; #endif 对于定义特定的常量来说，如果它们是整数，enum提供了一种方便的途径。也可以采用下面的方法： static const int Lbs_per_stn = 14; Stonewt有3个构造函数，让您能够将Stonewt对象初始化为一个浮点数（单位为磅）或两个浮点数（分别代表英石和磅）。也可以创建Stonewt对象，而不进行初始化。 Stonewt提供了两个显示函数，一个以磅为单位显示重量，另一个以英石和磅为单位显示重量。 程序11.17sthonewt.cpp #include &lt;iostream&gt; #include &quot;stonewt.h&quot; using std::cout; Stonewt::Stonewt(double lbs) { stone = int (lbs) / Lbs_per_stn; pds_left = int (lbs) % Lbs_per_stn; pounds = lbs; } Stonewt::Stonewt(int stn, double lbs) { stone = stn; pds_left = lbs; pounds = stn * Lbs_per_stn + lbs; } Stonewt::Stonewt() { stone = pounds = pds_left = 0; } Stonewt::~Stonewt() {} void Stonewt::show_stn() const { cout &lt;&lt; stone &lt;&lt; &quot; stone, &quot; &lt;&lt; pds_left &lt;&lt; &quot; pounds\n&quot;; } void Stonewt::show_lbs() const { cout &lt;&lt; pounds &lt;&lt; &quot; pounds\n&quot;; } 因为Stonewt对象表示一个重量，所以可以提供一些将整数或浮点数转换为Stonewt对象的方法。我们已经这样做了！在C++中，接受一个参数的构造函数为将类型与该参数相同的值转换提供了蓝图。因此，下面的构造函数用于将double类型转换为Stonewt类型： Sthonewt(double lbs); 即，可以编写如下代码： Stonewt myCat; myCat = 19.6; 程序将使用构造函数Stonewt(double)来创建一个临时的Stonewt对象，并将19.6作为初始化值。随后，采用逐成员赋值方式将该临时对象的内容赋值到myCat中。这一过程成为隐式转换，因为它是自动进行的，而不需要显式强制类型转换。 只有接受一个参数的构造函数才能作为转换函数。下面的构造函数有两个参数，因此不能用来转换类型： Stonewt(int stn, double lbs); 然而，如果给第二个参数提供默认值，它便可用于转换int: Stonewt(int stn, double lbs = 0); 将构造函数用作自动类型转换函数似乎是一项不错的特定。然而，当程序员拥有更丰富的C++经验时，将发现这种自动特性并非总是合乎需要的，因为这会导致意外的类型转换。因此，C++增加了关键字explicit用于关闭这种自动特性。即，可以这样声明构造函数： explicit Stonewt(double lbs); 这将关闭上述示例中介绍的隐式转换，但仍然允许显式转换，即显式强制转换： Stonewt myCat; myCat = 19.6; //错误语法 myCat = (Stonewt)19.6; myCat = Stonewt(19.6); 注意：只接受一个参数的构造函数时定义了从参数类型到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它智能用于显式转换，否则也可以用于隐式转换。 编译器在什么时候将使用Stonewt(doule)函数呢？如果在声明中使用了关键字explicict，则Stonewt(doule)将只用于显式强制类型转换，否则还可以用于下面的隐式转换： 将Stonewt对象初始化为double值时。 将double值赋给Stonewt对象时。 将double值传递给接受Stonewt参数的函数时。 返回值被声明为Stonewt的函数试图返回double值时。 在上述任意一种情况下，使用可转换double类型的内置类型时。 下面详细介绍最后一点。函数原型化提供的参数匹配过程，允许使用Stonewt(doule)构造函数来转换其他数字类型。即，下面两条语句都首先将int转换为double，然后使用Stonewt(double)构造函数。 Stonewt Jumbo(7000); Jumbo = 73000; 然而，当且仅当转换不存在二义性时，才会进行这种二步转换。即，如果这个类还定义了构造函数Stonewt(long)，则编译器将拒绝这些语句，可能指出：int可被转换为long或double，因此调用存在二义性。 程序11.18使用类的构造函数初始化一些Stonewt对象，并处理类型转换。 程序11.18 stone.cpp #include &lt;iostream&gt; #include &quot;stonewt.h&quot; using std::cout; void display(const Stonewt &amp; st, int n); int main() { Stonewt incognito = 275; Stonewt wolfe(287.5); Stonewt taft(21, 8); cout &lt;&lt; &quot;The celebrity weighed &quot;; incognito.show_stn(); cout &lt;&lt; &quot;The detective weighed &quot;; wolfe.show_stn(); cout &lt;&lt; &quot;The President weighed &quot;; taft.show_lbs(); incognito = 276.8; taft = 325; cout &lt;&lt; &quot;After dinner, the celebrity weighed &quot;; incognito.show_stn(); cout &lt;&lt; &quot;After dinner , the President weighed &quot;; taft.show_lbs(); display(taft, 2); cout &lt;&lt; &quot;The wrestler weighed even more.\n&quot;; display(422, 2); cout &lt;&lt; &quot;No stone left unearned\n&quot;; return 0; } void display(const Stonewt &amp; st, int n) { for (int i = 0; i &lt; n; i++) { cout &lt;&lt; &quot;Wow! &quot;; st.show_stn(); } } 输出： The celebrity weighed 19 stone, 9 pounds The detective weighed 20 stone, 7 pounds The President weighed 302 pounds After dinner, the celebrity weighed 19 stone, 10 pounds After dinner , the President weighed 325 pounds Wow! 23 stone, 3 pounds Wow! 23 stone, 3 pounds The wrestler weighed even more. Wow! 30 stone, 2 pounds Wow! 30 stone, 2 pounds No stone left unearned 程序说明 当构造函数只接受一个参数是，可以使用下面的格式来初始类对象： Stonewt incognito = 275; 这等价于前面介绍过的另外两种格式： Stonewt incognito(275); Stonewe incognito = Stonewt(275); 然而，后面两种格式可用于接受多个参数的构造函数。 接下来，注意下面两条赋值语句： incognito = 276.8; taft = 325; 第一条赋值语句使用接受double参数的构造函数，将276.8转换为一个Stonewt值，这将把incognito的pounds成员设置为276.8。因为该条语句使用了构造函数，所以还将设置stone和pds_left成员。同样，第二条赋值语句将一个int值转换为double类型，然后使用Stonewt(double)来设置全部3个成员。 最后，注意下面的函数调用： display(422, 2); display()的原型表明，第一个参数应是Stonewt对象(Stonewt和Stonewt&amp;形参都与Stonewt实参匹配)。遇到int参数时，编译器查找构造函数Stonewt(int)，以便将该int转换为Stonewt类型。由于没有找到这样的构造函数，因此编译器寻找接受其他内置类型的构造函数。Stonewt(double)构造函数满足这种要求，因此编译器将int转换为double，然后使用Stonewt(double)将其转换为一个Stonewt对象。 11.6.1 转换函数程序是将数字转换为Stonewt对象。可以做相反的转换吗？即，是否可以将Stonewt对象转换为double值。如下： Stonewt wolfe(285.7); double host = wolfe; 可以这样做，但不是使用构造函数。构造函数只用于从某种类型到类类型的转换。要进行相反的转换，必须使用特殊的C++运算符函数—转换函数。 转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它。例如，如果定义了从Stonewt到double的转换函数，就可以使用如下的转换： Stonewt wolfe(285.7); double host = double (wolfe); double thinker = (double) wolfe; 也可以让编译器来决定如何做： Stonewt wells(20, 3); double star = wells; 编译器发现，右侧是Stonewt类型，而左侧是double类型，因此它将查看程序员是否定义了于此匹配的转换函数。 创建转换函数，要转换为typeName类型，需要使用如下形式的转换函数： operator typeName(); 注意以下几点： 转换函数必须是类方法； 转换函数不能指定返回类型； 转换函数不能有参数； 例如，转换为double类型的函数的原型如下： operator double(); 要添加将Stonewt转换为int类型和double类型的函数，需要将下面的原型添加到类声明中： operator int(); operator double(); 程序11.19列出了修改后的类声明： 程序11.19 stonewt1.h #ifndef STONEWT1_H_ #define STONEWT1_H_ class Stonewt { private: enum {Lbs_per_stn = 14}; int stone; double pds_left; double pounds; public: Stonewt(double lbs); Stonewt(int stn, double lbs); Stonewt(); ~Stonewt(); void show_lbs() const; void show_stn() const; operator int(); operator double(); }; #endif 程序11.20对两个转换函数进行了定义。注意，虽然没有声明返回类型，这两个函数也就返回所需的值。另外，int转换将带转换的值进行四舍五入为最接近的整数，而不是去掉小鼠部分。例如，如果pounds为114.4，则pounds+0.5等于114.9，int(114.9)等于114。但是，如果pounds为114.6，则pounds+0.5是115.1，而int(115.1)为115。 程序11.20 stonewt1.cpp #include &lt;iostream&gt; #include &quot;stonewt1.h&quot; using std::cout; Stonewt::Stonewt(double lbs) { stone = int (lbs) / Lbs_per_stn; pds_left = int (lbs) % Lbs_per_stn; pounds = lbs; } Stonewt::Stonewt(int stn, double lbs) { stone = stn; pds_left = lbs; pounds = stn * Lbs_per_stn + lbs; } Stonewt::Stonewt() { stone = pounds = pds_left = 0; } Stonewt::~Stonewt() {} void Stonewt::show_stn() const { cout &lt;&lt; stone &lt;&lt; &quot; stone, &quot; &lt;&lt; pds_left &lt;&lt; &quot; pounds\n&quot;; } void Stonewt::show_lbs() const { cout &lt;&lt; pounds &lt;&lt; &quot; pounds\n&quot;; } Stonewt::operator int() { return int (pounds + 0.5); } Stonewt::operator double() { return pounds; } 程序11.21对新的转换函数进行测试。 程序11.21 stone1.cpp #include &lt;iostream&gt; #include &quot;stonewt1.h&quot; int main() { using std::cout; Stonewt poppins(9, 2.8); double p_wt = poppins; cout &lt;&lt; &quot;Convert to double = &quot;; cout &lt;&lt; &quot;Poppins: &quot; &lt;&lt; p_wt &lt;&lt; &quot; pounds.\n&quot;; cout &lt;&lt; &quot;Convert to int = &quot;; cout &lt;&lt; &quot;Poppins: &quot; &lt;&lt; int(poppins) &lt;&lt; &quot; pounds.\n&quot;; return 0; } 输出： Convert to double = Poppins: 128.8 pounds. Convert to int = Poppins: 129 pounds. 自动应用类型转换 程序11.21中将int(poppins)和cout一起使用。假设省略了显式强制类型转换： cout &lt;&lt; &quot;Poppins: &quot; &lt;&lt; poppins &lt;&lt; &quot; pounds.\n&quot;; 程序将无法进行隐式转换。因为没有指出应转换为int类型还是doubl类型。在缺少信息时，编译器将指出，程序中使用了二义性转换。 如果类只定义了double转换函数，则编译器将接受该语句。这是因为只有一种转换可能，因此不存在二义性。 负责的情况与此类似。对于当前的类深埋来说，编译器将认为下面的语句有二义性而拒绝它： long gone = poppins; //存在二义性 在C++中，int和double值都可以给赋值给long变量，所以编译器使用任意一个转换函数都是合法的。然而，如果删除了这两个转换函数之一，编译器将接受这条语句。 当类定义了两种或多种的转换是，仍可以使用显式强制类型转换来指出使用哪个转换函数。可以使用下面任何一种强制类型转换表示法： long gone = (double) poppins; long gone = int (poppins); 和转换构造函数一样，转换函数也有其优缺点。提供自动、隐式转换的函数所存在的问题是：在用户不希望进行转换时，转换函数也可能进行转换。如下： int ar[20]; Stonewt temp(14, 4); int Temp = 1; cout &lt;&lt; ar[temp] &lt;&lt; endl; 原则上，最后使用显式转换，而避免隐式转换。在C++11中，可以使用explicit来关闭隐式转换： class stonewt { ... explicit operator int() const; explicit operator double() const; }; 有了上述声明，需要强制转换时将调用这些运算符。 另一种方法是，用一个功能相同的非转换函数替换该转换函数即可，但仅在被显式地调用时，该函数才会执行。即： Stonewt::operator int(0 {return int (pounds + 0.5);} 可以替换为： int Stonewt::Stone_to_int() {return int (pounds + 0.5);} 这样，下面的语句是非法的： int plb = poppins; 但如果确实需要这种转换，可以这样做： int plb = poppins.Stone_to_int(); 总之，C++为类提供了下面的类型转换： 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。 被成为转换函数的特殊成员运算符函数，用于将类对象转换为其他类型。 注意：explicit关键字可以关闭以上两种隐私类型转换，但仍可以进行显式强制类型转换。 11.6.2 转换函数和友元函数在讨论Time类时指出过，可以使用成员函数或友元函数来重载加法。处于简化的目的，假设没有定义operator double()转换函数，可以使用下面的成员函数实现加法： Stonewt Stonewt::operator+(const Stonewt &amp; st) const { double pds = pounds + st.pounds; Stonewt sum(pds); return sum; } 也可以将加法作为友元函数来实现，如下： Stonewt operator+(const stonewt &amp; st1, const stonewt &amp; st2) { double pds = st1.pounds + st2.pounds; Stonewt sum(pds); return sum; } 注意，可以提供友元函数定义或成员函数定义，但不能都提供。上面任何一种格式都允许如下操作： Stonewt jennySt(9, 12); Stonewt bennySt(12, 8); Stonewt total = jennySt + bennySt; 另外，如果提供了Stonewt(double)构造函数，则可以这样做： Stonewt jennySt(9, 12); double kennyD = 176.0; Stonewt total = jennySt + kennyD; 但只有友元函数才允许如下这样做： Stonewt jenneySt(9, 12); double pennyD = 146.0; Stonewt total = pennyD + jennySt; 这样因为： Stonewt total = pennyD + jennySt; 只能被转换为： total = operator+(pennyD, jennySt); 第一个参数pennyD为double类型，因此调用构造函数Stonewt(double)，将它转换为Stonewt对象。 然而不能调用成员函数将jennySt和peenyD相加。将加法语法转换为函数将类似于下面这样： total = pennyD.operator+(jennySt); 这没有意义，因为只有类对象才可以调用成员函数。C++不会试图将pennyD转换为Stonewt对象。 将对成员函数参数进行转换，而不是调用成员函数的对象。 经验告诉我们，将加法定义为友元可以让程序更容易适应自动类型转换。原因在于，两个操作数都成为函数参数，因此与函数原型匹配。 实现加法时的选择 要将double量和Stonewt量相加，有两种选择。第一种方法是将下面的的函数定义为友元函数，让Stonewt(double)构造函数将double类型的参数转换为Stonewt类型的参数： operator+(const Stonewt &amp;, const Stonewt &amp;); 第二种方法是，将加法运算符重载为一个显式使用doulbe类型参数的函数： Stonewt operator+(double x); friend Stonewt operator+(double x, Stonewt &amp; s); 这样，下面的语句将与成员函数operator+(doulbe)完全匹配： total = jennySt + kennyD; 而下面的语句将于友元函数operator+(double, Stonewt &amp;)完全匹配： total = kennyD + jennySt; 每次中方法都有其优点。第一种方法使程序更简洁，因为定义的函数较少。缺点是，每次需要转换时，都将调用转换构造函数，这增加时间和内存开销。第二种方法刚好相反，使得程序较长，但运行速度快。 11.7 总结访问私有成员： 友元函数： friend 成员函数 运算符重载： operator+() 类型转换： 自动类型转换 强制类型转换 关闭隐私类型转换：explicit 转换构造函数: 只有一个参数的构造函数，或者有默认值参数的构造函数转换函数： operator int()]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习过程遇到的问题]]></title>
    <url>%2F2019%2F01%2F21%2FDjango%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2019第一篇博客，最近一个月忙于考试，博客没有更新，最近想继续Android开发，先用Django把后台搭好，考试结束就继续学习django。 学习Django过程使用的教程：Django中文网 极力推荐，学习过程中遇到的问题，博主给予了很大的帮助。 无法加载静态文件python3 manage.py collectstatic 运行上述命令，就会自动把所有静态文件全部复制到STATIC_ROOT中。如果开启了admin，这一步是很必要的，不然部署到生产环境的时候会找不到样式文件 数据库迁移是出现的问题运行python3 manage.py migrate时出现 django.db.utils.OperationalError: (1091, &quot;Can&apos;t DROP &apos;user_id&apos;; check that column/key exists&quot;) django.db.utils.OperationalError: (1060, &quot;Duplicate column name &apos;category_id&apos;&quot;) 运行： python3 manage.py migrate blog(项目名称) --fake 常用命令关闭uwsgi： killall -9 uwsgi 开启uwsgi： uwsgi -x mysite.xml 重启nginx: cd /usr/local/nginx/sbin ./nginx -s reload]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7备份和还原]]></title>
    <url>%2F2018%2F12%2F22%2FCentos7%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[Centos7备份系统和还原系统。 如果你备份过Windows系统，那么你一定记忆犹新：首先需要找到一个备份工具(通常都是私有软件)，然后重启电脑进入备份工具提供的软件环境，在这里备份或者恢复Windows系统。Norton Ghost是备份Windows系统时经常使用的备份工具。 备份系统首先成为root用户： sudo su 然后进入文件系统的根目录(当然，如果你不想备份整个文件系统，你也可以进入你想要备份的目录，包括远程目录或者移动硬盘上的目录)： cd / 下面是我用来备份系统的完整命令： tar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=backup.tgz / “tar”当然就是我们备份系统所使用的程序了。 cvpfz”是tar的选项，意思是“创建档案文件”、“保持权限”(保留所有东西原来的权限)、“使用gzip来减小文件尺寸”。 “backup.gz”是我们将要得到的档案文件的文件名。 “/”是我们要备份的目录，在这里是整个文件系统。 在档案文件名“backup.gz”和要备份的目录名“/”之间给出了备份时必须排除在外的目录。有些目录是无用的，例如“/proc”、“/lost+ found”、“/sys”。 备份完成后，在文件系统的根目录将生成一个名为“backup.tgz”的文件，它的尺寸有可能非常大。现在你可以把它烧录到DVD上或者放到你认为安全的地方去。 你还可以用Bzip2来压缩文件，Bzip2比gzip的压缩率高，但是速度慢一些。如果压缩率对你来说很重要，那么你应该使用Bzip2，用“j”代替命令中的“z”，并且给档案文件一个正确的扩展名“bz2”。完整的命令如下： tar cvpjf backup.tar.bz2 –-exclude=/proc –exclude=/lost+found -–exclude=/backup.tar.bz2 –-exclude=/mnt –exclude=/sys / 恢复系统在进行恢复系统的操作时一定要小心！如果你不清楚自己在做什么，那么你有可能把重要的数据弄丢，请务必小心！ 切换到root用户，并把文件“backup.tgz”拷贝到分区的根目录下。 在 Linux中有一件很美妙的事情，就是你可以在一个运行的系统中恢复系统，而不需要用boot-cd来专门引导。当然，如果你的系统已经挂掉不能启动了， 你可以用Live CD来启动，效果是一样的。 使用下面的命令来恢复系统： tar xvpfz backup.tgz -C / 如果你的档案文件是使用Bzip2压缩的，应该用： tar xvpfj backup.tar.bz2 -C / 注意：上面的命令会用档案文件中的文件覆盖分区上的所有文件。 执行恢复命令之前请再确认一下你所键入的命令是不是你想要的，执行恢复命令可能需要一段不短的时间。 恢复命令结束时，你的工作还没完成，别忘了重新创建那些在备份时被排除在外的目录： mkdir proc mkdir lost+found mkdir mnt mkdir sys]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7上Django+Mysql+Appach环境搭建]]></title>
    <url>%2F2018%2F12%2F21%2FCentos7%E4%B8%8ADjango%2BMysql%2BAppach%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[网上的教程都比较乱，结合Django官方文档搭建后台，在这里总结一下以备后用！ 环境 Python 3.5 Appache 2.4.6 Django 2.14 Django官方文档说明 Python问题由于Centos7自带的python为2.7，在这里我们同时安装python3.5。 Python下载地址： python镜像地址（更全）：https://www.python.org/ftp/python/ python下载并安装：[root@ansible soft]#yum install gcc gcc-c++ -y [root@ansible soft]# wget https://www.python.org/ftp/python/3.5.6/Python-3.5.6.tar.xz [root@ansible soft]# tar xvf Python-3.5.6.tar.xz [root@ansible soft]# cd Python-3.5.6/ [root@ansible Python-3.6.1]# ./configure [root@ansible Python-3.6.1]# make &amp;&amp; make install 验证#python -V #一个是旧版本，一个是新版本 Python 2.7.5 # python3 -V Python 3.6.1 设置3.X为默认版本查看 Python 的路径，在 /usr/bin 下面。可以看到 python 链接的是 python 2.7，所以，执行 python 就相当于执行 python 2.7。 [root@ansible ~]# ls -al /usr/bin | grep python -rwxr-xr-x. 1 root root 11232 Dec 2 2016 abrt-action-analyze-python lrwxrwxrwx. 1 root root 7 May 26 2017 python -&gt; python2 lrwxrwxrwx. 1 root root 9 May 26 2017 python2 -&gt; python2.7 -rwxr-xr-x. 1 root root 7136 Nov 6 2016 python2.7 将原来 python 的软链接重命名： # mv /usr/bin/python /usr/bin/python.bak 将 python 链接至 python3： # ln -s /usr/local/bin/python3 /usr/bin/python 配置yum升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件，此时： [root@ansible-admin Python-3.6.1]# yum list File &quot;/usr/bin/yum&quot;, line 30 except KeyboardInterrupt, e: SyntaxError: invalid syntax 修改/usr/bin/yum和/usr/libexec/urlgrabber-ext-down，将 #!/usr/bin/python 改为 #!/usr/bin/python2.7，保存退出即可。 注意：后面利用python3 manage.py Django安装官方文档将其分为三步： https://docs.djangoproject.com/en/2.1/topics/install/#installing-official-release pip安装来自官方文档：get-pip.py 首先下载get-pip.py: curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 然后运行： python3 get-pip.py Virtualenv安装pip install virtualenv Django安装默认安装的是2.1.4版本： pip install Django Mysql数据库安装Mysql密码重置问题参考：博客 重置密码解决MySQL for Linux错误 ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 1. 重置密码的第一步就是跳过MySQL的密码认证过程，方法如下：修改mysql配置文件： #vim /etc/my.cnf 在[mysqld]后面任意一行添加“skip-grant-tables”用来跳过密码验证的过程，如下图所示： 2. 重启Mysqlsystemctl restart mysqld 3. 重启之后输入#mysql即可进入mysql进入mysql设置密码: mysql&gt; use mysql; mysql&gt; update user set password=password(&quot;你的新密码&quot;) where user=&quot;root&quot;; mysql&gt; flush privileges; mysql&gt; quit 4. 编辑my.cnf,去掉刚才添加的内容，然后重启MySQL。大功告成！Mysql关联Django设置在setting.py设置文件中DATABASE参数修改为如下内容： DATABASES = { &apos;default&apos;: { &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mysite&apos;, &apos;HOST&apos;: &apos;localhost&apos;, &apos;PASSWORD&apos;: &apos;密码天这里&apos;, &apos;read_default_file&apos;: &apos;/path/to/my.cnf&apos;, &apos;init_command&apos;: &apos;SET default_storage_engine=INNODB&apos;, } } 注意：必须提前进入mysql，创建一个数据库名字为mysite 各个参数的意思参考官方文档 Appache安装]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7上Django+Mysql+Nginx+nwsgi环境搭建]]></title>
    <url>%2F2018%2F12%2F21%2FCentos7%E4%B8%8ADjango%2BMysql%2BNginx%2Bnwsgi%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前面用Appache+mod_wsgi搭建时，遇到问题没有解决，所以转移到Nginx+nwsgi。这里主要介绍如何配置nginx。 一、更新系统软件包yum update -y 二、安装软件管理包和可能使用的依赖yum -y groupinstall &quot;Development tools&quot; yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 三、下载Pyhton3到/usr/local 目录cd /usr/local wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz 解压 tar -zxvf Python-3.6.6.tgz 进入 Python-3.6.6路径 cd Python-3.6.6 编译安装到指定路径 ./configure --prefix=/usr/local/python3 注意：/usr/local/python3 路径可以自己指定，自己记着就行，下边要用到。 安装python3 make make install 安装完成之后 建立软链接 添加变量 方便在终端中直接使用python3 ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3 Python3安装完成之后pip3也一块安装完成，不需要再单独安装同样给pip3建立软链接 ln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip3 四、查看Python3和pip3安装情况 五、安装virtualenv ，建议大家都安装一个virtualenv，方便不同版本项目管理。pip3 install virtualenv 建立软链接 ln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv 安装成功在根目录下建立两个文件夹，主要用于存放env和网站文件的。(个人习惯，其它人可根据自己的实际情况处理) mkdir -p /data/env mkdir -p /data/wwwroot 六、切换到/data/env/下，创建指定版本的虚拟环境。virtualenv --python=/usr/bin/python pyweb 然后进入/data/env/pyweb/bin 启动虚拟环境： source activate 留意我标记的位置，出现(pyweb)，说明是成功进入虚拟环境。 七、虚拟环境里用python3安django和uwsgipip3 install django （如果用于生产的话，则需要指定安装和你项目相同的版本） pip3 install uwsgi 给uwsgi建立软链接，方便使用 ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi 八、切换到网站目录/data/wwwroot,创建Django项目django-admin.py startproject mysite 创建成功之后，/data/wwwroot下面就会多出一个mysite文件夹，我们的项目就在这个文件夹里。 然后新建立一个名叫blog的APP python3 manage.py startapp blog 进入项目文件夹/data/wwwroot/mysite,添加static和templates，分别用于存放静态文件和模板文件。编辑项目里mysite/settings.py文件 vim /data/wwwroot/mysite/mysite/settings.py 在INSTALLED_APPS 列表里添加’blog’，注意，后面要加上一个逗号’,’. 修改ALLOWED_HOSTS，[‘*’]，可以让任何IP访问: TEMPLATES的DIRS里添加模板路径 os.path.join(BASE_DIR, &apos;templates&apos;) 尾部添加 STATICFILES_DIRS = ( os.path.join(BASE_DIR,’static’), ) 九、在templates下添加index.html文件，输入下面内容。vim /data/wwwroot/mystie/templates/index.html 输入内容： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;我的网站&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎光临我的网站！&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 十、配置URL在mysite/mysite/目录下的urls.py文件添加内容，修改后如下： from django.contrib import admin from django.urls import path, include urlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;blog/&apos;, include(&apos;blog.urls&apos;)), ] 在blog文件夹中创建urls.py，输入如下内容： from django.contrib import admin from django.urls import path, include from . import views urlpatterns = [ path(&apos;&apos;, views.index), ] 十一、编辑blog APP下的views.py在blog下的views.py中添加如下内容： def index(request): return render(request, &apos;index.html&apos;) 十二、启动项目python3 manage.py runserver 0:8000 在浏览器内输入： 主机IP:8000 比如：111.230.111.82:8000 正常运行 十三、Django正常运行之后我们就开始配置一下uwsgi我们网站项目路径是 /data/wwwroot/mysite/,在项目根目录下创建mysite.xml文件，输入如下内容： &lt;uwsgi&gt; &lt;socket&gt;127.0.0.1:8997&lt;/socket&gt; &lt;!-- 内部端口，自定义 --&gt; &lt;chdir&gt;/data/wwwroot/mysite/&lt;/chdir&gt; &lt;!-- 项目路径 --&gt; &lt;module&gt;mysite.wsgi&lt;/module&gt; &lt;!-- mysite为wsgi.py所在目录名--&gt; &lt;processes&gt;4&lt;/processes&gt; &lt;!-- 进程数 --&gt; &lt;daemonize&gt;uwsgi.log&lt;/daemonize&gt; &lt;!-- 日志文件 --&gt; &lt;/uwsgi&gt; 十四、安装nginx和配置nginx.conf文件进入home目录，执行下面命令 cd /home/ wget http://nginx.org/download/nginx-1.13.7.tar.gz 下载完成后，执行解压命令： tar -zxvf nginx-1.13.7.tar.gz 进入解压后的nginx-1.13.7文件夹，依次执行以下命令： ./configure make make install nginx一般默认安装好的路径为/usr/local/nginx 在/usr/local/nginx/conf/中先备份一下nginx.conf文件，以防意外。 cp nginx.conf nginx.conf.bak 然后打开nginx.conf，把原来的内容删除，直接加入以下内容： events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; server { listen 80; server_name 127.0.0.1:80; #改为自己的域名，没域名修改为127.0.0.1:80 charset utf-8; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8997; #端口要和uwsgi里配置的一样 uwsgi_param UWSGI_SCRIPT mysite.wsgi; #wsgi.py所在的目录名+.wsgi uwsgi_param UWSGI_CHDIR /data/wwwroot/mysite; #项目路径 } location /static/ { alias /data/wwwroot/mysite/static/; #静态资源路径 } } } 要留意备注的地方，要和UWSGI配置文件mysite.xml，还有项目路径对应上。 进入/usr/local/nginx/sbin/目录执行./nginx -t命令先检查配置文件是否有错，没有错就执行以下命令： ./nginx 终端没有任何提示就证明nginx启动成功。可以使用你的服务器地址查看，成功之后就会看到一个nginx欢迎页面。 之后，在settings.py里设置： 1、关闭DEBUG模式。 DEBUG = False 2、ALLOWED_HOSTS设置为* 表示任何IP都可以访问网站。 ALLOWED_HOSTS = [&apos;*&apos;] 十五、访问项目的页面进入网站项目目录 cd /data/wwwroot/mysite/ 执行下面命令： uwsgi -x mysite.xml 以上步骤都没有出错的话。进入/usr/local/nginx/sbin/目录执行： cd /usr/local/nginx/sbin/ ./nginx -s reload 重启nginx 。 然后在浏览器里访问你的项目地址！ 111.230.111.81/blog/ Mysql数据库安装和配置https://www.django.cn/article/show-2.html 安装好数据库后还需要安装mysqlclient： sudo yum install python3-devel pip3 install mysqlclient 安装好Mysql后，进入创建数据库mysite 在setting.py设置文件中DATABASE参数修改为如下内容： DATABASES = { &apos;default&apos;: { &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mysite&apos;, &apos;HOST&apos;: &apos;localhost&apos;, &apos;PASSWORD&apos;: &apos;密码填这里&apos;, &apos;read_default_file&apos;: &apos;/path/to/my.cnf&apos;, &apos;init_command&apos;: &apos;SET default_storage_engine=INNODB&apos;, } } 注意：必须提前进入mysql，创建一个数据库名字为mysite 转自：www.django.cn]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android绘图系列之三(Paint常用函数介绍)]]></title>
    <url>%2F2018%2F12%2F15%2Fandroid%E7%BB%98%E5%9B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89(Paint%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D)%2F</url>
    <content type="text"><![CDATA[前面介绍了基本的paint和canvas的基本用法，这里汇总paint常用函数。 基本用法paint基本设置的函数： reset() ：重置画笔 setColor(int color) ：给画笔设置颜色值 setARGB(int a, int r, int g, int b) ：同样是设置颜色，但是利用ARGB分开设置 setAlpha(int a) ：设置画笔透明度 setStyle(Paint.Style style) ：设置画笔样式，取值有 Paint.Style.FILL ：填充内部 Paint.Style.FILL_AND_STROKE ：填充内部和描边、Paint.Style.STROKE ：仅描边 setStrokeWidth(float width) ：设置画笔宽度 setAntiAlias(boolean aa) ：设置画笔是否抗锯齿 字体相关 setTextSize(float textSize) ：设置文字大小 setFakeBoldText(boolean fakeBoldText) ：设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) ：设置带有删除线效果 setUnderlineText(boolean underlineText) ：设置下划线 setTextAlign(Paint.Align align) ：设置开始绘图点位置 setTextScaleX(float scaleX) ：水平拉伸设置 setTextSkewX(float skewX) ：设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface(Typeface typeface) ：字体样式]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android绘图系列之二(Canvas绘制文本drawText)]]></title>
    <url>%2F2018%2F12%2F13%2Fandroid%E7%BB%98%E5%9B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C(Canvas%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%ACdrawText)%2F</url>
    <content type="text"><![CDATA[系列之一介绍了绘制基本图形，比如矩形、直线、圆等。Canvas除了这些操作，还有两个重量级的绘制能力:Text(文本)和Path(路径),这里介绍Text的绘制。 Paint对于Text的相关设置普通设置： paint.setStrokeWidth(5)：设置画笔宽度 paint.setAntiAlias(true)：设置是否使用抗锯齿功能，如果使用，会导致绘图速度变慢 paint.setStyle(Paint.Style.FILL)：设置绘图样式，对于设置文字和几何图形都有效，可取值有三种 ：1、Paint.Style.FILL：填充内部 2、Paint.Style.FILL_AND_STROKE：填充内部和描边 3、Paint.Style.STROKE：仅描边 paint.setTextAlign(Align.CENTER)：设置文字对齐方式 paint.setTextSize(12)：设置文字大小 样式设置： paint.setFakeBoldText(true)：设置是否为粗体文字 paint.setUnderlineText(true)：设置下划线 paint.setTextSkewX((float) -0.25)：设置字体水平倾斜度，普通斜体字是 -0.25 paint.setStrikeThruText(true)：设置带有删除线效果 其他设置： paint.setTextScaleX(2)：设置水平拉伸，高度不会变 Canvas绘制文字普通水平绘制：void drawText (String text, float x, float y, Paint paint) void drawText (CharSequence text, int start, int end, float x, float y, Paint paint) void drawText (String text, int start, int end, float x, float y, Paint paint) void drawText (char[] text, int index, int count, float x, float y, Paint paint) 说明： 第一个构造函数时最简单的构造函数 第三、四个构造函数：实现截取一部分字体绘图 第二个构造函数最强大，因为传入的可以是 CharSequence 类型字体，所以可以实现绘制带图片的扩展文字，而且还能截取一部分绘制 onDraw方法： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setTextSize(50); canvas.drawText(“巴扎嘿”,100,100,paint); } 指定各个文字位置void drawPosText (char[] text, int index, int count, float[] pos, Paint paint) void drawPosText (String text, float[] pos, Paint paint) 参数： char[] text：要绘制的文字数组 int index：第一个要绘制的文字的索引 int count：要绘制的文字的个数，用来算最后一个文字的位置，从第一个绘制的文字开始算起 float[] pos：每个字体的位置，两个为一组 onDraw方法： paint.setTextSize(50); canvas.drawPosText(&quot;巴扎黑&quot;, new float[]{100, 100, 100, 200, 100, 300}, paint); 沿路径绘制void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint) void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint) 参数： Path path：文字的绘制路径 char[] text：要绘制的文字数组 int index：第一个要绘制的文字的索引 int count：要绘制的文字的个数，用来算最后一个文字的位置，从第一个绘制的文字开始算起 float hOffset：与路径起始点的水平偏移距离 float vOffset：与路径中心点的垂直偏移量 //声明全局变量 Path path; private void init() { //初始化画笔 paint = new Paint(); //设置抗锯齿 paint.setAntiAlias(true); //设置画笔宽度 paint.setStrokeWidth(5); //设置画笔颜色 paint.setColor(Color.RED); //设置画笔样式 paint.setStyle(Paint.Style.STROKE); //设置路径，以圆作为我们文本显示的路线 path = new Path(); path.addCircle(300,300,200,Path.Direction.CW);//路径的绘制方式，CW;表示正序绘制，CCW表示倒数绘制 } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setTextSize(50); //绘制路径 canvas.drawPath(path, paint); //把文字绘制在要显示的路径上，路径起始点偏移150，圆心偏移50 canvas.drawTextOnPath(&quot;搞笑我们是认真的！！！&quot;, path, 300, 50, paint); } drawText绘制技巧我们都知道绘制文本只需要调用 Canvas 的 drawText 方法就可以在任何位置绘制我们想要的文字，但是你知道你知道 drawText 方法绘制文本时是依据什么条件进行绘制的么？ 我们来看一个例子吧： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawLine(50,100,600,100,paint); paint.setTextSize(80); canvas.drawText(&quot;abcefghijlk&quot;,100,100,paint); } 结果： 发现一个很有意思的事情，就是我们明明给我们要绘制的文本设置的位置是 （50，100），而我们绘制的线的位置 Y 坐标是在 100 的位置上，为什么我们绘制的文本的第一个字母 “g” 会出现在标准线的下方呢？ 四线格与基线还记得我们小时候写拼音使用的四线格本子么？带你们回忆回忆童年，那时候我们都知道要写在四线格内： 那么问题来了，其实 Canvas 在调用 drawText 方法绘制文本时，也是有规则的，这个规则就是基线： 也就是说 Canvas 在调用 drawText 绘制文本时，是根据基线的位置来确定要绘制的 Text 的位置的，要想把 Text 绘制到正确的位置上，必须知道基线的位置。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android绘图系列之一(Canvas基本操作)]]></title>
    <url>%2F2018%2F12%2F12%2Fandroid%E7%BB%98%E5%9B%BE%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80(Canvas%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)%2F</url>
    <content type="text"><![CDATA[Canvas的基本操作以及开始绘制简单图形。 Canvas和PaintCanvas 和 Paint 之间的关系就像我们平时画画需要的画笔和画纸一样，我们画画无外乎也就需要这两个工具，而这两个工具体现在 Android 中，就是我们的 Paint（画笔）和 Canvas（画纸，通常称为画布），所以凡是跟要画的东西设置相关的，比如颜色、大小、宽度、样式、透明度等都是在 Paint 中设置的。而凡是跟要画的成品，比如想画一个矩形、圆形、文字、路径等都是通过 Canvas 操作的。 基础代码新建一个类，派生自View类，重写View的onDraw方法，在onDraw方法中通过Canvas来实现想要的效果： public class CustomView extends View { private Paint paint; public CustomView(Context context) { super(context); init(); } //要实现的构造函数 public CustomView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); init(); } //要实现的构造函数 public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } //要实现的构造函数 @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); init(); } private void init() { //初始化画笔 paint = new Paint(); //设置抗锯齿 paint.setAntiAlias(true); //设置画笔宽度 paint.setStrokeWidth(5); //设置画笔颜色 paint.setColor(Color.RED); //设置画笔样式 paint.setStyle(Paint.Style.STROKE); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); //绘制一个圆心为(300,300),半径为300的圆 canvas.drawCircle(300,300, 300, paint); } } 一定要对所有类型的构造函数都要实现，并在每个构造函数中不要忘记了初始化。 在布局文件中使用我们定义View： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.example.dztx.myapplication.CustomView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/LinearLayout&gt; Canvas基本图形圆void drawCircle(float cx, float cy, float radius, Paint paint) 参数： cx：圆心点的 X 轴坐标 cy：圆心点的 Y 轴坐标 radius：圆的半径 paint：画笔 private void init() { //初始化画笔 paint = new Paint(); //设置抗锯齿 paint.setAntiAlias(true); //设置画笔宽度 paint.setStrokeWidth(5); //设置画笔颜色 paint.setColor(Color.RED); //设置画笔样式 paint.setStyle(Paint.Style.STROKE); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(300,300,100,paint); } 矩形void drawRect (float left, float top, float right, float bottom, Paint paint) void drawRect (RectF rect, Paint paint) void drawRect (Rect r, Paint paint) 参数： 第一种写法是直接传入矩阵的四个点的位置； 而第二种写法是根据传入的RectF以及Rect矩形变量来指定所画的矩形。 示例代码： canvas.drawRect(100, 100, 300, 300, paint); canvas.drawRect(new Rect(100, 100,500,500), paint); canvas.drawRect(new RectF(100, 100,500,500), paint); 角矩形void drawRoundRect (RectF rect, float rx, float ry, Paint paint) void drawRoundRect (float left, float top, float right, float bottom, float rx, float ry, Paint paint) 参数： rect:所需画的矩形 rx:生成圆角的椭圆的X轴半径 ry:生成圆角的椭圆的Y轴半径 onDraw中代码实现： canvas.drawRoundRect(100,100,300,300,50,50,paint); canvas.drawRoundRect(new RectF(100,400,300,600),50,50,paint); 椭圆void drawOval (RectF oval, Paint paint) 参数： RectF oval:用来生成椭圆的矩形 onDrawd代码： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawRect(100,400,700,700,paint); paint.setColor(Color.BLUE); canvas.drawOval(new RectF(100,400,700,700),paint); } 圆弧圆弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以圆弧当然也是根据矩形来生成的。 void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 参数： Rect oval: 生成圆弧的矩形 float startAngle: 圆弧开始的角度，以X轴正方向为0° float sweepAngle: 圆弧持续的角度 boolean useCenter: 是否显示弧的两边，true显示，false不显示，只有一条弧线 onDraw方法： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawRect(100,100,400,500,paint); paint.setColor(Color.BLUE); canvas.drawArc(new RectF(100,300,400,500),0,90,false,paint); } 直线void drawLine (float startX, float startY, float stopX, float stopY, Paint paint) 参数： float startX：开始点 X 坐标 float startY：开始点 Y 坐标 float stopX：结束点 X 坐标 float stopY：结束点 Y 坐标 onDraw方法： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawLine(100,100,500,900,paint); paint.setStrokeWidth(50); canvas.drawLine(200,100,600,900,paint); } 多条直线void drawLines (float[] pts, Paint paint) void drawLines (float[] pts, int offset, int count, Paint paint) 参数： float[] pts：pts 是点的集合，每两个点形成一条连接线，100, 100, 500, 900 这四个数字其实就是确定了要连接的两个点的位置 onDraw方法： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); float[] ps = {100,100,200,200,300,300,500,500}; canvas.drawLines(ps,paint); } 转载：AkaiC]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Malware Propagations in Wireless Ad Hoc Networks]]></title>
    <url>%2F2018%2F12%2F09%2FMalware%20Propagations%20in%20Wireless%20Ad%20Hoc%20Networks%2F</url>
    <content type="text"><![CDATA[无线Ad hoc网络中恶意软件传播研究。 摘要无线自组织网络（WANET）中的恶意软件传播建模代表了一个基础和开放的研究问题，它显示了由于复杂的接入竞争，严重的信道干扰和动态连接而带来的显着挑战。为了解决这个问题，我们在本文中分别研究了在扩展模式和通信模式下两种传播方案（包括单播和广播）下的恶意软件传播。根据之前的文献，我们以三个方面突出我们的贡献。首先，通过应用无线网络容量理论，提供每个方案的恶意软件感染率的界限。其次，研究了移动性对恶意软件传播的影响。第三，讨论了不同方案和实际应用之间的关系。数值模拟和详细的性能分析表明，对于WANET中的恶意软件传播速度而言，具有扩展模式的广播方案是最危险的，并且移动性将进一步大大增加风险。本文所取得的成果不仅可以提供有关WANET中恶意软件传播特性的见解，还可以作为设计防御方案的基本指导原则。 介绍随着网络的发展，恶意软件，包括蠕虫和病毒，已经成为了最大的安全威胁。例如，Code Red[1]感染了数十万台主机并造成了的损失超过数十亿美元。最近几年，许多新型恶意软件的目标移向了移动终端。他们能在设备之间通过无线网络通信传播，这给无线网络的应用带来了许多安全挑战。 互联网的恶意软件攻击长期以来一直是广泛研究的主题[2] [3]。大多数相关工作是基于流行病传播。在这个框架下，恶意软件传播模型是根据每个节点的状态转换构造，包括，易感/传染(SI)模型[4]，易感染-易感染(SIS)模型[5]和易感染恢复(SIR)模型[6]。 在基本的SI框架中，每个节点只有两种可能的状态：易感或传染。 基于简单而有效的模型，已经做了大量的工作[7]，[8]，[9]，[10]，[11]，用于研究基于扫描和基于拓扑的蠕虫的传播。这些工作还提供了一种全面的方法，可以研究恶意软件爆发的基本传播模式。 无线网络中没有集中控制，以及它的节点移动性，使得恶意攻击传播的风险更大，而这在有限网络中没有参照物。研究无线网络中的恶意软件传播模型非常有限。Nekovee调查了无线自组织网络（WANET）[12]和车载自组织网络（VANET）[13]中蠕虫流行病的爆发。 Mishra等人。 [14]和De等人[15]研究了蠕虫在无线传感器网络中的传播行为。 Yan等人[16]研究了蓝牙网络中的蠕虫传播。这些研究非常鼓舞人心，但总体而言，对无线网络中恶意软件传播的系统调查仍处于起步阶段。 此外，与其潜在的好处相反，上面列出的大多数现有文献未能提供有关无线网络中恶意软件传播的全面研究，该研究应回答以下两个开放性问题： 在无线覆盖和终端移动性的前提下，恶意软件传播功能将是什么？ 无线ad hoc网络中最危险的恶意软件传播方案是什么 我们之前的一篇会议论文[17]讨论了移动性对恶意软件传播的影响，但它仅基于统一扫描传播方案，不能完全揭示无线信道的功能。 在本文中，我们使用图1所示的WANET基础框架来研究恶意软件在无线环境下的传播。WANETs[18]，[19]是由无线设备彼此直接通信形成的分布式网络。 WANET技术在提供无处不在的无线互联网接入，物联网（IoT）和无线传感器网络（WSN）方面具有重要的应用。 因此，对WANET的研究可以揭示其他类型的无线网络。 通过结合传统的流行病模型和无线网络的传输理论，我们可以更全面地了解WANET中的传播特性。我们的主要贡献如下： 我们分别在两种不同的网络模式下研究了两种可能的恶意软件传播方案。 在考虑同步传输之间的干扰的同时分析这四种情况下的传播特征。 据我们所知，这是第一次系统的分析在一般WANET框架下恶意软件传播问题，并结合了流行病理论和无线网络容量理论。 我们评估移动性对恶意软件传播的影响，并将其与具有固定节点的WANET方案中的模型进行比较。 在模拟中使用实用的媒体访问控制和移动模型来验证我们的理论。 我们介绍了如何在实际应用中使用这些方案以及对策是什么。 本文的其余部分安排如下。 第2节列出了相关工作。 第3节详细介绍了系统模型，包括假设和基本符号。 第4节介绍了传播方案的数学分析，包括不同条件下恶意软件感染率的界限。 性能分析和广泛的数值模拟在第5节中给出。最后，第6节给出了关于本文的结论，并提出了我们未来的工作。 相关工作WANET中恶意软件传播的主题涉及两个研究领域：1）恶意软件传播的流行特征; 2）无线网络的信号传播特性。 以下部分总结了这两个领域的相关文献。 恶意软件传播的流行特征早期工作对恶意软件传播的研究是以有线网络为基础。根据流行病理论[4]构建模型，并且连续微分方程被广泛用于呈现基于扫描的蠕虫的传播。 后来的工作通过考虑更复杂的病例，例如移除感染节点[1]，免疫防御[20]或拓扑网络[7]，继续改进模型。 Kesidis等人[21]提出了随机扫描和带宽饱和互联网蠕虫传播的确定性数学模型。 除了无线网络中的带宽饱和与传输范围高度相关之外，带宽饱和特性与无线信道具有一些共同特征。 在2006年左右，无线网络的恶意软件传播的研究开始。蓝牙恶意软件传播在[16,22,23,24]中被研究，其中几个模型被提出。这些模型是基于蓝牙协议范围小的特征；短波无线电通信协议，用于创建移动设备的小范围个人区域网络。Hu等人[25]描述了病毒在城市地区的一组重叠无线LAN上的传播。由于他们实际上认为攻击来自路由器连接的互联网端，并且需要与Wi-Fi网络本身上的客户端进行交互，因此结果不能直接用于其他无线方案。Nekovee主要基于模拟研究了VANET [12]和WANET [13]中蠕虫流行病的爆发。 虽然鼓舞人心，但这些作品缺乏系统的理论分析。 在[14]和[15]中也研究了蠕虫在无线传感器网络中的传播行为，但无线信道干扰和接入竞争的影响并未被考虑。 无线网络的信号传播与容量理论另一方面，无线信号传播和网络容量理论也是无线恶意软件传播模型的重要基础。Gupta和Kumar[26]提出了一种固定网络容量分析模型，该模型已成为设计无线工作的指南，也是许多后期工作的基础。 Tavli[27]提出了任意ad hoc无线网络广播容量的上限，这是对端到端传输的前一种结果的有用补充。 Tse[28]等人研究了移动性和扩展了Gupta的结果对移动网络的影响。 在[29]中，Xue和Kumar找到了必要的邻居数，它确保了具有n个节点的网络渐近连接。 以上论文以及其他一些相关工作已经解决了无线网络中的基本信息理论问题。 我们的工作结合了上述两个研究领域，以研究广义的WANET框架中的恶意软件传播问题，该框架可以提供有关恶意软件传播属性的基本见解。 一方面，由于恶意软件也是网络中的数据有效负载，因此容量分析可以帮助我们找到WANET中恶意软件传播速度的限制和界限。 另一方面，考虑到恶意软件传播的流行特征，重新审视无线网络协议可以帮助揭示和弥补网络安全意义上的弱点。 系统模型在本节中，我们概述了WANET的随机网络模型，无线传输的协议模型以及流行病传播模型。 随机网络模型首先，我们在本文中考虑具有以下设定和符号的随机网络模型： WANET由n个节点组成，这些节点随机位于单位区域中。 每个节点选择相同的传输范围r或功率电平p。 $X_i$表示节点i的位置。 无线信道的总带宽为$W(Hz)$，可以将其分为M个子信道，并且每个节点可以在任意m个信道上以每秒$W_m$比特进行传送，其中$1 \leq m \leq M$, 并且$\sum_{m=1}^{M}=W$。 无线传送协议模型在WANET中，具有重叠范围的并发传输导致冲突和传输失败。 因此，我们需要在其预期目标成功接收传输时对条件进行建模。 [26]中定义了两种可能的模型。 协议模型使用节点之间的距离来判断传输是否成功，物理模型使用物理层索引信号干扰比（SIR）作为标准。 这两个模型略有不同，但在计算网络容量或传输速率范围时，它们会导致相同的结果顺序。 在本文中，采用了协议模型，但如果使用物理模型，则可以获得类似的结果。 在协议模型中，如果满足以下条件，则可以通过$X_j$成功接收来自节点$X_i$的传输： $X_i$和$X_j$之间的距离小于$r$: 对于任何其他节点$X_k$同时传输： 其中$\Delta &gt; 0$表示保护区，可以防止节点$X_k$在同时在同一信道上传送。 流行病传播模型经典简单流行病模型[4]是SI模型。 在该模型中，网络中的任何节点只有两种状态：易感（S）和传染（I）。 此外，一旦节点被恶意软件感染，节点将永远保持在传染状态。 在我们展示模型之前，我们首先列出一些重要的符号，这些符号将在本文的其余部分中使用。 $n$：WANET中节点数量 $\delta$:一个非常小的时间间隔 $I(t)$：在t时刻，被感染的节点数量 $n-I(t)$：在时刻t，易感染（未传染）节点数量 $beta$: 流行病学研究中的感染率，表示在单位时间内网络中所有节点中感染节点与易感节点的感染率。 $T_n$:网络感染的时间 使用以上的符号，在时间间隔$[t, t+\delta]$内，一个传染节点平均可以感染$[n-I(t)]\beta \delta$个易感染节点。当$\delta$足够小，在在时间间隔$[t, t+\delta]$内，两个传染节点感染同一易感染节点的概率可以忽略不计。因此，在$\delta$时间间隔内，最新被感染的节点数量等于$I(t)[n-I(t)]\beta \delta$，$t+\delta$时刻的传染节点数量为： 当$\delta \rightarrow 0$，有限总体的经典简单流行病模型可以用以下微分方程表示： $t=0$的开始时刻，$I(0)$节点时易感染的，其他所有$n-I(0)$节点是易感染的。然而 ，在给定t时刻，传染节点数量可以通过求解等式(4)得到[30]： 更为甚者，如果恶意软件攻击需要时间T来感染$I(t)$个节点，根据等式5，可以得到： 具体说，我们将$T_n$定义为网络感染时刻，即网络中的所有节点都具有高概率的传染性$I(T_n) \rightarrow n$。 经典简单流行病模型是最简单和流行的微分方程模型。 它将作为本文其余部分的基本传播模型。 无线AD HOC网络中的恶意软件传播模型在本节中，提供了WANET中恶意软件传播的理论模型，这些模型基于经典的SI流行病传播模型[4]。 主要工作将集中在通过考虑节点之间的争用和干扰来识别具有不同传播方案的感染率$\beta$。 首先，我们给出了两种不同恶意软件传播方案和两种网络模型。 恶意软件传播方案I-单播：恶意软件通过单播消息传播，这意味着它可以一次感染其中一个邻居。 恶意软件传播方案II-广播：恶意软件旨在通过广播消息传播，这意味着它可以同时感染所有邻居。 网络模式I-传播模式：只有网络中的传染性节点竞争传输，并且所有易受感染的节点都不竞争传输。 这是当网络中的通信负载很轻并且节点不经常彼此通信时的情况的近似模型。 网络模式II-通信模式：网络中的所有节点都处于通信状态，同时竞争传输。 因此，当涉及传播方案和网络模式时，WANET中的恶意软件传播将有四种不同的条件，如表1所列。 在无线网络容量理论中，通常假设网络中的所有节点都相等并且竞争共享无线信道。 因此，我们将首先分析两种传播方案在通信模式下的性能，然后讨论传播模式的情况。 通信模式下的单播方案假设，每个传染节点在其覆盖范围内择一个随机节点传播恶意病毒，其传送的速率为$\lambda_{uni-comm}(bits/second)$。例如，正如图2所示，给定时刻t，网络中的三个编号为1，2，3的染节点随机选择三个对应的目标节点4，7，9传播恶意软件。 假设恶意软件的大小为$V(bits)$，一个传染节点可以在时间间隔$\delta$内传播恶意软件$\lambda_{uni-commn}\delta/\V$，每次都瞄准一个邻居节点。假设邻居节点的平均数量为$n_0$，在时间间隔$\delta$之前，一个节点的邻居节点中易感染节点的比例为$[n_0-I_{n_0}(t)]/{n_0}$，然后在$t+\delta$时刻，传染节点的数量为： 由于难以获得每个节点的邻居传染性节点的数量，我们使用整个网络的平均值，这可以得到： 其中： 当$\delta \rightarrow 0$，我们可以将这个模型转换为连续时间传播模型： 在等式(10)中的关键因是传输速率$\lambda_{uni_comm}$。在无线网络中，与恶意软件的数量相比，传输速率可能非常快，因此通常不予考虑。然而，在WANETs中，由于媒体共享，$\lambda_{uni_comm}$是的上限是每个节点的吞吐量。因此，WANET中传输速率的上限比有线网络低得多。基于无线容量理论[26]，我们证明在随机无线网络中，当节点只需要使用单播方案与其邻居通信时,每节点吞吐量不超过:。详细证明见附录A，可以在计算机协会数字图书馆找到：https://www.computer.org/csdl/trans/tq/2018/06/07792126-abs.html。 使用统一的流行传播方程，我们用单播方案重写传播模型： 其中，$\beta_{uni-comm} = \frac{\lambda_{nuni-comm}}{nV}$是单播方案的感染，并且： 1.下面符号将在本文中使用，给定非负函数$f(n)$和$g(n)$: 通信模式下的广播方案在WANET中传播恶意软件的另一种可能方案是每个传染性节点试图将恶意软件传输到其所有邻居节点。 这是可行的，因为广播到邻居的想法已经在WANET中以各种协议采用，例如在节点之间建立连接[31]。 此“邻居发现”方法也可用于传播恶意软件。 图3给出了广播方案的图示。 当前被感染的节点1,2和3可以分别将恶意软件传播到它们的邻居，而不会对其他节点的传输产生干扰。同样，我们在附录A中证明了，每个节点的吞吐量可以通过广播方案实现:。 假设平均邻居节点数量为$n_0$，在时间$\delta$间隔内，一个传染节点可以传播恶意软件到平均$\lambda_{broad-comm}\delta n_0/V$个节点，其中在时间间隔$delta$之前，为传染的节点比例仍为$[n_0-I_0(t)]/n_0$。随后，在时刻$t+\delta$的感染节点书晒为： 同样，取代整个网络的平均感染节点数量，可以得到： 当$\delta \rightarrow 0$，我们可以将此模型转换为连续时间传播模型： 另外，根据[29]，WANETs连接所需的邻居数量为$\Theta(n\log{n})$。代入 和： 到等式(15),我们可以得到广播方案的统一传播方程： 其中： 比较等式(19)和等式(12)，结论是恶意软件使用广播方案比单播方案传播得更快。 而且，随着网络规模的增加（即，n变大），广播的危害变得更大。 表2简要介绍了两种不同方案的主要特征。 扩散模式下的恶意软件传播上面的通信模式分析让我们了解了在繁忙的网络场景中恶意软件如何在所有节点竞争无线信道的情况下传播。另一种可能的网络方案是只有少数节点尝试同时使用共享介质。在这种情况下，我们假设存在恶意软件传播期，在此期间只有传染性节点竞争传播。因此，在计算每节点吞吐量时，只应考虑$I(t)$“活动”节点。例如，对于单播方案，我们现在有： 和 同样，我们可以用广播方案获得结果： 和： 因为$I(n) \leq n$，我们可以得到：$\beta_{uni-spread}(t) \geq \beta_{uni-comm}(t)$和$\beta_{broad-spread}(t) \geq \beta_{broad-comm}(t)$。因此，因此，扩散模式的感染率始终不低于通信模式的感染率，这意味着恶意软件传播的速度更快。 数值结果将在下一节中介绍，以便为上述现象提供更清晰的解释。 流动性增加感染率我们已经在WANET中研究了两种不同传播方案的传播模型。 我们可以得出结论，通常，数据传输速率和后续感染率随着不同的传输策略而变化，即单播或广播。它还显示了与有线网络中不同的传播属性。 不同之处在于无线信道共享具有有限带宽的公共传输介质（频谱），并且传输半径是有限的。因此，WANET中的受感染节点倾向于将附近的节点定为目标，而不是像在有线网络中那样扫描整个网络。 WANET中的通信往往发生在邻居之间，这一事实对我们在4.1和4.2节中的结果产生了偏见。当我们重新回到用$[n-I(t)]/n$取代$[n_0-I_{n_0}(t)]/n_0$的过程，值得注意的是，有： 的概率很大。因为，当节点是静态的，恶意软件趋向于在源节点周围传播。 一种使$[n_0-I_{n_0}(t)]/n_0$接近$[n-I(t)]/n$的方法是移动性。图4用来说明移动性如何增加恶意软件传播的可能性。 正如图4所示，是$t_1$时刻，节点1，2和3是传染的。它们分别通过广播方式向邻居节点传播恶意软件。然后，在$t_2$时刻，由于移动性，恶意软件在两种可能情况下蔓延的可能性增加： 节点5在时间$t_1$被节点1感染。 由于它没有节点1以外的邻居，因此如果网络是静态的，它就没有机会传播恶意软件来感染任何新节点。 相反，如果节点5在时间$t_2$移动到另一个易感节点6的邻域，则它可以感染易感节点。 节点3在时间$t_1$感染了节点9和10。 如果它保持静止，则周围没有新的易受影响的节点。 然而，如果节点3在时间$t_2$移动到新位置，则它具有作为节点11的新目标。 由于难以准确估计移动性对恶意软件传播的影响程度，我们将在下一节通过模拟对其进行评估。 性能分析和讨论仿真初始化为了揭示WANET中恶意软件传播的功能，我们开展了全面的模拟活动并分析了不同参数的影响。 为了便于模拟，我们使用NumPy / SciPy / Networkx软件包开发了一个专用的Python模拟程序。 所有模拟结果均在100次运行中取平均值。 模拟的关键特征描述如下。 网络模型。 随机网络模型由二维随机几何图形（RGG）[32]呈现，其最近已用于建模WANET[12]。 在我们的模拟中，它是通过首先在单位平方$[0,1]$中生成具有随机位置的节点，然后在彼此的传输范围内的任意两个节点之间创建边来构造的。 临界传输范围。临界传输范围$r_c$是每个通信节点以最小功耗和通信干扰实现连接网络的传输半径。Ajorloo等[33]给出了关于临界传输范围的一些数值结果。 例如，如果RGG的单位平方中有100个节点，则连接网络的概率为95％的临界传输范围约为0.21。 我们将使用这些结果来确保在模拟过程中网络的连通性 媒体访问控制。 在诸如WiFi的实际WANET中，节点对可用通信信道的访问由媒体访问控制（MAC）协议控制，其功能是确保网络中数据分组的无干扰无线传输。基于WiFi的无线设备使用的MAC协议遵循具有冲突避免的载波侦听多路访问（CSMA-CA）方案，该方案指定一组规则，使得附近的设备能够以分布式方式协调其传输。CSMA-CA使用请求发送/清除发送（RTS / CTS）方案，以保证在通信节点对的范围内没有其他节点同时发送，这满足了3.2节中我们协议模型的要求。 另外，在模拟中，系统时间被分成时隙。节点对之间的恶意软件传播在一个时隙内完成。在每个时隙的开始，生成网络中所有竞争节点的随机排序列表。然后，列表上的第一节点$i$可以访问无线信道，并且允许在该时隙期间发送到其目标节点$j$.节点$i$的传输范围内的所有其他节点（CSMA-CA中的RTS的功能）和$j$（CSMA-CA中的CTS的功能）从列表中消除，因为它们的传输可能对该通信造成干扰。对列表中的其余节点重复此过程。随后，如果通信对中的源节点在传输之前是传染性的，则目标节点在传输之后也被感染。 此外，如果广播方案用于传播，则目标是多个节点。 性能分析首先，我们比较了节点固定时四种不同条件下的恶意软件传播特性。 从图5中可以看出，在具有固定节点的WANET中，广播比单播更危险。平均而言，广播需要大约1/4的单播时间来感染通信模式和传播模式中相同数量的节点，对于给定参数。 图6中的网络快照给出了一个关于不同传播方案的恶意软件传播速度的更直接的示例。同时，与通信模式相比，传播模式更有效，因为当仅受感染的节点竞争传输时，干扰较少。 有一些参数会影响恶意软件的传播，包括网络中的节点数量，传输范围和移动性。 它们的影响将在以下部分详细分析。 网络中节点数量。平均网络感染时间如图7所示，节点数n分别设置为25,100和250。 并且相应的临界传输范围0.4,0.21和0.14用于确保网络连接。 说明网络感染时间不随节点数的增加而线性增加。实际上，通过分别用等式(12)(19)代替等式(6)，我们可以得到单播方案的网络感染时间为$\Theta(\log{n})^2$,广播方案的网络感染时间为$\Theta(\log{n})$。它非常符合模拟结果。 传输范围。 然后我们将节点数固定为$n = 100$并研究传输范围$r(n)$的影响。 图8示出当$r(n)$从0.21（临界传输范围）上升到0.6时，单播方案的网络感染时间比广播方案的网络感染时间更快。 尽管两种方案中的并发传输与$r^2(n)$成反比，如在线补充材料中可获得的附录A中所示，但是当$r(n)$增加时，广播方案的传播速度由更大的平均邻居数补偿。 移动。 我们引入随机游走模型[35]来模拟网络中节点的移动性。 假设节点在发送时不移动，但是在发送之间的标准化时间间隔$t=1$内以速度V改变它们的位置，并且V遵循$[0,V_{max}]$均匀分布。对于每个新的间隔$t$，每个节点随机均匀地从$(0,2\pi]$选择其新方向$\theta(t)$。因此，在时间间隔$t$期间，节点以速度矢量$[v(t)\cos{(\theta),v(t) \sin{(\theta)}}]$移动。 此外，我们研究了两种移动性清形：1）只有初始感染节点在移动（在我们的模拟中被视为标记为“移动一体”的有意传染源）; 2）网络中的所有节点都在移动（移动ad hoc网络情况，标记为“Mobile All”。 图9比较了当最大移动速度设置为$V_{max}=1$时静态和移动网络中的恶意软件传播特性。从图9中可以看出，对于单播方案，无论在传播模式下还是通信模式下，它们都会大大加速恶意软件的传播。 但是，对于广播来说，移动性的影响并不明显，特别是在通信模式下。 当网络中的大多数节点被感染并且干扰变得更加严重时，传播速度变慢。 我们进一步研究不同移动速度的影响。 如图10所示，当$V_{max}$的值超过临界传输范围时（例如，对于$n = 100$，为0.21），平均网络感染时间明显减少。 因为节点可以在一个时隙内从单跳范围移动到新位置这一事实可以显着改善移动性带来的多样性。 讨论有线网络和WANET之间的区别通过以上对WANET中恶意软件传播特性的分析，我们可以得出结论，恶意软件攻击的传播速度高度依赖于传输速率，传输速率由传播方案，网络模式和节点移动性决定。 这与有线网络的情况有很大不同，其中恶意软件传播的时间主要由覆盖所有节点的策略决定。 在恶意软件传播意义上的无线网络和有线网络（主要是指互联网）之间的不同特征总结如下： 互联网研究相关的设置中的节点数量很大，通常在$10^4$或$10^5$的数量级，而无线网络的规模要小得多（通常小于100）。 因特网中有线链路的带宽通常是足够的，特别是对于恶意软件传输，因此并发传输不会导致冲突。 相反，无线信道使用具有有限带宽的共享传输频谱。由于引起的干扰，并发传输的数量受到限制。 节点的平台（PC中的操作系统）在Internet上更为成熟，而传感器等无线网络中的节点更容易受到恶意软件攻击。 这些差异提醒我们要注意WANET中恶意软件传播的特殊特性，而不是直接使用有线对应的结果。 恶意软件类型，传播方案和实际应用中的移动性当前恶意软件的两个主要类别是蠕虫和病毒。 一般而言，病毒是通过将自身的副本插入并成为另一个程序的一部分而传播的恶意软件的类型。 与需要传播受感染主机文件的病毒相比，蠕虫是独立软件，不需要主机程序或人工帮助进行传播。 因此，蠕虫更易于使用我们定义的Spread模式传播，而病毒很容易进入通信模式。 因此，在可能的传输速度意义上，蠕虫比无线网络中的病毒更危险。 关于传播方案，第5.2节中的结果表明，广播方案在用于恶意软件传播时更有害。 在实际的无线网络中，广播传输通常发生在网络初始化阶段，例如，MAC层中的邻居发现协议。 恶意软件可以通过访问节点的MAC层信息或附加到邻居发现协议的多播分组来开始传播。 它提醒我们要特别注意WANET中的MAC层协议（警惕可能附着的病毒）。 此外，应仔细研究不在正常初始化阶段的任何广播包（可能的蠕虫）。 我们在论文中使用最广泛接受的随机移动模型来模拟WANET中移动节点的移动。 虽然在我们讨论的一般WANET框架中分析移动性的影响已足够，但实际场景的移动性特征可能更复杂。 还有一些其他具有独特特征的移动模型，如时间依赖性，空间依赖性或地理限制[35]，可用于未来更具体应用中的恶意软件传播研究。 无论如何，由于移动性大大增加了恶意软件传播的速度，因此应严格限制WANET中任何受感染节点的移动。 不同应用程序中的恶意软件传播风险基于上述结果和讨论，我们能够在两个典型应用中研究恶意软件传播问题。 第一个应用是VANET，它显示出高移动性功能。 可以预测，此应用程序中的风险将高于具有固定节点的风险。 此外，如果我们将范围扩展到更通用的移动ad hoc网络（MANET），风险会变得更高。 因为VANET中的车辆被限制在道路范围内移动，而在MANET中，节点的移动性可以变得更随机。 另一个广泛使用的WANET应用是WSN。 其主要组件是一些传感器节点，负责收集数据并通过无线链路相互连接。 在大多数现实生活应用中，例如环境监测，传感器分散在相对较大的区域，并且没有很多邻居。 另外，它们不经常相互通信。 因此，WSN中的恶意软件传播风险不如WANET中的情况那么高。 然而，可能存在一些传感器节点，其具有从其他传感器节点接收，处理和存储数据的特定任务。 它们通常被称为接收器或簇头[36]，可以提前指向或动态选择。 如果这些关键节点被感染，则会提高整个网络的风险等级。 防恶意软件措施最后，对恶意软件传播的分析也提供了对WANET保护的见解。 例如，修补整个网络的一个好方法是让所有节点停止正常通信（进入扩展模式），通过广播方案进行修补，并使具有修补能力的网络节点在网络中移动。 结论和未来工作在本文中，我们研究了WANET中的恶意软件传播问题。 考虑到无线干扰和终端移动性的特点，研究了广义的WANET结构用于传播模型分析。 首先，我们研究了两种具有两种不同网络模式的恶意软件传播方案，并分别提供了它们的感染率界限。 详细的性能分析表明，在四种不同的条件下，具有传播模式的广播方案是最危险的。 此外，还评估了移动性对恶意软件传播的影响。 基于这些分析，我们讨论了实际应用中的恶意软件传播问题以及可能的对策。 未来的工作有几个有趣的方向。 首先，我们可以考虑具有节点集群的网络模型，这意味着网络中的节点不相等。 其次，在某些特定应用中可以考虑具有诸如时间依赖性，空间依赖性或地理限制的独特特征的其他移动性模型。 第三，可以添加硬件和软件平台等因素，为不同系统提供更全面的风险评估。 最后，进一步研究不同传播模型的相应防御策略也很有趣。 参考文献： [1] C. C. Zou, W. Gong, and D. Towsley, “Code red worm propagation modeling and analysis,” in Proc. 9th ACM Conf. Comput. Commun. Secur., 2002, pp. 138–147. [2] Y. Wang, S. Wen, Y. Xiang, and W. Zhou, “Modeling the propagation of worms in networks: A survey,” IEEE Commun. Surveys Tutorials, vol. 16, no. 2, pp. 942–960, Apr.–Jun. 2014. [3] K. Yang, K. Zhang, J. Ren, and X. Shen, “Security and privacy inmobile crowdsourcing networks: Challenges and opportunities,”IEEE Commun. Mag., vol. 53, no. 8, pp. 75–81, Aug. 2015. [4] M. G. Roberts and J. A. P. Heesterbeek, “Mathematical models inepidemiology,” Encyclopedia Life Support Syst. (EOLSS), 2003. [5] R. Pastor-Satorras and A. Vespignani, “Epidemic spreading inscale-free networks,” Physical Rev. Lett., vol. 86, no. 14, 2001,Art. no. 3200. [6] Y. Moreno, J. B. Gomez, and A. F. Pacheco, “Epidemic incidence STX in correlated complex networks,” Physical Rev. E, vol. 68, no. 3, 2003, Art. no. 035103. [7] C. C. Zou, D. Towsley, and W. Gong, “Modeling and simulation study of the propagation and defense of internet e-mail worms,” IEEE Trans. Dependable Secure Comput., vol. 4, no. 2, pp. 105–118, Apr.–Jun. 2007. [8] Z. Chen and C. Ji, “Importance-scanning worm using vulnerablehost distribution,” in Proc. IEEE GLOBECOM, 2005, Art. no. 6. [9] Z. Chen and C. Chen, “A closed-form expression for static wormscanning strategies,” in Proc. IEEE Int. Conf. Commun., 2008,pp. 1573–1577. [10] Q. Wang, Z. Chen, C. Chen, and N. Pissinou, “On the robustnessof the botnet topology formed by worm infection,” in Proc. IEEEGLOBECOM, 2010, pp. 1–6. [11] W. Yu, X. Wang, P. Calyam, D. Xuan, and W. Zhao, “Modeling and detection of camouflaging worm,” IEEE Trans. Dependable Secure Comput., vol. 8, no. 3, pp. 377–390, May–Jun. 2011. 具体见论文]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CurosrLoader加载数据]]></title>
    <url>%2F2018%2F12%2F09%2F%E4%BD%BF%E7%94%A8CurosrLoader%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[使用CursorLoader在一个后台线程上从数据库中加载数据，这将保持我们应用的响应性。 CursorAdapter简介前面了解使用ListView可以很方便地显示一列信息。而要在ListView中填充信息，需要使用到适配器adapte，所以基本上来说适配器负责创建数据源中每只宠物的列表项试图，并将它们交给ListView以显示在屏幕上。 CursorAdapter是一个抽象类，我们定义一个类并继承该类。 扩展类包含一个构造函数，该构造函数使用超类构造函数来初始化自己。 作为开发者，我们需要填入newView()方法，为游标所指的当前行创建并返回一个空白的列表项。 同时，我们还需要填入bindView()方法，以从游标中的当前行读取数据，将它设置到这个列表项试图中的试图上。 具体函数如下： CursorAdapter类会帮我们处理一些逻辑，例如将游标移动正确的位置。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Content Providers简介]]></title>
    <url>%2F2018%2F12%2F04%2FContent%20Providers%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[如果直接调用SQLite数据库，很容易引入错误，假如Activity中有错别字，就会将无效输入插入到数据库中。可以通过引入一个名为Content Provider的概念，作为数据库和活动之间的一个层。使用其有很多好处，可以用它确保输入数据库中的数据是有效的。介绍它，必须介绍URI、UriMatcher、Content Resolver。 Content Providers存在的必要性Content Providers可帮助我们管理对有结构的数据集的访问，它可以作为数据源和UI代码之间很好的抽象层。这个抽象层可以添加数据验证，帮助我们修改数据存储的方式，而UI代码始终保持不变。 Content Providers可以与其他框架类完美结合。 为了更清楚说明这一点，继续讨论宠物列表。当宠物列表添加或被删除，我们希望UI显示最新消息时，我们每次都必须调用query和insert方法。取代这种繁琐工作的方法就是，利用一个名为Cursor Loader框架类。每当有宠物添加到列表或被删除时，列表会借助Cursor Loader始终处于更新状态。 因为Cursor Loader会在数据发生变更时自动进行检查，并在确定发生了数据变更后自动更新列表。Cursor Loader能与我们前面讨论的ListView和Cursor Adapter协作。从而在列表中显示所做的更改。而实现Cursor Loader需要用到Content Provider。所以Content Provider和Cursor Loader一起为我们省了很多工作，使我们不需要在发生数据更改时，一次次手动执行查询。 它还能与主屏幕小部件搭配使用。这些部件的名称为同步适配器，能将我们的数据同步到云，并为应用提供搜索建议。 另一个重要的优势是，分享数据。当应用中存在文本数据或文件时，其他应用是无法访问的。不过，可以通过Content Provider将我们的数据暴露给其他应用。这样，其他应用可以使用querty、insert、update和delete方法与provider交互从而访问我们的信息。 当然，这样做存在一些隐患。因为可能不希望某个应用访问和修改所有的应用数据，而且遇到恶意应用或许会删掉整个数据库表。所以，向其他应用暴露数据还需谨慎，处理不当可能会有危险。不过，开发者不同担心，Content Provider能以非常安全的方式管理数据访问，如果想要访问其他应用，提示用户授权访问数据的特定权限Content Provider可以帮助予以执行，而未获得权限的其他应用将无法访问数据。 总之，Content Providers有三大优点： 作为数据源和UI代码之间的抽象层，可以很好地进行数据验证； 帮助我们与其他框架类完美协助； 帮助我们轻松与其他应用分享数据。 一个应用向其他应用请求特定的数据，它会参考contacts contract，并创建特定内容URI请求。内容URI唯一标识一组数据，类似于Web URI地址唯一标识网络上的唯一网站。 Android系统根据我没在内容URI中传入的信息，知道Google+要向contacts app通信。给定这些信息，它会判断哪个content provider和应用可以处理请求。 Android上还有一个东西，叫做content resolver，它以URI为输入，来决定应该由哪种content provider处理我们的请求，判断秘诀就在于内容主机名。内容主机名是URI的一部分，它会告诉content resolver应由哪个provider来处理请求，内容主机名与网络URL的部分相似。 所以，可以得到所有这些其他应用实际上直接与content resolver通信，而非provider。content resovler会暴露这些方法：query()、insert()、update()和delete()。它对provider调用适当的方法，后者相应地调用适当的provider方法对数据库进行操作。 在一个应用中的实现： 其中Content Provider是一个抽象类。 URI与Provider交流时，需要告诉它两件事，第一，你想要执行什么操作；第二，在这个操作中使用什么数据。 URI代表同一资源标识符。它可以标识出我们感兴趣的资源的名称、位置。URL是URI的子集，URL代表统一资源定位符，它会给出某个文件或数据在网站上的具体位置。内容URI主要用来标识Provider中的数据，它可以指向数据库的某个部分，比如单个行、单个表或一组表，它也可以指向文件，比如文本文件、照片或其他媒体文件。 内容URI由三个部分组成： scheme：content://，这是Android应用中URI的标准开头。 主机名：最重要的部分，它指定我们要使用的content Provider，称为内容主机名，它的主要作用是指定我们要进行通信的content Provider类。 数据类型：指定了我们要执行操作的数据。 存在两种： 对于整个表进行操作：这时数据类型为表名，如下： 对某行进行操作：使用另一种URI，在表名后面跟上具体行的ID，如下： 汇总： URI MatcherProvider为了决定如何处理Content Resolver的请求，会使用URI matcher。URI matcher会确定传递给它的URI属于哪种类型。然后，我们可以用这个信息决定要进入的分支，比如，第一分支要对整个表进行操作；另一个分支，对某个行禁止操作。这样，我们就确切地知道了需要操作的数据库表。 URI Matcher用于将URI与整数代码相匹配，使用URI matcher需要实现的两个步骤： 第一步是用Content Provider可接受的URI模式设置UriMatcher，并向每个模式分配一个整数代码； 第二步需要调用一个UriMatcher.match(Uri)方法传入一个Uri，返回对应的整数代码（前提有与之匹配的模式），如果不匹配它会给我们提示。 实现示例： 其中CONTACTS和CONTACTS_ID是全局常量。sUriMatcher是一个静态全局UriMatcher对象。 private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); : private static final int PETS = 100; private static final int PETS_ID = 101; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static { sUriMatcher.addURI(PetContract.CONTENT_AUTHORITY,PetContract.PATH_PETS, PETS); sUriMatcher.addURI(PetContract.CONTENT_AUTHORITY,PetContract.PATH_PETS + &quot;/#&quot;, PETS_ID); } 查询query() query方法共分为三部分： 首先，需要获得数据库对象； 将URI发送到URI matcher; 帮我们决定选择哪条分支。 具体实现代码： 代码： @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { SQLiteDatabase database = mDbHelper.getReadableDatabase(); Cursor cursor; int match = sUriMatcher.match(uri); switch (match){ case PETS: cursor = database.query(PetContract.PetEntry.TABLE_NAME, projection,selection,selectionArgs,null, null,sortOrder); break; case PETS_ID: selection = PetContract.PetEntry._ID + &quot;=?&quot;; selectionArgs = new String[] {String.valueOf(ContentUris.parseId(uri))}; cursor = database.query(PetContract.PetEntry.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder); break; default: throw new IllegalArgumentException(&quot;Cannot query unknown URI + &quot; + uri); } return cursor; } 该方法的调用： Cursor cursor = getContentResolver().query(PetContract.CONTENT_URI, projection, null, null, null); 插入insert 实现步骤： 实现代码： 更新Update根据来自UriMatcher的结果，PETS和PET_ID case均支持。在PETS case中，调用者想要按照selection和selectionArgs 更新 pets 表中的多个行。 在PET_ID case中，调用者想要更新特定宠物。要写入数据库中的新值包含在传入方法的 ContentValues 对象中。 实现流程： 删除deletegettypegetType(Uri uri) 方法。此方法的用途是返回描述输入 URI 中存储的数据类型的字符串。该字符串为 MIME 类型，也称为内容类型。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础知识数据存储]]></title>
    <url>%2F2018%2F11%2F29%2FAndroid%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[创建存储数据的变量，当屏幕旋转时，Activity被销毁，存储的数据就会消失。因此需要一个更永久的方式来存储用户数据，当关闭应用并重新打开时，用户数据依然存在，这一概念叫做数据持久性。 计算机内存计算机有两种类型的存储器： 临时存储器：提到计算机内存就是临时存储器，比如随机存储器（RAM） 永久存储器：包括硬盘 数据存储选择Android提供了几种不同的数据持久性选择，用来将数据存储到本地存储器： 文件：图片、音视频 SharedPreferences：存储用户偏好设置，SharedPrederences使用键值对来保存少量的数据 SQLiteDatabases： 是一种数据库类型，数据库是有组织的数据集合，可以从中提取所需的数据，并加以分析。SQLite数据库是一种具体的数据库示例，由一个甚至多个表格组成，每个表格由列和行组成，每一行是一个对象。 SQLite数据库SQLite是一种数据库，使应用能够与互动的设备上创建一个本地数据库。Lite一词是指典型数据库的轻量级版本。对应的重量级数据，比如MSQL，可以提供更加复杂的功能。SQLite不需要服务器，数据存储在设备上的本地文件中。SQLite是开源免费的，并且Android自带的数据库。 sqlite安装，可以从网上直接搜索下载sqlite3。然后在C盘下创建sqlite文件，并添加到环境变量。然后打开命令提示符（cmd）,进入目录c:\sqlite，输入sqlite3进入程序。 echo命令用户在屏幕上输出相关内容。 echo %cd% cd表示当前目录，%是定界符，表示不是向屏幕输出字母cd，而是输出当前的目录 SQL是结构化查询语言的简写，是一种计算机语言，专门用户数据库。SQL专门用来创建表格，然后添加和删除以及操纵条目。 打开一个文件： .open pets.db 如果文件不存在，则会自动创建一个pets.db文件。 结束SQLite程序 .quit 直接进入程序并直接打开数据库： sqlite3 pets.db 查看数据库中的表格： .table 创建表格： CREATE TABLE table_name (column_name1 TEXT, column_name2 INTEGER); 示例： CREATE TABLE pets (_id INTEGER, name TEXT, breed TEXT, gender INTEGER, weight INTEGER); 显示创建表格语句： .schema talbe_name 利用SQL指令查看表格详情，包括表格所有列的名称和类型： PRAGMA TABLE_INFO(table_name); 注意.指令是SQLite程序指令，大写的指令，以分号结尾，则表示是SQL语句，即结构化查询语言。SQL语句不区分大小写，但是SQLite程序指令区分大小写。 删除表格，完全清空表格： DROP TABLE talbe_name; 修改表格内容输出模式： .mode tabs //以制表符分割值 .mode ascii .mode column //以表格形式显示 输出表格内容时，添加表头： .head on 示例： SQLite中的类型 INTEGER： 1、2、3、4、6、8byte Integer，即1字节整数，3字节整数 NULL: 空值 REAL: 浮点型 TEXT： 字符串 BOLB：表示数据完全按照输入的样式存储，例如图片或二进制数据 注意SQLite没有单独的Bool（布尔）类型。有效的方式是将布尔型存储为整型。 CRUD对表格进行的操作，可以总结为一个词：CRUD。分别表示：Create、Read、Update、Delete。 Read 从一个表格中读取某一列或所有列： SELECT &lt;columns&gt; FROM &lt;table_name&gt;； SELECT * FROM &lt;table_name&gt;; //读取所有列，*为通配符 Create 向表格中插入数据行： INSERT INTO &lt;table_name&gt; (&lt;columns_name_1&gt;, &lt;colums_name_2&gt;,...) VALUES (&lt;value_1&gt;, &lt;value_2&gt;); 更新表格中的数据： UPDATE table_name SET column_name = update_value WHERE column_name == value; 删除表格中的数据： DELETE FROM table_name; //删除所有数据行 DELETE FROM table_name WHERE column_name == value; //删除特定的行 删除一个表格： DROP TABLE talbe_name 示例： 关键字SQL提供了许多便捷的关键字，帮助我们来避免出现意外情况。 PRIMARY KEY:将相关列作为标识唯一的行，可以确保唯一性，表示每个表格只能只有一个主键，通常与AUTO INCREMENT关键字一起使用 AUTOINCREMENT：可以确保ID列是唯一的，并且当你添加一行是，自动生成新的唯一ID NOT NULL：表示向表格插入某个值时，必须具有相关的值 DEFAULT ：设置默认值，当该值缺省时，使用默认值 示例： 选择、位置和排序WHERE: 根据条件查询行 ORDER BY:更改输出顺序, ASC表示升序，DESC表示降序。 注意，当使用条件查询并排序时，需要先使用WHERE条件语句，在使用ORDER BY语句，否则会发生语法错误。 在Android应用中使用数据库Contract类使用Contract类的作用： 帮助定义架构，并且规定去哪查找数据库常量 生成SQL指令时，消除出现拼写错误的可能性 更容易更新数据库结构 创建Contract类的步骤： 首先需要一个外部类，可以命名为BlankContrack 其次，数据块中的每个表格还需要一个内部类，每个类叫做BlankEntry，每个内部类实现BaseColumns类 Contract中应该包含表格名和标题或列名称的字符串常量 对于特定情形，还需要为每个性别创建一个常量，并用刀相应的类中 SQLiteOpenHelper类帮助我们创建、打开、管理数据库关联关系。 当第一次访问数据库时，SQLiteOpenHelper类将创建我们使用的数据库，它会使用getWritableDatabase()或getReadableDateabase()方法进行创建。 再次打开该应用是，SQLite帮助我们访问已经存在的数据库，而不是创建新的数据库。 如果数据库版本发生任何更改，SQLiteOpenHelper类将帮助我们更新数据库架构。 创建SQLiteOpenHelper类的步骤： 首先，创建一个扩展自SQLiteOpenHelper抽象类的类； 第二步，为数据库名称和数据库版本创建常量； 接着，需要创建构造函数； 然后，实现onCreate()方法，当数据库第一次被创建时，会使用到该方法； 最好，还要实现onUpgrade()方法，当数据库架构发生变化时，会用到该方法，比如向数据库中添加列。 onCreate()中用db.execSQL()来使用SQL语句创建和初始化架构，该方法的输入参数是一个字符串常量，包含CREATE TABLE等字符串的SQL语句。execSQL()方法不得与任何SELECT语句一起使用，因为该方法不会返回任何实际的数据，只是用来执行语句从而修改数据库的配置和结构。 onUpgrade()方法的作用是：使你能够根据你对代码结构所做的更改更新数据库文件。 在终端检查数据库是否构建正确： 使用displayDatabaseInfo()方法 从云端下载数据库到计算机，在终端检查数据库的正确性 连接数据库PetDbHelper mDbHelper = new PetDbHelper(this); 构建了一个PetDbHelper类的实例 SQLiteDatabase db = mDbHelper.getReadableDatabase(); 将开发关联的数据库或创建一个数据库。可以看作是.open命令。 SQLite数据库对象插入数据如果想执行创建、更新或删除操作，则需要调用getWritableDatabase()方法 对于读取或选择操作，可以使用getReadableDatabase()方法 ContentValues类Content Values是一种类，其中存储了大量的键值对，键是数据库中的列名称，值是需要插入的值。 ContentValues使用起来非常简单。只需创建一个ContentValues实例，然后调用put()方法其中包含列名称和列值。这仅仅创建了一个对象，其中包含列名称和列值，并没有向数据库里插入任何内容。 要在数据库实际地创建新的一行，需要使用SQLiteDatabase类的insert()方法。 db.insert(PetEntry.TABLE_NAME, null, values); 第一个参数是表名，第二个参数null是在向数据库中插入完全为空的数据时使用，所以默认设置为null；第三个参数是创建的ContentValues实例。其会返回一个新插入行的ID，如果出现错误返回-1。 数据库查询方法SQLiteDatabase.query() CursorCursor是指代表数据库中的多行内容的对象。 不同的Get方法： 具体使用： String[] projection = { PetEntry._ID, PetEntry.COLUMN_PET_NAME, PetEntry.COLUMN_PET_BREED, PetEntry.COLUMN_PET_GENDER, PetEntry.COLUMN_PET_WEIGHT }; Cursor cursor = db.query(PetEntry.TABLE_NAME, projection, null, null, null, null, null); 使用完成后，记得调用: cursor.close(); 这样会完全情况Cuusor使其无效，仅在完全操作完毕后调用该方法。不关闭Cursor的话，会因为内存泄漏而降低性能。 SQL 注入假设你提供了可编辑文本，允许用户输入整数并获得 ID。友好型用户可能会输入“2”来搜索数据库中的第二个宠物。你可以让字符串 userInput 变成 “2” String selection = “PetEntry._ID + &quot; == &quot; + userInput + “;”; 这里就是： _ID == 2; 但是如果他们知道如何使用 SQLite 并且充满恶意，就会输入类似于下文的内容： “1; DROP TABLE pets;” 如果我们采用了这一输入 String selection = “PetEntry._ID + &quot; == &quot; + userInput + “;”; 就会让最终的字符串变成： _ID == 1; DROP TABLE pets; 问题是，当 SELECT 语句被调用时，恶意用户“注入”的 DROP TABLE 语句也会被调用。本质上，我们使用户能够对宠物数据库执行毁灭性的攻击，因为我们让他们有机会对数据库执行任何 SQL 语句。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程与并行]]></title>
    <url>%2F2018%2F11%2F28%2F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Android 系统能够同时运行多个线程， 因此可以相互独立的处理 两组或多组任务。如果有多个线程需要运行， Android 还会就何时运行哪些线程进行优先级排序， 并确定各线程的运行时长。 线程也知道如何保存其位置。它不仅会记录所有变量的值， 还会记住完成当前正在执行的指令 会调用的函数系列： 即能够重新完成工作所需的一切内容。 构建所有多线程应用程序都是为了能够同时运行两个或 多个进程。 AsyncTask类NetworkMainThread异常，这是由于Android不允许开发人员在主线程（main thread）上进行网络请求，因为这会造成应用无响应和延迟。 这使得开发者不得不在后台运行网络代码，然后将结果返回给UI线程。 只需要在一个单独的线程上，运行一个任务即HTTP请求，该线程不能是用于处理UI事件的线程。Android创建了专门的Java类，使这一操作变得简单，即AsyncTask类，Async是异步（asynchronous）的缩写，意思是事务可以在不同的时间进行。AsyncTask适合于短期的一次性任务，避免管理标准作业线程所需的开销。 AsyncTask提供一种方式，可以简单地将作业转到后台线程，并在作业完成时随时接收到结果，用户更新UI。主线程接收到结果并更新UI，只需要很少的时间。 AsyncTask是一个抽象类。使用是需要创建一个类，并扩展AsyncTask类，如下：、 private class DownloadWebpageTask extends AsyncTask&lt;params, prgress, result&gt;{...} 所有在后台工作的内容都包括在doInBackground()方法中。 更新UI在主线程中，onPostExecute()方法负责主线程和后台线程之间的通信，该方法在主线程中运行，后台工作完成或，调用此方法。 后台工作开始前，onPreExecut()方法就被调用到主线程上。 用户可能需要知道后台任务的进度，比如，下载图片时，显示图片下载进度条。则在doInBackground()方法中，可以定期调用publishProgress()方法，并传入新的进度值。可以重写主线程上的onProgressUpdate()方法用新的进度值来更新UI。 doInBackground()方法是抽象方法，所以我们需要执行此方法。 onPreExecute()、onPostExecute()、onProgressUpdate()这些方法不是抽象的，所以需要我们来执行。 AsyncTask定义了三个泛型数据params、progress和result，如果其中一个没有使用则用Void代替（注意V是大写，因为这里是泛型）。三个泛型数据分别由doInBackground、onPregressUpdate和onPostExecute方法进行处理。 可以用一个字符串对象，来替换第一个泛型数据，doInBackground方法处理第一个泛型数据params，该泛型数据可以是一个列表，通过使用...来表示，例如：URL... urls表示可以接受一个、两个或多个URL参数。 第二个参数progress由onProgressUpdate方法使用，同时其参数也可以是一个列表，如上。比如int... progress。 LoaderLoader解决AsyncTask的资源浪费问题，如果屏幕旋转，视图都会重新生成，HTTP连接重新发起，原先的资源将继续占用内存。 AsyncTask适合于处理许多事情，但对于更新用户界面的数据来说，却不是最佳的选择，对此，需要使用Loader。 首先，无论从loader上请求多少次数据，默认情况下loader仅仅获取一次数据，因此不会生成大量的AsyncTasks和活动。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP网络]]></title>
    <url>%2F2018%2F11%2F27%2FHTTP%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[网络简介HTTP请求，需要明确指出要找的内容，以及内容的提供方式。 设备要在Internet上，从其他计算器获取信息，HTTP请求是基础部分，原理是首先请求某些信息，然后获取响应，并使用适当的方式提取这些信息。请求中包好URL。 URL：统一资源定位符 Android权限默认情况下，APP不具有访问Internet的权限，Android操作系统拒绝APP发出HTTP请求，应用可能崩溃。 对于每个想要的每个权限，都要向应用的Android清单文件（AndroidManifest）中添加使用权限（uses-permission）元素。 例如，如果创建一个消息传递应用，且希望用户能够在你的应用内直接发送SMS消息，则需要在清单中声明该应用需要发送SMS(SEND_SMS)权限字符串。 应用程序权限具有不同都的保护基本，两个最重要的级别是： 正常权限：不会对用户隐私或其他应用的操作构成威胁，因此系统自动批准这些权限。 危险权限：会访问用户的个人身份信息或私人信息，并且会访问可能影响其他应用操作方式的功能，其中包括：使用照相机，访问联系人或通话记录，或者通过麦克风录音，运行这些权限前必须先进行请求。用户必须通过系统对话明确授权。 超文本传送协议HTTPHttp是可以对通过万维网交换数据的方式进行处理的核心技术。Http代表超文本传输一些，并来自于早期的web(计算机进传输基本网页信息)。 协议仅仅是一组预先定义的规则，可允许计算机彼此进行通信和协调，以完成任务。 HTTP动作(RequestMethod)： Get:即从某处获取或检索一些数据 Post:即创建某些新信息 Put:即更新某些现有信息 Delete: 即删除服务器上的某些现有的信息 详细介绍 HttpURLConnectionHttpUrlConnection是URLConnection的子类，继承了URLConnection所有的行为。 url.openConnection()返回值类型为HttpUrlConnection。 HttpUrlConnection是一个HTTP客户端，可用它来在Android中执行HTTP请求。Http连接帮助我们在Web内发送和接收数据。 打开HTTP连接过程： 设置HTTP连接 发起HTTP连接 接受响应 private String makeHttpRequest(URL url) throws IOException { String jsonResponse = &quot;&quot;; HttpURLConnection urlConnection = null; InputStream inputStream = null; try { urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setRequestMethod(&quot;GET&quot;); urlConnection.setReadTimeout(10000 /* milliseconds */); urlConnection.setConnectTimeout(15000 /* milliseconds */); urlConnection.connect(); inputStream = urlConnection.getInputStream(); jsonResponse = readFromStream(inputStream); } catch (IOException e) { // TODO: Handle the exception } finally { if (urlConnection != null) { urlConnection.disconnect(); } if (inputStream != null) { // function must handle java.io.IOException here inputStream.close(); } } return jsonResponse; } Android系统架构Android系统由4层组成：应用层、架构层(Framework)、操作系统层、硬件层 应用层：建立所有应用程序所在的层，在应用层我们使用一些Android Framework类，如TextView和Activity，当使用这些类的时候，仅仅需要通过一小行代码，就可以完成很多复杂的事情，例如，显示文本，打开网页。 Framework：连接应用和设备的桥梁，Framework类是我们清晰地展示了当用户使用应用时，设备如何表现。Framework类通过调用Android低级层来避免很多不必要的复杂事务，并把低级层作为起重设备。 HTTP请求方法类型urlConnection = (HttpURLConnection) url.openConnection(); HTTPUrlConnection对象只包含请求的目标地址。 urlConnection.setRequestMethod(&quot;GET&quot;); 定义服务器应在请求中执行的操作。 Get：通常是从服务器读取信息，并将其返回给客户端 Post: 通常是包含写入到服务器中的信息 urlConnection.connect(); 我们与服务器建立HTTP连接，前面的内容都是为了设置HTTP请求。之后的代码都是为了接收响应，并对在应用中对响应作出解释。 HTTP状态码： 状态码 描述 200 一切正常，可接受到请求并且一切正常运行 301 页面被永久移除 404 无法找到页面 500 内部服务器错误 维基百科详细介绍 百度百科详细介绍 1开头表示代表请求已被接受，需要继续处理 2开头代表请求已成功被服务器接收、理解、并接受 3开头表示重定向错误，代表页面等已暂时或永久转移，希望进行其他操作以继续请求 4开头代表了客户端看起来可能发生了错误，妨碍了服务器的处理，即设备或浏览器出现错误，这可能是URL出错或意外引发了格式错误的请求，而服务器不知道如何处理该请求 5、6开头代表了服务器在处理请求的过程中有错误或者异常状态发生，可能是服务器处理已崩溃或服务器在处理请求时遇到一些意外错误 通过HTTP码来判断是否对响应进行处理： //如果响应码为200，读取输入流和解析响应 if (urlConnection.getResponseCode() == 200){ inputStream = urlConnection.getInputStream(); jsonResponse = readFromStream(inputStream); } return jsonResponse; 后续的处理，必须可以处理当jsonResponse为空的情况。如下： if (TextUtils.isEmpty(earthquakeJSON)){ return null; } 从输入流读取通过inputStream来返回服务器响应的数据，需要在一个方法的帮助下，读取来自inputStream的数据。该方法为readFromStram()。 inputStream实际上并不会返回数字或字母等可读数据，而是返回原始的二进制0 1数据，而且并不会具体说明数据所代表的含义，数据可能是图片，音频，文字或一些需要解析的geoJSON数据。 InputStreamReader inputStreamReader = new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;)); 确定返回数据是文本，可以利用inputStreamReader处理从原始数据到可读字符的翻译过程。InputStreamReader一次只允许读取一个字符，这可能导致验证的性能问题，具体取决于底层inputStream实际提供数据的方式。 inputStream作为构造函数的一个参数传递给InputStreamReader实例，同时还为构造函数提供了一个字符集，简称Charset，Charset指定如何将inputStream的原始数据逐个字节翻译为可读字符。 BufferedReader reader = new BufferedReader(inputStreamReader); 为了避免这种情况，可以将inputStreamReader包装到BufferReader中，BufferReader在接收到对某个字符的请求后，会读取并保存该字符前后的一大块数据。当继续请求另一个字符时，BufferReader就能够利用提前读取的数据，来满足请求，而无需再回到inputStreamReader。 StringBuliderStringBulider是一个字符序列，但StringBulider是可变的，即在创建之后可以修改。 如果要通过若干个步骤，分步构建一个较长的文本字符串，则StringBulider更高效。否则，每一步都需要重新创建一个字符串，浪费内存资源。 示例： 最后字符串为：Word builder. 下面代码，创建一个StringBuilder向其添加BufferedReader中所有可用的各行文本。首先创建builder，和reader，然后向BufferedReader请求一行文本，在文本不为null时，将该行添加到StringBuilder中，然后继续读取下一行。最后直到BufferedReader中没有文本，使用toString方法从StringBuilder中获取字符串，并返回最终输出。 private String readFromStream(InputStream inputStream) throws IOException { StringBuilder output = new StringBuilder(); if (inputStream != null) { InputStreamReader inputStreamReader = new InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;)); BufferedReader reader = new BufferedReader(inputStreamReader); String line = reader.readLine(); while (line != null) { output.append(line); line = reader.readLine(); } } return output.toString(); } 异常异常是基本的错误，但可以被抛出throw或捕获到catch。 异常类型很多，这些异常类型实际上是从异常超类中继承而来。 try/catch 如果URL构造函数一切正常，那么就不会引发异常，不会在catch块内执行任何代码。如果try块中的代码引发了异常，会立即跳转到包含该异常的catch代码块中，并执行该代码。然后，退出try catch语句并继续执行其他代码。 URL url = null; try { url = new URL(stringUrl); } catch (MalformedURLException exception) { Log.e(LOG_TAG, &quot;Error with creating URL&quot;, exception); return null; } return url; 注意url的定义在全局，如果在try块中，try catch语句完成之后，将无法访问URL变量。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON解析]]></title>
    <url>%2F2018%2F11%2F23%2FJSON%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Json解析，以及字符串处理，日期和时间转换，小数点处理，switch语句等等 JSON概述JSON是JavaScript Object Notation的缩写。最初设计JSON是为了促进网络的有效沟通，因此以JavaScript开头，与JavaScritp并无关系。它是一组用户组织数据的规则，是一种完全独立的编程语言，因此可以选择任何编程语言来解释JSON，包括用于构建Android应用的Java。 JSON语法结构的核心是：键值对 大括号: 你会发现，JSON 示例中的所有内容都封闭在 一组大括号内，这表示可将整个内容视为一个 对象。 逗号: 键和值以冒号分隔，同时每个键/值对以逗号分隔。 JSON 支持可在大多数编程语言中找到的基本数据类型， 如，数字、字符串、布尔值、数组和对象。 可在以下示例中看到其中几种数据类型： Json解析 第一个 “size” 键的值为 9.5，由此可以判断出 该值属于数值类型，因为值周围没有引号。 第二个 “wide” 键的值为 true，不带引号。这 表示该值属于布尔值。如果数字周围有引号，则表示其为字符串。也就是我们在第三个键值对中找到的字符串。 第三个 “country-of-origin”键的值为 “usa”。 第四个键是 “style”，其值表示为对象，因为两侧有大括号。在 style 对象内部，我们可以找到两个嵌套键/值对：一个为 catergories，一个为color。其实 catergories 的值是一个数组，“boot” 和 “winklepicker”被包含在中括号内组成一个数组。 按照这种方式，通过使用对象和数组，可以嵌套几组值， 随后便可在这些容器中放入不同的数据类型。 键可以引用原始数据类型，如：布尔，字符串，数字。它们也能以对象和数组形式表示更复杂的数据。键可以指向其他嵌套对象或其他对象的数组。 GeoJson是Json的一个特殊格式，进过定制可显示地理信息。 JSON代码格式化网站：jsonprettyprint ，jsonformatter,推荐 地震数据API：开发者文档 JSON解析从Json中获取感兴趣的内容：教程 字符串分割在 String 对象上调用的其他方法： length() - 返回字符串中的 字符数 contains(CharSequence cs) - 根据 原始字符串中是否包含输入 CharSequence （或输入 String）返回 true 或 false indexOf(String string) - 返回输入 String 首次在原始 String 中出现的位置的索引，如果 原始 String 中不存在输入 String，则返回 -1 split(String string) - 根据输入 String 中 指定的位置对原始 String 进行拆分， 并返回包含拆分后 String 部分的数组。 substring(int start, int end) - 返回 一个新的 String，该 String 为从开始索引到结束索引 之间的内容（包括开始索引但不包括结束索引）。 日期和时间转换。有 一个很奇妙的名为 SimpleDateFormat 的类，知晓所有关于时区的信息， 以及知晓如何按照世界的不同地区书写日期，它会 帮你处理这些难题。 提供一种所需的时间格式，如：”yyyy-MM-dd HH:mm:ss” 在时间格式语法中，字符具有特殊含义，这一点 在此表中进行了详尽阐述。 “y” 代表年，”yyyy” 代表 4 位数的年份，如 2016。 “M” 代表月，”MM” 代表 2 位数的月份，如 03。 “d” 代表日，”dd” 代表 2 位数的日期，如 10。 “H” 代表时。 “m” 代表分。 “s” 代表秒。 所有未在特殊字符表中列出的字符 都将在输出字符串中直接使用。例如，如果时间格式字符串 包含冒号、短划线或逗号，则输出字符串 也将在相应位置直接包含相同的标点符号。 下面是 1463159138711 毫秒的示例。我们使用 “yyyy-MM-dd HH:mm:ss a” 格式创建一个 SimpleDateFormat 对象，然后 传入一个以时间 1463159138711 毫秒初始化的 Date 对象，随后该日期的格式便会被设置为 “2016-05-13 12:07:46 PM”。 代码如下。首先通过调用 Date 构造函数将 以毫秒为单位的时间转换为 Date 对象。 long timeInMilliseconds = 1454124312220L; Date dateObject = new Date(timeInMilliseconds); 然后便可初始化 SimpleDateFormat 实例，并将其配置为 根据指定格式提供更易懂的表示。 SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;MMM DD, yyyy&quot;); String dateToDisplay = dateFormatter.format(dateObject); 执行完这 4 行代码后，dateToDisplay 的值 便会呈现为格式更为美观的日期：”Jan 29, 2016”。 如果 Android Studio 不识别这些类，你可能需要 在文件顶部手动导入它们。 import java.text.SimpleDateFormat; import java.util.Date; DecimalFormat如果我们想把数字设置为统一格式，比如都保留两位小数。 Android 中有一个类可以帮到我们！这个类叫做 DecimalFormat 类。顺便提一句， 还有 NumberFormat 类可用于处理所有 类型的数字的格式，但这是一个抽象类， 而 DecimalFormat 是一个具体类，我们可以与之交互。 要初始化 DecimalFormat 对象，你要传入一个 与已定义模式相匹配的格式字符串（与 SimpleDateFormat 类 的 year、month、date 符号类似）。特殊符号具有 特殊的意义（如 0 表示数字的占位符、# 也表示 数字，但是不显示前导零）。在 DecimalFormat 文档页面的表中有完整的列表。 以下是我们使用 DecimalFormat 格式方法的示例。 DecimalFormat formatter = new DecimalFormat(&quot;0.00&quot;); String output = formatter.format(2.3234);//传入的是double类型 由于我们指定 DecimalFormat 显示三位数字 (“0.00”)， 因此，对 2.3234 这样的数字进行格式化会将其缩短到 两位小数，从而输出字符串值 “2.32”。 如果未自动导入此类，你可能需要在文件顶部 导入这个类。 import java.text.DecimalFormat; Switch语句示例1： 示例2： 如果进入case ‘D’,则会运行到case ‘F’中的内容，这是因为只有遇到break，程序才会停止。 URL处理提取Json中的URL，并点击列表通过浏览器打开链接。教程 // 创建一个将地震列表视为输入的新适配器 final EarthquakeAdapter adapter = new EarthquakeAdapter(this, earthquakes); // 在 {@link ListView} 上设置适配器 // 以便可以在用户界面中填充列表 earthquakeListView.setAdapter(adapter); earthquakeListView.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) { // 查找单击的当前地震 Earthquake currentEarthquake = adapter.getItem(position); // 将字符串 URL 转换为 URI 对象（以传递至 Intent 中 constructor) Uri earthquakeUri = Uri.parse(currentEarthquake.getUrl()); // 创建一个新的 Intent 以查看地震 URI Intent websiteIntent = new Intent(Intent.ACTION_VIEW, earthquakeUri); // 发送 Intent 以启动新活动 startActivity(websiteIntent); } }); Google API]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频处理]]></title>
    <url>%2F2018%2F11%2F18%2F%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[实现音乐的播放和停止。 关于MediaPlayer类 实现具体步骤 添加音乐文件到res中： 新建一个Android Resource Directory，并选择Resource Type为Raw；然后将mp3格式的文件复制到该目录下。 创建一个全局变量mediaPlayer 初始化mediaPlayer 点击按钮时，响应播放start()和暂停音乐pause() Java代码部分：实现音乐的播放和停止 public class MainActivity extends AppCompatActivity { private MediaPlayer mediaPlayer; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mediaPlayer = MediaPlayer.create(this, R.raw.song); Button playButton = (Button) findViewById(R.id.play_button); playButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mediaPlayer.start(); } }); Button pauseButton = (Button) findViewById(R.id.pause_button); pauseButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mediaPlayer.pause(); } }); } xml代码部分：&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:text=&quot;Play&quot; android:id=&quot;@+id/play_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;Button android:text=&quot;Pause&quot; android:id=&quot;@+id/pause_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; MediaPlayer类中播放音频文件，通过状态机来管理的，这意味着随着MediPlayer播放歌曲，我们可以在不同状态之间过渡：播放，停止，播放，…。 状态机图表 MediaPlayer类中的create是一个静态方法，所以在调用时，需要要创建实例。 mediaPlayer = MediaPlayer.create(this, R.raw.song); 上述代码直接使用类的名称MediaPlayer，而不是对象变量的名称来调用create方法。 create方法的声明： public static MediaPlayer create (Context context, Uri uri, SurfaceHolder holder, AudioAttributes audioAttributes, int audioSessionId) 释放资源资源是有限的，在不需要使用时，我们应该将其释放。 /** * 通过释放资源，清除media player */ private void releaseMediaPlayer() { //如果media player不为空，当前可能正在播放音乐 if (mMediaPlayer != null) { //不管当前medid player的状态，释放它的资源 //因为不再需要它 mMediaPlayer.release(); //设置media player为空 mMediaPlayer = null; } } //创建一个全局mCompletionListener，防止每次播放音频都创建一次，浪费资源 private MediaPlayer.OnCompletionListener mCompletionListener = new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { releaseMediaPlayer(); } }; //设置一个media player监听器，以至于一旦音频播放完我们可以停止和释放media player mMediaPlayer.setOnCompletionListener(mCompletionListener); //直接释放资源，上面是通过监听播放完成后再释放资源 releaseMediaPlayer(); 生命周期Activity生命周期表 Android系统负责，将你的Activity过渡到这里的每个状态，作为开发者，无法控制你所在的状态。 当你的Activity被启动，该Activity通过onCreate方法进入Created状态。然后使用onStart方法进入Started状态。这时候，它对用户可见。通过onResume方法进入Resumed状态，此时，该Activity依然对用户可见；但现在用户可以开始与该Activity互动了，此时，可以播放动画，使用传感器。该Activity可以一直保持为Resumed状态，只要用户盯着该屏幕。一旦用户切换到其他Activity，那么你的Activity就会通过onPause方法进入Paused状态。并接着通过onStop方法进入Stopped状态。此时，该Activity对用户不再可见，因为用户无法再看到该Activity。如果系统判断不再需要你的Activity，就会通过onDestroy方法销毁你的Activity，以便释放设备上的资源，接着Activity就会进入Destroyed状态。否则，你的Activity可以保持在Stopped状态，在被销毁之前，如果用户决定回到该Activity，该Activity就会通过onRestart方法重新进入Started状态。 如何告诉系统你想要知道某些转换情况呢？ 例如，可能只希望当用户正在查看你的Activity时，屏幕才播放动画，一旦屏幕对用户不可见，就希望停止该动画。 和处理点击操作类似，系统通过方法回调，通知你正在发生生命周期转换情况，每个转换都有自己的回调。作为开发者，可以使用这些回调来干预和执行声明，例如恢复或保存任何数据，甚至清空不再需要的引用。 通过重新onStop方法，如果用户离开Activity，就释放资源。 //当用户离开当前Activity，立即释放资源 @Override protected void onStop() { super.onStop(); releaseMediaPlayer(); } Audio Focus为了避免多个音频播放APP同时播放音频，Android引进了audio fouce，某一时刻，只能有一个App拥有audio focus。当你的app需要输出音频，它应该请求andio focus。如果它拥有focus，它就可以播放音频。但是，在获得audio focus（音频焦点）后，您可能无法在完成播放之前保留它。 另一个应用程序可以请求焦点，这会抢占您对音频焦点的控制。 如果发生这种情况，您的应用应暂停播放或降低音量，以便用户更轻松地听到新的音频源。 请求audio focus的方法： 通过调用AudioManager类中的requestAudioFocus(); public int requestAudioFocus (AudioManager.OnAudioFocusChangeListener l, int streamType, //播放音频的类型，歌曲or铃声 int durationHint)//Audio focus所需的时长 释放audio focus的方法： 通过调用AudioManager类中的abandonAudioFocus(); 监听设备上audio focus的改变，比如系统需要暂时或永久从我们的应用拿走audio focus，以便对其作出响应： 创建OnAudioFocusChangeListener实例,然后实现OnAudioFocusChange回调方法。 该接口包含一个需要我们实现的抽象方法，提供代码，指定当audio focus发生更改时应执行什么操作。例如，如果我们失去audio focus，我们可能应该停止播放应用中的单词发音。 AudioManager是一项系统服务。系统服务可以为所有应用提供常见的功能，例如通知服务，或闹钟管理器服务。某些系统服务可以让我们访问设备上的硬件组件，例如位置信息管理器服务。但最终，系统服务只是一个Java类，可以通过获得对象实例然后对其调用方法来与其互动。 当audio focus状态发生变化时，应该调节音频的播放行为。正确操作如下： 请求Audio Focus 创建AudioManager.OnAudioFocusChangeListener实例，并实施回调方法 当Audio Focus状态发生变化时，调整播放行为 释放Audio Focus 按下状态设置类别视图上的按下状态 列表视图上的按下状态]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[台式安装Android Studio后出现虚拟机无法启动]]></title>
    <url>%2F2018%2F11%2F18%2F%E5%8F%B0%E5%BC%8F%E5%AE%89%E8%A3%85Android%20Studio%E5%87%BA%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在台式机上安装了Android Studio，想利用虚拟机来进行安装App，启动虚拟机时，遇到该问题。 具体问题：运行程序，在启动虚拟机时，出现如下错误： Emulator: Process finished with exit code 1 Emulator: ERROR: x86 emulation currently requires hardware acceleration! 原因：1 台式没有开启Virtualizatoin Technology进入BIOS，联想通过开机按F1进入； 有些系统是在Security选项中，有些系统是在Advance中。 将Intel (R) Virtualization Technoloyg设置为Enable。 2 下载HAXM并安装下载地址 解压文件，点击haxm-android.exe安装即可。 参考博客]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组、列表、循环和自定义类]]></title>
    <url>%2F2018%2F11%2F09%2FJava%E6%95%B0%E7%BB%84%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java基本知识，包括：数组、数组列表，for、while循环和自定义类 8种基本类型： 注意：String不是基本类型，它是一个字符串对象。其中第一个字母S需要大写。 数组Array创建一个数组： int [] shoeSizes = new int[3]; 初始化数组元素： shoeSize[0] = 5; shoeSize[1] = 7; shoeSize[2] = 10; 获取数组的长度： shoeSize.length 创建一个数组，并初始化，通过输入到日志消息查看是否实现： String [] words = new String[10]; words[0] = &quot;one&quot;; words[1] = &quot;two&quot;; words[2] = &quot;three&quot;; words[3] = &quot;four&quot;; words[4] = &quot;five&quot;; words[5] = &quot;six&quot;; words[6] = &quot;seven&quot;; words[7] = &quot;eight&quot;; words[8] = &quot;nine&quot;; words[9] = &quot;ten&quot;; Log.v(&quot;NumbersActivity&quot;,&quot;Word at index 0: &quot; + words[0]); 数组列表ArrayList 数组的大小是固定的，而数组列表的大小可以改变； 数组中可以存储原始数据类型（比如int,double）和对象类型，但数组列表只能存储对象类型； 数组不是类，不需要方法来访问和修改元素；数组列表被定义成类，意味着数组列表的每个实例都是对象，具有方法供我们访问和修改数据。 ArrayList类继承于AbstractList类，AbstractList是一个抽象类，抽象类是部分实现的类，表示某些方法已经实现，某些方法还是空着的。 Java中有很多其他类型的列表，比如链表、堆栈和向量等。 具体类：具有状态和所有方法的实现，比如ArrayList 抽象类：部分方法实现，比如AbstractList 接口：所有方法都没有实现，比如List 创建一个数组列表： ArrayList&lt;String&gt; musicLibrary = new ArrayList&lt;String&gt;(); 对数组列表添加元素: musicLibrary.add(“Yellow Submarine”); musicLibrary.add(&quot;Thriller&quot;); //在特定位置添加元素 musicLibrary.add(0,&quot;Blue Suede Shoes&quot;); 访问数组列表中的元素: musicLibrary.get(0); 删除数组列表中的元素： musicLibrary.remove(2); musicLibrary.remove(&quot;Thriller&quot;); 获取数组列表的长度： musiciLibrary.size(); 下面列出了常见的类型参数： E - 元素（Java Collections Framework 大量用到） K - 键 N - 数字 T - 类型 V - 值 S、U、V 等 - 第 2 种、第 3 种、第 4 种类型。 创建数组列表的例子： ArrayList&lt;String&gt; words = new ArrayList&lt;String&gt;(); words.add(&quot;one&quot;); words.add(&quot;two&quot;); words.add(&quot;three&quot;); words.add(&quot;four&quot;); words.add(&quot;five&quot;); words.add(&quot;six&quot;); words.add(&quot;seven&quot;); words.add(&quot;eight&quot;); words.add(&quot;seven&quot;); words.add(&quot;ten&quot;); Log.v(&quot;NumbersActivity&quot;,&quot;Words at index 0: &quot; + words.get(0)); 根据列表向布局添加剂TextViewLinearLayout rootView = (LinearLayout) findViewById(R.id.rootView); TextView wordView = new TextView(this); wordView.setText(words.get(0)); rootView.addView(wordView); 首先获取根视图，然后创建子视图，并设置子视图中的内容，最后，将子视图添加到父视图。 循环while循环while (条件){ 循环体 } for循环for(初始化count; 条件; 更新count){ 循环体 } 视图回收内存资源是有限的，应该节约使用。如果我们要显示1000个联系人，创建1000个1000TextView，这样大大浪费了内存，因为显示在屏幕中的仅仅几个。如是考虑重复使用TextView。 视图回收：表示重复使用在屏幕上不再可见的视图。这里的视图是单行布局，包括LinearLayout、RelativeLayout。 采用ListView和ArrayAdapter根据需要在屏幕上显示的内容，创建阻隔的视图，即列表项行。 如果某个视图在屏幕上不再可见时，我们可以通过更改相关数据重复使用该视图，及更改视图中的数据，例如TextView中的文本或ImageView中的图片，我们不需要浪费事件从头创建整个视图。我们将这些多徐的视图放入Screap Pile中并等着回收利用。 当用户正在滚动查看屏幕，想查看列表的顶部，看看最新的推文，ListView意识到需要快速创建更多的列表项行，当用户滚动的时候，似乎列表项一直都存在，它可以从Scrap Pile中选择一个视图，（如果存在的话）重复使用，而不是从头创建。我们通过使用Scrap Pile中的视图创建了更多的视图行，然后就只需更改视图中的数据，以便为相关列表项显示正确的信息。ListView同时还很智能地知道位于屏幕底部的视图已经被滚出屏幕，这些对用户来说已经不可见，可以之间添加到Scrap Pile中。当用户往上滚动时，我们就可以使用这钱位于屏幕底部的列表项行。所有这些的目标是尽量创建很少的列表项，因为从XML向Java对象隐形膨胀视图的代价很大。 当第一次将适配器与ListView相关联时，该ListView会询问“你想显示多少个项？”。ArrayAdapter知道这一信息，所以ListView对ArrayAdapter调用方法，它将在该方法中传入一个输入参数，即用户当前正在查看的列表位置。知道这一信息后，ArrayAdapter会查看数据的内部来源，如果列表是来源数据的话，它会查看列表，并获取相关信息。ArrayAdapter具有说明（Instructionss）来告诉ArrayAdapter如何创建列表项视图并返回ListView。当屏幕占满后，ListView将停止工作向ArrayAdapter寻求更多的列表项，列表项仅在需要是才创建。当视图被滚动离开屏幕后，它们就会被添加到这个Scrap Pile。然后，当我们请求新的列表项时，我们可以通过将这些视图在返回到ArrayAdapter重复使用它们。Listview将请求列表中特定位置的视图，同时传入之前用户的视图，例如，如果用户请求位置6的视图，会将可重复使用的以前的视图传给ArrayAdapter，ArrayAdapter可以通过在回收的视图中放入数据，使用回收的视图，比如，通过调用TextView setText()方法来更改这里的内容。 ArrayAdapter itemsAdapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, words); ListView listView = (ListView) findViewById(R.id.list); listView.setAdapter(itemsAdapter); 首先，使用new关键字以及具有三个输入参数的构造函数创建了一个ArrayAdapter对象，将其存储在itemsAdapter变量中，其数据类型是ArrayAdapter。第一个参数是Context，this指代NumbersActivity；第二个参数是列表项布局文件，这里指定为android.R.layout，因为Android框架实际上预定义了一个XMK布局文件，叫做simple_list_item_1，我们可以直接使用Android预定义的这个文件。最后一个参数是对象列表，即ArrayAdapter的数据来源。 前面使用ArrayList创建字符串数组列表，讨论了泛型。因为ArrayList是个泛型类，我们可以重写成ArrayList，E表示它是个泛型类，E是类型参数或占位符，可以替换为具体的对象类型。例如，当我们创建ArrayList实例时，可以替换为字符串。创建一个泛型类，可以让我们稍后判断他将存储的数据类型，而不用创建多个具体的类，例如StringList类，IntegerList类等等。 第二行，找到布局中的ListView。 第三行，setAdapter方法输入参数是一个ListAdapter，ListAdatper是一个接口，由BaseAdapter抽象类实现某些方法，同时为其他方法保留为抽象方法，这时需要ArrayAdatper，ArrayAdapter是一个具体的类，所有方法都实现了。我们可以创建一个ArrayAdapter对象实例，并在我们的应用中使用。因此，ArrayAdapter是一个listAdapter，可以将itemsAdapter变量传入为listView.setAdapter()方法调用的输入参数。 使用下拉菜单（Spinner）、网格视图（GridView）时，都需要使用到适配器ArrayAdapter。 构造列表项布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;16dp&quot;&gt; &lt;TextView android:id=&quot;@+id/default_text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;one&quot;/&gt; &lt;TextView android:id=&quot;@+id/miwok_text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;一&quot;/&gt; &lt;/LinearLayout&gt; tools命名空间在XML中，命名空间使元素之间没有名称冲突。xmlns:android是一个命名空间，我们已经在Android中使用的属性，例如android:layout_height等等以android:开头。 上面代码还添加一个命名空间，叫做tools命名空间 xmlns:tools=&quot;http://schemas.android.com/tools&quot; 上面这行代码表示将tools前缀映射到这个命名空间http://schemas.android.com/tools。任何以tools开头的元素或属性都属于tools命名空间的一部分。 tools:text=&quot;one&quot; 利用tools命名空间text来设置内容，在Android Studio的设计预览中将会显示此文本，但不会在运行时出现，这样为我们开发提供帮助。 自定义类package com.example.android.miwok; /** * 创建了一个Wrod类，用户可以使用 * 其包含一个默认翻译和一个Miwok翻译对于同一个单词 * */ public class Word { private String mDefaultTranslation; private String mMiwokTranslation; public Word(String defaultTranslation, String miwokTranslaton) { mDefaultTranslation = defaultTranslation; mMiwokTranslation = miwokTranslaton; } /** * Get the Miwok Translation * @return */ public String getMiwokTranslation() { return mMiwokTranslation; } /** * Get the defualt translation * @return string */ public String getDefaultTranslation(){ return mDefaultTranslation; } } 根据自定义的类Word，可以创建Word对象数组列表，并传递给ArrayAdapter。 ArrayList&lt;Word&gt; words = new ArrayList&lt;Word&gt;(); words.add(new Word(&quot;one&quot;,&quot;一&quot;)); words.add(new Word(&quot;two&quot;,&quot;二&quot;)); 自定义ArrayAdapterpackage com.example.android.miwok; import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ArrayAdapter; import android.widget.TextView; import java.util.ArrayList; public class WordAdapter extends ArrayAdapter&lt;Word&gt; { //构造函数 public WordAdapter(Context context, ArrayList&lt;Word&gt; objects) { super(context, 0, objects); } /**@Override public View getView(int position, View convertView, ViewGroup parent) { return super.getView(position, convertView, parent); }*/ @Override public View getView(int position, View convertView, ViewGroup parent) { // Check if the existing view is being reused, otherwise inflate the view View listItemView = convertView; if(listItemView == null) { listItemView = LayoutInflater.from(getContext()).inflate( R.layout.list_item, parent, false); } // Get the {@link AndroidFlavor} object located at this position in the list Word currentWord = getItem(position); // Find the TextView in the list_item.xml layout with the ID version_name TextView defaultTextView = (TextView) listItemView.findViewById(R.id.default_text_view); // Get the version name from the current AndroidFlavor object and // set this text on the name TextView defaultTextView.setText(currentWord.getDefaultTranslation()); // Find the TextView in the list_item.xml layout with the ID version_number TextView miwokTextView = (TextView) listItemView.findViewById(R.id.miwok_text_view); // Get the version number from the current AndroidFlavor object and // set this text on the number TextView miwokTextView.setText(currentWord.getMiwokTranslation()); // Return the whole list item layout (containing 2 TextViews) // so that it can be shown in the List return listItemView; } } 在 WordAdapter adapter = new WordAdapter(this,words); ListView listView = (ListView) findViewById(R.id.list); listView.setAdapter(adapter);]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别(三)--判别函数及几何分类法]]></title>
    <url>%2F2018%2F11%2F08%2F%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB(%E4%B8%89)--%E5%88%A4%E5%88%AB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%A0%E4%BD%95%E5%88%86%E7%B1%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[统计模式识别分为聚类分析和判别函数法两大类，聚类分析属于非监督分类，判别函数法属于监督分类。判别函数法需要有足够的先验知识，首先利用已知类别的训练样本集确定判别函数，然后利用训练好的判别函数对未知的模式进行识别分类 判别函数，又可以分为线性判别函数法，非线性判别函数和统计决策方法。其中线性判别函数和非线性判别函数法是几何分类法，用户研究确定性事件的识别非零。统计决策方法是概率分类法，用于研究随机事件的识别分类。 3.1 判别函数模式识别系统的主要作用是判别各个模式的所在类别。 若分属于ω1，ω2的两类模式可用一方程d(X)=0来划分，那么称d(X)为判别函数或称判决函数、决策函数。 例：一个二维的两类判别问题,模式分布如图示，这些分属于ω1，ω2两类的模式可用一直线方程d(X)=0来划分。 $d(X)=w_1x_1+w_2x_2+w_3=0$ 式中：$x_1,x_2$为坐标向量，$w_1,w_2,w_3$为方程参数。 如果$d(X)&gt;0$，则$X \in w_1$类； 如果$d(X)&lt;0$，则$X \in w_2$类； 如果$d(X)=0$，则$X \in w_1$或$X \in w_2$类或拒绝。 维数=3是：判别边界是一平面。维数&gt;3时，判别边界为一超平面。 3.2 线性判别函数如果一些模式类能用线性判别函数分开，则称这些模式类是线性可分的。 3.2.1 线性判别函数的一般形式将二维模式推广到n维，线性判别函数的一般形式为： $d(X) = w_1x_1+w_2x_2+\dots+w_nx_n+w_{n+1}=W_0^TX+w_{n+1}$ 式中：$X=[x_1,x_2,\dots,x_n]^T$，$W_0=[w_1,w_2,\dots,w_n]^T$；$W_0$是权向量，即参数向量。 增广向量形式： $d(X)=w_1x_1+w_2x_2+\dots+w_nx_n+w_{n+1} \cdot 1 = [w_1,w_2,\dots,w_n, w_{n+1}][x_1,x_2,\dots,x_n,1]^T = W^TX$ 式中：$X=[x_1,x_2,\dots,x_n,1]^T$，$W_0=[w_1,w_2,\dots,w_n,w_{n+1}]^T$为增广权向量。 3.2.1 线性判别函数的性质1.两类情况若已知两类模式$w_1,w_2$，则判别函数$d(X)=W^TX$，具有如下性质： $d(x)=0$是不可分情况。 2.多类情况对$M$个线性可分模式类，$w_1,w_2,\dots,w_M$，有三种划分方式： $w_i/\bar{w_i}$两分法 $w_i/w_j$两分法 $w_i/w_j$两分法特例 $w_i/\bar{w_i}$两分法用线性判别函数将属于$w_i$类的模式与其余不属于$w_i$类的模式分开。 将某个待分类模式$X$分别代入$M$个类的$d(X)$中，若只有$d_i(X)&gt;0$，其他$d(X)$均$&lt;0$，则判为$ω_i$类。 对某一模式区，$d_i(X)&gt;0$的条件超过一个，或全部的$d_i(X)&lt;0$，分类失效。相当于不确定区(indefinite region ，IR)。 $w_i/w_j$两分法一个判别界只能分开两个类别，不能把其余所有的类别都分开。能够分开$w_i$类和$w_j$类的判别函数为：$d_{ij}(X)=W_{ij}^TX$，这里$d_{ij}=-d_{ji}$。 判别函数性质： $d_{ij}(X)&gt;0, \forall j \neq i, i,j = 1,2,\dots, M$，若$X \in w_i$ 在$M$类模式中，与$i$有关的$M-1$个判决函数全为正时，$X \in ωi$。其中若有一个为负，则为IR区。 $w_i/w_j$两分法每分离出一个模式，需要$M-1$个判别函数，而要分离所有的$M$类模式，共需要$M(M-1)/2$个判别函数。 $w_i/w_j$两分法特例当$w_i/w_j$两分法中的判别函数$d_{ij}(X)$，可以分解为：$d_{ij}(X)=d_i(X)-d_j(X)$时，那么$d_i(X) &gt; d_j(X)$相当于多累情况2中的$d_{ij}(X)&gt;0$。 因此，具有判别函数：$d_i(X)=W^T_iX, i=1,\dots,M$的$M$类情况，判别函数性质为： $d_i(X) &gt; d_j(X) \forall j \neq i, i,j = 1,2,\dots, M$ 若$X \in w_i$ 或 $d_i(X) \max{\lbrace d_k(X), k= 1,2,\dots, M \rbrace} $ 若$X \in w_i$ 3.3 广义线性判别函数对非线性边界：通过某映射，把模式空间X变成$X^{\ast}$，以便将X空间中非线性可分的模式集，变成在$X^{\ast}$空间中线性可分的模式集。 1. 非线性多项式函数非线性判别函数的形式之一是非线性多项式函数。 设一训练用模式集$\lbrace x \rbrace$，在模式空间$X$中线性不可分，非线性判别函数形式如下： $d(X)=w_1f_1(X)+w_2f_2(X)+\dots+w_kf_k(X)+w_{+1} = \sum_{i=1}^{k+1}w_if_i(X)$ 其中$\lbrace f_i(X),i=1,2,\dots,k \rbrace$是模式$X$的单值函数，$f_{k+1}(X)=1$。 广义形式的模式向量为： $X^{\ast}=[x_1^{\ast}.x_2^{\ast},\dots,x_k^{\ast},1]^T=[f_1(X),f_2(X),\dots,f_k(X),1]^T$ 这里$X^{\ast}$空间的维数$k$高于$X$空间的维数$n$。$d(X)$可以改写为： $d(X) = W^TX^{\ast}=d(X^{\ast}), W=[w_1,w_2,\dots,w_k,w_{+1}]^T$ 上式是线性的。讨论线性判别函数并不会失去一般性的意义。 问题 非线性变换可能非常复杂 。 维数大大增加： 维数灾难。 3.4 线性判别函数的几何性质略 3.5 感知器算法对于线性判别函数，当模式的维数已知时判别函数的形式实际上就已经定了下来，如： 二维: $X=(x_1,x_2)^T, d(X)=w_1x_1+w_2x_2+w_3$ 三维： $X=(x_1,x_2，x_3)^T, d(X)=w_1x_1+w_2x_2+w_3x_3+w_4$ 剩下的工作就是确定权重向量，只要求出权重向量，分类器的设计即告成功。 算法描述 收敛性如果经过算法的有限次迭代运算后，求除了一个使训练集中所有样本都能正确分离的$W$,则称算法是收敛的。可以证明感知器算法是收敛的。对于感知器算法，只要模式是线性可分的，就可以在有限的迭代步数内求出权重向量的解。 3.6 梯度法3.7 最小平方误差算法感知器算法、梯度算法和固定增量算法或其他类似算法，只有当被分类模式可分离是才收敛，在不可分的情况下，算法会来回摆动，始终不收敛。另一方面，在训练样本较多的情况下，即使模式类线性可分的，也不可能事先算出达到收敛时所需的迭代步数。很难判断操作不收敛的原因是由于迭代过程收敛的缓慢还是由于模式本身就线性不可分。 最小平方误差（LMSE）算法的推导利用了梯度的概念，他除了对线性可分的模式类收敛，对线性不可分的情况也可以在算法的迭代过程中明确地指示出来。 1. 分类器的不等式方程两类分类问题的解相当于求一组线性不等式的解。如果给出分别属于$w_1,w_2$两个模式的训练样本集$\lbrace X_i,i=1,2,\dots,N\rbrace$，就可以求出权重向量$W$，它们的性质满足： $W^TX_i &gt; 0$ 则上式可以分开写为： 感知器算法就是通过解不等式组求得的W，如果模式是线性可分的，则X的每一个$(n+1) \times (n+1)$阶子矩阵的都等于$(n+1)$。 2. LMSE算法原理LMSE算法把满足$XW&gt;0$的求解，改为满足： $XW=B$ 的求解，式中$B=(b_1,b_2,\dots,b_n)^T$是各分离均为正值的矢量。因此该式于$XW&gt;0$是等价的。 在方程组中，方程的个数多余未知数个数时，也就是行数大于列数时，通常没有精确解存在，称为矛盾方程组，一般求解近似解。 在模式识别中，训练样本数$N$总是大于模式的维数$n$，因此上式中方程的个数大于未知数$W$分量的个数，是矛盾方程组，只能求近似解，方法是求满足： $||XW^{\ast}-B|| = 极小$ 的$W^{\ast}$，$W^{\ast}$称为最小二乘近似解，也称为最优解。LMSE算法的出发点就是选择一个准则函数$J$，使得准则函数最小，$XW=B$可以得到最小二乘近似解。依据这种思路，可将LMSE算法的准则函数定义为: $J(W,X,B)=\frac{1}{2}||XW-B||^2$ 准则函数可继续写成： $J(W,X,B)=\frac{1}{2}||XW-B||^2=\frac{1}{2}\sum_{i=1}^N(W^TX_i-b_i)^2$ 准则函数的值等于$W^TX_i$与$b_i$误差的平方之和，我们的目标是使这个误差的平方的最小化，由此称之为最小平方误差算法。 算法描述1、 将$N$个分属于$w_1$和$w_2$类的$n$维模式样本写成增广形式，将属于$w_2$的训练样本乘以-1，写出规范化增广样本矩阵$X$。 2、 求$X$得伪逆矩阵$X^{\ast}=(X^TX)^{-1}X^T$。 3、 设置初值$c$和$B(1)$，$c$为正得校验增量，$B(1)$的各分量大于零，括号中数字代表迭代次数$k=1$，开始迭代： 计算$W(1)=X^{\ast}B(1)$…. 4、 计算$e(k)=XW(k)-B(k)$，进行可分性判别。 如果$e(k)=0$，模式类线性可分，解为$W(k)$，算法结束。 如果$e(k)&gt;0$，模式类线性可分，有界。若进入第5步继续迭代，可是$e(k) \rightarrow 0$，得到最优解。 如果$e(k)&lt;0$，停止迭代，检查$XW(k)$，若$XW(k)&gt;0$，有解；否则无解，算法结束。 若不是上述任一种情况，说明$e(k)$的各分量值有正有负，进入第5步： 5、 计算$W(k+1)$和$B(k+1)$。 方法1：分别计算$W(k+1)=W(k)+cX^{\ast}$和$B(k+1)=B(k)+c[e(k)+|e(k)|]$ 方法2：先计算$B(k+1)=B(k)+c[e(k)+|e(k)|]$，再计算$W(k+1)=X^{\ast}B(k=1)$。 迭代次数$k$加1，返回第4步。]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent和Activity]]></title>
    <url>%2F2018%2F11%2F08%2FIntent%E5%92%8CActivity%2F</url>
    <content type="text"><![CDATA[介绍如何使用intent来切换Activity。 打开一个项目遇到的问题如果拿到一个项目，在本地打开查看，出现如下错误： 解决办法： 报错的原因是：在SDK中没有找到Android API 23的信息。在项目中需要使用到Android API 23，但是本地没有下载。 在File-&gt;Setting,进入如下界面： 错误二： 解决方案： 在此已经下载好，如果没有下载，点击23.0.2进行下载，然后应用。 问题三: android studio 升级到了3.0 取消了apt 报了这个错 在最上级的builde.gralde增加谷歌库 解决问题 allprojects { repositories { google()//新增的 jcenter() } } 如图操作： 新建Activity新建Activity 当我们创建新的Activity时，AndroidManifest.xml文件中，会自动添加我们创建的Activity,如下： Manifest文件相当于一个目录，总结了应用中重要的信息。当在设备上安装应用时，Android系统首先会查看此文件，然后再运行应用中的任何代码。 Manifest文件包含的内容： Java文件包名称（应用的唯一标识符） 应用组件 设置最低Android API:即指出该应用与哪些版本的Android平台兼容 Intent创建一个打开该应用内的Activity: public void openNumbersList(View View) { Intent numbersList = new Intent(this, NumbersActivity.class); startActivity(numbersList); } &lt;TextView android:id=&quot;@+id/numbers&quot; style=&quot;@style/CategoryStyle&quot; android:background=&quot;@color/category_numbers&quot; android:text=&quot;@string/category_numbers&quot; android:onClick=&quot;openNumbersList&quot;/&gt; 创建一个新的intent消息，需要输入两个参数。第一个参数context,我们传入this，表示当前的Activity，通常Context将帮助intent更详细地了解应用的当前状态，这样，可以将第二个Activity放在当前Activity前面。第二个参数是传入一个类组件，这里是我们需要打开的Activity的名称，最后要加上.class扩展内容，以表明这是一个特定的Java类。 Intent有两种类型： 隐式intent 显式intent 当不知道用户再被设备上安装了哪些应用时，隐式intent带来这种灵活性，比如当打开应用中一个网站，可以先浏览器应用发送一个intent来显示相关网站，无论哪个浏览器处理该intent都没关系，它们可以显示网站。 有时候，我们需要完全确定当我我们发送一个intent时，特定的组件会收到该intent，例如上述代码，点击Numbers，会发送一个显式intent，要求打开性的Activity并显示该类别中的内容。 显式应用通常用在同一个应用中，尽量避免用显式intent来打开第三方应用，因为我们不清楚用户是否安装该应用。 显式intent内容包括： context Component(一般为Class或Activity) 可选URI,某些情况下，我们可能需要设置数据URI，以便其他Activity能够接收某些信息 隐式intent内容包括： Action Data URI 可选：Category\Components\Extras 注意两种intent都可以处理intent Extrea。 修改Activity名称当进入另一个Activity时，左上角的标题没有改变，如果先从左图变成右图，需要在AndroidManifest.xml文件中对应的Activity中添加label标签： &lt;activity android:name=&quot;.NumbersActivity&quot; android:label=&quot;@string/category_numbers&quot;&gt;&lt;/activity&gt; 在string.xml文件中已经定义了category_numbers字符串： &lt;!-- Category name for the vocabulary words for numbers [CHAR LIMIT=20] --&gt; &lt;string name=&quot;category_numbers&quot;&gt;Numbers&lt;/string&gt; Android中的事件监听器在XML文件中，我们定义了按钮点击行为。在XML布局中的视图添加android:onClick属性: android:onClick=&quot;openNumbersList&quot; 我们进一步讲解如何在应用中运用到按钮代码逻辑。在后面我们仅修改Java代码，不对XML文件做出任何更改，来实现相同的按钮点击行为。 我们可以选在当特定视图上，发送特定的事件时，获得通知。在代码中，当这个特定事件发送时，我们可以知道。在某种程度上，可以将应用看成一只耳朵，可以监听感兴趣的信号，这些信号表示的就是特定的用户事件。一旦知道该事件发送了，就可以编写当用户与UI的特定部分互动时应该发生的情况。 为了事件这一流程，可以为视图创建一个事件监听器对象，指定该事件发送时应该出现什么情况。如果我们关心点击事件，就创建一个OnClickListener，并写调用onClick方法时应该发生的情况说明，这些说明可以是任何想要的内容。比如，当用户点击视图时，打开新的屏幕、更改视图的外观等等。创建OnClickListener后，最后一步将其附在我们想要监听点击操作的视图上。 在开发时，不需要知道具体细节，只要为我们关心的事件设置监听器，Android将复杂运行指定的代码。 每个监听器都提供了单个回调方法，为该方法编写代码。 在View.OnClickListener中。 当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用onClick()方法。 接口类，其中包含完全实现的状态和方法。比如，TextView，具有状态：字体大小、颜色、位置；方法：获取内容、设置颜色等等。 接口，其中不含状态，但包含方法。比如：OnClick()，该方法的内部逻辑需要用户编写。 创建监听器完成三步操作： 定义事件监听器以及事件发生时会出现的自定义行为 通过调用构造函数为事件监听器创建新的对象示例 为想要在其上面监听事件的视图附加该监听器 定义NumbersClickListener类创建对象示例附到监听点击行为的视图上 创建一个类，类文件名为：NumberClickListener.java： package com.example.android.miwok; import android.view.View; import android.widget.Toast; public class NumberClickListener implements View.OnClickListener{ @Override public void onClick(View View) { Toast.makeText(View.getContext(), &quot;Open the list of numbers&quot;, Toast.LENGTH_SHORT).show(); } } 在MainActivity中使用： //创建一个实例 NumberClickListener clickListner = new NumberClickListener(); //找到number目录对应的View TextView numbers = (TextView) findViewById(R.id.numbers); //将创建的实例附加到View numbers.setOnClickListener(clickListner); 一种简洁的方法创建监听器： //找到number目录对应的View TextView numbers = (TextView) findViewById(R.id.numbers); //将创建的实例附加到View numbers.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View View) { //创建一个intent来打开numberActivity Intent numberIntent = new Intent(MainActivity.this, NumbersActivity.class); //启动新创建的activity startActivity(numberIntent); } }); 如上，将定义类，实例化以及将实例化类附到View上三个步骤整合到一起。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VPN断开后无法连接互联网问题解决方案]]></title>
    <url>%2F2018%2F11%2F05%2F%E4%BD%BF%E7%94%A8VPN%E6%96%AD%E5%BC%80%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[有些时候，使用VPN后断开，会发现无法连接互联网，这是由于浏览器已经开启了局域网代理。 问题描述： 解决方案： 以Chrome为例，首先点击右上角的三个点，找到设置并打开。 取消勾选“为LAN使用代理服务器”，点击确定即可完成。]]></content>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Git提交代码至Github以及克隆]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%88%A9%E7%94%A8Git%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E8%87%B3Github%E4%BB%A5%E5%8F%8A%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[平常写的代码，希望保存下来，放本地不安全，所以放到Github上。 这里默认已经安全了Git，并根Github已经建立连接。具体可以参照博客，只要安装Git即可，TortoiseGit可以不用安装，TortioseGit是图形化界面操作，如果不喜欢命令行操作的可以安装。 下面，以提交一个APP工程文件为例。 我要提交上图中的所有文件到Github上。 第一步，在Github创建一个repository，如下： 第二步，将Github上的仓库克隆到本地（开始为空），如下： 此时，本地多一个名为myapplication的文件夹： 第三步：将除myapplication文件外的其他文件拷贝到myapplication文件中： 第四步：进入myapplication目录，并执行如下代码： cd myapplication git add. git commit -m &quot;log&quot; 由于文件过大，所以没有等到提交完成。 成功后，Github会显式刚才提交的代码： 最后，可以给自己提交的代码添加README.md文件来描述提交的内容。 至于克隆到本地，具体如步骤二。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象编程]]></title>
    <url>%2F2018%2F10%2F31%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java一般语法，以及在Android开发中的知识点和注意事项。 private int calculatePrice(int quantity) {} private是访问修饰符，比如：public或private。这意味着calulatePrice方法只能被MainActivity里的其他方法调用，之外的部分无法调用它。如果声明位public，则所有代码都可以访问它。 int为返回类型。返回一个整型。 calculatePrice为函数名。 资源资源放在文件res目录下，资源包括：图片、布局、 访问资源: 在Java代码中： R.类型名.资源名，当编译项目时，Android中有一个AAPT的工具，会产生一个R类，（即一个叫R.java的文件）。 在XML代码中： @类型名/资源名 Java文件中有如下代码： setContentView(R.layout.activity_main); 该行代码表示我们引用了activity_main布局文件，展示了MainActivity怎么加载XML文件。 对象XML中的视图，比如TextView、imageView实际上是通过应用里的Java对象控制的。 一个TextView对象有属性: 字体大小 字体颜色 字体 方法： setText() getText() setTextSize() getTextSize() onDraw() 可以通过查看TextView.java文件，来指导TextView类有哪些属性和方法。 TextView类的简化版： /** * Displays text to the user. */ public class TextView extends View { // String value private String mText; // Text color of the text private int mTextColor; // Context of the app private Context mContext; /** * Constructs a new TextView with initial values for text and text color. */ public TextView(Context context) { mText = &quot;&quot;; mTextColor = 0; mContext = context; } /** * Sets the string value in the TextView. * * @param text is the updated string to be displayed. */ public void setText(String text) { mText = text; } /** * Sets the text color of the TextView. * * @param color of text to be displayed. */ public void setTextColor(int color) { mTextColor = color; } /** * Gets the string value in the TextView. * * @return current text in the TextView. */ public String getText() { return mText; } /** * Gets the text color of the TextView. * * @return current text color. */ public int getTextColor() { return mTextColor; } } 创建对象通过调用构造函数来初始化一个对象 TextView priceTextView = new TextView(content) 其中TextView(context)是调用构造函数，context是一个语境，可以帮助获取应用资源以及其他与语境有关的内容。 通过工厂方法来创建一个对象 MediaPlayer player = MediaPlayer.create(context, R.raw.song); 其中create是MediaPlayer的工厂方法，得到一个名字为player的MediaPlayer对象。 构造函数创建对象使用较多，而工厂方法创建对象使用较少。至于使用哪一种方法，通过查看开发手册得知。 对象调用方法调用格式： 对象名.方法名(输入参数); titleTextView.setText(&quot;News&quot;); titleTextView.setTextSize(18); titleTextView.setTextColor(Color.RED); 在类内部调用和类外部调用的区别： 类内部可以访问私有属性和私有方法，而外部只能访问类的公开方法和属性。另外，类内部访问不需要添加对象名，因为默认是this。而类外部访问需要添加对象名，如下： 继承Java代码中，开始处有如下代码： public class MainActivity extends AppCompatActivity { int scoreTeamA = 0; int scoreTeamB = 0; @Override } extends AppCompatActivity表明类MainActivity继承了AppCompatActivity的属性和方法。 如下方法，在MainActivity中没有定义，因此是继承自AppCompatActivity: setContentView(R.layout.activity_main); TextView scoreView = (TextView) findViewById(R.id.team_b_score); 下面的代码，在方法声明前添加@override表明这是重载函数，即该函数在AppCompatActivty类中已经定义，但是在这里重新定义，做出一些修改。 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 不同视图之间存在一些共性，比如，都具有大小、可以隐藏、位置等等。为了减少代码量，可以将这些相同的内容提出，放到一个新类View中，然后这些视图继承于View类。具体如下： 这样，TextView类中只要编写与View类不同的部分，以及不希望继承View的内容重新编写即可。这样，TextView、ImageView、Button继承于View。 通过资源编号获取视图对象onCreate(R.layout.activity_main) 方法，是根据XML文件中的布局建立一个视图层次结构，如下： 具体原理如下： findViewByid(int id) 会找到传入的id相对应的View。findViewByid方法编程视图结构，找到视图层次结构中的某个View。该方法的返回值是View类型的对象。 findViewByid()方法返回的View类型，通常我们要使用具体的视图比如：TextView。因此需要进行强制转换： private void displayForTeamB(int score) { TextView scoreView = (TextView) findViewById(R.id.team_b_score); scoreView.setText(String.valueOf(score)); } 其中(TextView)就是将View类型强制转换成TextView类型。如果不强制转换的话，无法调用setText()方法，因此View类型不具有该方法，只有TextView对象具有该方法。 视图中读取数据Getter 和 Setter 方法概述 已经使用过方法了，例如 setText 和 setImageResource。这些叫做 setter 方法，因为它们负责修改或操控视图的某个值（例如视图存储的文本或图片）。按照惯例，它们以“set”开头。 还有一种类别的方法，叫做getter方法，它们的唯一目的是从视图中“获取”值，例如获取视图的当前文本。按照惯例，它们以“get”开头。在下个练习中，我们将用到一些 getter 方法。 日志先Android日志中写消息，在代码中写出如下类似的语句： Log.i(&quot;EnterpriseActivity.java&quot;, &quot;Captain&apos;s Log, Stardate 43125.8. We have entered a spectacular binary star system in the Kavis Alpha sector on a most critical mission of astrophysical research.&quot;); 第一个参数是日志语句来自的类的名称，第二个参数是想要显式地文字。 这里，我们使用了 Log.i()，表示“信息”级别的日志。其他级别的选项如下所示： e(String, String)（错误） w(String, String)（警告） i(String, String)（信息） d(String, String)（调试） v(String, String) (详情) 读取TextView的内容，并输入到日志中： TextView textViewItem3 = (TextView) findViewById(R.id.menu_item_3); String menuItem3 = textViewItem3.getText().toString(); Log.v(&quot;MainActivity&quot;, menuItem3); 复选框组件： &lt;CheckBox android:id=&quot;@+id/whipped_cream_checkbox&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Whipped Cream&quot; android:layout_marginLeft=&quot;16dp&quot; android:paddingLeft=&quot;16dp&quot; android:textSize=&quot;26sp&quot;/&gt; Java代码中获取CheckBox的状态，并在写入日志消息中： CheckBox whippedCreamCheckBox = (CheckBox) findViewById(R.id.whipped_cream_checkbox); boolean hasWhippedCream = whippedCreamCheckBox.isChecked(); Log.v(&quot;MainActivity&quot;,&quot;The checkbox is &quot; + hasWhippedCream); 布尔类型声明： boolean hasWhippedCream = false; 变量名开头一般为“is”或“has”，这样，看变量名就知道该变量为布尔类型。 滚动条在原来的代码的基础上，最外层套一个ScrollView视图即可，具体如下： 对于线性布局 &lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout&gt; ... &lt;/LinearLayout&gt; &lt;/ScrollView&gt; 对于相对布局 &lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;RelativeLayout&gt; ... &lt;/RelativeLayout&gt; &lt;/ScrollView&gt; 输入框XML中 &lt;EditText android:id=&quot;@+id/name_edit_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;Name&quot; android:inputType=&quot;textCapCharacters&quot; android:layout_marginTop=&quot;16dp&quot;/&gt; Java代码中： EditText nameEditText = (EditText) findViewById(R.id.name_edit_view); String name = nameEditText.getText().toString(); EditText继承于TextView，所以它具有getText方法。 在此，getText()返回类型为EditText，所以需要使用.toString将其转换为字符串类型。 if/elseif (numberOfGuests &lt; 6) { tip = 50; } else if (numberOfGuests &lt; 20) { tip = 100; } else { tip = 1000; } ToastToast用来在屏幕上显式消息。比如，如果预定的咖啡数量不能小于1，当数量等于之后，用户再点击减少时，在屏幕显示“预定咖啡数量不能小于1”。如下： if (quantity &lt; 1) { //通过toast,给出一个错误信息 Toast.makeText(this, &quot;You cannot have less than 1 coffees.&quot;, Toast.LENGTH_LONG).show(); //退出这个方法 return; } 创建Toast消息，需要调用Toast.makeText方法，并且输入三个参数，输入context指向这个activity。第二个参数是在屏幕上显示的消息内容。第三个参数指定它在屏幕显示的时间。最后这个对象调用show()方法来显示该消息。 intent消息intent消息包含两个主要内容： 动作 数据 还可以指定额外消息： 种类 成分 其他 这些内容可以让Android决定哪个应用来处理该intent消息。 比如，电话intent消息： ACTIO_DAIL tel:2125551212 注意数据格式采用：URI（uniform resource identifier），这是构建数据的标准方法。这样才可以正确处理该消息。 添加一个邮件intent: Intent intent = new Intent(Intent.ACTION_SENDTO); intent.setData(Uri.parse(&quot;mailto:&quot;));//仅仅邮件APP处理该消息 intent.putExtra(Intent.EXTRA_SUBJECT, &quot;Just Java order for &quot; + name);//邮件标题 intent.putExtra(Intent.EXTRA_TEXT, priceMessage);//邮件内容 if (intent.resolveActivity(getPackageManager()) != null) //只有当APP接受了该消息，才开始启动 startActivity(intent); 本地化res-&gt;values该目录下是默认的语言文件。如果希望能根据系统语言来适配APP的语言，我们需要添加不同语言的资源文件。具体如下： 其中values-es表示西班牙语资源文件，values-fr表示法国语言资源文件。语言资源文件的格式如下： &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;My Application&lt;/string&gt; &lt;/resources&gt; 中间可以随机添加字符串。name表示该字符串的名字。在XML文件中，可以如下调用它： android:text = &quot;@string/name&quot; 在Java代码中，调用： getString(R.string.name); 这样，就不需要再XML和Java代码中出现字符串，字符串全部放在资源文件中。 在有些时候，可能不想翻译一部分文本字符串。例如，我们想要创建一个字符串，然后，留出一个空隙来添加变量。这个时候，需要使用xliff标签来标出不被翻译的部分。翻译用户的名字没有意义，但是翻译Name是有意义的。xliff标签给出一个名字的ID,在xliff标签中可以放入不用翻译的字符串，使用%s来代替，稍后会被id为name的字符串取代。具体如下： //resource &lt;string name = &quot;order_summary_name&quot;&gt;Name: &lt;xliff:g id=&quot;name&quot; example&quot;Amy&quot;&gt;%s&lt;/xliff:g&gt;&lt;/string&gt; //java String priceMessage = getString(R.string.order_summary_anme, name); 以表格的形式查看resource文件中的语言种类： 样式styles.xml文件中定义样式： &lt;!--style for a header TextView--&gt; &lt;style name=&quot;CustomText&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;26sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;#4527A0&lt;/item&gt; &lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt; &lt;/style&gt; 布局文件中调用styles.xml文件中的样式： &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;TOPPINGS&quot; style=&quot;@style/CustomText&quot; /&gt; 调用的格式如： style=&quot;@style/样式名字&quot; 主题styles.xml文件中最开始的代码： &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#009688&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;#00796B&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;#536DFE&lt;/item&gt; &lt;/style&gt; 这是用来设置主题的风格，所有的视图都会使用该样式。可以改变应用栏或状态栏的颜色等特征。 样式被应用于一个单一的View，而主题被应用到活动或者应用中的所有View。 Android中有一些自带的标准系统主题。 定义分别如下： 在此，使用上述第二种主题。在styles.xml文件中，使其称为父主题： #80DEEA #000000 #536DFE #E0F7FA 还可以在上述代码中，设置不同区域的颜色，这样会覆盖父主题的默认值。不同区域的名称： 应用清单每个应用的根目录中都必须包含一个AndroidManifest.xml文件（且文件名精确无误）。 清单文件向 Android 系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。 &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; android:theme=&quot;@style/AppTheme&quot;指出了所有活动都使用AppTheme主题，如果将该语句放到MainActivity活动中，这仅该活动使用AppTheme主题。由于上述代码中就一个活动，因此放在哪里都没关系。其中AppTheme主题风格在styles.xml文件的开头定义的。如下: &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; &lt;activity android:name=&quot;.MainActivity&quot; android:theme=&quot;@style/AppTheme&quot;&gt;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; Android-找不到R类问题的解决方法 重新检查资源文件中XML文件的有效性如果最近一次编译时未生成R.java文件，则会引起项目资源引用错误，通常这是由于布局文件中的拼写错误导致的。因无法校验布局文件的有效性，IDE往往无法进行输入错误警示。改正错误并保存xml文件，IDE会重新生成R.java文件。 删除gen目录若以上方法还不能够重新生成R.java文件，可以删除整个gen目录，IDE会重新生成R.java文件。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作一款交互性应用]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%B6%E4%BD%9C%E4%B8%80%E6%AC%BE%E4%BA%A4%E4%BA%92%E6%80%A7%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[设计一个简单的计数模块，比如预定咖啡的数量，点击Order计算咖啡的总价格。 篮球计分器：代码 效果： 利用java进行交互在本次实现，学会创建java变量，以及使用java的全局变量quantity。代码如下： MainActivity.java /** * Add your package below. Package name can be found in the project&apos;s AndroidManifest.xml file. * This is the package name our example uses: * * package com.example.android.justjava; */ package com.example.myapplication; import java.text.NumberFormat; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.TextView; import com.example.myapplication.R; /** * This app displays an order form to order coffee. */ public class MainActivity extends AppCompatActivity { int quantity = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } /** * This method is called when the order button is clicked. */ public void submitOrder(View view) { displayPrice(quantity * 5); } public void increment(View View) { quantity = quantity + 1; display(quantity); } public void decrement(View View) { quantity = quantity - 1; display(quantity); } /** * This method displays the given quantity value on the screen. */ private void display(int number) { TextView quantityTextView = (TextView) findViewById(R.id.quantity_text_view); quantityTextView.setText(&quot;&quot; + number); } private void displayPrice(int number) { TextView priceTextView = (TextView) findViewById(R.id.price_text_view); priceTextView.setText(NumberFormat.getCurrencyInstance().format(number)); } } activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;Quantity&quot; android:textAllCaps=&quot;true&quot;/&gt; &lt;Button android:onClick=&quot;increment&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:text=&quot;+&quot; android:textSize=&quot;30sp&quot;/&gt; &lt;TextView android:id=&quot;@+id/quantity_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_margin=&quot;16dp&quot; android:textColor=&quot;@android:color/black&quot; android:text=&quot;0&quot; /&gt; &lt;Button android:onClick=&quot;decrement&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:textSize=&quot;30sp&quot; android:text=&quot;-&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;PRICE&quot; /&gt; &lt;TextView android:id=&quot;@+id/price_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_marginLeft=&quot;16dp&quot; android:textColor=&quot;@android:color/black&quot; android:text=&quot;$0&quot; /&gt; &lt;Button style=&quot;@style/Widget.AppCompat.Button&quot; android:layout_width=&quot;134dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;ORDER&quot; android:textSize=&quot;26sp&quot; android:onClick=&quot;submitOrder&quot;/&gt; &lt;/LinearLayout&gt; 效果： 实现Java字符串处理，包括创建一个字符串变量，字符串相加等。以及布局中的嵌套LinearLayout。具体代码如下： MainActivity.java /** * Add your package below. Package name can be found in the project&apos;s AndroidManifest.xml file. * This is the package name our example uses: * * package com.example.android.justjava; */ package com.example.myapplication; import java.text.NumberFormat; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.TextView; import com.example.myapplication.R; import org.w3c.dom.Text; /** * This app displays an order form to order coffee. */ public class MainActivity extends AppCompatActivity { int quantity = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } /** * This method is called when the order button is clicked. */ public void submitOrder(View view) { String priceMessage = &quot;Price $ &quot; + (quantity * 5) + &quot;\n&quot; + &quot;Thank your!&quot;; displayMessage(priceMessage); /** displayPrice(quantity * 5);*/ } public void increment(View View) { quantity = quantity + 1; display(quantity); } public void decrement(View View) { quantity = quantity - 1; display(quantity); } /** * This method displays the given quantity value on the screen. */ private void display(int number) { TextView quantityTextView = (TextView) findViewById(R.id.quantity_text_view); quantityTextView.setText(&quot;&quot; + number); } private void displayPrice(int number) { TextView priceTextView = (TextView) findViewById(R.id.price_text_view); priceTextView.setText(NumberFormat.getCurrencyInstance().format(number)); } /**显式字符串*/ private void displayMessage(String str) { TextView priceTextView = (TextView) findViewById(R.id.price_text_view); priceTextView.setText(str); } } activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;Quantity&quot; android:textAllCaps=&quot;true&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:onClick=&quot;decrement&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:textSize=&quot;30sp&quot; android:text=&quot;-&quot;/&gt; &lt;TextView android:id=&quot;@+id/quantity_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_marginLeft=&quot;16dp&quot; android:textColor=&quot;@android:color/black&quot; android:layout_gravity=&quot;center_vertical&quot; android:text=&quot;0&quot; /&gt; &lt;Button android:onClick=&quot;increment&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:text=&quot;+&quot; android:textSize=&quot;30sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;PRICE&quot; android:textSize=&quot;26sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/price_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;26sp&quot; android:layout_marginLeft=&quot;16dp&quot; android:textColor=&quot;@android:color/black&quot; android:text=&quot;$0&quot; /&gt; &lt;Button style=&quot;@style/Widget.AppCompat.Button&quot; android:layout_width=&quot;134dp&quot; android:layout_height=&quot;50dp&quot; android:layout_margin=&quot;16dp&quot; android:text=&quot;ORDER&quot; android:textSize=&quot;26sp&quot; android:onClick=&quot;submitOrder&quot;/&gt; &lt;/LinearLayout&gt; 效果：]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发实践]]></title>
    <url>%2F2018%2F10%2F30%2FAndroid%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Anddroid Studio(AS)安装和使用教程。 Android Studio安装分为两步： 安装JDK(Java Development Kit（Jave开发工具包）)：JDK让电脑读取并运行Java语言 安装Android Studio Android Studio是开发APP的工作环境，没有JDK的支持，它是无效的。 制作卡片分为三个步骤： 选择合适的视图 确定视图的位置 选择合适的风格 代码： &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/androidparty&quot; android:scaleType=&quot;centerCrop&quot;/&gt; &lt;TextView android:text=&quot;Happy Birthday Ben!&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:textSize=&quot;36sp&quot; android:textColor=&quot;@android:color/white&quot; android:fontFamily=&quot;san-serif-light&quot; /&gt; &lt;TextView android:text=&quot;From Layin&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:paddingBottom=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; android:textSize=&quot;36dp&quot; android:textColor=&quot;@android:color/white&quot; android:fontFamily=&quot;san-serif-light&quot;/&gt; &lt;/RelativeLayout&gt; 注意： 视图的顺序，决定了视图放置的位置。如果，图片视图放置在最后，文字视图将会被覆盖，无法看到。 图片等比放大，充满整个屏幕，使用centerCrop值 公司简介&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:id=&quot;@+id/Image_Relative&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:src=&quot;@drawable/androidparty&quot; android:scaleType=&quot;centerCrop&quot;/&gt; &lt;TextView android:text=&quot;南京维达科技有限公司&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:textSize=&quot;46sp&quot; android:textColor=&quot;@android:color/white&quot; android:fontFamily=&quot;san-serif-light&quot; /&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/Image_Relative&quot; android:layout_margin=&quot;16dp&quot;&gt; &lt;TextView android:id=&quot;@+id/address_text&quot; android:text=&quot;地址：南京市江宁区东南大学&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:paddingBottom=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; android:textSize=&quot;36dp&quot; android:fontFamily=&quot;san-serif-light&quot;/&gt; &lt;TextView android:id=&quot;@+id/phone_text&quot; android:layout_below=&quot;@id/address_text&quot; android:text=&quot;电话：18212345678&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;36dp&quot; android:paddingBottom=&quot;16dp&quot; android:fontFamily=&quot;san-serif-light&quot;/&gt; &lt;TextView android:id=&quot;@+id/introduction_text&quot; android:layout_below=&quot;@id/phone_text&quot; android:text=&quot;公司介绍：上海若讷信息科技有限公司是一家专注于云计算实用化的科技公司，公司成员大部分来自华为、阿里巴巴等知名科技公司。下一个十年将是云计算不断深入社会各行各业的过程，若讷信息技术瞄准这个目标，与其他同行一起将推动云计算的应用，提升云计算在政府、企事业单位、厂矿、小微企业、甚至是个人用户客户的渗透率。&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;28dp&quot; android:fontFamily=&quot;san-serif-light&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt;]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用开发前准备--快速开发APP(一)]]></title>
    <url>%2F2018%2F10%2F30%2F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B--%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91APP(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[APP开发的前期准备，包括，原型设计、UI设计和应用开发。 项目开发流程项目开发流程：项目需求 原型设计：根据项目需求设计产品原型 UI设计：利用原型设计，进行界面设计 应用开发：根据原型设计和UI设计的图片开发 案例分析项目需求分析：美食APP–一款美食服务APP。为用户推荐附近美食，提供店铺评价信息、自诩电话、店铺地址定位等，以移动互联网为入口，满足用户的日常需求。 项目功能： 美食APP功能模块： 原型设计]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造布局]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%89%93%E9%80%A0%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[介绍基本的视图，包括文本视图、图片视图；以及开发环境和软件。最后，介绍开发中的注意事项和开发文档查询。 视图视图包括： 图片视图 View 文本视图 TextView 按钮 环境IDE：集成开发环境（Integrated Development Environment） Android开发中，使用Android Studio 使用的语言：XML-可扩展标记语言（Extensible Markup Language）可以用来描述Android应用的外观，可以用它来构建布局。 第一行代码第一行代码： &lt;TextView android:text=&quot;Happy Birthday!&quot; android:background=&quot;@android:color/darker&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;75dp&quot; /&gt; XML语法&lt;视图名称 属性 /&gt; 或者 &lt;视图名称&gt; 属性:决定行为或者视图效果的特性 &lt;/视图名称&gt; &lt;TextView&gt; android:text=&quot;Happy Birthday!&quot; android:background=&quot;@android:color/darker&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;75dp&quot; &lt;/TextView&gt; dp: 表示独立密度像素（Density-independent pixels），使用该单位时，视图会根据不同设备的分辨率进行调整。 比如，有三个不同的分布率的设备，定义一个高为2像素，宽为2像素(px)的按钮： 这样，分辨率更大的手机上无法用手指去点击它，这是因为极高频率设备不代表我们有更小的手指。这就是dp的原因： wrap_content：自动根据文字内容来设置视图大小 &lt;TextView&gt; android:text=&quot;Happy Birthday!&quot; android:background=&quot;@android:color/darker&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; &lt;/TextView&gt; 更改字体大小： &lt;TextView&gt; android:text=&quot;Happy Birthday!&quot; android:background=&quot;@android:color/darker&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;45sp&quot; &lt;/TextView&gt; sp:代表规模独立的像素，是一个测量单位跟应用里面的dp很像，只用在字体上因为它是根据用户的偏好进行调整。 更改字体颜色： android:textColor=&quot;#AED581&quot; 图片视图：&lt;ImageView android:src=&quot;@drawable/cake&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:scaleType=&quot;center&quot;/&gt; scaleType属性值为centerCrop时，将放大图片以填充满屏幕。CenterCrop可以均匀的条件图像，意味着它始终保持纵横比。等比条件，可以避免图片水平或垂直地拉长。 LinearLayout–ViewGroup视图ViewGroup可以控制子视图的位置，每个子视图都是其他子视图的兄弟姐妹。包括： 线性布局LinearLayout:可以使子视图垂直排列，可以将子视图排列在一个水平行上。 相对布局RelativeLayout: 放置它的子视图上有它独特的规则，比如，它跟根据父视图的位置放置子视图，另一个功能是能将子视图放置在相对于其他子视图的位置上。如下图： 第一个TextView可以跟ImageView上对其，第二TextView可以更改ImageView下对其。 视图组： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:text=&quot;Guest List&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;TextView android:text=&quot;Kunal&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;TextView android:text=&quot;Kunal&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;/LinearLayout&gt; 第一行是XML命名空间声明，使用这个命名空间就是为了指定所有属性都属于android。这个操作，给android指定一个唯一的URL。可以创建自定义属性，为了防止命名冲突，会在属性名之前添加前缀，android:表明是android的属性。基本上，时刻记住在XML文件的根视图中的起始标签后添加XML命名空间的声明。 视图标签的顺序决定了视图在屏幕放置的顺序。 Match Parent下图描述了三种不同的子视图大小的设置分别为：固定200dp，wrap_content（根据内容自适应大小）以及根据父视图自适应 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/darker_gray&quot;&gt; &lt;TextView android:text=&quot;VIP List&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#4CAF50&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;TextView android:text=&quot;Kunal&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#4CAF50&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;TextView android:text=&quot;Kagure&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#4CAF50&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;TextView android:text=&quot;Lyla&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#4CAF50&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;/LinearLayout&gt; 权重需要设置权重时，要将该子视图的宽度或高度设置为0。如下： android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; 如果没有设置权重时，默认为0，则该子视图为默认大小。权重越大所占屏幕区域越大。权重大小可以为任意整数值，比如1，2，9等。如果多个子视图的权重值相同，则这些子视图的将均分剩余的可用区域。 示例： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:src=&quot;@drawable/ocean&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;5&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;TextView android:text=&quot;You&apos;re invited!&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;54sp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#009688&quot; /&gt; &lt;TextView android:text=&quot;Bonfire at the beach&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;34sp&quot; android:background=&quot;#009688&quot; /&gt; &lt;/LinearLayout&gt; RelativeLayout–ViewGroup布局参数在子视图中声明，父ViewGroup用它们来布局子视图。 子视图相对父视图的位置： android:layout_alignParentTop = &quot;true&quot; //与父视图顶部对齐 android:layout_alignParentLeft = &quot;true&quot; //与父视图左侧对齐 设置水平居中： android:layout_centerHorizontal = &quot;true&quot; 垂直居中： android:layout_centerVertical = &quot;true&quot; 示例： &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:textAppearance=&quot;?android:textAppearanceLarge&quot; android:text=&quot;Happy&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot; android:textAppearance=&quot;?android:textAppearanceLarge&quot; android:text=&quot;Birthday&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textAppearance=&quot;?android:textAppearanceLarge&quot; android:text=&quot;To You&quot; /&gt; &lt;/RelativeLayout&gt; 相对与其他子视图： &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/lyla_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Lyla&quot; /&gt; &lt;TextView android:id=&quot;@+id/me_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_toRightOf=&quot;@id/lyla_text_view&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Me&quot; /&gt; &lt;TextView android:id=&quot;@+id/natalie_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Natalie&quot; /&gt; &lt;TextView android:id=&quot;@+id/jennie_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Jennie&quot; /&gt; &lt;TextView android:id=&quot;@+id/omoju_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_above=&quot;@id/jennie_text_view&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Omoju&quot; /&gt; &lt;TextView android:id=&quot;@+id/amy_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_toLeftOf=&quot;@id/jennie_text_view&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Amy&quot; /&gt; &lt;TextView android:id=&quot;@+id/ben_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Ben&quot; /&gt; &lt;TextView android:id=&quot;@+id/kunal_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_toLeftOf=&quot;@id/ben_text_view&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Kunal&quot; /&gt; &lt;TextView android:id=&quot;@+id/kagure_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:textSize=&quot;24sp&quot; android:text=&quot;Kagure&quot; /&gt; &lt;/RelativeLayout&gt; 子视图相对位置练习示例 &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;ImageView android:id=&quot;@+id/image_view&quot; android:layout_width=&quot;56dp&quot; android:layout_height=&quot;56dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/ocean&quot; /&gt; &lt;TextView android:id=&quot;@+id/pebble_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toRightOf=&quot;@id/image_view&quot; android:text=&quot;Pebble Beach&quot; android:textAppearance=&quot;?android:textAppearanceMedium&quot; /&gt; &lt;TextView android:id=&quot;@+id/California_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;California&quot; android:layout_below=&quot;@id/pebble_text_view&quot; android:layout_toRightOf=&quot;@id/image_view&quot; android:textAppearance=&quot;?android:textAppearanceSmall&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;10 miles away&quot; android:layout_below=&quot;@id/California_text_view&quot; android:layout_toRightOf=&quot;@id/image_view&quot; android:textAppearance=&quot;?android:textAppearanceSmall&quot; /&gt; &lt;/RelativeLayout&gt; margin和paddingpadding是在视图内部进行填充，而margin是使得子视图距父视图边缘的距离。 android:padding=&quot;8dp&quot; android:paddingLeft=&quot;8dp&quot; android:paddingRight=&quot;8dp&quot; android:paddingTop=&quot;8dp&quot; andorid:paddingBottom=&quot;8dp&quot; android:layout_magrin=&quot;8dp&quot; android:layout_magrinLeft=&quot;8dp&quot; Android开发文档：英文版 中文版]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挑糖果游戏]]></title>
    <url>%2F2018%2F10%2F28%2F%E6%8C%91%E7%B3%96%E6%9E%9C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[游戏设置：这里有一排糖果，两个人分别轮流从中抓取一块或两块（注：抓取的两块必须是挨着的）。 中奖规则：谁拿到了最后的糖果，谁就是胜者！ 算法要求：编写一条算法：保证先抓的人一定能赢。 思路A、B两个人， 1.如果这里有3块糖果，A先拿走了中间的一块，显而易见，那么无论B怎么拿，A都会赢 2.如果这里有4块糖果，A先拿了中间的2块，同样的，无论B怎么拿，A也都会赢 3.举一反三，如果这里增到五块糖果，A先拿了中间的1块，如果B拿走1块，A就拿和B中心对称的一块，这样A还是会赢。 如果想让先拿的获胜，我们就得出以下规律： 糖果如果是奇数块，先拿的就拿中间的一块； 糖果如果是偶数块，先拿的就先拿中间的两块； 1、2步骤后剩下的只要和对方的基于中心点对称就一定会赢。 实现#include &lt;iostream&gt; using namespace std; bool take_stone(char *stones, int len, int start, int num) { bool bRet = true; if ((start &lt; 0) || ((start+num) &gt; len) || (num &lt; 1 || num &gt; 2)) return false; if (((num == 1) &amp;&amp; (stones[start] != &apos;O&apos;)) || ((num == 2) &amp;&amp; ((stones[start] != &apos;O&apos;) || (stones[start+1] != &apos;O&apos;)))) return false; if (num == 1) stones[start] = &apos;x&apos;; else if (num == 2) { stones[start] = &apos;x&apos;; stones[start+1] = &apos;x&apos;; } return bRet; } bool scan(char *stones, int len, int start, int num, int round) { int i = 0, mid = 0; bool bRet = false; mid = (len+1)/2; if (round == 0) { if (len%2 == 1) { mid = (len-1)/2; stones[mid] = &apos;x&apos;; } else { mid = len/2 - 1; stones[mid] = &apos;x&apos;; stones[mid+1] = &apos;x&apos;; } } else { mid = len - 1 - start; stones[mid] = &apos;x&apos;; mid = mid - (num-1); stones[mid] = &apos;x&apos;; } for (i=0; i &lt; len; i++) { if (stones[i] == &apos;O&apos;) { bRet = true; break; } } if (!bRet) { cout &lt;&lt; &quot;PROGRAM WIN!!&quot; &lt;&lt; endl; bRet = false; } return bRet; } void print(char *stones, int len) { int i = 0; for (i=0; i &lt; len; i++) { cout &lt;&lt; stones[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void play(char *stones, int len) { int nStart=0, nNum=0; int round = 0; while(scan(stones, len, nStart, nNum, round)) { print(stones, len); cout &lt;&lt; &quot;please input the start stone and will take how many(max is 2)&quot; &lt;&lt; endl; cin &gt;&gt; nStart &gt;&gt; nNum; while (!take_stone(stones, len, nStart, nNum)) { cout &lt;&lt; &quot;please re-input your choose&quot; &lt;&lt;endl; cin &gt;&gt; nStart &gt;&gt; nNum; } round++; } print(stones, len); } void main() { char test[]={&apos;O&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;}; int len = 8; play(test, len); cin &gt;&gt; len; } 转自：CSDN云计算公众号 类似游戏]]></content>
      <tags>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题配置]]></title>
    <url>%2F2018%2F10%2F27%2FNext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前面一直使用Yelle主题，最近感觉太花哨了，所以修改成简洁的Next主题。 数学公式必须在每个文章开头添加： mathjax: true 这样，才能正确显示数学公式。 第三方评论来必力来必力： https://www.livere.com 在主题文件中添加如下命令： livere_uid: kjfkdjffklajdf 在安装之后，发现首页也有评论栏，严重影响美观。去掉方案为，修改layout\_third-party\comments中的livers.siwg文件： {% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %} {% if theme.livere_uid %} (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); {% endif %} {% endif %} uid来自来必力管理后台： 更多评论第三方： https://blog.csdn.net/xiangzhihong8/article/details/77703791 搜索本地搜索： local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 将enable设置为true即可。 网站访问量不蒜子官网：http://ibruce.info/2015/04/04/busuanzi/ 由于域名更新，以前用的无法再使用，需要更新域名。根据官网首页提示即可完成。 在layout\_partials目录下，footer.swig文件顶部添加如下代码： &lt;div&gt; &lt;script async src=&quot;https//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&apos;display:none&apos;&gt; 访问人数 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; 文章浏览量Leancloud官网：https://leancloud.cn/ 网站注册和密钥获取见：https://www.jianshu.com/p/702a7aec4d00 在主题配置文件_config.yml中修改如下面命令： leancloud_visitors: enable: true app_id: 2AyV3DKioBSdodryrFdRodhzjB-gzGzodHsz app_key: XynedcHydJCVCdrTfbD4dyYnodo 在layout\_scripts目录下，创建文件lean-analytics.swig文件，代码如下： &lt;!-- custom analytics part create by xiamo --&gt; &lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;{{theme.leancloud_visitors.app_id}}&quot;, &quot;{{theme.leancloud_visitors.app_key}}&quot;);&lt;/script&gt; &lt;script&gt; function showTime(Counter) { var query = new AV.Query(Counter); $(&quot;.leancloud_visitors&quot;).each(function() { var url = $(this).attr(&quot;id&quot;).trim(); query.equalTo(&quot;url&quot;, url); query.find({ success: function(results) { if (results.length == 0) { var content = $(document.getElementById(url)).text() + &apos; 0&apos;; $(document.getElementById(url)).text(content); return; } for (var i = 0; i &lt; results.length; i++) { var object = results[i]; var content = $(document.getElementById(url)).text() + &apos; &apos; + object.get(&apos;time&apos;); $(document.getElementById(url)).text(content); } } }); }); } &lt;/script&gt;]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--对象和类（十）]]></title>
    <url>%2F2018%2F10%2F25%2FC%2B%2B%20Primer%20Plus--%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象编程（OOP） 10.1 过程性编程和面向对象编程采用过程性编程时，首先考虑要遵循的步骤，然后考虑如何表示这些数据（并不需要程序一直运行，用户可能希望能够将数据存储在一个文件中，然后从这个文件中读取数据）。 对于OOP程序员，首先考虑数据–不仅考虑如何表示数据，还要考虑如何使用数据。总之，采用OOP方法时，首先从用户的角度考虑对象—描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。 10.2 抽象和类生活中充满复杂性，处理复杂性的方法之一是简化和抽象。将问题的本质特征提取出来，并根据特征来描述解决方案。 10.2.1 类型指定基本类型完成三项工作： 决定数据对象需要的内存数据； 决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）； 决定可使用数据对象执行的操作和方法。 对于内置类型，有关操作的信息被内置到编译器中。但在C++中定义用户自定义的类型时，必须自己提供这些信息。 10.2.2 C++类类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。下面来看一个表示股票的类： 首先，必须考虑如何表示股票。可以将一股作为一个基本单元，定义一个表示一股股票的类。然而，这意味着需要100个对象才能表示100股，这不现实。相反，eyi将某人当前持有的某种股票作为一个基本单元，数据表示中包含它持有的股票数据。一种比较现实的方法是，必须记录最初够买价格和购买价格等内容。另外，还必须管理诸如拆股等事件。首先定义就考虑这么多因素有些苦难，因此我们对其进行简化。具体地说，应该将可执行的操作限制为： 获得股票 增持 卖出股票 更新股票价格 现实关于所持股票的信息 可以根据上述清单定义stock类型的公有接口。为支持该接口，需要存储一些信息。再次进行简化，例如，不考虑标准的美式股票计价方式。我们将存储下面的信息： 公司名称 所持股票数量 每股价格 股票总值 接下来定义类，一般来说，类规范由两个部分组成： 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。 类方法定义：描述如何实现类成员函数。 接口 接口是一个共享框架，供两个系统交互时使用；例如，用户可能是您，而程序可能是字处理器。使用字处理器时，您不能直接将脑子中想到的词传输到计算机内存中，而必须同程序提供的交互接口。您敲打键盘时，计算机将字符串显示到屏幕；您移动鼠标时，计算机移动屏幕上的光标；您无意间单击鼠标时，计算机对您输入的段落进行奇怪的处理。程序接口将您的意图转换为存储在计算机中的具体信息。 对于类，我们说的公共接口。在这里，公众是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成的。接口让程序员能够编写与类交互的代码，从而让程序能够使用类对象。例如，要计算sting对象中包含多少个字符，您无需打开对象，只需要使用sting类提供的size()方法。类设计禁止公共用户直接访问类，但公众可以使用方法size()。方法size()是用户和string类对象之间的公共接口的组成部分。通常，方法getline()是对象istream类的公共接口的组成部分，使用cin的程序不是直接与cin对象内部交互来读取一行输入，而是使用getline()。 为开发一个类并编写一个使用它的程序，需要完成多个步骤。这里将开发过程分为多个阶段，而不是一次性完成。通过，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。第一个文件，它是Stock类的类声明。 类名首字母大写。 stock00.h #ifndef STOCK00_H_ #define STOCK00_H_ #include &lt;string&gt; class Stock { private: std::string company; long shares; double share_val; double total_val; void set_tot() { total_val = share_val * shares;} public: void acquire(const std::string &amp; co, long n, double pr); void buy(long num, double price); void sell(long num, double price); void update(double price); void show(); }; #endif 先看一下类的通用特性。首先，C++关键字class指出这些代码定义了一个类设计（不同于模板参数中，在这里，关键字class和typename不是同意词，不能使用typename代替class）。这种语法指出，Stock是这个新类的类型名。该声明让我们能够声明Stock类型的变量–称为对象或实例。每个对象都表示一支股票。例如，下面的声明创建两个Stock对象，它们名称分别为sally和solly: Stock sally; Stock solly; 例如，sally对象可以表示Sally持有的某公司股票。 接下来，要存储的数据以类数据成员（如company和shares）的形式出现。例如，sally的company成员存储了公司的名称，share成员存储了sally持有的股票数量，…。同样，要执行的操作以类函数成员（方法，如sell()或update()）的形式出现。成员函数可以就地定义（如set_tot()），也可以用原型表示。将数据和方法组合成一个单元是类最吸引人的特性。有了这种设计，创建Stock对象时，将自动制定使用对象规则。 1.访问控制关键字private和public，描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友员函数，参见第11章）来访问对象的私有成员。例如，要修改Stock类的shares成员，只能通过Stock的成员函数。因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。C++还提供了第三个访问控制关键字protected（第13章介绍）。 类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏是一种封装，将实现的细节隐藏在私有部分中，就像Stock类对set_tot()所做的那样，也是一种封装。封装的另一个例子是，将函数定义和类声明放在不同的文件中。 数据隐藏不仅可以防止直接访问数据，还可以让开发者无需了解数据是如何标识的。例如，show()成员将显式某支股票的总价格（还有其他内容），这个值可以存储在对象中，也可以在需要时通过计算得到。从使用类的角度看，使用哪种方法没有声明区别。所需要知道的只是各种成员函数的功能；即，需要知道成员函数接受什么样的参数以及返回生命类型的值。原则是将实现细节从接口设计中分离出来。如果以后找到了更好的、实现数据表示或成员函数细节的方法，可以对这些细节进行修改，而无需修改程序接口，这使得程序维护起来更容易。 2.控制对成员的访问：公有还是私有无论类成员是数据成员还是函数成员，都可以在类的公有部分或私有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则就无法从从程序中调用这些函数。正如Stock声明所表明的，也可以把成员函数放在私有部分中。不能直接从程序中调用这种函数，但公有方法却可以访问使用它们。通常，程序使用私有成员函数来处理不属于公有接口的实现细节。 不必在类声明中使用关键字private，因为这是类对象的默认访问控制: class World { float mass; char name[20]; public: void tellall(void); } 然而，为强调数据隐藏的概念，本书显式地使用了private。 类和结构 类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。实际上，C++对结构进行了扩展，使之具有与类相同的特性。它们之间的唯一区别是，结构的默认访问类型是public，而类为private。C++程序员通常使用类实现类描述，而把结构限制为只表示纯粹的数据对象。 10.2.3 实现类成员函数还需要创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，它们由函数头和函数体，也可以返回类型和参数。但它们两个特殊的特征： 定义成员函数，使用作用域解析运算符(::)来标识函数所属的类； 类方法可以访问类的private组件。 首先，成员函数的函数头使用作用域运算符解析（::）来指出函数所属的类。例如，update()成员函数的函数头如下： void Stock::update(double prive) 这种表示法意味着我们定义的update()函数是stock类的成员。这不仅将update()标识为成员函数，意味着我们可以将另一个类的成员函数也命名为update()。例如，Buffon类的update()函数的函数头如下： void Buffon::update() 因此，作用域解析运算符确定了方法定义对应的类的身份。Stock类的其他成员函数不必使用作用域解析运算符，就可以使用update()方法，这是因为它们属于同一个类，因此update()是可见的。然而，在类声明和方法定义职位使用update()时，需要采用特殊的措施。 类方法的完整名称中包括类名。即，Stock::update()是函数的限定名；而简单的update()是全名的缩写，它只能在类作用域中使用。 方法的第二个特点是，方法可以访问类的私有成员，例如，Show()方法可以使用这样的代码： std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; compangy &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; endl; 其中，company和shares都是Stock类的私有数据成员。如果试图使用非成员函数访问这些数据成员，编译器禁止这样做。 stock00.cpp #include &lt;iostream&gt; #include &quot;stock00.h&quot; void Stock::acquire(const std::string &amp; co, long n, double pr) { company = co; if (n &lt; 0) { std::cout &lt;&lt; &quot;Number of shares can&apos;t be nagative: &quot; &lt;&lt; company &lt;&lt; &quot; share set to 0.\n&quot;; shares = 0; } else shares = n; share_val = pr; set_tot(); } void Stock::buy(long num, double price) { if (num &lt; 0) { std::cout &lt;&lt; &quot;Number of shares purchased can&apos;t be nagative. &quot; &lt;&lt; &quot;Transaction is aborted.\n&quot;; } else { shares += num; share_val = price; set_tot(); } } void Stock::sell(long num, double price) { using std::cout; if (num &lt; 0) { cout &lt;&lt; &quot;Number of shares sold can&apos;t be nagative. &quot; &lt;&lt; &quot;Transaction is aborted.\n&quot;; } else if (num &gt; shares) { cout &lt;&lt; &quot;You can&apos;t sell more than you have!&quot; &lt;&lt; &quot; Transantion is aborted.\n&quot;; } else { shares -= num; share_val = price; set_tot(); } } void Stock::update(double price) { share_val = price; set_tot(); } void Stock::show() { std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; std::endl &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; std::endl; } 1.成员函数说明acquire()确保管理对某个公司购买的首次购买，而buy()和sell()管理增加或减少持有的股票。方法buy()和sell()确保买入或卖出的股票不能为负数。另外，如果用户试图卖出超过他所拥有的股票数量，则sell()函数结束这次交易。这些使数据私有并限于对公有函数的计数允许我们能够控制数据如何被使用。 set_tot()只是实现代码的一种方式，而不是公有接口的组成部分，因为这个类将其声明为私有成员函数。 2. 内联方法其定义位于类声明中的函数都将自动为内联函数，因此Stock::set_tot()是一个内联函数。类声明常将短小的成员函数作为内联函数。 如果愿意，也可以类声明以外定义成员函数，并使其成员内联函数。只需要在定义函数时使用inline限定符，如下： inline void Stock::set_tot() { total_val = shares * share_val; } 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多个文件程序中的所有文件都可用，最简单的方法是：将内联定义放在定义类的头文件。 3. 方法使用哪个对象下面介绍使用对象时最重要的一个方面；比如将类方法应用于对象。下面代码使用了一个对象的shares成员： shares += num; 则问题是使用哪个对象的shares成员。首先，看如何创建对象： Stock kate, joe; 接下来，看看如何使用对象的成员函数： kate.show(); joe.show(); 第一条语句调用kate对象show()成员。这意味着show()方法把shares解释为kate.shares，将share_val解释为kate.share_val。 所创建的每个新对象都有自己的存储空间，用于存储其内部变量和成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。例如，假设kate和joe都是Stock对象，则kate.shares将占据一个内存块，而joe.shares占用另一个内存块，但kate.show()和joe.show()都调用同一个方法。 10.2.4现在，创建一个程序，他创建并使用对象。C++的目标是使用使得类和使用基本的内置类型尽可能相同。要创建类对象，可以声明类变量，也可以使用new为类对象分配存储值。可以对象作为参数和返回值，也可以将一个对象赋给另一个对象。 usestock00.cpp #include &lt;iostream&gt; #include &quot;stock00.h&quot; int main() { Stock fluffy; fluffy.acquire(&quot;NanoSmart&quot;, 20, 12.50); fluffy.show(); fluffy.buy(15, 19.125); fluffy.show(); fluffy.sell(400, 20.00); fluffy.show(); fluffy.buy(300000, 40.125); fluffy.show(); fluffy.sell(300000, 0.125); fluffy.show(); return 0; } 结果： Company: NanoSmart Shares: 20 Share Price: $12.5 Total Worth: $250 Company: NanoSmart Shares: 35 Share Price: $19.125 Total Worth: $669.375 You can&apos;t sell more than you have! Transantion is aborted. Company: NanoSmart Shares: 35 Share Price: $19.125 Total Worth: $669.375 Company: NanoSmart Shares: 300035 Share Price: $40.125 Total Worth: $1.20389e+07 Company: NanoSmart Shares: 35 Share Price: $0.125 Total Worth: $4.375 客户/服务器模式 OOP程序常依照客户/服务器模式来讨论程序设计。客户是使用类的程序，类声明（包括类方法）构成了服务器，它是程序可以使用的资源。客户只能通过以公有方式定义的接口使用服务器，这意味着客户唯一责任是了解该接口。 10.2.5 修改实现在前面的程序输出中，数字的格式不一致。现在可以改进实现，但保持接口不变。ostream类包含一些可用于控制格式的成员函数。如下： std::cout.setf(std::ios_base::fixed, std::ios_base::floatfiled); 这设置了cout对象的一个标记，命令cout使用定点表示法。同样，下面的语句导致cout在使用定点表示法，显式3位小数： std::cout.precision(3); 第17章介绍更多细节。 可在方法show()中使用这些工具来控制格式，但是还有一点需要考虑。修改方法的实现时，不应影响客户程序的其他部分。上述格式修改将一直有效，因为它们可能影响客户程序中的后续输出。因此，show()应重置格式信息，使其恢复到自己被调用前的状态。为此，可以像乳腺程序，使用返回的值： std::streamsize prec = std::cout.precision(3);//保存修改之前的值 ... std::cout.precision(prec); //重置为旧值 std::ios_base::fmtflags orig = std::cout.setf(std::ios_base); ... std::cout.setf(orig, std::ios_base::floatfield); 您可能还记得，fmtflags是在ios_base类中定义的一种类型，而ios_base类又是在名称空间std中定义的，因此orig的类型名非常长。其次，orig存储了所有的标记，而重置语句使用这些信息来重置floatfield，而floatfield包含定点表示法标记和科学表示法标记。第三，请不要过多考虑这里的细节。这里的要旨是，将修改限定在实现文件中，以免影响程序的其他方面。 根据上面的介绍，可在实现文件中将方法show()的定义修改如下所示： void Stock::show() { using std::cout; using std::ios_base; ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield); std::streamsize prec = cout.precision(3); std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; std::endl &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val //set format to #.## cout.precision(2); cout &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; std::endl; cout.setf(orig, ios_base::floatfield); cout.precision(prec); } 完成上述修改后（保留头文件和客户文件不变），可重新编译该程序。 10.2.6 小结指定类设计的第一步是提供类的声明。类声明类似结构的声明，可以包括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的部分中，因此典型的声明的格式如下： class className { private: data number declarations; public: member function prototypes; }; 公有部分的内容构成了设计的抽象部分—公有接口。将数据封装到私有部分中可以保护数据的完整性，这被称为数据隐藏。因此，C++通过类使得实现抽象、数据隐藏和封装等OOP特性很容易。 指定类设计的第二步是实现类成员函数。可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。例如，假设Bozo有一个名为Retort()的成员函数，该函数返回char指针，则其函数头如下所示： char * Bozo::retort(); 换句话来说，Retort()不仅仅是一个char $\ast$类型的函数，而是一个属于Bozo类的Char $\ast$函数。该函数的全名（或限定名）为Bozo::Retort()。而名称Retort()是限定名的缩写，只能在某些特定的环境中使用。如类方法的代码中。 另一种描述这种情况的方式是，名称Retort的作用域为整个类，因此在类声明和类方法之外使用该名称时，需要使用作用域解析运算符进行限定。 要创建对象（类的实例），只需将类名视为类型名即可： Bozo bozetta; 这样做是可行的，因为类是用户定义的类型。 类成员函数（方法）可通过类对象来调用。为此，需要使用成员运算符句点： cout &lt;&lt; bozetta.Retort(); 这将调用Retort()函数，每当其中的代码引用某个数据成员时，该函数都将使用bozetta对象中相应成员的值。 10.3 类的构造函数和析构函数对于Stock类，还有其他一些工作要做。应为类提供称为构造函数和析构函数的标准函数。下面介绍为什么需要这些函数以及如何使用这些函数。 C++的目标之一是让类对象就像使用标准类型一样，然而，到现在为止，本章提供的代码还不能让您初始化int或结构那样来初始化Stock对象。即，常规的初始化语法不适用于类型Stock: int year = 2018; Struct thing { char * pn; int m; }; thing amabob = {&quot;wodget&quot;, -23}; Stock hot = {&quot;Sukie&apos;s Autos, Inc.&quot;, 200, 50.25} //编译错误 不能像上面这样初始化Stock对象的原因在于，数据部分的访问状态私有的，这意味着程序不能直接访问数据成员。您已经看到，程序只能通过成员函数来访问数据成员，因此需要设计合适的成员函数，才能成功地将对象初始化（如果使数据成员成为公有，而不是私有，就可以按刚才介绍的方法初始化类对象，但使数据成为公有的违背了类的一个主要初衷：数据隐藏）。 一般来说，最好是在创建对象时对它进行初始化。例如，请看下面的代码： Stock gift; gift.buy(10, 24.75); 就Stock类当前的实现而言，gift对象的company成员是没有值的。类设计假设用户在调用任何其他成员函数之前调用acquire(),但无法强加这种假设。避开这种问题的方法之一是在创建对象时，自动对它进行初始化。为此，C++提供了特殊的成员函数—类构造函数，专门构造新对象、将值赋给它们的数据成员。更准确地说，C++为这些成员函数提供了名称和使用语法，而程序员需要提供方法定义。名称与类名相同。例如，Stock类一个可能的构造函数是名为Stock()的成员函数。构造函数的原型和函数头有一个有趣的特征—-虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。 10.3.1 声明和定义构造函数现在需要创建Stock的构造函数。由于需要Stock对象提供3个值，因此应为构造函数提供3个参数。（第4个值，total_val成员，是根据shares和share_val计算得到的，因此不必为构造函数提供这个值。）程序员可能只想设置company成员，而将其他值设置为0；这可以使用默认参数来完整。因此原型如下所示： Stock(const string &amp; co, long n = 0; double pr = 0.0); 第一个参数是指向字符串的指针，该字符串用户初始化成员company。n和pr参数为shares和share_val成员提供值。注意，没有返回类型。原型位于类声明的公有部分。 Stock::Stock(const string &amp; co, long n, double pr { company = co; if (n &lt; 0) { std::cerr &lt;&lt; &quot;Number of shares can&apos;t be nagative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\n&quot;; shares = 0; } else shares = n; share_val = pr; set_tot(); } 上述代码和本章前面的函数acquire()相同。区别在于，程序声明对象时，将自动调用构造函数。 成员名和参数名 不熟悉构造函数的您会试图将类成员名称为构造函数的参数名，如下所示： Stock::Stock(const string &amp; company, long shares, double share_val) { ... } 这样是错误的。构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能与类成员相同，否则最终的代码是这样的： shares = shares; 为避免这种混乱，一种常见的做法是在数据成员名中使用m_前缀： class Stock { private: string m_company; long m_shares; ... }; 另一种常见的做法是，在成员名中使用后缀_: class Stock { private: string company; long shares; ... } 无论采用哪种做法，都可在公有接口中在参数名中包含company和shares。 10.3.2 使用构造函数C++提供了两种使用构造函数来初始化对象的方式。第一种方式是显示地调用构造函数： Stock food = Stock(&quot;World Cabbage&quot;, 250, 1.25); 这将food对象的company成员设置为字符串”World Cabbage”,将shares成员设置为250，以此类推。 另一种方式是隐式调用构造函数： Stock garment(&quot;Furry Mason&quot;, 50, 2.5); 这个格式更为紧凑，它与下面的显示调用等价： Stock garment = Stock(&quot;Furry Mason&quot;, 50, 2.5); 每次创建对象（甚至使用new动态分配内存）时，C++都使用类构造函数。下面是将构造函数与new一起使用的方法： Stock *pstock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0); 这条语句创建一个Stock对象，将其初始化为参数提供的值，并将该对象的地址赋给pstock指针。在这种情况下，对象没有名称，但可以使用指针来管理该对象。下一章将进一步讨论对象指针。 构造函数的使用方式不同于其他类方法。一般来说，使用对象来调用方法； stock1.show(); 但无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存的。因此构造函数被用来创建对象，而不能通过对象来调用。 10.3.3 默认构造函数默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。也就是说，它是用于下面这种声明的构造函数： Stock fluffy_the_cat; //使用默认的构造函数 程序10.3就是这样做的！这样语句管用的原因在于，如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。对于Stock类来说，默认构造函数可能如下： Stock::Stock(){} 因此将创建fluffy_the_cat对象，但不初始化其成员，这和下面的语句创建x，但没有提供值给它一样： int x; 默认构造函数没有参数，因为声明中不包含值。 但是，当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。如果提供了非默认构造函数(如Stock(const char $\ast$co,int n, double pr))，但没有提供默认构造函数，则下面的声明将出错： Stock stock1; //没有默认的构造函数 这样做的原因可能是想禁止创建未初始化的对象。然而，如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种给已有构造函数的所有参数提供默认值： Stock::Stock(const string &amp; co = &quot;Error&quot;, int n= 0, double pr = 0.0); 另一种方式是通过函数重载来定义一个构造函数—-一个没有参数的构造函数： Stock::Stock(); 由于只能有一个默认构造函数，因此不要同时采用这两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。例如，下面未Stock类定义的一个默认构造函数： Stock::Stock()//默认构造值 { company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0; } 提示：在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。 使用上述任何一种方式（没有参数或所有参数都有默认值）创建默认构造函数后，便可以声明对象变量，而不对它们进行显示初始化： Stock first; Stock first = Stock(); Stock *prelief = new Stock; 然而，不要被非默认构造函数的隐式形式所误导： Stock first(&quot;Concrete Conglomerate&quot;); //调用非默认构造函数 Stock second(); //声明一个函数 Stock thrid; //隐式调用默认构造函数 第一个声明调用非默认构造函数，即接受参数的构造函数；第二个声明指出，second()是一个返回Stock对象的函数。隐式地调用默认构造函数时，不要使用圆括号。 10.3.4 析构函数用构造函数创建对象后，程序负责跟踪对象，直到到起为止。对象到期时，程序将自动调用一个特殊的成员函数，该函数的名称令人生畏—析构函数。 析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。Stock的构造函数没有使用new，因此析构函数实际上没有需要完成的任务。在这种情况下，只需让编译器生成一个什么不要做的的隐式析构函数即可，Stock类第一版正是这样做的。然而，了解如何声明和定义析构函数是绝对必要的，下面为Stock类提供一个析构函数。 和构造函数一样，析构函数的名称也很特殊：在类名之前加上~。因此，Stock类的析构函数为~Stock()。另外，和构造函数一样，析构函数也快车没有返回值和声明类型。与构造函数不同的是，析构函数没有参数，因此Stock析构函数的原型必须是这样的： ~Stock(); 由于Stock的析构函数不承担任何重要的工作，因此可以将它编写为不执行任何操作的函数： Stock::~Stock(){} 然而，为让您看出析构函数何时被调用，这样编写其代码： Stock::~Stock() { cout &lt;&lt; &quot;Bye. &quot; &lt;&lt; company &lt;&lt; &quot; !\n&quot;; } 由于类对象过期时析构函数将自动被调用，因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。 10.3.5 改进的Stock类下面将构造函数和析构函数加入到类和方法的定义中。 1.头文件 程序10.4列出了头文件。它将构造函数和析构函数的原型加入到原来的类声明中。另外，它还删除了acquire()函数—现在已经不再需要它了，因为有构造函数。 程序10.4 stock00.h #ifndef STOCK00_H_ #define STOCK00_H_ #include &lt;string&gt; class Stock { private: std::string company; long shares; double share_val; double total_val; void set_tot() { total_val = share_val * shares;} public: Stock(); Stock(const std::string &amp; co, long n = 0, double pr = 0.0); ~Stock(); void buy(long num, double price); void sell(long num, double price); void update(double price); void show(); }; #endif 2.实现文件 程序10.5提供了方法的定义。它包含了头文件stock00.h，以提供类声明。 程序10.5 stock00.cpp #include &lt;iostream&gt; #include &quot;stock00.h&quot; Stock::Stock() { std::cout &lt;&lt; &quot;Default constructor called\n&quot;; company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0; } Stock::Stock(const std::string &amp; co, long n, double pr) { std::cout &lt;&lt; &quot;Constructor using &quot; &lt;&lt; co &lt;&lt; &quot; called\n&quot;; company = co; if (n &lt; 0) { std::cerr &lt;&lt; &quot;Number of shares can&apos;t be nagative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\n&quot;; shares = 0; } else shares = n; share_val = pr; set_tot(); } Stock::~Stock() { std::cout &lt;&lt; &quot;Bye, &quot; &lt;&lt; company &lt;&lt; &quot; !\n&quot;; } void Stock::buy(long num, double price) { if (num &lt; 0) { std::cout &lt;&lt; &quot;Number of shares purchased can&apos;t be nagative. &quot; &lt;&lt; &quot;Transaction is aborted.\n&quot;; } else { shares += num; share_val = price; set_tot(); } } void Stock::sell(long num, double price) { using std::cout; if (num &lt; 0) { cout &lt;&lt; &quot;Number of shares sold can&apos;t be nagative. &quot; &lt;&lt; &quot;Transaction is aborted.\n&quot;; } else if (num &gt; shares) { cout &lt;&lt; &quot;You can&apos;t sell more than you have!&quot; &lt;&lt; &quot; Transantion is aborted.\n&quot;; } else { shares -= num; share_val = price; set_tot(); } } void Stock::update(double price) { share_val = price; set_tot(); } void Stock::show() { std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; std::endl &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; std::endl; } 3.客户文件 程序10.6提供了一个测试这些新方法的小程序。 程序10.6 usestock2.cpp #include &lt;iostream&gt; #include &quot;stock00.h&quot; int main() { { using std::cout; cout &lt;&lt; &quot;Using constructors to create new objects\n&quot;; Stock stock1(&quot;NanoSmart&quot;, 12, 20.0); stock1.show(); Stock stock2 = Stock(&quot;Boffo objects&quot;, 2, 2.0); stock2.show(); cout &lt;&lt; &quot;Assigning stock1 to stock2: \n&quot;; stock2 = stock1; cout &lt;&lt; &quot;Listing stock1 and stock2: \n&quot;; stock1.show(); stock2.show(); cout &lt;&lt; &quot;Using a constructor to reset an object\n&quot;; stock1 = Stock(&quot;Nifty Foods&quot;, 10, 50.0); cout &lt;&lt; &quot;Revised stock1:\n&quot;; stock1.show(); cout &lt;&lt; &quot;Done\n&quot;; } return 0; } 编译： g++ usestock2.cpp stock00.cpp -o file 运行: ./file 输出结果： Using constructors to create new objects Constructor using NanoSmart called Company: NanoSmart Shares: 12 Share Price: $20 Total Worth: $240 Constructor using Boffo objects called Company: Boffo objects Shares: 2 Share Price: $2 Total Worth: $4 Assigning stock1 to stock2: Listing stock1 and stock2: Company: NanoSmart Shares: 12 Share Price: $20 Total Worth: $240 Company: NanoSmart Shares: 12 Share Price: $20 Total Worth: $240 Using a constructor to reset an object Constructor using Nifty Foods called Bye, Nifty Foods ! Revised stock1: Company: Nifty Foods Shares: 10 Share Price: $50 Total Worth: $500 Done Bye, NanoSmart ! Bye, Nifty Foods ! 提示：您可能注意到，在程序10.6中，main()的开头和结尾多了一个大括号。诸如stock1和stock2等自动变量将在程序退出其定义所属代码块时消失。如果没有大括号，代码块将为整个main()，因此仅当main()执行完毕后，才会调用析构函数。在窗口环境中，这意味着将在两个析构函数调用前关闭，导致您无法看到最后两条消息。但添加这些大括号后，最后两个析构函数调用将在到达返回语句前执行，从而显示相应的消息。 4.程序说明 略 5.C++11列表初始化 在C++11中，可将列表初始化语法用于类，只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起来： Stock hot_tip = {&quot;Derivatives Plus Plus&quot;, 1-, 45.0}; Stock jock {&quot;Sport Age Storage, Inc&quot;}; Stock temp {}; 在前两个声明中，用大括号括起来的列表和下面的构造函数匹配： Stock::Stock(const std::string &amp; co, long n = 0, double pr = 0.0); 因此，将使用该构造函数来创建这两个对象。创建对象jockk时，第二和第三个参数将为默认值0和0.0。第三个声明与默认构造函数匹配，因此将使用该构造函数创建对象temp。 另外，C++还提供了名为std::initialize_list的类，可将其用作函数参数或方法参数的类型。这个类可表示任意长度的列表，只要所有列表项的类型都相同或可转换为相同的类型。 6.const成员函数 请看下面的代码段： const Stock land = Stock{&quot;Kludgehorn Properties&quot;}; land.show(); 对于当前的C++来说，编译将拒绝第二行。因为show()的代码无法确保调用对象不被修改—调用对象和const一样，不应被修改。我们以前通过将函数参数声明为const引用或指向const的指针来解决这个问题。但这里存在语法问题：show()方法没有任何参数。相反它所有使用的对象是由方法调用隐式提供的。需要一种新的语法—保证函数不会修改调用对象。C++的解决方法是将const关键字放在函数的括号后面。即，show()声明如下： void show() const; 同样，函数定义的开头也应该如下： void Stock::show() const 以这种方式声明和定义的类函数被称为const成员函数。就像应尽可能将const引用和指针用作函数形参一样，只要类方法不修改调用对象，就应该将其声明为const。 10.3.6 构造函数和析构函数小结构造函数是一种特殊的类成员函数在创建类对象时被调用。构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，条件是每个函数的参数列表都不同。另外，构造函数没有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配。例如： Bozo (const char * fname, const char * lname); 初始化新对象： Bozo boeztta = Bozo(&quot;Bozetta&quot;, &quot;Biggens&quot;); Bozo fufu(&quot;Fufu&quot;,&quot;O&apos;Dweeb&quot;); Bozo *pc = new Bozo(&quot;Popo&quot;, &quot;Le pu&quot;); 如果支持C++，则可使用列表初始化： Bozo bozetta = {&quot;Bozetta&quot;, &quot;Biggens&quot;}; Bozo fufu{&quot;Fufu&quot;, &quot;O&apos;Dweeb&quot;}; Bozo *pc = new Bozo{&quot;Popo&quot;, &quot;Le pu&quot;}; 默认构造函数没有参数，因此如果创建对象时没有进行显示初始化，则将调用默认构造函数。 就像对象被创建时程序调用构造函数一样，当对象被删除时，程序将调用析构函数。每个类只能有一个析构函数。析构函数没有返回类型，也没有参数，其名称为类名称前加上~。 如果构造函数使用了new，则必须提供使用delete的析构函数。 10.4 this指针到目前为止，每个类成员函数都只涉及一个对象，即调用它的对象。但有时候方法方法可能涉及到两个对象，在这种情况下需要使用C++的this指针。 虽然Stock类声明可以显示数据，但它缺乏分析能力。例如，从show()的输出我们可以知道持有哪一支股票价格最，但由于程序无法直接访问total_val，因此无法作出判断。要让程序知道存储的数据，最直接的方式让方法返回一个值。为此，通常使用内联代码，如下： class Stock { private: double total_val; ... public: double total() const ({return total_val;} } 就直接程序访问而言，上述定义实际上是使total_val为只读。也就是说，可以使用方法total_val()来获得total_val的值，但这个类没有提供专门用于重新设置total_val的值的方法（作为一种副产品，其他方法，如buy()、sell()、update()确实在重新设置成员shares和share_val的值的同时修改了total_val的值）。 通过将该函数添加到类声明中，可以让程序查看一系列股票，找到价格最高的那一只。然而，可以采用另一种方法—-一种帮助您了解this指针的方法。这种方法是：定义一个成员函数，它查看两个Stock对象，并返回股价较高者的那个对象的引用。 首先，如何将两个要比较的对象提供给成员函数呢？可以按引用来传递参数，即，topval()方法使用一个类型为const Stock &amp; 的参数。 其次，如何将方法的答案传回给调用程序呢？最直接的方法是让方法返回一个引用，该引用指向股价总值较高的对象。因此，用于比较的方法的原型如下： const Stock &amp; topval(const Stock &amp; s) const; 该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其中一个对象的引用。括号中的const表明，该函数不会修改被显式地访问的对象；而括号后的const表明，该函数不会修改被隐式地访问的对象。由于该函数返回了两个const对象之一的引用，因此返回类型也应为const引用。 假设要对Stock对象stock1和stock2进行比较，并将其中股价总值较高的那一个赋给top对象，则可以使用下面两条语句之一： top = stock1.topval(stock2); top = stock2.topval(stock1); 注意的是topval()的实现，它将引发一个小问题。下面的部分实现强调了这个问题： const Stock &amp; Stock::topval(const Stock &amp; s) const { if (s.total_val &gt; total_val) return s; else return ???? //隐式对象 } 如果s.total_val大于total_val，则函数将返回指向s的引用；否则，将返回用来调用该方法的对象。问题在于，如何称呼这个对象？ C++解决这种问题的方法是：使用被称为this的特殊指针。this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。这样，函数调用stock1.topval(stock2)将this设置为stock1对象的地址，这使得这个指针可用于topval()方法。 注意： 每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式$\ast$this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。 然而，要返回的并不是this，因为this是对象的地址，而是对象的本身，即$\ast$this。现在，可以将$\ast$this作为调用对象的别名来完成前面的方法定义。 const Stock &amp; Stock::topval(const Stock &amp; s) const { if (s.total_val &gt; this.total_val) return s; else return *this; } 返回对象为引用意味着返回的是调用对象本身，而不是副本。程序10.7列出了新的头文件。 程序10.7 stock20.h #ifndef STOCK00_H_ #define STOCK00_H_ #include &lt;string&gt; class Stock { private: std::string company; long shares; double share_val; double total_val; void set_tot() { total_val = share_val * shares;} public: Stock(); Stock(const std::string &amp; co, long n = 0, double pr = 0.0); ~Stock(); void buy(long num, double price); void sell(long num, double price); void update(double price); void show() const; const Stock &amp; topval(const Stock &amp; s) const; }; #endif 程序10.8 stock20.cpp #include &lt;iostream&gt; #include &quot;stock00.h&quot; Stock::Stock() { std::cout &lt;&lt; &quot;Default constructor called\n&quot;; company = &quot;no name&quot;; shares = 0; share_val = 0.0; total_val = 0.0; } Stock::Stock(const std::string &amp; co, long n, double pr) { std::cout &lt;&lt; &quot;Constructor using &quot; &lt;&lt; co &lt;&lt; &quot; called\n&quot;; company = co; if (n &lt; 0) { std::cerr &lt;&lt; &quot;Number of shares can&apos;t be nagative; &quot; &lt;&lt; company &lt;&lt; &quot; shares set to 0.\n&quot;; shares = 0; } else shares = n; share_val = pr; set_tot(); } Stock::~Stock() { std::cout &lt;&lt; &quot;Bye, &quot; &lt;&lt; company &lt;&lt; &quot; !\n&quot;; } void Stock::buy(long num, double price) { if (num &lt; 0) { std::cout &lt;&lt; &quot;Number of shares purchased can&apos;t be nagative. &quot; &lt;&lt; &quot;Transaction is aborted.\n&quot;; } else { shares += num; share_val = price; set_tot(); } } void Stock::sell(long num, double price) { using std::cout; if (num &lt; 0) { cout &lt;&lt; &quot;Number of shares sold can&apos;t be nagative. &quot; &lt;&lt; &quot;Transaction is aborted.\n&quot;; } else if (num &gt; shares) { cout &lt;&lt; &quot;You can&apos;t sell more than you have!&quot; &lt;&lt; &quot; Transantion is aborted.\n&quot;; } else { shares -= num; share_val = price; set_tot(); } } void Stock::update(double price) { share_val = price; set_tot(); } void Stock::show() const { std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; std::endl &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; std::endl; } const Stock &amp; Stock::topval(const Stock &amp; s) const { if (s.total_val &gt; total_val) return s; else return *this; } 当然，我们想知道this指针是否有用。显然，应在一个包含对象数组的程序中使用这种新方法。因此接下来介绍对象数组。 10.5 对象数组和Stock示例一样，用户通常要创建同一类的多个对象。可以创建独立对象变量，就像前面介绍的一样，但创建对象数组更合适。声明对象数组的方法与声明标准类型数组相同： Stock mystuff[4]; 前面讲过，当程序创建未被显式初始化的类对象时，总是调用默认构造函数。上述声明要求，这个类要么没有显式地定义任何构造函数（在这种情况下，将使用不执行任何操作的隐式默认构造函数），要么定义了一个显式默认构造函数。每个元素都是Stock对象，可以使用Stock方法： mystuff[0].updata(); mystuff[1].show(); const Stock * top = mystuff[2].topval(mystuff[1]); 可以用构造函数来初始化数组元素。在这种情况下，必须为每个元素调用构造函数： cosnt int STKS = 4; Stock socks[STKS] = { Stock(&quot;NanoSmart&quot;, 12.5, 20), Stock(&quot;Boffo Objects&quot;, 200, 2.0), Stock(&quot;Monolithic Obelisks&quot;, 130, 3.25), Stock(&quot;Fleep Enterprises&quot;, 60, 6.5) }; 这里的代码使用标准格式对数组进行初始化：用括号括起来，以逗号分割的值列表。其中，每次构造函数调用表示一个值。如果类包含多个过早函数，则可以对不同的元素使用不同的构造函数： const int STKS = 10; Stock stocks[STKS] = { Stock(”Nanosmart“, 12.5, 20), Stock(), Stock(&quot;Monolithic Obelisks&quot;, 130, 3.25) }; 上述代码使用Stock(const string &amp; co, long n, double pr)初始化stocks[0]和stocks[2]，使用构造函数Stock()初始化stock[1]。由于该声明只初始化了数组的部分元素，因此余下7个元素将使用默认构造函数进行初始化。 初始化对象数组的方案是：首先使用默认构造函数创建数组元素，然后花括号种的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。 程序10.9在一个小程序中使用了这些原理，该程序对4个数组进行初始化，显示它们的内容，并找出这些元素中总值最高的一个。由于topval()每次只检查两个对象，因此程序使用for循环来检查整个数组。 程序10.9 usestock2.cpp #include &lt;iostream&gt; #include &quot;stock00.h&quot; int main() { { using std::cout; cout &lt;&lt; &quot;Using constructors to create new objects\n&quot;; Stock stock1(&quot;NanoSmart&quot;, 12, 20.0); stock1.show(); Stock stock2 = Stock(&quot;Boffo objects&quot;, 2, 2.0); stock2.show(); cout &lt;&lt; &quot;Assigning stock1 to stock2: \n&quot;; stock2 = stock1; cout &lt;&lt; &quot;Listing stock1 and stock2: \n&quot;; stock1.show(); stock2.show(); cout &lt;&lt; &quot;Using a constructor to reset an object\n&quot;; stock1 = Stock(&quot;Nifty Foods&quot;, 10, 50.0); cout &lt;&lt; &quot;Revised stock1:\n&quot;; stock1.show(); cout &lt;&lt; &quot;Done\n&quot;; } return 0; } 程序输出： Constructor using NanoSmart called Constructor using Boffo Objects called Constructor using Monolithic Obelisks called Constructor using Fleep Enterprises called Stock holding: Company: NanoSmart Shares: 12 Share Price: $20 Total Worth: $240 Company: Boffo Objects Shares: 200 Share Price: $2 Total Worth: $400 Company: Monolithic Obelisks Shares: 130 Share Price: $3.25 Total Worth: $422.5 Company: Fleep Enterprises Shares: 60 Share Price: $6.5 Total Worth: $390 Most valuable holding: Company: Monolithic Obelisks Shares: 130 Share Price: $3.25 Total Worth: $422.5 Bye, Fleep Enterprises ! Bye, Monolithic Obelisks ! Bye, Boffo Objects ! Bye, NanoSmart ! 值得注意的是，大部分工作是在类设计完成的。完成类设计后，编写程序的工作本身相当简单。 顺便说一句，知道this指针就可以更深入了解C++的工作方式。例如，最初UNIX实现使用C++前端cfront将C++程序转换为C程序。处理方法的定义，只需要将下面这样的C++方法定义： void Stock::show() const { std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; std::endl &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; std::endl; } 转换为下面这样C-风格定义： void Show(const Stock * this) { std::cout &lt;&lt; &quot;Company: &quot; &lt;&lt; company &lt;&lt; &quot; Shares: &quot; &lt;&lt; shares &lt;&lt; std::endl &lt;&lt; &quot; Share Price: $&quot; &lt;&lt; share_val &lt;&lt; &quot; Total Worth: $&quot; &lt;&lt; total_val &lt;&lt; std::endl; } 即将Stock::限定符转换为函数参数（指向Stock的指针），然后用这个指针来访问类成员。 同样，该前端将下面的函数调用： top.show(); 转换为： show(&amp;top); 这样，将调用对象的地址赋给了this指针。 10.6 类作用域第9章介绍了全局（文件）作用域和局部（代码块）作用域。可以在全局变量所属文件的任何地方使用它，而局部变量只能在其所属的代码块中使用。函数名称的作用域也可以是全局的，但不能是局部的。C++类引入了一种新的作用域：类作用域。 在类中定义的名称（如类数据成员和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。即，要调用公有成员函数，必须通过对象： Stock sleeper{&quot;Exclusive Ore&quot;, 100, 0.25}; sleeper.show(); show(); //无效，不能直接调用方法 同样，在定义成员函数时，必须使用作用域解析运算符： void Stock::update(double price) {...} 总之，在类声明或成员函数定义中，可以使用未修饰的成员名称（未限定的名称），就像sell()调用set_tot()成员函数时那样。构造函数名称在被调用时，才能被识别，因为它的名称与类名相同。在其他情况下，使用类名称时，必须根据上下文使用直接成员运算符(.)、间接成员运算符(-&gt;)或作用域解析运算符(::)。下面的代码片段演示了如何访问具有类作用域的标识符： class IK { private: int fuss; public: IK(int f = 9) {fuss = f;} //过早函数 void ViewIK() const; } void IK::ViewIK() const { cout &lt;&lt; fuss &lt;&lt; endl; } int main() { IK * pik = new Ik; Ik ee = IK(8); ee.ViewIk(); pik-&gt;ViewIk(); } 10.6.1 作用域为类的常量有时候，使符号常量的作用域为类很有用。例如，类声明eng使用字面值30来指定数组的长度，由于该常量对于所有对象来说都是相同的，因此创建一个由所有对象共享的常量是个不错的注意。您可能以为这样做可行： class Bakery { private: const int Months = 12; double consts[Months]; ... 但这是行不通的，因为声明类只是描述了对象的形式，并没有创建对象。因此在创建对象前，将没有用于存储值的空间。然而，由两种方式可以实现这个目标，并且效果相同。 第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整个整型常量提供作用域为整个类的符号名称。即，可以这样开始Bakery声明： class Bakery { private: enum {Months = 12}; double costs[Months]; ... 注意，用这种方式声明枚举并不会创建类数据成员。即，所有对象中都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到它，编译器将用12来替换它。 由于这里使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供没居民。顺便说一句，在很多实现中，ios_base类在其公有部分中完成了类似的工作，诸如ios_base::fixed等标识符就来自这里。其中，fixed是ios_base类中定义的典型的枚举量。 C++提供了另一种在类中定义常量的方式—使用关键字static: class Bakery { private: static const int Months = 12; double costs[Months]; ... 这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Bakery对象共享。第12章将深入介绍静态类成员。 在C++98中，只能使用这种技术声明值为整数或枚举的静态常量，而不能存储doubLe常量。C++11消除了这种限制。 10.6.2 作用域内枚举(C++11)传统的枚举存在一些问题，其中之一就是两个枚举定义的枚举量可能发生冲突。假设有一个出差鸡蛋和T恤的项目，其中可能包含类似下面的代码： enum egg {Small, Medium, Large, Jumbo}; enum t_shirt {Small, Medium, Large, Xlarge}; 这将无法通过编译，因为egg Small和t_shirt Small位于相同的作用域内，它们将发生冲突。为避免这种问题，C++11提供了一种新枚举，其枚举量的作用域为类。这种枚举的声明类似下面这样： enum class egg {Small, Medium, Large, Jumbo}; enum class t_shirt {Small, Medium, Large, Xlarge}; 也可使用关键字struct代替class。无论使用哪种方式，都需要使用枚举名来限定枚举量： egg choice = egg::Large; t_shirt Floyd = t_shirt::Large; 枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生冲突了，而您可继续编写处理鸡蛋和T恤的项目。 C++还提供了作用域内枚举的类型安全。在有些情况下，常规枚举将自动转换为整型，如将其赋给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型： enum egg_old {Small, Medium, Large, Jumbo}; enum class t_shirt {Small, Medium, Large, Jumbo}; egg_old one = Mdeium; t_shirt rolf = t_shirt::Large; int king = one; int ring = rolf; //错误，不能隐式类型转换 if (king &lt; Jumbo) std::cout &lt;&lt; &quot;Jumbo converted to int before comparison.\n&quot;; if (king &lt; t_shirt::Medium) //错误 std::cout &lt;&lt; &quot;Not allowed: &lt; not defined for scoped enum.\n&quot;; 但在必要时，可进行显式类型转换： int Frodo = int(t_shirt::Small); 枚举用某种底层整型类型表示，在C++98中，如何选择取决于实现，因此包含枚举的结构的长度可能随系统而异。对于作用域内枚举，C++11消除了这种依赖性。默认情况下，C++11作用域内枚举的底层类型为int。另外，还提供了一种语法，可用于做出不同的选择： enum class : short pizza {Small, Medium, Large, Xlarge}; :short将底层类型指定为short。底层类型必须为整型。在C++11中，也可使用这种语法来指定常规枚举的底层类型，但如果没有指定，编译器的底层类型将随实现而异。 10.7 抽象数据类型Stock类非常具体。然而，程序员常常通过定义类来表示更通用的概念。例如，就实现计算机专家们所说的抽象数据类型(abstract data type, ADT)而言，使用类是一种非常好的方式。顾名思义，ADT以通用的方式描述数据类型，而没有引入语言或实现细节。例如，通过使用栈，可以以这样的方式存储数据，即总是从堆顶添加或删除数据。例如，C++程序使用栈来管理自动变量。当新的自动变量生成后，它们被添加到堆顶；消亡时，从栈顶中删除它们。 下面介绍一下栈的特征。首先，栈存储了多个数据项（该特征使得栈称为一个容器—一种更为通用的抽象）；其次，栈可对他执行的操作来描述。 可创建空栈； 可将数据项添加到堆顶(压入)； 可从栈顶删除数据项(弹出)； 可查看栈是否填满； 可插件栈是否为空。 可以将上述描述转换为一个类声明，其中公有成员函数提供了表示栈操作的接口，而私有数据成员负责存储数据。类概念非常适合于ADT方法。 私有部分必须表明数据存储的方式。例如，可以使用常规数组、动态分配数组或更高级的数据结构（如链表）。然而，公有接口应隐藏数据表示，而以通用的术语来表示，如创建栈、压入等。程序10.10演示了一种方法，它假设系统实现了bool类型。 程序10.10 stack.h #ifndef STACK_H_ #define STACK_H_ typedef unsigned long Item; class Stack { private: enum {MAX = 10}; Item items[MAX]; int top; public: Stack(); bool isempty() const; bool isfull() const; bool push(const Item &amp; item); bool pop(Item &amp; item); }; #endif 在程序10.10所示的示例中，私有部分表示，栈是使用数组实现的；而公有部分隐藏了这一点。因此，可以使用动态数组来代替数组，而不会改变类的接口。这意味着修改栈的实现后，不需要重新编写使用栈的程序，而只需要重新编译栈代码，并将其与已有的程序代码链接起来即可。 接口时冗余的，因此pop()和push()返回有关栈状态的信息（满或空），而不是void类型。在如何处理超出栈限制或清空栈方面，这位程序员提供了两种选择。它可以在修改栈前使用isempty()和isfull()来查看，也可以使用push()和pop()的返回值来确定操作是否成功。 这个类不是根据特定的类型来定义栈，而是根据通用的Item类型来描述。在这个例子中，头文件使用typedef用Item代替unsigned long。如果需要double栈或结构的栈，则只需要修改typedef语句，而类声明和方法定义保持不变。类模板（参见第14章）提供了功能更强大的方法，来讲存储的数据类型于类设计隔离开来。 接下来需要实现类方法。 程序10.11 stack.cpp #include &quot;stack.h&quot; #include &lt;iostream&gt; using namespace std; Stack::Stack() { top = 0; } bool Stack::isempty() const { return top == 0; } bool Stack::isfull() const { return top == MAX; } bool Stack::push(const Item &amp; item) { if (top &lt; MAX) { items[top++] = item; return true; } else return false; } bool Stack::pop(Item &amp; item) { if (top &gt; 0) { item = items[--top]; return true; } else return false; } 默认构造函数确保所有栈被创建时都是为空。pop()和push()的代码确保栈顶被正确处理。这种保证措施是OOP更可靠的原因之一。 下面来测试该栈。程序10.12模拟售货员的行为—使用栈的后进先出方式，从购物框的最上面开始处理购物订单。 程序10.12 stacker.cpp #include &quot;stack.h&quot; #include &lt;iostream&gt; #include &lt;cctype&gt; int main() { using namespace std; Stack st; char ch; unsigned long po; cout &lt;&lt; &quot;Please enter A to add a purchase order,\n&quot; &lt;&lt; &quot;P to process a PO, or Q to quit.\n&quot;; while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != &apos;Q&apos;) { while (cin.get() != &apos;\n&apos;) continue; if (!isalpha(ch)) { cout &lt;&lt; &apos;\a&apos;; continue; } switch(ch) { case &apos;A&apos;: case &apos;a&apos;: cout &lt;&lt; &quot;Enter a PO number to add: &quot;; cin &gt;&gt; po; if (st.isfull()) cout &lt;&lt; &quot;stack already full\n&quot;; else st.push(po); break; case &apos;p&apos;: case &apos;P&apos;: if (st.isempty()) cout &lt;&lt; &quot;stack already empty\n&quot;; else{ st.pop(po); cout &lt;&lt; &quot;PO #&quot; &lt;&lt; po &lt;&lt; &quot; popped\n&quot;; } break; } cout &lt;&lt; &quot;Please enter A to add a purchase order, \n&quot; &lt;&lt; &quot;P to process a PO, or Q to quit.\n&quot;; } cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } 程序运行结果： Please enter A to add a purchase order, P to process a PO, or Q to quit. A Enter a PO number to add: 17885 Please enter A to add a purchase order, P to process a PO, or Q to quit. P PO #17885 popped Please enter A to add a purchase order, P to process a PO, or Q to quit. A Enter a PO number to add: 17965 Please enter A to add a purchase order, P to process a PO, or Q to quit. A Enter a PO number to add: 18002 Please enter A to add a purchase order, P to process a PO, or Q to quit. P PO #18002 popped Please enter A to add a purchase order, P to process a PO, or Q to quit. P PO #17965 popped Please enter A to add a purchase order, P to process a PO, or Q to quit. P stack already empty Please enter A to add a purchase order, P to process a PO, or Q to quit. Q Bye. 10.8 总结类声明分成两部分组成。类声明放在头文件中；定义成员函数的源代码放在方法文件中。 类是用户定义的类型，对象是类的实例。即，对象是这种类型的变量。 每个对象都存储自己的数据，而共享类方法。 如果希望成员函数堆多个对象进行操作，可以讲额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用this指针。 类适合用于描述ADT。公有成员函数接口提供了ADt描述的服务，类的私有部分和类方法的代码提供了出现，这些实现对类的客户隐藏。]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小技巧]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[给初学者的Python小技巧，非常实用，可以用在你的程序中，代码瞬间变得高大上，看起来还有Pythonic（很Python）的感觉。 交换两个值a, b = 4, 10 print(a, b) a, b = b, a print(a, b) 在很多语言中，交换两个变量不得不引入一个临时变量，而Python可以直接交换，无需引入第三者。 评价列表中的字符串&gt;&gt;&gt; a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;] &gt;&gt;&gt; print(&quot; &quot;.join(a)) python is awesome 虽然你可以用“+”操作来合并多个字符串，但是使用join方法效率会更高哦。 查找列表中出现最频繁的元素&gt;&gt;&gt; a = [1, 2, 4, 3, 1, 2, 1, 3, 1] #方法一 &gt;&gt;&gt; print(max(set(a), key = a.count)) 1 #方法二 &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; cnt = Counter(a) &gt;&gt;&gt; print(cnt.most_common(3)) [(1, 4), (2, 2), (3, 2)] set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。 Counter在统计计算的时候给了我们很大的便利，无需自己再去造个轮子。 检查两个字符是否有相同的字符构成&gt;&gt;&gt; str1 = &quot;abc&quot; &gt;&gt;&gt; str2 = &quot;bcd&quot; &gt;&gt;&gt; Counter(str1) == Counter(str2) False &gt;&gt;&gt; str1 = &quot;abcd&quot; &gt;&gt;&gt; str2 = &quot;abcd&quot; &gt;&gt;&gt; Counter(str1) == Counter(str2) True 列表反转&gt;&gt;&gt; a = [5, 4, 3, 2, 1] &gt;&gt;&gt; print(a[::-1]) [1, 2, 3, 4, 5] &gt;&gt;&gt; for ele in reversed(a): print(ele) 1 2 3 4 5 &gt;&gt;&gt; reversed(a) &lt;list_reverseiterator object at 0x0000022DB7E244A8&gt; &gt;&gt;&gt; b = reversed(a) &gt;&gt;&gt; print(list(b)) [1, 2, 3, 4, 5] 列表有个reverse方法，也是反转列表，但是它是对原列表进行反转，而不是返回一个新的列表 装置二维数组&gt;&gt;&gt; original = [[&apos;a&apos;,&apos;b&apos;],[&apos;c&apos;,&apos;d&apos;],[&apos;e&apos;,&apos;f&apos;]] &gt;&gt;&gt; transposed = zip(*original) &gt;&gt;&gt; print(list(transposed)) [(&apos;a&apos;, &apos;c&apos;, &apos;e&apos;), (&apos;b&apos;, &apos;d&apos;, &apos;f&apos;)] 链式比较&gt;&gt;&gt; print(4 &lt; 6 &lt; 7) True &gt;&gt;&gt; print(1 == 6 &lt; 7) False &gt;&gt;&gt; print(1 &lt; 6 == 7) False 链式函数调用&gt;&gt;&gt; def product(a, b): return a * b &gt;&gt;&gt; def add(a, b): return a + b &gt;&gt;&gt; b = True &gt;&gt;&gt; print((product if b else add)(5, 7)) 35 拷贝列表&gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; b = a &gt;&gt;&gt; b[0] = 10 &gt;&gt;&gt; a [10, 2, 3, 4, 5] &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b[0] = 11 &gt;&gt;&gt; b [11, 2, 3, 4, 5] &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; print(list(a)) [1, 2, 3, 4, 5] &gt;&gt;&gt; print(a.copy()) [1, 2, 3, 4, 5] &gt;&gt;&gt; from copy import deepcopy &gt;&gt;&gt; l = [[1, 2], [3, 4]] &gt;&gt;&gt; l2 = deepcopy(l) &gt;&gt;&gt; print(l2) [[1, 2], [3, 4]] 字典get&gt;&gt;&gt; d = {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; print(d.get(&apos;c&apos;, 3)) 3 &gt;&gt;&gt; d {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; print(d.get(&apos;a&apos;, 3)) 1 找不到时，返回默认值 按字典的值排序&gt;&gt;&gt; d = {&apos;a&apos;: 1, &apos;b&apos;: 3, &apos;c&apos;: 2} &gt;&gt;&gt; print(sorted(d.items(), key = lambda x: x[1])) [(&apos;a&apos;, 1), (&apos;c&apos;, 2), (&apos;b&apos;, 3)] &gt;&gt;&gt; from operator import itemgetter &gt;&gt;&gt; print(sorted(d.items(), key=itemgetter(1))) [(&apos;a&apos;, 1), (&apos;c&apos;, 2), (&apos;b&apos;, 3)] &gt;&gt;&gt; print(sorted(d, key=d.get)) [&apos;a&apos;, &apos;c&apos;, &apos;b&apos;] for elsea = [1, 2, 3, 4, 5] for el in a: if el == 0: break else: print(&quot;did not brek out of for loop&quot;) ==================== RESTART: C:/Users/zxp/Desktop/11.py ==================== did not brek out of for loop 将列表转成用逗号分割的字符串&gt;&gt;&gt; items = [&apos;foo&apos;, &apos;bar&apos;, &apos;xyz&apos;] &gt;&gt;&gt; print(&apos;,&apos;.join(items)) foo,bar,xyz &gt;&gt;&gt; numbers = [2, 3, 4, 5] &gt;&gt;&gt; print(&apos;,&apos;.join(map(str, numbers))) 2,3,4,5 &gt;&gt;&gt; data = [2, &apos;hello&apos;, 3, 4.4] &gt;&gt;&gt; print(&apos;,&apos;.join(map(str, data))) 2,hello,3,4.4 合并字典&gt;&gt;&gt; d1 = {&apos;a&apos;: 1} &gt;&gt;&gt; d2 = {&apos;b&apos;: 2} &gt;&gt;&gt; print({**d1, **d2}) {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; print(dict(d1.items() | d2.items())) {&apos;a&apos;: 1, &apos;b&apos;: 2} &gt;&gt;&gt; d1.update(d2) &gt;&gt;&gt; d1 {&apos;a&apos;: 1, &apos;b&apos;: 2} 获取列表中最大值与最小值的位置&gt;&gt;&gt; lst = [3, 1, 2, 4] &gt;&gt;&gt; def minIndex(lst): return min(range(len(lst)), key=lst.__getitem__) &gt;&gt;&gt; def maxIndex(lst): return max(range(len(lst)), key=lst.__getitem__) &gt;&gt;&gt; print(minIndex(lst)) 1 &gt;&gt;&gt; print(maxIndex(lst)) 3 移除列表中重复的元素&gt;&gt;&gt; items = [2, 2, 3, 3,1] &gt;&gt;&gt; newitems = list(set(items)) &gt;&gt;&gt; print(newitems) [1, 2, 3] &gt;&gt;&gt; from collections import OrderedDict &gt;&gt;&gt; items = [&apos;foo&apos;, &apos;bar&apos;, &apos;bar&apos;, &apos;foo&apos;] &gt;&gt;&gt; print(list(OrderedDict.fromkeys(items).keys())) [&apos;foo&apos;, &apos;bar&apos;] 转自:https://mp.weixin.qq.com/s/k_coGMYUd8aBpqX67yWQbw]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--内存模型和名称空间（九）]]></title>
    <url>%2F2018%2F10%2F18%2FC%2B%2B%20Primer%20Plus--%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[单独编译，存储持续性、作用域和链接性，定位运算符，名称空间。 9.1 单独编译和C语言一样，C++允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独地编译这些文件，然后将它们链接成可执行文件的程序。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。 大多数C++环境提供了其他工具来帮助管理。比如：Linux系统具有make程序，可以跟踪程序依赖文件以及这些文件的最后修改时间。运行make时，如果检测上次编译后修改了源文件，make将记住重新构建所需的步骤。大多数继承环境都在project菜单中提供了类似的工具。 C++提供了#include来处理不同文件使用同一个结构的问题。与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该文件头。这样，要修改结构声明时，只需在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。因此，可以将原来的程序分成三部分： 头文件：包含结构声明和使用这些结构的函数的原型。 源代码文件：包含与结构有关的函数的代码。 源代码文件：包含调用与结构相关的函数的代码。 这是一种非常有用的组织程序的策略。例如，如果编写另一个程序，也需要使用这些函数，则只需要包含头文件，并将函数文件添加到项目列表或make列表中即可。另外，这种组织方式也与OOP方法一致。一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操作用户定义类型的函数的代码。这两个文件组成了一个软件包，可用于各种程序中。 请不要将函数定义或变量声明放在头文件中。这样做对于简单的情况可能是可行的，但通过会迎来麻烦。例如，如果头文件包含一个函数定义，然后在其他两个文件中包含该头文件，则同一个程序中包含同一个函数的两个定义，除非函数是内联的，否则这将出错。 下面列出了头文件中包含的内容： 函数原型 使用#define或const定义的符合常量 结构声明 类声明 模板声明 内联函数 将结构放在头文件中可以的，因为它们不会创建变量，而只是在源代码文件中声明结构时，告诉编译器如何创建变量。同样，模板声明不是被编译的代码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义。被声明为const的数据和内联函数有特殊的链接属性，因此可以放在头文件中。 下面三个程序是将第7章中坐标转换程序分成几个独立部分后得到的结果。注意，在包含头文件时，使用“coordin.h”，而不是&lt;coordin.h&gt;。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录。如果没有在那里找到头文件，则将在标准位置查找，因此在包含自己的头文件时，应使用双引号而不是尖括号。 coordin.h #ifndef COORDIN_H_ #define COORDIN_H_ struct polar { double distance; double angle; }; struct rect { double x; double y; }; polar rect_to_polar(rect xypos); void show_polar(polar dapos); #endif file1.cpp #include &lt;iostream&gt; #include &quot;coordin.h&quot; using namespace std; int main() { rect rplace; polar pplace; cout &lt;&lt; &quot;Enter the x and y value: &quot;; while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) { pplace = rect_to_polar(rplace); show_polar(pplace); cout &lt;&lt; &quot;Nest two number(q to quit): &quot;; } return 0; } file2.cpp #include &lt;iostream&gt; #include &lt;cmath&gt; #include &quot;coordin.h&quot; using namespace std; polar rect_to_polar(rect xypos) { polar answer; answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y); answer.angle = atan2(xypos.y, xypos.x); return answer; } void show_polar(polar dapos) { const double Rad_to_deg = 57.29577951; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; dapos.distance; cout &lt;&lt; &quot;, Angle = &quot; &lt;&lt; dapos.angle * Rad_to_deg &lt;&lt; &quot; degrees.\n&quot;; } 编译多文件 g++ file1.cpp file.cpp -o file 运行可执行文件 ./file 结果： Enter the x and y value: 30 100 Distance = 104.403, Angle = 73.3008 degrees. Nest two number(q to quit): q 我们讨论的是根据文件进行单独编译，但为保持通用性，C++标准使用了术语”翻译单元”，而不是文件；文件并不是计算机组织信息时的唯一方式。出于简化的目的，可将文件术语解释为“翻译单元”。 头文件管理 在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef(即if not defint)的。下面的代码片段意味着仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#ifndef和endif之间的语句： #ifndef COORDIN_H_ ... #endif 通常，使用#define语句用来创建符合常量，如下： #define MAXIMUM 4096 但只要将#define用于名称，就足以完成该名称的定义，如下： #define COORDIN_H_ 使用这种技术将文件内容包含在#ifdef中： #ifndef COORDIN_H_ #define COORDIN_H_ ... #endif 编译器首次遇到该文件时，名称COORDIN_H_没有定义（根据include文件名来选择名称，并加上一些下划线，以创建一个在其他地方不太可能被定义的名称）。在这种情况下，编译器将查看#ifndef和#endif之间的内容，并读取定义COORDIN_H_的这一行。如果在同一文件中遇到其他包含coordin.h的代码，编译器将知道COORDIN_H_已经被定义了，从而跳到#endif后面的一行上。注意，这种方法并不能防止编译器将文件包含两次，而只是让它忽略地磁包含之外的所有内容。大多数标准C/C++头文件都使用这种防护方案。否则，可能在一个文件中定义同一个结构两次，这将导致错误。 多个库的链接 C++标准允许每个编译器设计人员以他认为合适的方式实现名称修饰（第8章已经介绍），因此由不同的编译器创建的二进制模板可能无法正确地链接。即，两个编译器将为同一个函数生成不同的修饰名称。名称的不同将使链接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有对象文件或库都是由同一个编译器生成的。如果有源代码，通常可以用自己的编译器重新编译源代码来消除链接错误。 9.2 存储连续性、作用域和链接性接下来扩展第4章对内存方案的讨论，即存储类别如何影响信息在文件间的共享。先复习一下内存有关的知识。C++使用三种不同的方案存储数据，这些方案区别在于数据保留在内存的时间。 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。 静态存储存储性：在函数定义外定义的变量和使用的关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。 线程存储持续性（C++11）：当前，多核处理很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量使用关键字thread_local声明的，则其声明周期与所属的线程一样长。（本系列不讨论） 动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时候被称为自由存储或堆。 下面介绍，各种变量合适在作用域内或可间以及链接性的细节。链接性决定了哪些可在文件间共享。 9.2.1 作用域和链接作用域描述了名称在文件（翻译单元）的多大范围可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件的函数定义之前定义的变量则可在所有函数中使用。 链接性描述了名称如何在不同单元（文件）间共享。链接性为外部的名称可文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。 C++函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的。 9.2.2 自动存储持续性在默认情况下，在函数中声明的函数参数和变量的存储性为自动，作用域为局部，没有链接性。即，如果在main()中声明一个名为tesas的变量，并在函数oil()中也声明一个名为tesax变量，则创建了两个独立的变量—只有在定义它们的函数中才能使用它们。 如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。例如，假设在main()的开头定义了一个名为teledeli的变量，然后在main()中开始一个新的代码块，并其中定义了一个新的websight，则teledeli在内部代码块和外部代码块都是可见的，而wabsight就只在内部代码块中可见，它的作用域是从定义它的位置到该代码块的结尾： int main() { int teledeli = 5; { int websight = -2; cout &lt;&lt; websight &lt;&lt; &apos; &apos; &lt;&lt; teledeli &lt;&lt; endl; } cout &lt;&lt; teledeli &lt;&lt; endl; } 而，如果将内部代码块中的变量命名为teledeli，而不是websight，使得有两个同名的变量（一个位于外部代码块中，另一个位于内部代码块中）。在这种情况下，程序执行内部代码块中的语句时，将teledeli解释为局部代码块变量。新的定义隐藏了以前的定义，新定义可见，旧定义暂时不见。在程序离开该代码块时，原来的定义又重新可见。 auto.cpp #include &lt;iostream&gt; using namespace std; void oil(int x); int main() { int texas = 31; int year = 2018; cout &lt;&lt; &quot;In main(), texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; oil(texas); cout &lt;&lt; &quot;In main(), texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; return 0; } void oil(int x) { int texas = 5; cout &lt;&lt; &quot;In oil(), texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; cout &lt;&lt; &quot;In oil(), x = &quot; &lt;&lt; x &lt;&lt; &quot;, &amp;x = &quot;&lt;&lt; &amp;x &lt;&lt; endl; { int texas = 113; cout &lt;&lt; &quot;In block, texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; cout &lt;&lt; &quot;In block, x = &quot; &lt;&lt; x &lt;&lt; &quot;, &amp;x = &quot;&lt;&lt; &amp;x &lt;&lt; endl; } cout &lt;&lt; &quot;Post-block, texas = &quot; &lt;&lt; texas &lt;&lt; &quot;, &amp;texas = &quot;&lt;&lt; &amp;texas &lt;&lt; endl; } 结果 In main(), texas = 31, &amp;texas = 0x7fffa7f13e28 In oil(), texas = 5, &amp;texas = 0x7fffa7f13dfc In oil(), x = 31, &amp;x = 0x7fffa7f13dec In block, texas = 113, &amp;texas = 0x7fffa7f13df8 In block, x = 31, &amp;x = 0x7fffa7f13dec Post-block, texas = 5, &amp;texas = 0x7fffa7f13dfc In main(), texas = 31, &amp;texas = 0x7fffa7f13e28 执行main()时，程序为texas分配空间，使得这些变量可见。当程序调用oil()时，这些变量仍留在内存中，但不可见。为两个新变量（x和texas）分配内存，从而使它们可见。在执行到oil()中的内部代码块时，新的texas将不可见，它被一个更新的定义代替。然而，变量x仍可见，这是因为该代码块中没有定义x变量。当程序流程离开该代码块时，将释放最新的texas使用的内存，而第二个texas再次可见。当oil()函数结束时，texas和x都将过期，而最初的texas再次变得可见。 使用C++11中的auto C++11中，关键字auto用于自动类型推断。但在C语言和以前的C++中，auto的含义截然不同，它用于显式地指出变量为自动存储： int froob(int n) { auto float ford; ... } 由于只能将关键字auto用于默认为自动的变量，因此程序员几乎不使用它。它的主要用途是指出当前变量为局部自动变量。 在C++11中，这种用法不再合法。指定标准的人不愿引入新关键字，因为这样做可能导致将关键字用于其他目的代码非法。考虑到auto的老用法很少使用，因此赋予其新含义比引入新关键字是更好的选择。 1.自动变量的初始化可以使用任何在声明时其值为已知的表达式来初始化自动变量，下面的示例初始化变量x,y和z： int w; int x = 5; int big = INT_MAX - 1; int y = 2 * x; cin &gt;&gt; w; int z = 3 * w; 2.自动变量和栈由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以称为栈，是由于新数据被象征性地放在原有数据的上面（即，在相邻的内存单元中，而不是在同一内存单元中），当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。 程序使用两个指针来跟踪栈，一个指针指向栈低—栈的开始位置；另一个指针指向栈顶–下一个可以内存单元。当函数调用时，其自动变量将加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。 栈是LIFO(后进先出)的，即最后加入栈的变量最先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。 3.寄存器关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量： register int count_fast; 这旨在提供访问变量的速度。 在C++之前，这个关键字在C++中的用法始终未变，只是随着硬件和编译器变得越来越复杂，这种提示表明变量用的很多，编译器可对其做特殊处理。在C++中，这种提示作用也失去了，关键字register只是显式地指出变量是自动的。鉴于关键字register只能用于原本就是自动的变量，使用它的唯一原因是指出程序员想使用一个自动变量，这个变量的名称可能于外部变量相同。这与auto以前的用途完全相同。然后，保留关键字register的重要原因是，避免使用了该关键字的现有代码非法。 9.2.3 静态持续变量和C语言一样，C++也为静态存储持续性变量提供了3中链接性：外部链接（可在其他文件中访问）、内部链接（只能在当前文件中访问）和无链接（只能在当前函数或代码块中访问）。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化为静态变量，编译器将把他设置为0.在默认情况下，静态数组和结构每个元素或成员的所有都设置为0。 下面介绍如何创建3种静态持续变量： 要想创建链接性为外部的静态持续变量，必须在代码块的外部声明它； 要想创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符； 要创建没有链接性的静态持续变量，必须在代码块内部声明它，并使所以static限定符。 下面的代码说明了3种变量： int gloabl =1000; //静态持续性变量，外部链接 static int one_file = 50; //静态持续性变量，内部链接 int main() {...} void fun1(int n) { static int count = 0; //静态持续性变量，没有链接性 int llama = 0; } void fun2(int q) {...} 正如前面指出的，所有静态持续变量（global\one_file\count）在整个程序执行期间都存在。 在fun1中声明的变量count作用域为局部，没有链接性，这意味只能在fun1()函数中使用它，就像自动白llama一样。然而，与llama不同的是，即使在func1()函数没有被执行时，count也留在内存中。 global和one_file的作用于都为整个文件，即从声明位置到文件结尾的范围内都可以被使用。具体说，可以在main()、fun1()和fun2()中使用它。由于one_file的链接性为内部，因此只能在包含上述代码的文件中使用它；由于global的链接性为外部，因此可在程序的其他文件中使用它。 所有的静态持续性变量又下述初始化特征：未被初始化的静态变量的所有为被设置为0。这种变量被称为零初始化的。 下表总结了5中变量的存储特性。 5种变量存储方式 存储描述 持续性 作用域 链接性 如何声明 自动 自动 代码块 无 在代码块中 寄存器 自动 代码块 无 在代码块中，使用关键字register 静态，无链性 静态 代码块 无 在代码块中，使用关键字static 静态，外部链接性 静态 文件 外部 不在任何函数内 静态，内部链接性 静态 文件 内部 不在任何函数内，使用关键字static 静态变量初始化 除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件时初始化变量。动态初始化意味着变量将在编译后初始化。 初始形式由什么因素决定？首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容就可计算表达式，编译器将执行常量表达式初始化。必要时，编译器将执行简单计算。如果没有足够的信息，变量将被动态初始化。情况如下代码： #include &lt;cmath&gt; int x; //零初始化 int y = 5; //常量表达式初始化 long z = 13 * 13; //常量表达式初始化 const double pi = 4.0 * atan(1.0); //动态初始化 首先，x,y,z和pi被零初始化。然后，编译器计算常量表达式，并将y和z分别初始化为5和169。但要初始化pi，必须调用函数atan()，这需要等到函数被链接且程序执行时。 常量表达式并非只能是使用字面常量的算术表达式。例如，它还可以使用sizefo运算符： int enough = 2 * sizeof(long) + 1; C++新增了关键字constexpr，这增加了创建常量表达式的方式。 9.2.4 静态持续性、外部链接性链接性未外部的变量简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言是都是外部的。 1.单定义规则一方面，在每个使用外部变量的文件中，都必须声明它；另一方面，C++有“单定义规则”，该规则指出，变量只能有一次定义。为满足这种需求，C++提供了两种变量声明，一种是定义声明或简称定义，它给变量分配存储空间；另一种是引用声明或简称声明，它不给变量分配存储空间，因为它引用已有变量。 引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间: double up; extern int blem; //声明 extern char gr = &apos;z&apos;; //定义，因为初始化 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，但在使用该变量的其他所有文件中，都必须使用关键字extern声明它： //file1.cpp extern int cats = 20; //定义 int dogs = 22; //定义 int fleas; //定义 //file2.cpp //使用来自文件file1.cpp的变量cats,dogs extern int cats; extern int dogs; //file3.cpp //使用来自文件file1.cpp的变量cats,dogs,fleas extern int cats; extern int dogs; extern int fleas; 在这里，所有文件都使用了file1.cpp中定义的变量cats和dogs，但file2.cpp没有重新声明变量fleas，因此无法访问它。在file1.cpp中，关键字extern并非必不可少，因为即使省略它，效果也相同。 注意，单定义规则并非意味着不能有多个变量的名称相同。例如，在不同函数中声明的同名自动变量是彼此独立，它们都有自己的地址。另外，正如前面示例所表示的，局部变量可能隐藏同名的全局变量。然而，虽然程序中可包含多个同名的变量，单每个变量都只有一个定义。 如果在函数中声明了一个与外部变量同名的变量，这种声明将被视为一个自动变量的定义，当程序执行自动变量所属的函数时，该变量将位于作用域内。 external.cpp #include &lt;iostream&gt; using namespace std; double warming = 0.3; void update(double dt); void local(); int main() { cout &lt;&lt; &quot;Global warming is &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; update(0.1); cout &lt;&lt; &quot;Global warming is &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; local(); cout &lt;&lt; &quot;Global warming is &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; return 0; } support.cpp #include &lt;iostream&gt; using std::cout; extern double warming; void update(double dt); void local(); void update(double dt) { extern double warming; warming += dt; cout &lt;&lt; &quot;Updating global warming to &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; } void local() { double warming = 0.8; cout &lt;&lt; &quot;Local warming = &quot; &lt;&lt; warming &lt;&lt; &quot; degrees.\n&quot;; cout &lt;&lt; &quot;But global warming = &quot; &lt;&lt; ::warming &lt;&lt; &quot;dgrees.\n&quot;; } 结果 Global warming is 0.3 degrees. Updating global warming to 0.4 degrees. Global warming is 0.4 degrees. Local warming = 0.8 degrees. But global warming = 0.4dgrees. Global warming is 0.4 degrees. main()和update()都可以访问外部变量warming，注意update()修改了warming，这种修改在随后的使用该变量时显现出来了。 在external.cpp中，warming的定义如下： double external = 0.3; //定义 在support.cpp中，使用关键字external声明变量warming，让该文件中的函数能够使用它： extern double warming; //使用来自external文件中的变量warming 另外，函数update()使用关键字extern重新声明了变量warming，这个关键字的意思是，通过这个关键字的意思是，通过这个名称使用在外部定义的变量。由于即使省略该声明，update()的功能也相同，因此该声明是可选的。它指出了函数被设计成使用外部变量。 local()函数表明，定义与全局变量同名的局部变量后，局部变量将隐藏全局变量。例如，local()函数显示warming的值时，将使用warming的局部定义。 C++提供了作用域解析运算符（::）。放在变量前面时，该运算符表示使用的全局变量版本。因此，local()将warming显示为0.8，但::warming显示为0.4。 全局变量和局部变量 所有的函数能访问全局变量，因此不用传递参数。但易于访问的代价很大–程序不可靠。程序越能避免对数据进行不必要的访问，就越能保持数据的完整性。通过情况下，应使用局部变量，应在需要知晓时才传递数据，而不应不加区分地使用全局变量来使数据可用。全局变量尤其适合于表示常量数据，因为这样可以使用关键字const来防止数据被修改。比如，月份数组： const char * const months[12] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;Auguest&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; } 第一个const表示数组中的元素为常量，防止修改字符串，而第二个const表示数组中每个指针始终指向它最初指向的字符串。 9.2.5 静态持续性、内部链接性将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部。在多文件中程序，内部链接性和外部链接性之间的差别很有意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都具有外部链接性，即可以在其他文件中使用。 如果要在其他文件中使用相同的名来表示其他变量，该如何办呢？只需省略关键字extern即可吗？ //file1.cpp int errors; //file2.cpp int errors; void froobins(){cout &lt;&lt; errors;} 这种做法将失败，因为它违反了单定义规则。file2.cpp中的定义试图创建一个外部变量，因此程序将包含errors的两个定义，这是错误的。 如果文件定义了一个静态外部变量，其名称与另一个文件声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量： //file1.cpp int errors; //file2.cpp static int errors = 5; void froobins(){cout &lt;&lt; errors;} 这没有违反单定义规则，因为关键字static指出标识符errors的链接性为内部，因此并非要提供外部定义。 注意：在多文件程序中，可以在一个文件中定义一个外部变量。使用该变量的其他文件必须使用关键字extern声明它。 可使用外部变量在多个文件程序的不同部分之间共享数据；可使用链接为内部的静态变量在同一个文件中的多个函数之间共享数据。另外，如果将作用域为整个文件的变量变为静态，就不必担心其名称与其他文件中的做业务为整个文件的变量发送冲突。 下面程序演示了如何处理链接性为外部和内部的变量。 twofile1.cpp #include &lt;iostream&gt; int tom = 3; //外部变量 int dick = 30; //外部变量 static int harry = 300; //静态外部变量 void remote_access(); using namespace std; int main() { cout &lt;&lt; &quot;main() reports the following addresses:\n&quot; ; cout &lt;&lt; &amp;tom &lt;&lt; &quot; = &amp;tom. &quot; &lt;&lt; &amp;dick &lt;&lt; &quot; = &amp;dick, &quot;; cout &lt;&lt; &amp;harry &lt;&lt; &quot; = &amp;harry\n&quot;; remote_access(); return 0; } twofile2.cpp #include &lt;iostream&gt; extern int tom; //声明，使用twofile1.cpp中定义的tom变量 static int dick = 10; //覆盖外部变量dick int harry = 200; //外部变量定义，不与twofile1.cpp中的harry冲突 using namespace std; void remote_access() { cout &lt;&lt; &quot;remote_access() reports the following addresses:\n&quot;; cout &lt;&lt; &amp;tom &lt;&lt; &quot; = &amp;tom, &quot; &lt;&lt; &amp;dick &lt;&lt; &quot; = &amp;dick, &quot;; cout &lt;&lt; &amp;harry &lt;&lt; &quot; = &amp;harry&quot;; } 结果 main() reports the following addresses: 0x60104c = &amp;tom. 0x601050 = &amp;dick, 0x601054 = &amp;harry remote_access() reports the following addresses: 0x60104c = &amp;tom, 0x601058 = &amp;dick, 0x60105c = &amp;harry 从上述地址可知，这两个文件使用了同一个tom变量，但使用了不同的dick和harry变量。 9.2.6 静态存储持续性、无链接性创建无连接性的局部变量，将static限定符用于代码块中定义的变量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。这意味着虽然该变量只在该代码块中可用，但它在该代码块中不处于活动状态时仍然存在。因此，在两次函数调用之间，静态局部变量的值将保持不变。 另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化。以后调用函数时，将不会像自动变量那样再次被初始化。 static.cpp #include &lt;iostream&gt; using namespace std; const int ArSize = 10; void strcount(const char * str); int main() { char input[ArSize]; char next; cout &lt;&lt; &quot;Enter a line:\n&quot;; cin.get(input, ArSize); while (cin) { cin.get(next); while (next != &apos;\n&apos;) cin.get(next); strcount(input); cout &lt;&lt; &quot;Enter next lin (empty line to quit):\n&quot;; cin.get(input, ArSize); } cout &lt;&lt; &quot;Bye.\n&quot;; return 0; } void strcount(const char * str) { static int total = 0; int count = 0; cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; contains &quot;; while (*str++) count ++; total += count; cout &lt;&lt; count &lt;&lt; &quot; characters\n&quot;; cout &lt;&lt; total &lt;&lt; &quot; characters total.\n&quot;; } 结果 Enter a line: nice pants &quot;nice pant&quot; contains 9 characters 9 characters total. Enter next lin (empty line to quit): thanks &quot;thanks&quot; contains 6 characters 15 characters total. Enter next lin (empty line to quit): parting is such sweet sorrow &quot;parting i&quot; contains 9 characters 24 characters total. Enter next lin (empty line to quit): ok &quot;ok&quot; contains 2 characters 26 characters total. Enter next lin (empty line to quit): Bye. 该程序中使用了一种处理行输入可能长于目标数组的方法，cin.get(input, ArSize)将一直读取输入，直到达到行尾或读取了ArSize-1个字符为止。它把换行符留在队列中。该程序使用cin.get(next)读书行输入后的字符。如果next是换行符，在说明cin.get(input, ArSize)读取了整行；否则说明行中还有字符没有被读取。随后，程序使用一个循环来丢弃余下的字符。该程序还是用cin.get(char*, int)读取空行将导致cin为false。 注意到，每次函数被调用时，自动变量count被重置为0。而静态变量total只在程序运行时被设置为0，以后在两次函数调用之间，其值保持不变，因此能够记录读取的字符总数。 9.2.7 说明符和限定符有些被称为存储说明符或cv-限定符的C++关键字提供了其他有关存储的信息。下面是存储说明符： auto(C++中不再是说明符): 在C++之前，可以在声明中使用关键字auto指出变量为自动变量，但在C++11中，auto用于自动类型推断。 register: 关键字register用于在声明中指示寄存器存储，而在C++11中，它指示显示地指出变量是自动的。 static: 关键字static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。 extern: 关键字extern表明引用声明，即声明引用在其他地方定义的变量。 thread_local(C++新增): 关键字thread_lcoal指出变量的持续性雨其所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。 mutable： 关键字mutable的含义将根据const来解释。thread_local可与static或extern结合使用。 1. CV限定符下面是cv限定符： const volatile 最常用的cv-限定符是const，它表明，内存被初始化后，程序边便不能再对它进行修改。 关键字volatile表明，即使程序代码没有对他内存单元进行修改，其值也可能发送变化。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件（而不是程序）可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条与剧中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次时间之间不会变化。如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。 2. mutablemutable可以指出，即使结构（或类）变量为const，其某个成员也可以被修改。例如： struct data { char name[30]; mutable int accesses; }; const data veep = {&quot;Clodde&quot;, 0}; strcpy(veep.name, &quot;Joye&quot;); // 非法 veep.accesses++; //被声明为mutable，所以是合法的 veep的const限定符禁止程序修改veep的成员，但accesses成员的mutable说明符是的accesses不受这种限制。 3. 再谈const在C++中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部，但const全局变量的链接性为内部。即，在C++看来，全局const定义就像使用了static说明符一样： const int fingers = 10; //同static const int fingers = 10一样 int main() {...} C++修改了常量类型的规则。例如，假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都将包含类似下面的定义： const int fingers = 10; const char * waring = &quot;Wak!&quot;; 如果全局const声明的链接性像常规变量那样为外部的，则根据单定义规则，这将出错。即，只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明。另外，只有使用extern关键字的声明才能进行初始化： extern const int fingers; //不能被初始化 extern const char * waring; 因此，需要为某个文件使用一组定义，而其他文件使用另一组声明。然而，由于外部定义的const数据的链接性为内部，因此可以在所有文件中使用相同的声明。 内部链接性还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是其所属文件私有的，这就是能够将常量定义放在头文件中的原因。这样，只要在两个源代码文件中包括同一个头文件，则它们可以获得同一组常量。 如果出于某种原因，程序员希望某个常量的链接为外部，则可以使用extern关键字来覆盖默认的内部链接性： extern const int states = 50; 在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。这与常规外部变量不同，定义常规外部变量时，不必使用extern，但使用该变量的其他文件中必须使用extern，然而，鉴于单个const在多个文件之间共享，因此只有一个文件可对其进行初始化。 在函数或代码块中声明const，其作用域为代码块，即仅当程序执行该代码块中的代码时，该常量才可用的。这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量冲突。 9.2.8 函数和链接性和变量一样，函数也有链接性，虽然可选择的范围比变量小。和C语言一样，C++不允许在一个函数中定义另一个函数，因此所有的函数的存储新都自动为静态的，即在整个程序执行期间都一直存在。默认情况下，函数的链接性为外部的，即可以文件间共享。 实际上，可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，不过这是可选的。还可以使用关键字static将函数的链接性设置为内部，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字： static int private(double x); static int private(double x) {...} 这意味着该函数只在这个文件中可见，还意味着可以在其他文件中可以定义同名函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。 单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。 内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。然而，C++要求同一个函数的所有内联定义都必须相同。 C++在哪里查找函数 假设在程序的某个文件中调用了一个函数，C++将到哪里去寻找该函数的定义呢？如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；否则，编译器（包括链接程序）将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。 9.2.9 语言链接性另一种形式的链接性–称为语言链接性也对函数有影响。 首先介绍一些背景知识，链接程序要求每个不同的函数都有不同的符合名。在C语言中，一个名称只对应一个函数，因此容易实现。为满足内部需要，C语言编译器可能将spiff这样的函数名翻译为_spiff。这种方法称为C语言链接性。但在C++中，同一名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称矫正或名称修饰（参考第八章），为重载函数生成不同的符号名称。例如，可能将spiff(int)转换为_spiff_i，而将spiff(double,double)转换为_spiff_d_d。这种方法被称为C++语言链接。 链接程序寻找与C++函数调用匹配的函数时，使用的方法与C语言不同。但如果要在C++程序中使用C库中预编译的函数。将出现什么情况？例如： spiff(22); //spiff(int)来子一个C库 它在C库文件中的符号名称为_spiff，但对于我们假设的链接程序来说，C++查询约定是查找符号名称_spiff_i。为解决这种问题，可以用函数原型来指出要使用的约定： extern &quot;C&quot; void spiff(int); extern void spiff(int); extern &quot;C++&quot; spiff(int); 第一个原型使用C语言链接性；而后面的两个使用C++语言链接性。第二个原型是通过默认方式指出这一点的。 C和C++链接性是C++标准指出的说明符，但实现可提供其他语言链接性说明符。 9.2.10 存储方案和动态分配前面介绍C++用来为变量（包括数组和结构）分配内存的5中方案，它们不适用于使用C++运算符new(或C函数malloc())分配内存，这种内存被称为动态内存。第4章介绍过，动态内存有运算符new和delete控制，而不是由作用域和链接性规则控制。因此，可以在一个函数中分配动态内存，而在另一个函数中将其释放。与自动内存不同，动态内存不是LIFO，其分配和释放顺序要取决于new和delete在何时以何种方式被使用。通常，编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，另一块用于动态存储。 虽然存储方案概念不再适用于动态存储，但适用于用来跟踪动态内存的自动和静态指针变量。例如，假设一个函数中包含下面的语句： float * p_fees = new float[20]; 由new分配的80个字节（假设float为4个字节）的内存将一直保留再内存中，直到使用delete运算符将其释放。但当包含该声明的语句块执行完毕时，p_fees指针将消失。如果希望另一个函数能够使用这80个字节中的内容，则必须将其地址传递或返回给该函数。另一方面，如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都可以使用它。另外，通过在另一个文件中使用下述声明，便可在其中使用该指针： extern float * p_fees; 注意： 当程序结束时，由new分配的内存通常都将被释放，不过情况也并不总是这样。例如，在不那么健壮的操作系统中，有某些情况下，请求大型内存块将导致该代码块在程序结束不会被自动释放。最佳的做法是，使用delete来释放new分配的内存。 1.使用new运算符初始化为内置的标量类型分配存储空间并初始化，可在类型后后面加上初始值，并将其用括号括起来： int * pi = new int (6); double * pd = new double (99.99); 这种语法也可用于由合适构造函数的类型。 然而，要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11: struct where {double x; double y; double z}; where * one = new where{3.5, 4.5, 6.6}; int *ar = new int [4] {1,2,3,4}; 在C++11中，还可以将列表初始化用于单值变量： int * pin = new int {6}; double * pdo = new double {99.99}; 2.new失败时new可能找不到请求的内存量。在最初的10年中，C++在这种情况下让new返回空指针，但现在将引发异常std::bad_alloc。第15章通过一些简单的例子演示了这两种方法的工作原理。 3.new: 运算符、函数和替换函数运算符new和new[]分别调用如下函数： void * operator new(std::size_t); void * operator new[](std::size_t); 这些函数被称为分配函数，它们位于全局名称空间中。同样，也有由delete和delete[]调用的释放函数： void operator delete(void *); void operator delete[] (void *); 它们使用第11章将讨论的运算符重载语法。std::size_t是一个typedef，对应于合适的整型。对于下面这样的基本语句： int * pi = new int; 被转换为下面的语句： int * pi = new(sizeof(int)); 而下面的语句： int * pa = new int [14]; 被转换为下面这样： int * pa = new(14 * sizeof(int)); 使用new的语句也可能包含初始值，因此，使用new运算符时，不仅仅调用new()函数。 同样， 下面的语句： delete pi; 将转换位如下函数调用： delete (pi); C++将这些函数称为可替换的。这意味着如果您有足够的知识和意愿，可为new和delete提供替换函数，并根据需要对其进行定制。例如，可定义作用域为类的替换函数，并对其进行定制，以满足该类的内存分配需求。在代码中，仍将使用new运算符，但它将调用您定义的new()函数。 4.定位new运算符通过，new负责在堆中找到一个足以能够满足需求的内存块。new运算符还有另一个种变体，被称为定位new运算符，它让您能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。 要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；然后将new运算符用于提高了所需地址的参数。除需要指定参数外，句法与常规new运算符相同。具体说，使用定位new运算符时，变量后面可以有方括号，也可以没有。下面的代码演示了new运算符的4种用法： #include &lt;new&gt; struct chaff { char dross[20]; int slag; }; char buffer1[50]; char buffer2[500]; int main() { chaff *p1, *p2; int *p3, *p4; //常规new运算符 p1 = new chaff; p3 = new int [20]; //定位new运算符 p2 = new (buffer1) chaff; p4 = new (buffer2) int [20]; } 出于简化的目的，这个示例使用两个静态数组来定位new运算符提供内存空间。因此，上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。 下面程序使用常规new运算符和定位new运算符创建动态分配的数组。 newplace.cpp #include &lt;iostream&gt; #include &lt;new&gt; using namespace std; const int BUF = 512; const int N = 5; char buffer[BUF]; int main() { double *pd1, *pd2; int i; cout &lt;&lt; &quot;Calling new and placement new:\n&quot;; pd1 = new double[N]; pd2 = new (buffer) double[N]; for (i = 0; i &lt; N; i++) pd2[i] = pd1[i] = 1000 + 20.0 * i; cout &lt;&lt; &quot;Memory addresser:\n&quot; &lt;&lt; &quot; heap: &quot; &lt;&lt; pd1 &lt;&lt; &quot; static: &quot; &lt;&lt; (void *) buffer &lt;&lt; endl; cout &lt;&lt; &quot;Memory contens:\n&quot;; for (i = 0; i &lt; N; i++) { cout &lt;&lt; pd1[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd1[i] &lt;&lt; &quot;;&quot;; cout &lt;&lt; pd2[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd2[i] &lt;&lt; endl; } cout &lt;&lt; &quot;\n Calling new and placement new a secong time:\n&quot;; double *pd3, *pd4; pd3 = new double[N]; pd4 = new (buffer) double[N]; for (i = 0; i &lt; N; i++) pd3[i] = pd4[i] = 1000 + 400 * i; cout &lt;&lt; &quot;Memory contents:\n&quot;; for (i = 0; i &lt; N; i++) { cout &lt;&lt; pd3[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd3[i] &lt;&lt; &quot;;&quot;; cout &lt;&lt; pd4[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd4[i] &lt;&lt; endl; } cout &lt;&lt; &quot;\n Calling new and placement new a secong time:\n&quot;; delete [] pd1; pd1 = new double[N]; pd2 = new (buffer + N * sizeof(double)) double[N]; for (i = 0; i &lt; N; i++) pd2[i] = pd1[i] = 1000 + 60.0 * i; cout &lt;&lt; &quot;Memory contens:\n&quot;; for (i = 0; i &lt; N; i++) { cout &lt;&lt; pd1[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd1[i] &lt;&lt; &quot;;&quot;; cout &lt;&lt; pd2[i] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;pd2[i] &lt;&lt; endl; } delete [] pd1; delete [] pd3; return 0; } 结果 alling new and placement new: Memory addresser: heap: 0x72a010 static: 0x6021a0 Memory contens: 1000 at 0x72a010;1000 at 0x6021a0 1020 at 0x72a018;1020 at 0x6021a8 1040 at 0x72a020;1040 at 0x6021b0 1060 at 0x72a028;1060 at 0x6021b8 1080 at 0x72a030;1080 at 0x6021c0 Calling new and placement new a secong time: Memory contents: 1000 at 0x72a040;1000 at 0x6021a0 1400 at 0x72a048;1400 at 0x6021a8 1800 at 0x72a050;1800 at 0x6021b0 2200 at 0x72a058;2200 at 0x6021b8 2600 at 0x72a060;2600 at 0x6021c0 Calling new and placement new a secong time: Memory contens: 1000 at 0x72a010;1000 at 0x6021c8 1060 at 0x72a018;1060 at 0x6021d0 1120 at 0x72a020;1120 at 0x6021d8 1180 at 0x72a028;1180 at 0x6021e0 1240 at 0x72a030;1240 at 0x6021e8 5.程序说明定位new运算符确实将数组pd2放在了数组buffer中，pd2和buffer的地址都是0x6021a0。然而，它们的类型不同，pd2是double指针，而buffer是char指针。（顺便说一句，这也是程序使用(void $\ast$)对buffer进行强制转换的原型，如果不这样做，cout将显示一个字符串。）。同时，常规new将数组pd1放在很远的地方，其地址为0x72a010，位于动态管理的堆中。 需要指出的第二点是，第二个常规new运算符查找一个新的内存块，其起始地址为0x72a040；但第二个定位new运算符分配与以前相同的内存块；起始地址为00FD9138的内存块。定位new运算符使用传递给它的地址，它不跟踪哪些内存块已被使用，也不查找未使用的内存块。这将一些内存管理的负担交给了程序员。例如，在第三次调用定位new运算符时，提供了一个从数组buffer开头算起的偏移量，因此将分配性的内存： pd2 = new (buffer + N * sizeof(double)) double[N]; 第三点差别是，是否使用delete来释放内存。对于常规new运算符，下面的语句释放起始地址为0x72a010的内存块，因此接下来再次调用new运算符时，该内存块是可用的： delete [] pd1; 然而，程序中没有使用delete来释放定位new运算符分配的内存。事实上，在这个例子不能这样做。buffer指定的内存是静态内存，而delete只能用于这样的指针：指向常规new运算符分配的堆内存。即，数组buffer位于delete的管辖区之外，下面的语句将引发运行阶段错误： delete [] pd2; 另一方面，如果buffer是使用常规new运算符创建的，便可以使用常规delete运算符来释放整个内存块。 定位new运算符的另一种用法，将其与初始化结合使用，从而将信息放在特定的硬件地址处。 定位new运算符的工作原理：基本上，它只是返回传递给它的地址，并将其强制转换为void $\ast$，以便能够赋给任何指针类型。但这说的是默认定位new函数，C++允许程序员重载定位new函数。 将定位new运算符用于类对象时，情况更复杂，将在第12章介绍。 6.定位new的其他形式将向常规new调用一个接受一个参数的new()函数一样，标准定位new()调用一个接受两个参数的new()函数： int * pi = new int; //调用new(sizeof(int)) int * p1 = new(buffer) int; //调用new(sizeof(int), buffer) int * p2 = new(buffer) int[40]; //调用new(40*sizeof(int), buffer) 定位new函数不可替换，但可重载。它至少需要接受两个参数，其中第一个指向std::size_t，指出了请求的字节数。这样的重载函数都被称为定义new，即使额外的参数没有指定位置。 9.3 名称空间在C++中，名称可以时变量、函数、结构、枚举、类以及类和结构的成员。当随着项目的增大，名称空间的冲突可能也将增加。使用多个厂商的类库时，可能导致名称冲突。例如，两个库可能都定义了名为List、Tree和Node的类，但定义的方式不兼容。用户可能希望使用一个库的List类，而使用另一个库的Tree类。这种冲突被称为名称空间问题。 C++提供了名称空间工具，以便更好地控制名称的作用域。 9.3.1 传统的C++名称空间首先介绍一些术语： 声明区域：是可以在其中进行声明的区域。例如，可以在函数外面声明全部变量，对于这种变量，其声明区域为其声明所在文件。对于在函数中声明的变量，其声明区域为其声明所在代码块。 潜在作用域： 变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。 然而，变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。例如，在函数中声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一个文件中声明的全局变量（对于这种变量，声明区域为整个文件）。变量对程序而言可见的范围被称为作用域。 C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域声明e名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发送冲突。 9.3.2 新的名称空间特性C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另一个名称空间的相同名称冲突，同时允许程序的其他使用该名称空间中声明的东西。例如，下面的代码使用新的关键字namespace创建了两个名称空间： namespace Jack{ double pail; void fetch(); int pal; struct Well{...}; } namespace Jill{ double bucket(double n) {...} double fetch; int pal; struct Hill{...}; } 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，默认情况下，在名称空间中声明的名称的链接性为外部（除非它引用了常量）。 除了用户定义的名称空间外，还存在另一个名称空间–全局名称空间。它对应于文件级声明区域，因此前面所说的全局变量被描述为位于全局名称空间中。 任何名称空间中的名称都不会于其他名称空间中的名称发送冲突。因此，Jack中的fetch可以于Jill中的fetch共存，Jill中的Hill可以于外部Hill共存。名称空间中的声明和定义规则同全局声明和定义规则相同。 名称空间是开放的，即可以把名称加入到已有的名称空间中。例如，下面这条语句将名称goose添加到Jill中已有的名称列表中： namespace Jill{ char * goose (const char *); } 同样，原来的Jack名称空间为fetch()函数提供了原型。可以在该文件后面再次使用Jack名称空间来提供函数的代码： namespace Jack{ void fetch() {...} } 当然，需要有一种办法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析运算符::，使用名称空间来限定该名称： Jack::pail = 12.34; Jill::Hill mole; Jack::fetch(); 未被装饰的名称（如pail）称为未限定的名称；包含名称空间的名称（如Jack::pail）称为限定的名称。 1.using声明和using编译指令C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。using声明使特定的标识符可用，using编译指令使整个名称空间可用。 using声明由被限定的名称和它前面的关键字uing组成： uing Jill::fetch;//using声明 using声明将特定的名称添加到它所属的声明区域中。例如main()中的using声明Jill::fetch将fetch添加到main()定义的声明区域中。完成该声明后，便可以使用名称fetch代替Jill::fetch。下面的代码段说明了这几点： namespace Jill{ double bucket (double n){...} double fetch; struct Hill{...}; } char fetch; int main() { using Jill::fetch; double fetch; //非法的 cin &gt;&gt; fetch; //读取一个值到Jill::fetch cin &gt;&gt; ::fetch; //读取一个值到全局fetch } 由于using声明将名称添加到局部声明区域中，因此这个示例避免了将另一个局部变量也命名未fetch。另外，和其他局部变量一样，fetch也将覆盖同名的全局变量。 在函数的外面使用using声明时，将把名称添加到全局名称空间中： void other(); namespace Jill{ double bucket (double n){...} double fetch; struct Hill{...}; } using Jill::fetch; int main() { cin &gt;&gt; fetch; other(); } void other() { cout &lt;&lt; fetch; } using声明使一个名称可用，而using编译指令使所有的名称都可用。using编译指令由名称空间和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符： using namespace Jack; 在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。这种情况出现多次： #include &lt;iostream&gt; using namespace std; 在函数中使用using编译指令。将使其中的名称在该函数中可用，如下： int main() { using namespace Jack; ... } using编译指令和using声明，它们增加了名称冲突的可能性。即，如果名称空间jack和jill，并在代码中使用作用域解析运算符，则不会存在二义性： jack::pal = 3; jill::pal = 10; 变量jack::pal和jill::pal是不同的标识符，表示不同的内存单元。然而，如果使用using声明，情况将发送变法： using jack::pal; using jill::pal; pal = 3; 事实上，编译器不允许同时使用上述两个using声明，因为这将导致二义性。 2.using编译指令和using声明之笔记使用using编译指令导入一个名称空间中所有的名称，像大量使用作用域解析运算符。而使用using声明时，像声明了相应的名称一样。如果某个名称在函数中声明了，则不能使用using声明导入相同的名称。然而，使用using编译指令，将进行名称解析，就像在包含using声明和名称空间本身最小声明区域中声明了名称一样。下面的示例，名称空间未全局的。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。不过仍可像下面的示例中那样使用作用域解析运算符： namespace Jill{ double bucket(double n){...} double fetch; struct Hill{...}; } char fetch; int main() { using namespace Jill; Hill Thrill; double water = bucket(2); double fetch; //创建一个局部变量fetch，隐藏Jill::fetch和全局fetch cin &gt;&gt; fetch; cin &gt;&gt; ::fetch; cin &gt;&gt; Jill::fetch; } int foom() { Hill top; //错误的 Jill::Hill crest; //合理的 } 在main()中，名称Jill::fetch被放在局部名称空间中，但其作用域不是局部，因此不会覆盖全局的fetch。然而，局部声明的fetch将隐藏Jill::fetch和全局fetch。然而，如果使用作用域解析运算符，则后两个fetch变量都是可用的。 需要指出的另一点是，虽然函数中的using编译指令将名称空间的名称视为在函数之外声明的，但它不会使得该文件中的其他函数能够使用这些名称。因此，在前一个例子中，foom()函数不能使用未限定的表示符Hill。 注意：假设名称空间和声明区域定义了相同的名称如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称回发送冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间的版本。 一般来说，使用using声明比使用using编译指令更安全，这是由于它只是导入指定的名称。如果该名称与局部名称发送冲突，编译器将指出来。using编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发送冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确直到添加了哪些名称。 本书的大部分示例采用的方法： #include &lt;iostream&gt; int main() { using namespace std; 首先，#include 语句将头文件iostream放到名称空间std中；然后，using编译指令使该名称空间在main()函数中可用。有些示例采取下述方法： #include &lt;iostream&gt; using namespace std; 这将名称空间std中的所有内容导出到全局名称空间中。使用这种方法的主要原因是方便。它易于完成，同时如果系统不支持名称空间，可以将前两行替换成： #incluce &lt;iostream.h&gt; 然而，名称空间的支持者希望有更多的选择，既可以使用解析运算符，也可以使用using声明，即，不要这样做： using namespace std; 而这样做： int x; std::cin &gt;&gt; x; std::cout &lt;&lt; x &lt;&lt; std::endl; 或者这样做： using std::cin; using std::cout; using std::endl; int x; cin &gt;&gt; x; cout &lt;&lt; x; 可以用嵌套名称空间来创建一个包含常用using声明的名称空间（下一节介绍）。 3.名称空间的其他特性可以将名称空间声明进行嵌套： namespace elements { namespace fire{ int flame; ... } float water; } 这里，flame指的是elements::fire::flame。同样，可以使用下面的usin编译指令使内部的名称可用： using namespace elements::fire; 另外，也可以在名称空间中使用using编译指令和using声明，如下： namespace myth{ using Jill::fetch; using namespace elements; using std::cout; } 假设要访问Jill::fetch。由于Jill::fetch现在位于名称空间myth中，因此可以如下访问： std::cin &gt;&gt; myth::fetch; 当然，由于它也位于Jill名称空间中，仍可以称作Jill::fetch std::cout &lt;&lt; Jill::fetch; 如果没有与之冲突的局部变量，则也可以这样做： using namespace myth; cin &gt;&gt; fetch; using编译指令是可传递的（A&gt;B,B&gt;C -&gt; A&gt;C）。在这种情况下，下面的语句将导入名称空间myth和elements： using namespace myth; 这条编译指令与下面两条编译指令等价： using namespace myth; using namespace elements; 可以名称空间创建别名，例如，假设有下面的名称空间： namespace my_very_favorite_things {...} 则可以使用下面的语句让mvft成为my_very_favorite_things别名： namespace mvft = my_very_favorite_things; 可以使用这种技术来简化对嵌套名称空间的使用： namespace MEF = myth::elements::fire; using MEF::flame; 4.未命名的名称空间可以通过声明名称空间的名称来创建未命名的名称空间： namespace{ int ice; int bandycoot; } 这就像后面跟着using编译指令一样，即，在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域的末尾。从这个方面看，它们与全局变量相似。然而，由于这种名称空间没有名称，因此不能显式地使用using编译指令和using声明来使用它在其他位置都可用。具体地说，不能在未命名空间所属文件之外的其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。例如： static int counts; int others(); int main(){} int others(){} 采用名称空间的方法如下： namespace {int counts;} int others(); int main(){} int others(){} 9.3.3 名称空间示例该程序的第一个文件是头文件，其中包含头文件中常包含的内容：常量、结构定义和函数原型。在这个例子中，这些内容放在两个名称空间中。第一个名称空间叫做pers，其中包括Person结构的定义和两个函数原型—一个用来用人民填充结构，另一个函数显式结构的内容；第二个名称空间叫做debts，定义了一个结构，该结构用来存储人名和金额。该结构使用Person结构，因此debts名称空间使用一条using编译指令，让pers中的名称在debts名称空间可用。 namesp.h #include &lt;iostream&gt; namespace pers { struct Person { std::string fname; std::string lname; }; void getPerson(Person &amp;); void showPerson(const Person &amp;); } namespace debts { using namespace pers; struct Debt { Person name; double amount; }; void getDebt(Debt &amp;); void showDebt(const Debt &amp;); double sumDebts(const Debt ar[], int n); } 第二个文件是源代码文件，它提供了头文件中的函数原型对应的定义。在名称空间中声明的函数名的作用与为整个名称空间，因此定义和声明必须位于同一名称空间中。这正是名称空间的开放性发挥的地方。通过包含namesp.h导入原来的名称空间。然后，该文件将函数定义添加入到两个名称空间中。 namesp.cpp #include &lt;iostream&gt; #include &quot;namesp.h&quot; namespace pers { using std::cout; using std::cin; void getPerson(Person &amp; rp) { cout &lt;&lt; &quot;Enter first name: &quot;; cin &gt;&gt; rp.fname; cout &lt;&lt; &quot;Enter last name: &quot;; cin &gt;&gt; rp.lname; } void showPerson(const Person &amp; rp) { std::cout &lt;&lt; rp.lname &lt;&lt; &quot;, &quot; &lt;&lt; rp.fname; } } namespace debts { void getDebt(Debt &amp; rd) { getPerson(rd.name); std::cout &lt;&lt; &quot;Enter debt: &quot;; std::cin &gt;&gt; rd.amount; } void showDebt(const Debt &amp; rd) { showPerson(rd.name); std::cout &lt;&lt; &quot;: $&quot; &lt;&lt; rd.amount &lt;&lt; std::endl; } double sumDebts(const Debt ar[], int n) { double total = 0; for (int i = 0; i &lt; n; i++) total += ar[i].amount; return total; } } 第三个文件是一个源代码文件，它使用了名称空间中声明和定义的结构和函数。 namessp.cpp #include &lt;iostream&gt; #include &quot;namesp.h&quot; void other(); void another(); int main() { using debts::Debt; using debts::showDebt; Debt golf = {{&quot;Benny&quot;, &quot;goatsniff&quot;}, 120.0}; showDebt(golf); other(); another(); return 0; } void other() { using std::cout; using std::cin; using std::endl; using namespace debts; Person dg = {&quot;Doobles&quot;, &quot;Glister&quot;}; showPerson(dg); cout &lt;&lt; endl; Debt zippy[3]; int i; for (i = 0; i &lt; 3; i++) getDebt(zippy[i]); for (i = 0; i &lt; 3; i++) showDebt(zippy[i]); cout &lt;&lt; &quot;Total debt: $&quot; &lt;&lt; sumDebts(zippy, 3) &lt;&lt; endl; } void another() { using pers::Person; Person collector = {&quot;Milo&quot;, &quot;Rightshift&quot;}; pers::showPerson(collector); std::cout &lt;&lt; std::endl; } 结果 goatsniff, Benny: $120 Glister, Doobles Enter first name: Z Enter last name: xp Enter debt: 1000 Enter first name: W Enter last name: xp Enter debt: 2000 Enter first name: Y Enter last name: xp Enter debt: 3000 xp, Z: $1000 xp, W: $2000 xp, Y: $3000 Total debt: $6000 Rightshift, Milo 在第三个文件中，main()函数首先使用了两个using声明： using debts::Debt; using debts::showDebt; 注意，using声明只是用了名称，例如，第二个using声明没有描述showDebt的返回类型或函数特征标，而只是给出名称；因此，如果函数重载，则一个using声明将导入所有的版本。另外，虽然Debt和showDebt都使用了Person类型，但不必导入任何Person名称，因为debt名称空间有一条包含pers名称空间的using编译指令。 接下来，other()函数采用了一种不太好的方法，即使用一条using编译指令导入整个名称空间： using namespace debts; 由于debts中的using编译指令导入了pers名称空间，因此other()函数可用使用Person类型和showPerson()函数。 最后，another()函数使用using声明和作用域解析运算符来访问具体名称： using pers::Person; pers::showPerson(collector); 9.3.4 名称空间及其前途指导原则： 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。 如果开发了一个函数库或类库，，将其放在一个名称空间中。 仅将编译指令using作为一种将旧代码转换为使用名称看似吗的权宜之计。 不要在腾文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序行为。如果非要使用编译指令using，应将其放在所有预处理编译指令#include之后。 导入名称时，首先十三亿作用域解析运算符或using声明的方法。 对于using声明，首先将其作用域设置为局部而不是全局。 使用名称空间的主旨时简化大型编程项目的管理工作。对于只有一个文件的简单程序，使用using编译指令是没影响。 老式头文件（如iostream.h）没有使用名称空间，但心头文件（如iostream）使用了std名称空间。 9.4 总结头文件 存储方案：作用域、持续性、链接性 名称空间： using声明，usign编译指令，作用域解析运算符]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--函数探幽（八）]]></title>
    <url>%2F2018%2F10%2F12%2FC%2B%2B%20Primer%20Plus--%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内联函数、按引用传递变量、默认的参数值、函数动态以及模板函数。 8.1 C++内联函数内联函数是C++为提高运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。 编译过程的最终产品是可执行程序–由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后逐步执行这些指令。 常规函数调用也是程序跳到另一个地址，并在函数结束时返回。下面更详细介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来。即，编译器将使用相应的函数的代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序包含该函数代码的10个副本。 应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间吗将只占用整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以声明非内联调用使用的大部分时间。由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非函数经常被调用。 要使用这项特性，必须采取下述措施之一： 在函数声明前加上关键字inline; 在函数定义前加上关键字inline。 通常的做法是省略原型，将整个定义放在本应提供原型的地方。 程序员请求将函数作为内联函数时，编译器不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己(内联函数不能递归)，因此不将其作为内联函数；而有些编译器没有启动或实现这这种特性。 inline.cpp #include &lt;iostream&gt; using namespace std; inline double square(double x) {return x * x;} int main() { double a, b; double c = 13.0; a = square(5.0); b = square(5.5+7.5); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c; cout &lt;&lt; &quot;, c squared = &quot; &lt;&lt; square(c++) &lt;&lt; endl; cout &lt;&lt; &quot;Now c = &quot; &lt;&lt; c &lt;&lt; endl; return 0; } 结果 a = 25, b = 169 c = 13, c squared = 169 Now c = 14 输出表明，内联函数和常规函数一样，也是按值来传递参数的。尽管程序没有提供独立的原型，但C++原型特性仍在起作用。这是因为在函数首次使用前出现了整个函数定义充当了原型。 内联与宏 inline工作是C++新增的特定。C语言使用预处理语句#define来提高宏—内联代码的原始实现。例如： #define SQUARE(x) x*x 这并不是通过传递参数实现的，而是通过文本替换实现的–x是“参数”的符号标记。 a = SQUARE(4.5 + 7.5); b = SQUARE(c++); 上述语句不能正常工作，可以通过使用括号来进行改进: #define SQUARE(x) ((x)*(x)) 但仍然存在问题，即弘不能按值传递。即使使用新的定义，SQUARE(c++)仍将c递增两次，程序inline.cpp中，内联函数square()计算的c的结果，传递它，以计算其平方值，然后将c递增一次。 8.2 引用变量C++增加了一种复合类型–引用变量。引用是已定义的变量的别名(另一个名称)。例如：如果将twain作为clement变量的引用，则可以交替使用twain和clement来表示变量。 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计来说，引用也是必不可少的。 8.2.1 创建应用变量C++给&amp;符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做： int rats; int &amp; rodents = rats; 其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的char$\ast$指的是指向char的指针一样，int&amp;指的是指向int的引用。上述声明允许将rats和rodents互换–它们指向相同的值和内存单元。 firstref.cpp #include &lt;iostream&gt; using namespace std; int main() { int rats = 101; int &amp; rodents = rats; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; rodents ++; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;rats addresss = &quot; &lt;&lt; &amp;rats; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; return 0; } 结果 rats = 101, rodents = 101 rats = 102, rodents = 102 rats addresss = 0x7ffc899ccdf4, rodents address = 0x7ffc899ccdf4 创建rats的指针和引用： int rats = 101; int &amp; rodents = rats; int * prats = &amp;rats; 这样，表达式rodents和$\ast$prats都可以同rats互换；表达式&amp;rodents和prats都可以同&amp;rats互换。 引用与指针差别之一是：引用必须在声明引用的时将其初始化，而不能像指针那样，先声明，再赋值。 引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就一致效忠于它。即： int &amp; rodents = rats; 实际上是下述代码的伪装表示： int * const pr = &amp;rats; 其中，因此rodents扮演的角色与表达式$\ast$pr相同。 sceref.cpp #include &lt;iostream&gt; using namespace std; int main() { int rats = 101; int &amp; rodents = rats; cout &lt;&lt; &quot;rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;rats address = &quot; &lt;&lt; &amp;rats; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; int bunnies = 50; rodents = bunnies; cout &lt;&lt; &quot;bunnies = &quot; &lt;&lt; bunnies; cout &lt;&lt; &quot;, rats = &quot; &lt;&lt; rats; cout &lt;&lt; &quot;, rodents = &quot; &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; &quot;bunnies address = &quot; &lt;&lt; &amp;bunnies; cout &lt;&lt; &quot;, rodents address = &quot; &lt;&lt; &amp;rodents &lt;&lt; endl; return 0; } 结果 rats = 101, rodents = 101 rats address = 0x7ffddcafd674, rodents address = 0x7ffddcafd674 bunnies = 50, rats = 50, rodents = 50 bunnies address = 0x7ffddcafd670, rodents address = 0x7ffddcafd674 最初，rodents引用的rats，但随后程序试图将rodents作为bunnies的引用： rodents = bunnies; 咋一看，这种意图暂时成功，因此rodents的值从101变成了50，rats的值也变成了50。但是bunnies的地址与rats和rodents的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效： rats = bunnies; 即，这意味着将bunnies变量的值赋给rats变量。简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 程序员试图这样做： int rats = 101; int *pt = &amp;rats; int &amp; rodents = *pt; int bunnies = 50; pt = &amp;bunnies; 将rodents初始化为$\ast$pt使得rodents指向rats，接下来将pt改为指向bunnies，并不能改变rodents和rats的值，即rodents引用的是rats。 8.2.2 将引用作为函数参数引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。 交换两个变量的值，对使用引用和使用指针进行比较。 swaps.cpp #include &lt;iostream&gt; using namespace std; void swapr(int &amp; a, int &amp; b); void swapp(int * p, int * q); void swapv(int a, int b); int main() { int wallet1 = 300; int wallet2 = 250; cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; &quot;Using references to swap contents:\n&quot;; swapr(wallet1, wallet2); cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; &quot;Using pointers to swap contents:\n&quot;; swapp(&amp;wallet1, &amp;wallet2); cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; &quot;Using values to swap contents:\n&quot;; swapv(wallet1, wallet2); cout &lt;&lt; &quot; wallet1 = &quot; &lt;&lt; wallet1; cout &lt;&lt; &quot;, wallet2 = &quot; &lt;&lt; wallet2 &lt;&lt; endl; return 0; } void swapr(int &amp; a, int &amp; b) { int temp = a; a = b; b = temp; } void swapp(int * p, int * q) { int temp = *p; *p = *q; *q = temp; } void swapv(int a, int b) { int temp = a; a = b; b = temp; } 结果 wallet1 = 300, wallet2 = 250 Using references to swap contents: //第一交换，成功 wallet1 = 250, wallet2 = 300 Using pointers to swap contents: //在第一次交换的基础上，交换，成功 wallet1 = 300, wallet2 = 250 Using values to swap contents: //交换失败 wallet1 = 300, wallet2 = 250 引用和指针方法都成功地交换了两个值，而按值传递的方法没能完成这项工作。 按引用传递和按值传递看来相同，只能通过隐形或函数定义才能知道swapr()是按引用传递的。按引用传递的函数和按值传递的函数的代码，唯一区别是声明函数参数的方式不同。 void swapr(int &amp; a, int &amp; b) void swapv(int a, int b) 当然还有内在区别，在swapr()中，变量a和b是wallet1和wallet2的别名，所以交换a和b的值相当于交换wallet1和wallet2的值。但在swapv()中，变量a和b是wallet1和wallet2的副本，因此交换a和b的值并不会影响wallet1和wallet2的值。 比较按引用传递的函数和按指针传递的函数，第一区别是声明函数的方式： void swapr(int &amp; a, int &amp; b) void swapp(int * p, int * q) 另一个区别是指针版本需要在函数使用p和q的整个过程中使用解除引用运算符$\ast$。 8.2.3 引用的属性和特别之处使用两个函数计算参数的立方，其中一个函数接受double类型的参数，另一个接受doulbe引用。 cubes.cpp #include &lt;iostream&gt; double cube(double a); double refcube(double &amp;ra); using namespace std; int main() { cout &lt;&lt; cube(x) &lt;&lt; &quot; = cube of &quot; &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; refcube(x) &lt;&lt; &quot; = cube of &quot; ; cout &lt;&lt; x &lt;&lt; endl; //主要该处x必须重启一行 return 0; } double cube(double a) { a *= a * a; return a; } double refcube(double &amp;ra) { ra *= ra * ra; return ra; } 结果 27 = cube of 3 27 = cube of 27 注意，如果程序中命令修改为如下： cout &lt;&lt; refcube(x) &lt;&lt; &quot; = cube of &quot; &lt;&lt; x &lt;&lt; endl; 输出结果为： 27 = cube of 3 refcube()函数修改main()函数中的x的值，而cube()没有影响。如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。例如： double refcube(const double &amp;ra); 如果要编写类似于上述示例的函数(即使用基本数值类型)，应采用按值传递的方式，而不要采用按引用传递的方式。当数据量比较大(如结构和类)时，引用参数将很有用。 按引用传递时，传递引用的参数的限制更严格，比如：不能使用x+0.2这样： doulbe z = refcube(x+0.2); //非法 如果这样做，由于x+0.2不是double类型的变量，因此程序创建一个临时的无名变量，并将其初始化为表达式x+0.2的值。然后，ra将成为该临时变量的引用。 临时变量、引用参数和const 如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这种做。 如果引用参数是const，则编译器将下面两种情况下生成临时变量： 实参的类型正确，但不是左值 实参的类型不正确，但可以转换为正确的类型 左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左右的实体，但这是引入关键字const之前的情况。现在，常规变量和const变量都可视为左值，因此可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可能修改的左值。 重新定义refcube()，使其接受一个常量引用参数： double refcube(const double &amp; ra) { return ra * ra * ra; } 现在考虑如下代码： double side = 3.0; double * pd = &amp;side; double &amp; rd = side; long edge = 5L; double lens[3] = {2.1,2.3,1.4}; double c1 = refcube(side); double c2 = refcube(lens[2]); double c3 = refcube(rd); double c4 = refcube(*pd); double c5 = refcube(edge); //ra是临时变量 double c6 = refcube(7.0); //ra是临时变量 doubel c7 = refcube(side+1.0); //ra是临时变量 参数side、lens[2]、rd和$\ast$pd都是有名称的、double类型的数据对象，因此可以为其创建引用，而不要临时变量。然而，edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，参数7.0和side+1.0的类型正确，但没有名称，在这些情况下，编译器将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器边可以随意将其删除。 如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将组织这种意图的实现。解决方法是：禁止创建临时变量。 现在来看refcube()函数。该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而是函数在可处理的参数种类方面更同样。因此，如果声明将引用指定为const，C++将在必要时生成临时变量。实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值。 注意：如果函数调用的参数不是左值或相应const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。 应尽可能使用const 将引用参数声明为常数数据的引用的理由有三个： 使用const可以避免无意中修改数据的编程错误； 使用const使函数能够处理const和非const实参，否则将只能接受非const数据； 使用const引用使函数能够正确生成并使用临时变量。 C++11新增了另一种引用–右值引用。这种引用可指向右值，是使用&amp;&amp;声明的： double &amp;&amp; rref == sqrt(36.0); double j = 15.0; double &amp;&amp; jref = 2.0*j+18.5; cout &lt;&lt; rref &lt;&lt; endl; cout &lt;&lt; jref &lt;&lt; end; 新增右值引用的主要目的是，让库设计人员能够提供有些操作的更有效实现。以前的引用(使用&amp;声明的引用)现在称为左值引用。 8.2.4 将引用用于结构引用非常适合用于结构和类（C++的用户定义类型）。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。 使用结构引用参数的方式与基本变量引用相同，只需在声明结构参数时使用引用运算符&amp;即可。比如： struct free_throws { string name; int made; int attempts; float percent; }; 则可以这样编写函数原型，在函数中将指向该结构的引用作为参数： woid set_pc(free_throws &amp; ft); 如果不希望函数修改传入的结构，可使用const： void display(const free_throws &amp; ft); strtref.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; struct free_throws { string name; int made; int attempts; float percent; }; void display(const free_throws &amp; ft); void set_pc(free_throws &amp; ft); free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source); int main() { free_throws one = {&quot;Ifelsa Branch&quot;, 13, 14}; free_throws two = {&quot;Andor Knott&quot;, 10, 16}; free_throws three = {&quot;Minnie Max&quot;, 7, 9}; free_throws four = {&quot;Whily Looper&quot;, 5, 9}; free_throws five = {&quot;Long Long&quot;, 6, 14}; free_throws team = {&quot;Throwgoods&quot;, 0, 0}; free_throws dup; set_pc(one); display(one); accumulate(team, one); display(team); display(accumulate(team, two)); accumulate(accumulate(team, three), four); display(team); dup = accumulate(team, five); cout &lt;&lt; &quot;Displyaing team:\n&quot;; display(team); cout &lt;&lt; &quot;Display dup after assignment:\n&quot;; display(dup); set_pc(four); accumulate(dup,five) = four; cout &lt;&lt; &quot;Displaying dup after ill-advised assignment:\n&quot;; display(dup); return 0; } void display(const free_throws &amp; ft) { cout &lt;&lt; &quot;Name: &quot; &lt;&lt; ft.name &lt;&lt; endl; cout &lt;&lt; &quot; Made: &quot; &lt;&lt; ft.made &lt;&lt; &quot;\t&quot;; cout &lt;&lt; &quot;Attempts: &quot; &lt;&lt; ft.attempts &lt;&lt; &quot;\t&quot;; cout &lt;&lt; &quot;Percent: &quot; &lt;&lt; ft.percent &lt;&lt; endl; } void set_pc(free_throws &amp; ft) { if (ft.attempts != 0) ft.percent = 100.0f * float(ft.made) / float(ft.attempts); else ft.percent = 0; } free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source) { target.attempts += source.attempts; target.made += source.made; set_pc(target); return target; } 结果 Name: Ifelsa Branch Made: 13 Attempts: 14 Percent: 92.8571 Name: Throwgoods Made: 13 Attempts: 14 Percent: 92.8571 Name: Throwgoods Made: 23 Attempts: 30 Percent: 76.6667 Name: Throwgoods Made: 35 Attempts: 48 Percent: 72.9167 Displyaing team: Name: Throwgoods Made: 41 Attempts: 62 Percent: 66.129 Display dup after assignment: Name: Throwgoods Made: 41 Attempts: 62 Percent: 66.129 Displaying dup after ill-advised assignment: Name: Whily Looper Made: 5 Attempts: 9 Percent: 55.5556 1.程序说明该程序首先初始化了多个结果对象。如果指定的初始值比成员少，余下的成员(这里是percent)将被设置为零。第一个函数调用如下： set_pc(one); 由于函数set_pc()的形参ft为引用，因此ft指向one，函数set_pc()的代码设置成员one.percent。按值传递不行，因此这将导致设置的是one的临时拷贝的成员percent。另一种方法是使用指针参数，并传递结构的地址，要复杂些。 下一个函数调用如下： display(one); 由于display()显示结构的内容，而不修改它，因此这个函数使用了一个const引用参数。就这个函数而言，也可按值传递，但与复制原始结构的拷贝相比，使用引用可节省时间和内存。 再下一个函数调用如下： accumulate(team, one); 函数accumulate()接收两个结构参数，并将第二结构的成员attempts和made的数据添加到第一个结构的相应成员中。只修改了第一个结构，因此第一个参数为引用，而第二个参数为const引用： free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source) 当前讨论的函数调用没有使用它，就目前而言，原本可以将返回值声明void，但请看下述函数调用： display(accumulate(team, two)); 首先，结构对象team作为第一个参数传递给了accumulate()。意味着在函数accumulate()中，target指向的是team。函数accumulate()修改team，在返回指向它的引用。注意到返回语句如下： return target; 光看这条语句并不能知道返回的是引用，但函数头和原型中指出了这一点。如果返回类型被声明为free_throws而不是free_throws &amp;，上述返回语句将返回target（即team）的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象。 接下来，将accumulate()的返回值作为参数传递给了display()，这意味着将team传递给了display()。display()的参数为引用，这意味着函数display()中的ft指向是team，因此将显示team的内容。 2.为何要返回引用下面更深入地讨论返回引用与传统返回机制的不同。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。 double m = sqrt(16.0); cout &lt;&lt; sqrt(25.0); 在第一天语句中，值4.0被复制到一个临时位置，然后被复制给m。在第二条语句中，值5.0被复制到一个临时位置，然后被传递给cout。 dup = accumulate(team, five); 如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到dup，其效率更高。 3. 返回引用时需要注意的问题返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。应避免写下面这样的代码： const free_throws &amp; clone2(free_throws &amp; ft) { free_throws newguy; newguy = ft; return newguy; } 该函数返回一个指向临时变量的引用，函数运行完毕它将不再存在。也应避免返回指向临时变量的指针。 为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数。正如accumulate()一样，第一个引用就是这个作用。 另一种方法是用new来分配新的存储空间。前面使用过，使用new为字符串分配内存空间，并返回指向该内存空间的指针。下面是使用引用来完成类似的工作： const free_throws &amp; clone(free_throws &amp; ft) { free_throws * pt; *pt = ft; return *pt; } 第一条语句创建一个无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构。上述代码似乎会返回结构，但函数声明表明，该函数实际上将返回这个结构的引用。这样，便可以这样使用该函数： free_throws &amp; jolly = clone(three); 这使得jolly成为新结构的引用，这种方法存在一个问题：在不再需要new分配的内存时，应使用delete来释放它们。调用clone()隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。第16章讨论的auto_ptr模板以及C++新增的unique_ptr可帮助程序员自动完成释放工作。 4. 为何将const用于引用返回类型程序中： accumulate(dup, five) = four; 其效果如下：首先将five的数据添加到dup中，再使用four的内容覆盖dup的内容。这条语句为何能够通过编译呢？在赋值语句中，左边必须是可修改的左值，即在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。在这里，函数返回值指向dup的引用，它确实标识的是一个这样的内存块，因此这条语句是合法的。 另一方面，常规（非引用）返回类型是右值—不能通过地址访问的值。这种表达式可出现在赋值语句的右边，但不能出现在左边。其他右值包括字面值(如10.0)和表达式(x+y)。显然，获取字面值的地址没有意义，但为何常规函数返回值是右值呢？这是因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在。 假设要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需要将返回类型声明为const引用： const free_throws &amp; accumulate(free_throws &amp; target, const free_throws &amp; source); 现在返回类型为const，是不可修改的左值，因此下面的赋值语句不合法： accumulate(dup, five) = four; 返回类型为const引用后，下面的语句仍合法： display(accumulate(team, two)); 这是因为display()的形参也是const free_throws &amp;类型。但下面的赋值语句不合法，因此accumulate()的第一形参不是const: accumulate(accumualte(team, three), four); 在此，影响不大，仍可以这样做： accumulate(team, three); accumulate(team, four); 8.2.5 将引用用于对象将类对象传递给函数是，C++通过的做法是使用引用。例如，可以通过使用引用，让函数将类string、ostream、istream、ofstream和ifstream等类的对象作为参数。 使用string类，演示一些不同的设计方案。这个例子的基本思想是:创建一个函数，它将指定的字符串加入到另一个字符串的前面和后面。下面程序提供了三个函数，然后其中的一个存在非常大的缺陷，可能导致程序崩溃甚至不通过编译。 strquote.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; string version1(const string &amp; s1, const string &amp; s2); const string &amp; version2(string &amp; s1, const string &amp; s2); const string &amp; version3(string &amp; s1, const string &amp; s2); int main() { string input; string copy; string result; cout &lt;&lt; &quot;Enter a string: &quot;; getline(cin, input); copy = input; cout &lt;&lt; &quot;Your string as entered: &quot; &lt;&lt; input &lt;&lt; endl; result = version1(input, &quot;***&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; result = version2(input, &quot;###&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;Resetting original string.\n&quot;; input = copy; result = version3(input, &quot;@@@&quot;); cout &lt;&lt; &quot;Your string enhanced: &quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;Your original string: &quot; &lt;&lt; input &lt;&lt; endl; return 0; } string version1(const string &amp; s1, const string &amp; s2) { string temp; temp = s2 + s1 + s2; return temp; } const string &amp; version2(string &amp; s1, const string &amp; s2) { s1 = s2 + s1 + s2; return s1; } const string &amp; version3(string &amp; s1, const string &amp; s2) { string temp; temp = s2 + s1 + s2; return temp; } 结果： Enter a string: It&apos;s my fault Your string as entered: It&apos;s my fault Your string enhanced: ***It&apos;s my fault*** Your original string: It&apos;s my fault Your string enhanced: ###It&apos;s my fault### Your original string: ###It&apos;s my fault### Resetting original string. Your string enhanced: Your original string: It&apos;s my fault 编译时给出警告 strquote.cpp: 在函数‘const string&amp; version3(std::string&amp;, const string&amp;)’中: strquote.cpp:50:9: 警告：返回了对局部变量的‘temp’的引用 [-Wreturn-local-addr] string temp; 即version3尝试返回一个局部变量的引用。temp是一个新的string对象，只在函数version1()中有效，该函数执行完毕，它将不再存在。因此返回指向temp的引用不可行，因此该函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中，然后在main()中，该存储单元的内容被复制到一个名为result的strin中。 将C-风格字符串用作string对象引用参数 对于函数version1()，可能注意到有趣的一点：该函数的两个形参(s1和s2)的类型都是const sting &amp;，但实参(input和”$\ast\ast\ast$”)的类型分别为string和const char *。由于input的类型为string，因此让s1指向它没有任何问题，然而，程序怎么能够接受char指针赋给string引用呢？ 这里有两点需要说明：首先，string类定义了一种char$\ast$到string的转换功能，这使得可以使用C-风格字符日来初始化string对象。其次，本章前面讨论过的类型为const引用的形参的一个属性。假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。例如，将int实参传递给const double &amp;形参时，就是以这种方式处理的。同样，也可以将实参char$\ast$或const char$\ast$传递给形参const string &amp;。 这种属性的结果是，如果形参类型为const string &amp;，在调用函数时，使用的实参可以是string对象或C-风格字符串，如用引号括起来的字符串字面量、自空字符结尾的char数组或指向char的指针变量。因此，下面代码是可行的： result = version1(input, &quot;***&quot;); 函数version2()不创建临时string对象，而是这将修改原来的string对象。由于s1指向main()中一个对象(input)的引用，因此将s1作为引用返回是安全的。由于s1指向input的引用，调用该函数将带来修改input的副作用。 verson3()函数的做法是错误的非法的。它存在一个致命的错误：返回一个指向version3()中声明的变量的引用。这个函数能够通过编译（但编程器会给出警告），但当程序试图执行该函数时将崩溃。具体地说，问题是由下面的赋值语句引起的： result = version3(input, &quot;@@@&quot;); 程序试图引用已经释放的内存。 8.2.6 对象、继承和引用ostream和ofstream类凸显了引用的一个有趣属性。ofstream对象可以使用ostream类的方法，这使得文件输入/输出的格式与控制台输入/输出相同。使得能够将特性从一个类传递到另一个类的语言特性被称为继承，这将在第13章讨论。简单地说，ostream是基类，而ofstream是派生类。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性。 继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制转换。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类作为参数，也可以将派生类对象作为参数。例如：参数类型为ostream &amp;的函数可以接受ostream对象(如 cout)或声明的ofstream对象作为参数。 下面程序，通过调用一个函数将数据写入文件和显示到屏幕上来说明这一点。该程序要求用户输入望远镜物镜和一些目镜的焦距，然后计算并显示每个目镜的放大倍数。放大倍数等于物镜的焦距除以目镜的焦距。 filefun.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; void file_it(ostream &amp; os, double fo, const double fe[], int n); const int LIMIT = 5; int main() { ofstream fout; const char * fn = &quot;ep-data.txt&quot;; fout.open(fn); if (!fout.is_open()) { cout &lt;&lt; &quot;Can&apos;t open &quot; &lt;&lt; fn &lt;&lt; &quot;. Bye.\n&quot;; exit(EXIT_FAILURE); } double objective; cout &lt;&lt; &quot;Enter the focal length of your telescope objective in mm: &quot;; cin &gt;&gt; objective; double eps[LIMIT]; cout &lt;&lt; &quot;Enter the focal lengths, in mm, of &quot; &lt;&lt; LIMIT &lt;&lt; &quot; eyepieces:\n&quot;; for (int i = 0; i &lt; LIMIT; i++) { cout &lt;&lt; &quot;Eyepiece #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; ; cin &gt;&gt; eps[i]; } file_it(fout, objective, eps, LIMIT); file_it(cout, objective, eps, LIMIT); return 0; } void file_it(ostream &amp; os, double fo, const double fe[], int n) { ios_base::fmtflags initial; initial = os.setf(ios_base::fixed); os.precision(0); os &lt;&lt; &quot;Foacal length of objective: &quot; &lt;&lt; fo &lt;&lt; &quot; mm\n&quot;; os.setf(ios::showpoint); os.precision(1); os.width(2); os &lt;&lt; &quot;f.1 eyepiece&quot;; os.width(15); os &lt;&lt; &quot;magnification&quot; &lt;&lt; endl; for (int i = 0; i &lt; n; i++) { os.width(12); os &lt;&lt; fe[i]; os.width(15); os &lt;&lt; int (fo/fe[i] + 0.5) &lt;&lt; endl; } os.setf(initial); } 结果： Enter the focal length of your telescope objective in mm: 1800 Enter the focal lengths, in mm, of 5 eyepieces: Eyepiece #1: 30 Eyepiece #2: 19 Eyepiece #3: 14 Eyepiece #4: 8.8 Eyepiece #5: 7.5 Foacal length of objective: 1800 mm f.1 eyepiece magnification 30.0 60 19.0 95 14.0 129 8.8 205 7.5 240 对于该程序，最重要的一点是，参数os（其类型为ostream &amp;）可以指向ostream对象（如cout），也可以指向ofstream对象（如fcout）。 方法setf()让您能够设置各种格式化状态。例如，方法调用setf(ios_base::fixed)将对象置于使用定点表示法模式；set(ios_base::showpoint)将对象置于显示小数点的模式，即使小数部分为零。方法precision()指定显示多少位小数。所有这些设置都将保持不变，直到再次调用相应的方法重新设置它们。方法width()设置下一次输出操作使用的字段宽度，这种设置只在显示下一值时有效，然后将恢复到默认设置。默认的字段宽度为零，这意味着刚好能容纳下要显示的内容。 函数file_it()使用了两个有趣的方法调用： ios_base::fmtflags initial; initial = os.setf(ios_base::fixed); ... os.setf(initial); 方法setf()返回调用它之前有效的所有格式设置。ios_base::fmtflags是存储这种信息所需的数据类型名称。因此，将返回值赋给initial将存储调用file_it()之前的格式化设置，然后便可以使用变量initial作为参数来调用setf()，将所有的格式化设置恢复到原来的值。因此，该函数将对象回到传递给file_it()之前的状态。 需要说明的最后一点，每个对象都存储了自己的格式化设置。因此，当程序将cout传递给file_it()时，cout的设置将被修改，然后被恢复；当程序将fout传递给file_it()时，fout的设置将被修改了，然后被恢复默认。 8.2.7 何时使用引用参数使用引用参数的主要原因有两个： 程序员能够修改调用函数中的数据对象 通过传递引用而不是整个数据对象，可以提高程序的运行速度 当数据对象比较大时（如结果和类对象），第二个原因最重要。这些也是使用指针参数的原因。 对于使用传递值而不作修改的函数。 如果数据对象很小，如内置数据类型或小型结构，则按值传递。 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。 如果数据对象是比较大的结构，则使用const指针和const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这种特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。 对于修改调用函数中数据的函数： 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码(其中x是int)，则很明显，该函数将修改x。 如果数据对象是结构，则使用引用或指针。 如果数据对象是数组，则只能使用指针。 如果数据对象是类对象，则使用引用。 当然，这只是一些值得原则，很可能有充分的理由做出其他选择。 8.3 默认参数默认参数指的是当函数调用中省略了实参时自动使用的一个值。 由于编译器通过查看原因来了解函数所使用的参数数目，因此函数原型必须将可能的默认参数告知程序。方法是将值赋给原型中的参数。例如： char * left (const char * str, int n = 1); 对于带参数列表的函数，必须从右到左添加默认值。即要为某个参数设置默认值，则必须为它右边的所有参数提供默认： int harpo(int n, int m = 4, int j = 5); int chico(int n, int m = 6, int j); //非法的 int groucho(int k = 1, int m = 2, int n = 3); 丽日，harpo()原型允许调用该函数时提供1、2或3个参数： beeps = harpo(2); beeps = harpo(1,8); beeps = harpo(8,7,6); 实参按从左至右的顺序依次被赋给相应的形参，而不能跳过任何参数。因此，下面的调用是不允许的： beeps = harpo(3, ,8); left.cpp #include &lt;iostream&gt; using namespace std; const int ArSize = 80; char * left(const char * str, int n = 1); int main() { char sample[ArSize]; cout &lt;&lt; &quot;Enter a string:\n&quot;; cin.get(sample, ArSize); char *ps = left(sample, 4); cout &lt;&lt; ps &lt;&lt; endl; delete [] ps; ps = left(sample); cout &lt;&lt; ps &lt;&lt; endl; delete [] ps; return 0; } char * left(const char * str, int n)//注意在函数定义时，不要添加默认参数，否则会报错 { if (n &lt; 0) n = 0; char * p = new char[n+1]; int i; for (i = 0; i &lt; n &amp;&amp; str[i]; i++) p[i] = str[i]; while (i &lt;= n) p[i++] = &apos;\0&apos;; return p; } 结果 Enter a string: forthcoming fort f 为了防止用户要求的字符数目可能多于字符串包含的字符数，为预防这种情况，函数使用了一个组合测试： i &lt; n &amp;&amp; str[i] i&lt;n测试让循环复制了n个字符后就终止。测试的第二部分–表达式str[i]，是要复制的字符的编码。遇到空值字符后，循环结束。 另一种设置新字符串长度的方法是，将n设置为传递的值和字符长度中较小的一个： int len = strlen(str); n = (n &lt; len) ? n : len; char *p = new char[n+1]; 这件确保new分配的空间不会多余存储字符串所需的空间。如果用户执行像left(“Hi!”, 1000)这样的调用，这种方法很有用。第一种方法是，将“Hi!”复制到由1000个字符组成的数组中，并将除前3个字符之外的所有字符都设置为空值字符；第二种方法是，将“Hi！”复制到由4个字符组成的数组中。但由于添加了另一个函数调用strlen()，因此程序将更长，运行速度将检查，同时还必须包括头文件cstring。 如果调用strlen()所需的时间很长，则可以让left()直接确定n和字符串长度哪个小。例如，当m的值等于n或到达字符串结尾时，下面的循环都将停止： int m = 0; while (m &lt;= n &amp;&amp; str[m] != &apos;\0&apos;) // 也可以写成while (m &lt;= n &amp;&amp; str[m]) m++; char *p = new char[m+1]; 8.4 函数重载函数重载指的是可以有多个同名的函数，因此对名称进行了重载。可以通过函数重载来设计一系列函数–它们完成相同的工作，但使用不同的参数列表。C++根据使用上下文来确定要使用的重载函数版本。 函数重载的关键是函数的参数列表–也称为函数特征标。如果两个函数的参数数目和类型相同，同时参数的排序顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。例如，可以定义一组原型如下print()函数： void print(const char * str, int width); void print(double d, int width); void print(long l, int width); void print(int i, int width); void print(const char * str); 使用print()函数时，编译器根据所采用的用法使用相应特征标的原型。 使用被重载的函数时，需要在函数调用中使用正确的参数类型，例如，对如下面的语句： unsigned int year = 3210; print(year, 6); print()调用与哪个原型匹配呢？它不与任何原型匹配！没有匹配的原型并不会自动停止使用其他的某个函数，因为C++将尝试使用标准类型强制转换进行匹配。如果原型只有第二个，则函数调用print(year,6)将把year转换为doule类型。但在上面的代码中，有3个将数字作为第一个参数的原型，因此有3种转换year的方式。在这种情况下，C++拒绝这种函数调用，并将其视为错误。 一些看起来彼此不同的特征标是不能共存的，例如： double cube(double x); double cube(double &amp; x); 编译器考虑这个问题时，请看如下代码： cout &lt;&lt; cube(x); 参数x与double x原型和 double &amp; x原型都匹配，因此编译器不知道究竟使用哪个原型。为避免这种混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。 匹配函数时，并不区分const和非const变量。 void dribble(char * bits); void dribble(const char * cbits); void babble(char * bits); void drivel(const char * bits); 下面列出了各种函数调用对应的原型： const char p1[20] = &quot;How&apos;s the weather?&quot;; char p2[20] = &quot;How&apos;s business?&quot;; dribble (p1); dribble(p2); dabble(p1); //不匹配 dabble(p2); drivel(p1); drivel(p2); dribble()函数有两个原型，一个用于const指针，另一个用于常规指针，编译器根据实参是否为const来决定使用哪个原型。dabble()函数只与带非const参数的调用匹配，而drivel()函数可以与带const和非const参数的调用匹配。drivel()和dabble()在行为上有这种差别，主要是由于将非const值赋给const变量是合法的，但反之是非法的。 请记住，是特征标，而不是函数类型使得可以对函数进行重载。例如，下面两个声明是互斥的： long gronk(int n, float m); double gronk(int n, float m); 因此，C++不允许以这种方式重载gronk()。返回类型可以不同，但特征标也必须不同： long gronk(int n, float m); double gronk(float n, float m); 重载引用参数 类设计和STL经常使用引用参数，因此直到不同引用类型的重载很有用： void sink(doube &amp; r1); void sank(const double &amp;r2); void sunk(double &amp;&amp; r3); 左值引用参数r1与可修改的左值参数匹配；const左值引用参数r2与可修改的左值参数、const作者参数和右值参数(如两个double值的和)匹配；最后，右值引用参数r3与右值匹配。注意到r1或r3匹配的参数都与r2匹配。 注意到与r1或r3匹配的参数都与r2匹配。这就带来一个问题：如果重载使用这三种参数的函数，结果将如何？答案是将调用最匹配的版本： void staff(doube &amp; rs); void staff(const double &amp; rcs); void stove(double &amp; r1); void stove(const double &amp; r2); void stove(double &amp;&amp; r3); 这让您根据参数是左值、const还是右值来定制函数的行为： double x = 55.5; const double y = 32.0; stove(x); //调用stove(double &amp;) stove(y); //调用stove(const double &amp;) stove(x+y); //调用 stove(doubel &amp;&amp;) 如果没有定义stove(double &amp;&amp;)，stove(x+y)将调用函数stove(const double &amp;)。 8.4.1 重载示例前面创建了left()函数，它返回一个指针，指向字符串的前n个字符。下面添加另一个left()函数，它返回整数的前n位。 一种方法是，先计算数字包含多少位，将数字除以10便可以去掉一位，因此可以使用除法来计算数位。更准确的，可以使用下面循环： nsigned digits = 1; while (n /= 10) digits++; 上述循环计算每次删除n中的一位时，需要多少次才能删除所有的位。 现在假设数字共有5位，并要返回前3位，则将这个数除以10再除以10，便可以得到所需的值。每除以10就删除数字的最后一位。要直到需要删除多少位，只需要将总数减去要获得的位数即可。可以如下编写： ct = digits - ct; while(ct--) num /= 10; return num; leftover.cpp #include &lt;iostream&gt; unsigned long left(unsigned long num, unsigned ct); char * left (const char * str, int n = 1); using namespace std; int main() { char * trip = &quot;Hawaii!!&quot;; unsigned long n = 12345678; int i; char * temp; for (i = 1; i &lt; 10; i++) { cout &lt;&lt; left(n, i) &lt;&lt; endl; temp = left(trip, i); cout &lt;&lt; temp &lt;&lt; endl; delete [] temp; } return 0; } unsigned long left(unsigned long num, unsigned ct) { unsigned digits = 1; unsigned long n = num; if (ct == 0 || num == 0) return 0; while (n /= 10) digits++; if (digits &gt; ct) { ct = digits - ct; while(ct--) num /= 10; return num; } else return num; } char * left(const char * str, int n) { if (n &lt; 0) n = 0; char * p = new char [n+1]; int i; for (i = 0; i &lt; n &amp;&amp; str[i]; i++ ) p[i] = str[i]; while (i &lt;= n) p[i++] = &apos;\0&apos;; return p; } 结果： 1 H 12 Ha 123 Haw 1234 Hawa 12345 Hawai 123456 Hawaii 1234567 Hawaii! 12345678 Hawaii!! 12345678 Hawaii!! 8.4.2 何时使用函数重载函数重载一般使用在：仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。另外，是否可以通过使用默认参数来实现同样的目的。例如，可以用两个重载函数来代替面向字符串的left()函数： char * left(const char * str, unsigned n); char * left(const char * str); 使用一个带默认参数的函数要简单些。只需编写一个函数，程序也只需为一个函数请求内存；需要修改函数时，只需修改一个。然而，如果需要使用不同类型的参数，则默认参数便不管用了，在这种情况下，应使用函数重载。 名称修饰 C++如何跟踪每一个重载函数？它给这些函数指定了秘密身份。使用C++开发工具中的编辑器编写和编译程序时，C++编译器将执行一些神奇的操作–名称修饰或名称矫正，它根据函数原型中指定的形参类型对每个函数名进行加密。请看下述未经修饰的函数原型： long MyFunctionFoo(int, float); 这种格式对于人类来说很合适；我们直到函数接受两个参数，并返回一个long值。而编译器将名称转换为不太好看的内部表示，来描述该接口，如下所示： ？MyfunctionFoo@@YAXH 对原始名称进行的表面看来无意义的修饰将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异。 8.5 函数模板函数模板是通用的函数描述，即它们使用泛型来定义函数。其中的泛型可以具体的类型(如int或double)替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型的方式编写程序，因此有时也称为通用编程。由于类型是用参数表示的，因此模板特性有时也称为参数化类型。 前面，定义了一个交换两个int的值的函数。假设要交换两个double值，则一种方法是复制原来的代码，并用double替换所有的int。如果需要需要交换两个char值，可以再次使用同样的技术。进行这种修改将浪费宝贵时间，且容易出错。 C++的函数模板功能能自动完成这一过程，可以节省时间，而且更可靠。 函数模板允许以任意类型的方式来定义函数。例如，可以这样建立一个交换模板： template &lt;typename AnyType&gt; void Swap(AnyType &amp; a, AnyType &amp;b) { AnyType temp; temp = a; a = b; b = temp; } 第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和type是是必需的，除非可以使用关键字class代替typename。另外，必须使用尖括号。类型名可以任意选择，只要遵守C++命名规则即可。模板不创建任何函数，而只是告诉编译器如何定义函数。需要交换int的函数时，编译器将按模板创建这样的函数，并用int代替AnyType。同样，需要交换double的函数时，编译器将按模板创建这样的函数，并用double代替AnyType。 在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。即，可以如下编写模块定义： template &lt;class AnyType&gt; void Swap(AnyType &amp; a, AnyType &amp;b) { AnyType temp; temp = a; a = b; b = temp; } funtemp.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b); int main() { int i = 10; int j = 20; cout &lt;&lt; &quot;i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; Swap(i, j); cout &lt;&lt; &quot;Now i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; double x = 24.5; double y = 81.4; cout &lt;&lt; &quot;x, y = &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl; Swap(x, y); cout &lt;&lt; &quot;Now x, y = &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl; return 0; } template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp; temp = a; a = b; b = temp; } 结果 i, j = 10, 20 Now i, j = 20, 10 x, y = 24.5, 81.4 Now x, y = 81.4, 24.5 当Swap()函数接受两个int参数，因此编译器生成该函数的int版本。即用int替换所有的int，生成下面的代码： void Swap(int &amp;a, int &amp;b) { int temp; temp = a; a = b; b = temp; } 程序员看不到这些代码，当编译器确实生成并在程序中使用了它们。 注意函数模板不能缩短可执行程序。对于上述程序，最终仍将有两个独立的函数定义，就像以手工的方式定义了这些函数一样最终代码不包含任何模板，而只包含为程序生成的时间函数。 更常见的情形时是，将模板放在头文件中，并在需要使用模板的文件中包含头文件。 8.5.1 重载的模板需要多个对不同类型使用同一种算法的函数时，可使用模板。然而，并非所有的类型都使用相同的算法。为满足这种需求，可以像重载常规函数一样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须相同。例如，上面程序新增了一个交换模板，用于交换两个数组中的元素。 cat twotemps.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b); template &lt;typename T&gt; void Swap(T a[], T b[], int n); void Show(int a[]); const int Lim = 4; int main() { int i = 10, j = 20; cout &lt;&lt; &quot;i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; Swap(i, j); cout &lt;&lt; &quot;Now i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; int d1[Lim] = {0,7,0,4}; int d2[Lim] = {1,9,6,9}; cout &lt;&lt; &quot;Original arrays:\n&quot;; Show(d1); Show(d2); Swap(d1, d2, Lim); cout &lt;&lt; &quot;Swapped arrays:\n&quot;; Show(d1); Show(d2); return 0; } template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp; temp = a; a = b; b = temp; } template &lt;typename T&gt; void Swap(T a[], T b[], int n) { T temp; for (int i = 0; i &lt; n; i++) { temp = a[i]; a[i] = b[i]; b[i] = temp; } } void Show(int a[]) { for (int i = 0; i &lt; Lim; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } 结果： i, j = 10, 20 Now i, j = 20, 10 Original arrays: 0 7 0 4 1 9 6 9 Swapped arrays: 1 9 6 9 0 7 0 4 8.5.2 模板的局限性假设有如下模板函数： template &lt;class T&gt; void f(T a, T b) {} 通常，代码假定可执行哪些操作。例如，下面的代码假定定义了赋值，但如果T是数组，这种假设将不成立: a = b; 同样，下面语句假设定义了&lt;，但如果T为结构，该假设便不成立： if (a &gt; b) 另外，为数组名定义了运算符，但由于数组名为地址，因此它比较的是数组的地址，而这可能不是您所希望的。下面的语句假定为类型T定义了乘法运算，但如果T为数组、指针或结构，这种假设便不成立： T c = a*b; 总之，编写的函数模板很可能无法处理某些类型。另一方面，有时候通用化是有意义的，但C++语法不允许这样左。例如，将两个包含位置坐标的结构相加是有意义的，虽然没有为结构定义运算+。一种解决方案是，C++允许您重载运算符+，以便能够将其用于特定的结构或类。这样使用运算符+的模板便可处理重载了运算符的结构。另一种解决方案是，为特定类型提供具体化的模板定义，接下来介绍。 8.5.3 显示具体化假设定义了如下结构： struct job { char name[40]; double salary; int floor; } 另外，希望能够交换两个这种结构的内容。原来模板使用下面的代码来完成交换： temp= a; a = b; b = temp; 由于C++允许将一个结构赋给另一个结构，因此即使T是一个job结构，上述代码也适用。然而，假设只想交换salary和floor成员，而不交换name成员，则需要使用不同的代码，但Swap()的参数将保持不变，因此无法使用模板重载来提供其他代码。 然而，可以提供一个具体化函数定义–称为显式具体化，其中包含所需的代码。当编译器找到与函数调用的具体化定义时，将使用该定义，而不再寻找模板。 C++标准定义的形式： 1.第三代具体化C++98标准选择了下面的方法： 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板以及它们的重载版本。 显式具体化的原型和定义应以teplate&lt;&gt;开头，并通过名称来指出类型。 具体化优先于常规模板，而非模板函数由于具体化和常规模板。 下面是用于交换job结构的非模板函数、模板函数和具体化的原型： void Swap(job &amp;, job &amp;); template &lt;typename T&gt; void Swap(T &amp;, T &amp;); template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;); //具体化 下面看一看显式具体化的工作方式。 2.显式具体化示例twoswap.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b); struct job { char name[40]; double salary; int floor; }; template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2); void Show(job &amp;j); int main() { cout.precision(2); cout.setf(ios::fixed,ios::floatfield); int i = 10, j = 20; cout &lt;&lt; &quot;i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; Swap(i,j); cout &lt;&lt; &quot;Now, i, j = &quot; &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; endl; job sue = {&quot;Susan&quot;, 73000.6, 7}; job sidney = {&quot;Sidney&quot;, 78060.7, 9}; cout &lt;&lt; &quot;Before job swapping:\n&quot;; Show(sue); Show(sidney); Swap(sue, sidney); cout &lt;&lt; &quot;After job swapping:\n&quot;; Show(sue); Show(sidney); return 0; } template &lt;typename T&gt; void Swap(T &amp; a, T &amp; b) { T temp; temp = a; a = b; b = temp; } template &lt;&gt; void Swap&lt;job&gt;(job &amp; j1, job &amp; j2) { double t1; t1 = j1.salary; j1.salary = j2.salary; j2.salary = t1; int t2; t2 = j1.floor; j1.floor = j2.floor; j2.floor = t2; } void Show(job &amp;j) { cout &lt;&lt; j.name &lt;&lt; &quot;: $&quot; &lt;&lt; j.salary &lt;&lt; &quot; on floor &quot; &lt;&lt; j.floor &lt;&lt; endl; } 结果： i, j = 10, 20 Now, i, j = 20, 10 Before job swapping: Susan: $73000.60 on floor 7 Sidney: $78060.70 on floor 9 After job swapping: Susan: $78060.70 on floor 9 Sidney: $73000.60 on floor 7 8.5.4 实例化和具体化在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。例如，在上述程序中，函数调用Swap(i,j)导致编译器生成Swap()的一个实例，该实例使用int类型。模板并非函数定义，但使用int的模板实例是函数定义，这种实例化被称为隐式实例化。 最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化。这意味着可以直接命令编译器创建特定的实例，如Swap()。其语法是，声明所需的种类–用&lt;&gt;符号指出类型，并在声明前加上关键字template: template void Swap&lt;int&gt;(int, int); 实现了这种特性的编译器看上上述声明后，将使用Swap()模板生成一个使用int类型的实例。即，该声明的意思是：使用Swap()模板生成int类型的函数定义。 与显式实例化不同的是，显式具体化使用下面两个等价的声明之一： template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;); template &lt;&gt; void Swap(int &amp;, int &amp;); 区别在于，这些声明的意思是：不要使用Swap()模板生成函数定义，而应使用专门为int类型显式地定义的函数定义。这些原型必须有自己的函数定义。显式具体化声明在关键字templat包含&lt;&gt;，而显式实例化没有。 警告： 试图在同一个文件中使用同一种类型的显式实例和显式具体化将出错。 还可以通过在程序中使用函数来创建显式实例化。例如，请看下面代码： templatte &lt;class T&gt; T Add(T a, T b) { return a + b; } int m = 6; double x = 10.2; cout &lt;&lt; Add&lt;double&gt;(x, m) &lt;&lt; endl; 这里的模板与函数调用Add(x,m)不匹配，因为该模板要求两个函数参数的类型相同。但通过使用Add(x,m),可强制为double类型实例化，并将参数m强制转换为double类型，以便与函数Add(double,double)的第二个参数匹配。 如果对Swap()做类型的处理： int m = 5; double x = 14.3; Swap&lt;double&gt;(m, x); 这将为类型double生成一个显式实例化，不幸的是，这些代码不管用，因此的哥形参的类型为double &amp;，不能只想int变量m。 隐式实例化、显式实例化和显式具体化统称为具体化。它们的相同之处在于，它们表示都是使用具体类型的函数定义，而不是通用描述。 引入显式实例化后，必须使用新的语法–在声明中使用前缀template和template&lt;&gt;，以区分显式实例化还是显式具体化。通常，功能越多，语法规则也越多。下面的代码片段中间了这些概念： template &lt;class T&gt; void Swap(T &amp;a , T &amp;b); template &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;);//显式具体化 int main() { template void Swap&lt;char&gt;(char &amp;, char &amp;); //显式实例化 short a, b; Swap(a, b); //隐私实例化 job n, m; Swap(n, m); //使用显式具体化 char g, h; Swap(g, h); //使用显式实例化 } 编译器看到char的显式实例化后，将使用模板定义来生成Swap()的char版本。对于其他Swap()调用，编译器根据函数调用中实际使用的参数，生成相应的版本。例如，当编译器看淡函数调用Swap(a,b) 后，将生成Swap(a,b)的short版本，因为两个参数的类型都是short。当编译器看到Swap(n,m)后，将使用short类型提供的独立定义(显式具体化)。当编译器看到Swap(g,h)后，将使用处理显式实例化时生成的模板具体化。 8.5.5 编译器选择使用哪个函数版本对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数的定义，尤其是有多个参数时。这个过程称为重载解析。大致了解一下这个过程是如何进行的： 第一步：创建候选函数列表。其中包含于被调用函数的名称相同的函数和函数模板。 第二步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为doule，从而与doule形参匹配，而模板可以为float生成一个实例。 第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。 考虑只有一个函数参数的情况，如下面的调用： may(&apos;B&apos;); 首先，编译器将寻找候选者，即名称为may()的函数和函数模板。然后，寻找那些可以用一个参数调用的函数。例如，下面的函数符合要求，因为其名称和被调用的函数函数相同，且可只给它传递一个参数： void may(int); #1 float may(flaot, flaot = 3); #2 void may(char); #3 char * myay(const char *); #4 char may (const char &amp;); #5 template &lt;class T&gt; void may(const T &amp;); #6 template &lt;class T&gt; void may(T *); #7 注意，只考虑特征标，而不考虑返回类型。其中的两个函数(#4和#7)不可行，因为整型类型不能被隐式地转换（即没有显式强制类型转换）为指针类型。剩余的一个模板可用来生成具体化，其中T被替换为char类型。这样剩余5个可行的函数，其中的每一个函数，如果它式声明唯一一个函数，都可以被使用。 接下来，编译器必须确定哪个可行函数是最佳的。它查看为使函数调用参数与可行的候选函数的参数匹配所需进行的转换。通过从最佳到最差的顺序如下所述： 完全匹配，但常规函数优先于模板。 提升转换（例如，char和short自动转换为int, float自动转换为double）。 标准转换（例如，int转换为char，long转换为double）. 用户定义的转换，如类声明中定义的转换。 例如，函数#1优先于函数#2，因为char到int的转换为提升转换，而char到float的转换是标准转换。函数#3、函数#5和函数#6都优先于函数#1和#2，因为它们都是完全匹配的。#3和#5优先于#6，因为#6是函数模板。如果两个函数(如#3和#5)都完全匹配，将如何办？通常，有两个函数完全匹配是一种错误，但这一规则有两个例外。下面，深入探讨这一点： 1. 完全匹配和最佳匹配完全匹配允许的无关紧要的转换： 从实参 到形参 Type Type &amp; Type &amp; Type Type [] Type $\ast$ Type (argument-list) Type ($\ast$)(argument-list) Type const Type Type volatile Type Type $\ast$ const Type Type $\ast$ volatile Type $\ast$ Type表示任意类型，例如int实参与int &amp;形参完全匹配。Type(argument-list)意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的。volatile下一章介绍。 假设有下面的函数代码： struct blot {int a, char b[10]}; blot ink{25, &quot;spots&quot;}; recycle(ink); 在这种情况下，下面的原型都是完全匹配的： void recycle(blot); #1 void recycle(const blot); #2 void recycle(blot &amp;); #3 void recycle(const blot &amp;); #4 正如预期的，如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译程将生成一条错误消息，该消息可能会使用诸如“ambiguous(二义性)”这样的词语。 然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。即，在recycle()示例中，如果只定义了函数#3和#4是完全匹配的，则将选择#3，因为int没有被声明为const。然而，const和非const之间的区别只适用于指针和引用指向的数据。即，如果只定义了#1和#2，则将出现二义性。 一个完全匹配优先于另一个的另一种情况是，其中一个是非模板函数，而另一个不是。在这种情况下，非模板函数将优先于模板函数（包括显式具体化）。 如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如，这意味着显式具体化将优先于使用模板隐式生成的具体化： struct blot {int a; char b[10]}; template &lt;class Type&gt; void recycle(Type t); template &lt;&gt; void recycle&lt;blot&gt; (blot &amp; t); blot ink = {25, &quot;spots&quot;}; recycle(int); 术语“最具体”并不一定意味显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。例如，请看下面两个模板： template &lt;class Type&gt; void recycle(Type t); #1 template &lt;class Type&gt; void recyclle(Type * t); #2 recycle(&amp;ink); recyele(&amp;ink)调用与#1模板匹配，匹配时间Type解释为blot $\ast$。recycle(&amp;ink)函数调用也与#2模板匹配，这样Type被解释为blot。因此两个隐式实例–recycle&lt;blot$\ast$&gt;(blot$\ast$)和recycle(bloat$\ast$)发送到可行函数池中。 在这两个模板函数中，recycle&lt;blot$\ast$&gt;(blot$\ast$)被认为是更具体地，因为在生成过程中，它需要进行地转换更少。即，#2模板已经显式指出，函数参数是指向Type的指针，因为出可以直接用blot标识Type；而#1模板见Type作为函数参数，因此Type必须被解释为指向blot的指针。即，在#2模板中，Type已经被具体化为指针，因为说它“更具体”。 2. 部分排序规则实例下述程序有两个用来显式数组内容的模板定义。第一个定义（模板A）假设作为参数传递的数组中包含了要显式地数据；第二个定义（模板B）假设数组元素为指针，指向要显示地数据。 temptempover.cpp #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void ShowArray(T arr[], int n); template &lt;typename T&gt; void ShowArray(T * arr[], int n); struct debts { char name[30]; double amount; }; int main() { int things[6] = {13, 31, 103, 301, 310, 130}; struct debts mr_E[3] = { {&quot;Volfe&quot;, 2400.0}, {&quot;Foxe&quot;, 1300.0}, {&quot;Stout&quot;, 1800.0} }; double *pd[3];//3个指针组成的数组 for (int i = 0; i &lt; 3; i++) pd[i] = &amp;mr_E[i].amount; cout &lt;&lt; &quot;Listing Mr. E&apos;s counts of things:\n&quot;; ShowArray(things, 6); cout &lt;&lt; &quot;Listing Mr. E&apos;s debts:\n&quot;; ShowArray(pd, 3); return 0; } template &lt;typename T&gt; void ShowArray (T arr[], int n) { cout &lt;&lt; &quot;Template A\n&quot;; for (int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; } template &lt;typename T&gt; void ShowArray(T * arr[], int n) { cout &lt;&lt; &quot;Template B\n&quot;; for (int i = 0; i &lt; n; i++) cout &lt;&lt; *arr[i] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; } 结果 Listing Mr. E&apos;s counts of things: Template A 13 31 103 301 310 130 Listing Mr. E&apos;s debts: Template B 2400 1300 1800 标识符things是一个int数组的名称，因为与下面的模板匹配： template &lt;typename T&gt; #模板A void ShowArray(T arr[], int n); pd是一个doulbe $\ast$数组的名称，这与下面的模板匹配： template &lt;typename T&gt; #模板B void ShowArray(T * arr[], int n); 如果将模板B删除，则编译器将使用模板A来显示pd内容，因此显示的将是地址，而不是值。 简而言之，重载解析将寻找最匹配的函数。如果只存在一个这样的函数，则选择它；如果存在多个这样的函数，但其中只有一个是非模板函数，则选择该函数；如果存在多个适合的函数，且它们都为模板函数，但其中有一个函数比其他函数具体，则选择该函数。如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数具体，则函数调用将不是确定的，因此是错误；当然，如果不存在匹配函数，则也是错误。 3. 创建自定义选择在有些情况下，可通过编写合适的函数的调用，引导编译器做出您希望的选择。下面程序，将模板函数定义放在文件开头，从而无需提供模板原型。与常规函数一样，通过在使用函数前提供模板函数定义，让他充当原型。 choices.cpp #include &lt;iostream&gt; using namespace std; template &lt;class T&gt; //#1 T lesser(T a, T b) { return a &lt; b ? a : b; } int lesser (int a, int b) //#2 { a = a &lt; 0 ? -a : a; b = b &lt; 0 ? -b : b; return a &lt; b ? a : b; } int main() { int m = 20; int n = -30; double x = 15.5; double y = 25.9; cout &lt;&lt; lesser(m, n) &lt;&lt; endl; //使用#2 cout &lt;&lt; lesser(x, y) &lt;&lt; endl; //使用#1 cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl; //使用#1 cout &lt;&lt; lesser&lt;int&gt;(x, y) &lt;&lt; endl;//使用#1 return 0; } 结果 20 15.5 -30 15 上述程序提供了一个模板和一个标准函数，其中模板返回两个值较小的一个，而标准函数返回两个值绝对值较小的那个。如果函数定义是在使用函数前提供的，它将充当原型，因此这个示例无需提供原型 lesser&lt;&gt;(m, n); &lt;&gt;指出，编译器应选择模板，而不是非模板函数；编译器注意到实参的类型为int，因此使用int替代T对模板进行示例化。 最后，lesser(x, y)这条语句要求进行显示实例化，将使用显示实例化得到的函数。x和y的值将被强制转换为int，该函数返回一个int值 4.多个参数的函数将有多个参数的函数调用与有多个参数的原型进行匹配时，情况将非常复杂。编译器必须考虑所有参数的匹配情况。如果找到比其他可行函数都合适的函数，则选择该函数。一个函数要比其他函数都合适，其所有参数的匹配程度都必须不必其他函数差，同时至少有一个参数的匹配程度比其他函数都高。 8.5.6 模板函数的发展在C++发展的早期，大多数人都没有想到模板函数和模板类会有这么强大而有用。 1.是什么类型在C++98中，编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型。如下： template &lt;class T1, class T2&gt; void ft(T1 x, T2 y) { ?type? xpy = x + y; ... } xpy应为什么类型。由于不知道ft()将如何使用，因此无法预先知道这一点。正确的类型可能是T1、T2或其他类型。例如，T1可能是double，而T2可能是int，在这种情况下，两个变量的和将为double类型。T1可能是short，而T2可能是int，在这种情况下，两个变量的和为int。T1还可能是short，而T2可能是char，在这种情况下，加法运算将导致自动整型提升，因此结果类型为int。另外，结构和类可能重载运算符+，这导致问题更加复杂。 2.关键字decltype(C++11)C++11新增的关键字decltype提供了解决方案，可这样使用该关键字： int x; decltype(x) y; //是y的类型跟x相同 给decltype提供的参数可以是表达式，因此在前面的模板函数ft()中，可使用下面的代码： decltype(x + y) xpy; xpy = x + y; 另一种方法是，将这两条语句合二为一： decltype(x + y) xpy = x + y; decltype比这些示例演示的更复杂些。为确定类型，编译器必须遍历一个核对表。假设有如下声明： decltype(expression) var; 则核对表的简化版如下： 第一步：如果expression是一个没有用括号括起来的标识符，则var的类型与该标识符的类型相同，包括const等限定符： double x = 5.5; double y = 7.9; double &amp;rx = x; const double * pd; decltype(x) w; dexltype(rx) u = y; decltype(pd) v; 第二步：如果expression是一个函数调用，则var的类型与函数的返回类型相同： long indeed(int); decltype(indeed(3)) m; 注意：并不会实际调用函数，编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。 第三步： 如果expression是一个左值，则var为指向其类型的引用。这好像意味着前面的w应为引用类型，因为x是一个左值。但别忘了，这种情况已经在第一步处理过了。要进入第三步，expression不能是用未用括号括起来的标识。那么，expression是用括号括起来的标识符： double xx = 4.4; decltype((xx)) r2 = x; //r2是doule &amp; 类型 decltype(xx) w = x; //w是double类型 顺便说一句，括号并不会改变表达式的值和左值性。例如下面两条语句等效： xx = 98.6; (xx) = 98.6; 第四步：如果前面的条件都不满足，则var的类型与expresssion类型相同： int j = 3; int &amp;k = j; int &amp;n = j; decltype(j+6) i1; //i1为int decltype(100L) i2; //i2为long decltype(k+n) i3; //i3为int 请注意，虽然n和k都是引用，但表达式k+n不是引用，它是两个int的和，因此类型为int。 如果需要多次声明，可结合typedef和decltyep: template &lt;class T1, class T2&gt; void ft(T1 x, T2 y) { typedef decltype(x + y) xytype; xytype xpy = x + y; xytype arr[10]; xytyep &amp; rxy = arr[2]; ... } 3. 另一种函数声明的语法（C++后置返回类型）另一个相关的问题是decltype本身无法解决的。如下不完整的模板函数： template &lt;class T1, class T2&gt; ?type? t(T1 x, T2 y) { ... return x + y; } 同样，无法预先知道x和y相加得到的类型。好像可以将返回类型设置为decltype(x+y)。但不幸的是，此时还未声明参数x和y，它们不在作用域内。必须在声明参数后使用decltype。为此，C++新增了一种声明和定义函数的语法。下面使用内置类型来说明这种语法的工作原理。对于下面的原型： double h(int x, float y); 使用新增的语法可编写成这样： auto h (int x, float y) -&gt; double; 这将返回类型移动到参数声明后面。-&gt;double被称为后置返回类型。其中auto是一个占位符，表示后置返回类型提供的类型。这是C++新增给auto的一种角色。这样语法可以用于函数定义： auto h(int x, float y) -&gt; double {...} 通过结合使用这种语法和decltype，便可给出gt()指定返回类型，如下： template&lt;class T1, class T2&gt; auto gt(T1 x, T2 y) -&gt; decltype(x + y) { return x + y; } 现在decltype在参数声明后面，因此x和y位于作用域内。 8.6 总结函数 引用变量： &amp; k 默认参数 重载 模板 模板重载]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软面试题目--字母易位词]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%BE%AE%E8%BD%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE--%E5%AD%97%E6%AF%8D%E6%98%93%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目两个单词如果包含相同的字母，次序不同，则称为字母易位词(anagram)。例如，“silent”和“listen”是字母易位词，而“apple”和“aplee”不是易位词。请定义函数检查两个单词是否是字母易位词。可以假设两个单词字母均为小写。要求算法复杂度尽量低。 1. 方法一思路首先，最基本的思路，便是检测字符串s1中的字符是否都出现在s2中（在s1和s2长度一样的前提下）。为了解决“apple”和“aplee”不是易位词的这种情况，不能仅仅判断出现在s2中就可以了，还需要做个标记。这里可以考虑将字符串转换为list，对于比较过的便设置为None。算法代码设计如下： 代码def anagram(s1, s2): if len(s1) != len(s2): return false alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(s2) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 += 1 if found: alist[pos2] = None #匹配一个字符除掉该字符，防止apple和aplee这种类型匹配 else: stillOK = False break pos1 += 1 return stillOK if __name__ == &quot;__main__&quot;: print(anagram(&quot;apple&quot;,&quot;aplee&quot;)) 让我们考虑一下算法复杂度。可以从字符串s2来考虑，对于s2中的每个元素，s1都会从头开始进行遍历一次，所以算法的复杂度为： 即算法的复杂度为O(n^2)。 2.方法二思路母易位词即为各个字母的数目相同，而顺序不一致。因而，如果对字符串按照字母顺序排序后，那么两个字符串应该完全一致。这样算法复杂度是否更低？ 代码def anagram(s1, s2): if len(s1) != len(s2): return False alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 while pos &lt; len(s1): if alist1[pos] == alist2[pos]: pos += 1 else: return False return True if __name__ == &quot;__main__&quot;: print(anagram(&quot;badc&quot;,&quot;abcd&quot;)) 这样算法复杂度是否是O(n)了呢？因为仅仅进行了n次比较啊。当然不是，为什么呢？因为事先先对两个字符串进行了排序，而排序的复杂度并未计入。所以，此种算法的复杂度即为O(nlogn+n)，为O(nlogn)。复杂度比方法一的复杂度降低了。 3.方法三思路从另外一个角度思考，字母一共有多少个？很明显，只有26个（只考虑小写字母）。那么，我们可以为字符串s1和s2分别设置26个计数器，然后判断这对应位置的计数是否相等，如果对应计数完全相等，则为字母易位词。 代码def anagram(s1, s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i]) - ord(&apos;a&apos;) c1[pos] += 1 for i in range(len(s2)): pos = ord(s2[i]) - ord(&apos;a&apos;) c2[pos] += 1 j = 0 while j &lt; 26: if c1[j] == c2[j]: j += 1 else: return False return True if __name__ == &quot;__main__&quot;: print(anagram(&quot;badc&quot;,&quot;abcd&quot;)) 附件： &apos;&apos;&apos;两个单词如果包含相同的字母，次序不同，则称为字母易位词(anagram)。 例如，“silent”和“listen”是字母易位词，而“apple”和“aplee”不是 易位词。请定义函数检查两个单词是否是字母易位词。可以假设两个单词字母 均为小写。要求算法复杂度尽量低。&apos;&apos;&apos; #方法一 &apos;&apos;&apos;def anagram(s1, s2): if len(s1) != len(s2): return false alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(s2) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 += 1 if found: alist[pos2] = None #匹配一个字符除掉该字符，防止apple和aplee这种类型匹配 else: stillOK = False break pos1 += 1 return stillOK&apos;&apos;&apos; #方法二 &apos;&apos;&apos;def anagram(s1, s2): if len(s1) != len(s2): return False alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 while pos &lt; len(s1): if alist1[pos] == alist2[pos]: pos += 1 else: return False return True&apos;&apos;&apos; #方法三 def anagram(s1, s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i]) - ord(&apos;a&apos;) c1[pos] += 1 for i in range(len(s2)): pos = ord(s2[i]) - ord(&apos;a&apos;) c2[pos] += 1 j = 0 while j &lt; 26: if c1[j] == c2[j]: j += 1 else: return False return True if __name__ == &quot;__main__&quot;: print(anagram(&quot;badc&quot;,&quot;abcd&quot;)) 转自: https://mp.weixin.qq.com/s/v_186DNtc2w3JfAY0Yj9_Q]]></content>
      <tags>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别(二)--感知器算法]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%84%9F%E7%9F%A5%E5%99%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[感知器算法 原理 python实现import numpy as np def Perception(x,w,c): count = 1#记录训练失败的样本数量 k = 0#迭代计数 while count:#记录训练失败的样本数量为0，则循环结束 count = 0 for i in range(np.shape(x)[0]): temp = sum(w*x[i][:])#计算W^T(k)X k += 1 if temp &lt;= 0: #如果W^T(k)X&lt;=0，更新权重，如果W^T(k)X&gt;0，权重不变 w = w + c*x[i][:]#更新权重 count += 1 #利用count来判断所有训练都得到了正确的分类结果， #count=0,所有W^T(k)X&gt;0,即得到所有训练都得到了正确的分类节 print(&apos;#&apos;,c,&apos; k=&apos;,k)#输出迭代次数 return w if __name__ == &quot;__main__&quot;: x =np.array([[0,0,0,1],[1,0,0,1],[1,0,1,1],[1,1,0,1], [0,0,-1,-1],[0,-1,-1,-1],[0,-1,0,-1],[-1,-1,-1,-1]])#写成增广矩阵形式 w = np.array([-1,-2,-2,0])#权重向量 #c = 1#校正增量系数 #p = Perception(x,w,c) #print(p) for c in range(1,101): p = Perception(x,w,c) print(p)]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式机器学习框架--参数服务器]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6--%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在大规模数据上跑机器学习任务是过去十多年内系统架构师面临的主要挑战之一，许多模型和抽象先后用于这一任务。 参数服务器的概念最早来自Alex Smola于2010年提出的并行LDA的框架[4]。它通过采用一个分布式的Memcached作为存放参数的存储，这样就提供了有效的机制用于在分布式系统不同的Worker节点之间同步模型参数，而每个Worker只需要保存它计算时所依赖的一小部分参数即可。当然，这里存放参数的存储跟做OLTP应用中的Key-Value抽象有所不同，因为以Key-Value为单元进行频繁的参数数据交互会导致过高的通信开销，因此参数服务器通常采用数学封装来进行参数同步，比如向量，张量，矩阵的行列等。 上图的sampler是并行LDA里的组件，可类比为通用参数服务器框架里的计算单元。Smola提出的模型是最早的参数服务器抽象，随后出现了许多改进，最出名的应当是Google的跨界高人Jeff Dean 2012年进一步提出了第一代Google大脑的解决方案DistBelief[5]，主要用于超大规模深度学习网络的训练。DistBelief将巨大的深度学习模型分布存储在全局的参数服务器中，计算节点通过参数服务器进行信息传递，很好地解决了SGD和L-BFGS算法的分布式训练问题。由于SGD和L-BFGS是机器学习的普遍性优化问题，因此尽管DistBelief是作为深度学习的系统框架而提出，但DistBelief的核心结构却可以应用到多种普通机器学习手段中。相比最早的参数服务器模型，DistBelief把该模型扩展成为更加通用和灵活的框架，豆瓣的Paracel[3]正是参考DistBelief的直接实现，先来看看Paracel和DistBelief模型： 图中是分布式异步SGD架构流程图，运行时，需要把训练数据分为多个子集，然后在每个子集上运行模型的多个副本，模型通过集中式的参数服务器通信，参数服务器存放了模型的全部参数和状态。异步体现在两方面：模型的副本独立运行；参数服务器的分片也各自独立运行。DistBelief没有过多谈论系统实现，从Paracel里我们可以看到具体的工程实现：总体上Paracel实现非常简单，参数服务器直接采用内存hashtable，并封装了对分网络，图，稀疏矩阵，稠密矩阵等数据格式用于参数同步。Paracel解决的另一问题是straggler问题：由于一些软硬件的原因，节点的计算能力往往不尽相同。对于迭代问题来说，每一轮结束时算得快的节点都需等待算得慢的节点算完，再进行下一轮迭代。这种等待在节点数增多时将变得尤为明显，从而拖慢整体的性能。Paracel放宽了“每个迭代步都等待”这个约束：当在一轮迭代结束时，算得快的节点可以继续下一轮迭代，但不能比最慢的节点领先参数s个迭代步。当领先超过s个迭代步，Paracel才会强制进行等待。这样异步的控制方式既从整体上省去了等待时间，也能间接地帮助慢的节点赶上。从优化问题的角度来看，虽然单迭代步收敛得慢了，然而每个迭代步的时间开销变少了，总体上收敛也就变快了。这种做法又叫Staleness Synchronous Parallel (SSP)，基本思想是允许各机器以不同步调对模型进行更新，但是加一个限制，使得最快的机器的进度和最慢机器的进度之差不要太大。这样做的好处是：既减轻慢的机器拖整个系统的后腿，又能保证模型的最终收敛。 SSP是由CMU Eric Xing的Petuum项目组提出的[6]，Paracel引入SSP使得豆瓣的参数服务器方案工程上更加成熟，在Paracel内部，SSP的等待通过调用MPI来实现。关于一致性收敛和Petuum，在下边还会有介绍。关于参数服务器，另一个重要的方面是容错设计。在几十台机器的集群上运行，这也许并不是一个问题，但是如果在有上千台机器的集群上运行任务，节点发生任务失败的概率就会大很多，如果缺乏容错设计，就会导致任务重启，从而浪费大量时间。不过，在Paracel的代码里并没有找到相关的处理逻辑，通常容错处理需要借助于Checkpoint来做快照，这样任务重启时无需从头进行，比如DistBelief就是这样处理。跟豆瓣的工程师咨询后已经确认，在开源版本的Paracel里确实还没有相关设计。 上面讲述了不少参数服务器的背景和系统结构，那么为什么参数服务器能够具备更好的性能呢？仍以SGD为例说明：在传统同步SGD中，如果一台机器失效，整个训练过程将会延时；但是对于异步SGD来讲，如果某个模型副本的一台机器失效，其他模型副本仍然继续处理样本并更新参数服务器中的模型参数，因此异步SGD具备更好的鲁棒性。此外，多种异步处理形式给最优化过程带来进一步的随机性：模型实例最可能是使用一个稍微过时的参数来计算梯度，因为这时其他的副本可能已经更新了参数服务器上的参数。除此之外还有其他随机的来源，因为参数服务器组的每台机器是行为独立的，所以无法保证在给定时间点上，每个节点的参数被更新的次数相同，或者以同样的顺序被更新。更进一步，因为模型副本使用不同的线程来获取参数和推送梯度值，故在同一时间戳上，单个副本内的参数将有额外的稍微不一致的现象。尽管对于非凸问题的这些操作的安全性缺乏理论基础，但是在实践中，这种放松一致性要求的做法是相当有效的。传统同步SGD的最优化过程，每次迭代选取的方向是由全部训练数据决定，或者由随机选定的一小部分训练集指定(mini-batch)。而异步的做法由于上述更多的随机性则会同时在很多方向上由不同的mini-batch选定不同梯度方向，这就好比整个最优化过程是以一个区域为单位进行的，而区域内的点代表不同SGD的过程，因此这种并行化的工作会带来性能上的提升。 介绍另外一个重要项目，来自Alex Smola的高徒——李沐设计的参数服务器[7]。这个项目在早期拥有一个独立域名http://parameterserver.org，后来因为李沐和陈天奇等国内英才成立的DMLC深度学习项目组，之前的项目也进行了重构因此转移到[7]所在的地址，而项目的背景介绍则在[8]和[9]。从架构上来说，ps-lite跟Paracel并没有什么不同，作为参数服务器，都需要一个全局分布式的key-value用来存储算法的模型或参数。当计算节点需要某个参数的时候，可以从参数服务器上读取。用户可定义不同的函数在参数服务器端对参数进行更新、过滤等操作。在大部分情况下，计算节点之间的通信都是通过参数服务器进行。 ps-lite应当属于第三代参数服务器，就是提供了更加通用的设计，在架构上包含一个Server Group和若干个Worker Group： Server Group用来做参数服务器，每个Server Node存放一个参数分片，由Server Manager管理整个Server Group，维持整个Server Group的元数据的一致性视图，以及参数分片情况。 每个Worker Group运行一个应用，Worker Node只跟Server Node通信用来更新参数，Worker Node之间没有任何交互。每个Worker Group内有一个调度器，负责给Worker Nodes分配任务以及监控，如果有Worker Node挂掉或者新加入，调度器负责重新调度剩余的任务。 跟Paracel不同，ps-lite提供了多种数据一致性选择： Sequential：这种情况下，所有任务顺序进行，因此数据严格一致，不会出现不同副本看到的数据有不同的情况，因此实际上跟前文介绍的BSP是等价的。 Eventual：这种情况下，所有任务并行执行，因此拥有最大的随机性。Eventual只适用于对于数据一致没有要求，非常健壮的算法，比如SGD。 Bounded Delay：每个任务需要设置最大超时时间，在该时间之前如果有任务未结束，那么新任务将会等待。Bounded Delay类似于上面的SSP，只不过这是用时间而SSP则是用迭代次数。 转自：http://chuansong.me/n/2161528]]></content>
      <tags>
        <tag>分布式机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(四)--网络层]]></title>
    <url>%2F2018%2F10%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E5%9B%9B)--%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络层 4.1 网络层提供的两种服务借助于电信网的成功经验，让网络复杂可靠交付。电信网使用昂贵的程控交换机，用面向链接的通信方式，使电信网络能够向用户(实际上使电话机)提供可靠传输的服务。计算机网络也应该模仿打电话所使用的面向连接的通信方式。当计算机进行通信时，也应当先建立连接(但在分组交换中使建立一条虚电路VC)以保证双方通信所需的一切网络资源。然后，双方就沿着已建立的虚电路发送分组。这样的分组首部不需要填写完整的目的主机地址，而只需要填写这条虚电路的编号(一个不大的整数)，因而减少了分组的开销。这种通信方式如果再使用可靠传输的网络协议，就可使所发的分组无差错按序到达终点，当然也不会丢失、不重复。在通信结束以后释放虚电路。具体如下图： 计算机网络的端系统是有智能的计算机，计算机有很强的差错处理能力，因此，因特网在设计上就采用了和电信网完全不同的思路。 这种思路就是：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络在发送分组时不需要先建立连接。每一个分组独立发送，所传送的分组可能出错、丢失、重复和失序，当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这种网络中的路由器比较简单，价格低廉。如果主机中的进程之间的通信需要是可靠的，那么就由路由网络的主机中的运输层负责（包括差错处理、流量控制）。如下图： 4.2 网际IP协议网际协议IP是TCP/IP体系中两个主要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套使用的还有三个协议： 地址解析协议ARP 网际空值报文协议ICMP 网际组管理协议IGMP 还有一个协议叫做逆地址解析协议RARP，是和ARP协议配合使用的，但现在已被淘汰不使用了。 下图画出了这三个协议和网际协议IP的关系。在这一层中，ARP画在最下面，因为IP经常要使用这个协议。ICMP和IGMP画在这一层的上部，因为它们要使用IP协议。这三个协议后面陆续介绍。由于网际协议IP是用来使互联起来的许多计算机网络能够进行通信，因此TCP/IP体系中的网络层常常称为网际层或IP。 4.2.1 虚拟互连网络将互联网互连在一起要使用一些中间设备。根据中间设备所在的层次，可以有一下四种不同的中间设备： 物理层使用的中间设备：转发器 数据链路层使用的中间设备:网桥或桥接器 网络层使用的中间设备：路由器 网络层以上使用的中间设备：网关 当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度，这仍然是一个网络，一般并不称为网络互连。我们讨论网络互连，是指用路由器进行网络互连和路由选择。路由器就是一个专用计算机，用来在互联网中进行路由选择。 TAP/IP体系在网络互连商采用的做法是在网络层（即IP层）采用了标准化协议，当相互连接的网络则是可以异构的。 4.2.2 分类的IP地址1 IP地址及其表示法整个因特网就是一个单一的、抽象的网络，IP地址就是给因特网上的每一个主机的每一个接口分配一个在全世界范围是唯一的32位的标识符。IP地址的结构使我们在因特网上很方便地进行寻址。 IP地址由两个固定长度的字段组成，其中第一个字段是网络号，它标志主机所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。第二个字段是主机号，它标志该主机，一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。 这种两级的IP地址可以记为： IP地址::={&lt;网络号&gt;,&lt;主机号&gt;} 其中“::=”表示“定义为” 下图给出了各种IP地址的网络号字段和主机号字段，这里A类、B类、C类地址都是单播地址（一对一通信），是最常用的。 从上图可以看出： A类、B类和C类地址的网络号字段分别位1、2和3字节长，而在网络号字段的最前面由1~3位的类别位，其数值分别规定为0，10和110。 A类、B类和C类地址的主机号字段分别为3个、2个和1个字节长。 D类地址（前4位是1110）用于多播（一对多通信）。 E类地址（前4位是1111）保留为以后用。 从IP地址结构来看，IP地址并不仅仅指明一个主机，而是还指明了主机所连接到的网络。 IP地址点分十进制记法： 2. 常用的三种类别的IP地址A类地址的网络号字段占用一个字节，只有7位可供使用（该字段第一位固定为0），可指派的网络号是127个（$2^7-2$）。减2的原因是：第一，IP地址中的全0表示“这个（this）”。网络号字段为全0的IP地址是个保留地址，意思是“本网络”。第二，网络号为127（即01111111）保留作为本地软件环回测试本主机的进程之间的通信之用。网络号为127的地址不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。 A类地址的主机号占3字节，因为每一个A类网络中的最大主机数是$2^{24}-2$，即16 777 214。这里的减2原因是：全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址（例如，一主机的IP地址为5.6.7.8，则该主机的网络地址就是5.0.0.0），而全1表示“所有的（all）”，因此全1的主机号字段表示该网络上的所有主机。 B类地址的网络号字段有2个字节，但前面两位（1 0）已经固定了，剩下14可以进行分配。因为，前面两位中有0和1，所以不管怎么取都不会有全0和全1,并且，B类网络地址128.0.0.0是不指派的，而可以指派的B类最小网络地址是128.1.0.0。所以，B类地址的网络数位$2^{14}-1$，即16 383。B类地址的每一个网络上的最大主机数是$2^{16}-2$，即65 534。这里需要减去2是因为扣除全1和全0的主机号。 C类地址有3个字节的网络号字段，最前面的3位是（1 1 0），还有21位可以进行分配。C类网络地址192.0.0.0也是不指派的，可以指派的C类网络地址是192.0.1.0，因此C类地址可指派的网络总数是$2^{21}-1$，即2097151。每一个C类地址的最大主机数是$2^8-2$。 注意： 路由器总是具有两个或两个以上的IP地址。即路由器的每一接口都有一个不同的网络号的IP地址。 在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。 用网桥（它只工作在链路层）互连的网段仍然是一个局域网，只能有一个网络号。 4.2.3 IP地址与硬件地址物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址（称IP地址是逻辑地址是因为IP地址是由软件实现的）。 在发送数据时，数据从高层下到底层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的的地址都是硬件地址，这两个硬件地址都写在MAC帧的首部。 IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。 路由器只根据目的站的 IP 地址的网络号进行路由选择。在具体的物理网络的链路层只能看见 MAC 帧而看不见 IP 数据报。 IP层抽象的互联网屏蔽了下层很复杂的细节在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信。 4.2.4 地址解析协议ARP由于IP协议使用了ARP协议，因此通常把ARP协议划归网络层。ARP协议的用途是为了从网络层使用的IP协议解析出在数据链路层使用的硬件地址。 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 ARP 高速缓存的作用： 为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。 当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了 ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 不直接使用硬件地址通信，而采用IP地址的原因： 由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。 连接到因特网的主机都拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为调用 ARP 来寻找某个路由器或主机的硬件地址都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。 4.2.5 IP数据报格式一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本——占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 (即 IPv4)。 首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)因此 IP 的首部长度的最大值是 60 字节。 区分服务——占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。 总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。 标识(identification)——占 16 位，它是一个计数器，用来产生数据报的标识。 标志(flag)——占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF  0 时才允许分片。 片偏移(13 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。 一数据报的总长度为3820字节，其数据部分为3800字节长。需要分片长度不超过1420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分不超过1400字节。于是分为3个数据报片。 生存时间(8 位)记为 TTL (Time To Live)数据报在网络中可通过的路由器数的最大值。 协议(8 位)字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。 首部检验和(16 位)字段只检验数据报的首部不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 源地址和目的地址都各占 4 字节。 4.2.6 IP层转发分组的流程有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想像，若按目的主机号来制作路由表，则所得出的路由表就会过于庞大。但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目。这样就可使路由表大大简化。 查找路由表 根据目的网络地址就能确定下一跳路由器，这样做的结果是： IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。 只有到达最后一个路由器时，才试图向目的主机进行直接交付。 特定主机路由 这种路由是为特定的目的主机指明一个路由。 采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。 默认路由 路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。 这种转发方式在一个网络只有很少的对外连接时是很有用的。 默认路由在主机发送IP数据报时往往更能显示出他的好处。 如果一个主机连接在一个小网络上，而这个网络只用一个路由器和因特网连接，那么在这种情况下使用默认路由是非常合适的。 只要目的网络不是 N1 和 N2，就一律选择默认路由，把数据报先间接交付路由器 R1，让 R1 再转发给下一个路由器。 注意 IP数据报的首部中没有地方可以用来指明“下一跳路由器的IP地址”。 当路由器收到待转发的数据报，不是将下一跳路由器的IP地址填入IP数据报，而是送交下层的网络接口软件。 网络接口软件使用ARP复杂将下一跳路由器的IP地址转换成硬件地址，并将此硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。 分组转发算法 （1）从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。 （2）若网络地址N与此路由器直接相连，则把数据报直接交付目的主机D;否则间接交付，执行(3)。 （3）若路由表中有目的地址为$D$的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。 （4）若路由表中有到达网路N的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。 （5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。 （6）报告转发分组出错。 4.3 划分子网和构造超网4.3.1 划分子网1. 从两级IP地址到三级IP地址 在 ARPANET 的早期，IP 地址的设计确实不够合理。 IP 地址空间的利用率有时很低。 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 两级的 IP 地址不够灵活 三级iP地址： 从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。 这种做法叫作划分子网(subnetting) 。划分子网已成为因特网的正式标准协议 基本思路 IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;} 划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。 凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。 然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。 最后就将 IP 数据报直接交付目的主机。 灯谜： 天鹅飞去鸟不归良字无头双人配受字中间多两笔人尔结合是自己]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格理论与密码学--格的定义与相关性质（三）]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6--%E6%A0%BC%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[格中计算性难题 3.2 格中的计算性难题与格相关的基本计算性难题有： 在格中寻找最短的非零向量（最短向量问题SVP） 在格中寻找与指定非格向量最为接近的向量（最近向量问题CVP） 首先介绍两个最基本的格难题： 最短向量问题(SVP): 在格$L$中寻找一个最短的非零向量，基寻找一个非零向量$v \in L$，使它的欧几里得范数$||v||$最小。 最近向量问题(CVP): 给定一个不在格$L$中的向量$w \in R^m$，寻找一个向量$v \in L$，使它最接近$w$，即寻找一个向量$v \in L$，使欧几里得范数$||w-v||$最小。 注意： 在格中可能存在不止一个最短的非零向量。例如，在$Z^2$中，$(0,\pm1)$和$(\pm,0)$这四个向量都是SVP解。这种情形适用于CVP。 CVP和SVP这一类问题都属于非常深奥的难题。随着格的维度$n$的增加，它们在计算上也越来越难解。另外，即使是对SVP和CVP的近似解，在理论和应用数学的诸多领域都有着惊人的应用。一般来说，CVP被认为是NP难问题，SVP在特定的“随机规约假设”下也被认为是NP难问题。 在实际应用中，用到了一些很重要的SVP和CVP的变形形式，如下： 最短基问题(SBP)：寻找格的一个基$v_1,v_2,\dots,v_n$，使它 在某些情况下最短。例如，可能需要使下式最小： $max_{i \leq i \leq n}||v_i||$ 或 $\sum_{i=1}^n||v_i||^2$ 因此，可能有许多版本的SBP，这取决于如何定义基的“大小”。 近似最短向量问题(apprSVP)：设$\Psi (n)$是$n$的一个函数。在$n$维格$L$中，寻找一个非零向量，使其不大于最短非零向量的$\Psi (n)$倍。即，如果$v_{最短}$是$L$的最短非零向量，那么寻找一个非零向量$v \in L$，使其满足： $||v|| \leq \Psi (n) ||v_{最短}||$ 不同的函数$\Psi(n)$可以形成不同版本的apprSVP。比如，如要求设计一个算法，用于寻找非零的向量$v \in L$，满足： $||v|| \leq 3 \sqrt{n}||v_{最短}||$ 或 $||v|| \leq 2^{n/2}||v_{最短}||$ 很明显，前者的算法比后者要强，但如果格的维度不大，即使对后者的解也可能是非常有用的。 近似最近向量问题(apprCVP)。这和apprSVP类似，只不过要找的是对CVP的近似解。]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格理论与密码学--格基约减算法与实现（四）]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6--%E6%A0%BC%E5%9F%BA%E7%BA%A6%E5%87%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二维格中的高斯约减算法，以及著名的LLL算法，该算法能够解决某些维数较低的格中的SVP问题和CVP问题。三随着格维数的增高，该算法的运行效果也随之减弱，以至于对高维度的格来说，即使LLL算法，也无法很好地解决SVP和CVP问题。所以大多数基于格理论的密码系统的安全性，都依赖于LLL算法以及其他格基约减算法能否高效解决apprSVP和apprCVP问题的困难性。 4.1 二维格中的高斯格基约减算法高斯提出了如何在二维格中找出一组优质基的算法，这个算法的根本思想是：从一个基向量中交替减去另一个基向量的倍数，直到再没有更好的改进为止。没有更好的改进，就是没事算法中的一个特定的条件要求。 给定一个二维格$L \subset R^2$，它的一组基向量为$v_1$和$v_2$，并假设$||v_1|| &lt; ||v_2||$。这个条件很容易实现，因为即使不能够直接满足上述条件，只需要将$v_2$和$v_2$交换位置即可。然后通过从向量$v_2$中减去$v_1$的倍数来达到减少$v_2$的目的。若可以从$v_2$中减去$v_1$任意倍数，则可以利用如下式中的$v^{\ast}_2$来代替$v_2$: $v_2^{\ast} = v_2 - \frac{v_1 \cdot v_2}{||v1||^2} v_1$ 由上式可以看出，向量$v^{\ast}_2$和向量$v_1$是正交的，并且向量$v^{\ast}_2$就是$v_2$在$v_1$证据补上的投影，如下图： 但上述做法在实际中并不可行，因为通过上式计算出来的向量$v^{\ast}_2$很可能根本不在格$L$中。所以，在实际应用中只允许从向量$v_2$中减去$v_1$的整数倍。为了达到跟上式相近的结果，利用下式的向量来取代$v_2$: $v_2 - m v_1, m = \lceil \frac{v_1 \cdot v_2}{||v1||^2} \rceil$ 如果$v_2$仍旧比$v_1$长，那么算法结束；否则，交换向量$v_1$和$v_2$，然后重复上述过程。高斯证明了这个过程可以在有限步后结束，并且最终的基向量具有良好的正交性质。算法4.1对上述程序给出了严格的描述。 更准确地说，当这个算法终止的时候，向量$v_1$就是格$L$中最短的非零向量。因此算法4.1很好地解决了SVP问题。 例4.1 4.2 LLL格基约减算法及其衍生和变形4.2.1 LLL格基约减算法高斯格基约算法给出了一个在二维格中找到最短非零向量的有效方法。但是这个方法具有一定的局限性，因为随着格维数的增加，寻找最短向量也变得越来越困难。1982年，Lenstra、Lenstra和Lovasz提出了著名的LLL算法。该算法思想源于Lagrange、Gauss、Hermite、Korkine-Zolotareff等的二次型理论及Minkovski的数的几何理论。 给定格$L$的一组基$\lbrace v_1,\dots, v_n\rbrace$，然后对他进行约减。约减的主要目的是将这组任意给定的基转化为一组正交性较好的优质基，并使得这个优质基中的各个向量尽量短。即，首先要得到能够通过算法找到的最短向量，然后，找到比这个最短向量稍长一点的向量，依次类推，直到最后找到这组基中的最后一个向量为止。或者，要使得在这个优质基中的向量之间具有相当好的正交性，即两个向量的点乘$v_i \cdot v_j$尽可能地接近零。 根据Hadamard不等式能够得到： $delL = vol(F) \leq ||v_1||||v_2||\dots||v_n||$]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--函数(C++的编程模块)（七）]]></title>
    <url>%2F2018%2F10%2F04%2FC%2B%2B%20Primer%20Plus--%E5%87%BD%E6%95%B0(C%2B%2B%E7%9A%84%E5%8F%98%E6%88%90%E6%A8%A1%E5%9D%97)%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数 7.1 复习函数的基本知识使用C++函数，必须完成的工作： 提供函数定义 提供函数原型 调用函数 库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数。 7.1 定义函数可以将函数分成两类：没有返回值的函数和有返回值的函数。没有返回值的函数称为void函数，其通用格式如下： void functionName(parameterList) { statement return ; } 其中，parameterList指定了传递给函数的参数类型和数量。可选的返回语句标记了函数的结尾；否则函数将在右花括号处结束。void类型的函数，通常用来执行某种操作。比如，打印执行文字n次： void cheers(int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; &quot;cheers&quot; &lt;&lt; endl; } 参数列表int n 意味着调用函数cheers()时，应将一个int值作为参数传递给它。 有返回值的函数将生成一个值，并将它返回给调用函数。通用格式如下： typeName functionName(parameterList) { statement return value; } 有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量，也可以是表达式，只是其结果的类型必须为typeName类型或可以被转换为typeName（比如，如果声明的返回类型为double,而函数返回一个int表达式，则该int值被强制转换为double）。 C++对返回值的类型有一定的限制：不能是数组，但可以是其他任何类型—整型、浮点数、指针，甚至可以是结构和对象。虽然C++函数不能之间返回数组，但可以将数组作为结构或对象组成部分来返回。 函数如何返回值：函数通过将返回值复制到指定CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。 函数包含多条返回语句： int bigger (int a, int b) { if (a &gt; b) return a; else //else可以省略，程序意图未变 return b; } 7.1.2 函数原型和函数调用1.函数原型必要性原型描述了函数到编译器的接口，即，它将函数返回值的类型以及参数的类型和数量告诉编译器。比如，函数调用： double volume = cube(side); 首先，原型告诉编译器，cube()有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放在执行位置–可能是CPU寄存器，也可能是内存。然后，调用，调用函数将从这个位置取得这个返回值。由于原型指出了cube()的类型为double，因此编译器知道检索多少个自己以及如何解释它们。 编译器需要原型，难道它就不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高。编译器在搜索文件的剩余部分时，必须停止对mian()的编译。一个更严重的问题时，函数甚至可能并不在文件中。C++允许将一个程序放在多个文件中，单独编译这些文件，然后组合起来。这种情况下，编译器在编译mian()时，可能无权访问函数代码。 2. 原型的语法函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是：复制函数定义中的函数头，并添加分号。 double cube(double x); 然而，函数原型不要求提供变量名，有类型列表就足够了。 void cheers(int); 原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。 3. 原型的功能 编译器正确处理函数返回值； 编译器检查使用的参数数目是否正确； 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可以的话）。 cheers(cube(2)); 首先，cube()原型指定了一个doulbe类型参数，因此将2转换为2.0。接下来，cube()返回一个double值0.8，这个值被用作cheers()的参数。编译器再一次检查原型，并发现cheers()要求一个int参数，因此将返回值转换为整数8。 7.2 函数参数和按转传递C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其复制给一个新的变量。如下： double volume = cube(side); 其中，side是一个变量。cube()的函数头如下: double cube(double x); 被调用时，该函数将创建一个新的名为x的double变量，并将其初始化为5。这样，cube()执行的操作将不会影响main()中的数据，因此cube()使用的是side的副本，而不是原来的数据。 用于接收传递值得变量称为形参。传递给函数得值被称为实参。C++标准使用参数来表示实参，使用参量来表示形参，因此参数传递将参数赋给参量。 在函数中声明的变量(包括参数)是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存。这样的变量被称为局部变量。 7.2.1 多个参数函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可： n_chars(&apos;R&apos;, 25); 同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表： void n_chars(char c, int n) 该函数头指出了，函数n_chars()接收一个char参数和一个int参数。传递给函数的值被赋值给参数c和n。如果函数的两个参数的类型相同，必须分别指定每个参数的类型，而不能像声明常规变量那样，将声明组合在一起： void fifi(float a, float b) void fifi(float a, b) //非法的 和其他函数一样，只需添加分号就可以得到该函数的原型： void n_chars(char c, int n); 和一个参数一样，原型中的变量名不必与定义中的变量名相同，而且可以省略： void n_chars(char, int); 然而，提供变量名将使原型更容易理解，尤其是两个参数的类型相同时，这样，变量名可以提醒参量和参数之间的对应关系。 twoarg.cpp #include &lt;iostream&gt; using namespace std; void n_chars(char, int); int main() { int times; char ch; cout &lt;&lt; &quot;Enter a character: &quot;; cin &gt;&gt; ch; while (ch != &apos;q&apos;) { cout &lt;&lt; &quot;Enter an integer: &quot;; cin &gt;&gt; times; n_chars(ch, times); cout &lt;&lt; &quot;\nEnter another character or presss the q to quit: &quot;; cin &gt;&gt; ch; } cout &lt;&lt; &quot;The value of times is &quot; &lt;&lt; times &lt;&lt; &quot;.\n&quot;; return 0; } void n_chars(char c, int n) { while (n-- &gt; 0) cout &lt;&lt; c; } 结果 Enter a character: h Enter an integer: 10 hhhhhhhhhh Enter another character or presss the q to quit: q The value of times is 10. 程序中使用cin&gt;&gt;ch，而不使用cin.get(ch)或ch=cin.get()来读取一个字符，这样因为cin.get()函数读取所有的字符，包括空格和换行符，而cin&gt;&gt;跳过空格和换行符。当用户对程序提示做出响应时，必须在每行的最后按下Enter键，以生成换行符。cin&gt;&gt;ch方法可以轻松跳过这些换行符。 n的自减对main()中的times的值没有影响。 7.2.2 另一个接收两个参数的函数假设从51个数中选取6个，计算不同组合的数量。 totto.cpp #include &lt;iostream&gt; using namespace std; long double probability(unsigned numbers, unsigned picks); int main() { double total, choices; cout &lt;&lt; &quot;Enter the total nember of choices on the game card and the number of picks allowed: \n&quot;; while ((cin &gt;&gt; total &gt;&gt; choices) &amp;&amp; total &gt;= choices) { cout &lt;&lt; &quot;You have one chance in &quot;; cout &lt;&lt; probability(total, choices); cout &lt;&lt; &quot; of wining.\n&quot;; cout &lt;&lt; &quot;Next two numbers (q to quit): &quot;; } return 0; } long double probability(unsigned numbers, unsigned picks) { long double result = 1.0; long double n; unsigned p; for (n = numbers, p = picks; p &gt; 0; p--, n--) result *= n/p; return result; } 结果 Enter the total nember of choices on the game card and the number of picks allowed: 51 6 You have one chance in 1.80095e+07 of wining. Next two numbers (q to quit): 10 2 You have one chance in 45 of wining. Next two numbers (q to quit): q 7.3 函数和数组将一个数组名作为参数传递给函数，为使函数通用，而不限于特定长度的数组，还需要传递数组长度。将一个形参声明为数组名。函数头如下： int sum_arr(int arr[], int n) 方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。实际情况是：arr并不是数组，而是一个指针！在编写函数时，可以将arr看作时数组。 arrfun1.cpp #include &lt;iostream&gt; const int ArSize = 8; int sum_arr(int arr[], int n); using namespace std; int main() { int cookies[ArSize] = {1,2,4,8,16,32,64,128}; int sum = sum_arr(cookies, ArSize); cout &lt;&lt; &quot;Total: &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } int sum_arr(int arr[], int n) { int total = 0; for (int i = 0; i &lt; n; i++) total += arr[i]; return total; } 结果： Total: 255 7.3.1 函数如何使用指针来处理数组在前面介绍过，C++将数组名解释为起第一个元素的地址： cookies = &amp;cookies[0]; 该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度；第三，正如前面指出的，将地址运算符&amp;用于数组名时，将返回整个数组的地址，例如，&amp;cookes将返回一个32字节内存卡的地址。 int sum = sum_arr(cookies, ArSize); 其中，cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素为int，因此cookies的类型必须是int指针，即int*。正确的函数头为： int sum_arr(int *arr, int n) 其中用int * arr替换了int arr[]。这证明这两个函数头都是正确的。这种表示仅在函数头和函数原型中等价，不能在函数体中，使用int arr[]来声明指针。 下面两个等式等价： arr[i] = *(arr+i); &amp;arr[i] = arr + i; 7.3.2 将数组作为参数意味着什么arr_sum()函数将cookies的地址赋给指针变量arr,将ArSize赋给int变量n。这意味着并没将数组内容传递给函数，而是将数组的位置、包含的元素种类以及元素数目提交给函数 传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。实际上，这种区别并不违反C++按值传递的方法，sum()函数传递了一个值，这个值被赋给一个新变量，但这个值是一个地址，而不是数组的内容。 如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。 arrfun2.cpp #include &lt;iostream&gt; const int ArSize = 8; int sum_arr(int arr [], int n); using namespace std; int main() { int cookies[ArSize] = {1,2,4,8,16,32,64,128}; cout &lt;&lt; cookies &lt;&lt; &quot; = array address, &quot; &lt;&lt; sizeof(cookies) &lt;&lt; &quot; = sizeof cookies.\n&quot;; int sum = sum_arr(cookies, ArSize); cout &lt;&lt; &quot;Total cookies eaten: &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies, 3); cout &lt;&lt; &quot;First three eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies+4, 4); cout &lt;&lt; &quot;Last four eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } int sum_arr(int arr[],int n) { int total = 0; cout &lt;&lt; arr &lt;&lt; &quot; = arr, &quot;; cout &lt;&lt; sizeof(arr) &lt;&lt; &quot; = sizeof arr.\n&quot;; //实际得到的地址的长度 for (int i = 0; i &lt; n; i++) total += arr[i]; return total; } 结果 0x7ffff779f8b0 = array address, 32 = sizeof cookies. 0x7ffff779f8b0 = arr, 8 = sizeof arr. Total cookies eaten: 255 0x7ffff779f8b0 = arr, 8 = sizeof arr. First three eaters ate 7 0x7ffff779f8c0 = arr, 8 = sizeof arr. Last four eaters ate 240 注意，地址值和数组的长度随系统而异。 cookies和arr指向同一个地址，但sizeof(cookies)的值为32，而sizeof(arr)为8。这是由于sizeof(cookies)是整个数组的长度，而sizeof(arr)只是指针变量的长度。这是必须现实传递数组长度，而不能在sum_arr()中使用sizeof(arr)的原因；指针本身没有指出数组的长度。 注意： 将数组类型和元素数量告诉数组处理函数，不要试图使用方括号表示法来传递数组长度： void filarray(int arr[size]); //非法的 7.3 更多数组函数示例假设要使用一个数组记录房地产的价值。 1. 填充数组由于接收数组名参数的函数访问的是原始数组，而不是副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组的名称。第二个参数是数组的长度。由于用户输入的元素数目可能少于数组的长度，因此函数返回实际输入的元素数目。 停止循环的方法：使用一个特殊值来指出输入结束。由于所有的属性都不为负数，因此可以使用负数来指出输入结束。 2. 显示数组及使用const保护数组接受数组名的函数将使用原始数据，为防止函数无意中修改数组的内容，可在声明形参时使用关键字const。 void show_array(const double ar[], int n); 该声明表明，指针ar指向的是常量数组。这意味着不能使用ar修改该数据。 3. 修改数组具体见代码 4. 组合arrfun3.cpp #include &lt;iostream&gt; const int Max = 5; int fill_array(double ar[], int n); void show_array(const double ar[], int n); void revalue(double r, double ar[], int n); using namespace std; int main() { double properties[Max]; int size = fill_array(properties,Max); show_array(properties, size); if (size &gt; 0) { cout &lt;&lt; &quot;Enter revaluation factor: &quot;; double factor; while (!(cin &gt;&gt; factor)) { cin.clear(); while (cin.get() != &apos;\n&apos;) continue; cout &lt;&lt; &quot;Bad input; Please enter a number: &quot;; } revalue(factor, properties, size); show_array(properties, size); } return 0; } int fill_array(double ar[], int n) { double temp; int i; for (i = 0; i &lt; n; i++) { cout &lt;&lt; &quot;Enter values #&quot;&lt;&lt; i+1 &lt;&lt; &quot; : &quot; ; cin &gt;&gt; temp; if (!cin) { cin.clear(); while (cin.get() != &apos;\n&apos; ) //读取输入队列中的所有内容 continue; cout &lt;&lt; &quot;Bad input; input process terminated.\n&quot;; break; } else if (temp &lt; 0) break; ar[i] = temp; } return i; } void show_array(const double ar[], int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; &quot;Property #&quot; &lt;&lt; i+1 &lt;&lt; &quot;: $ &quot; &lt;&lt; ar[i] &lt;&lt; endl; } void revalue(double r, double ar[], int n) { for (int i = 0; i &lt; n; i++) ar[i] *= r; } 结果： Enter values #1 : 30000 Enter values #2 : 20000 Enter values #3 : 10000 Enter values #4 : -3 Property #1: $ 30000 Property #2: $ 20000 Property #3: $ 10000 Enter revaluation factor: 0.8 Property #1: $ 24000 Property #2: $ 16000 Property #3: $ 8000 [root@localhost ~]# ./a.out Enter values #1 : oo Bad input; input process terminated. 5. 数组处理函数的常用编写方式如果函数修改数组，其原型可能如下： void f_modify(double ar[], int n); 如果函数不修改数组，其原型可能如下： void f_no_change(const double ar[], int n); 7.3.4 使用数组区间的函数前面，对于处理数组的C++函数，必须将数组中的数据类型、数组的起始位置和数组中元素的数量提交给它。 还有一种给函数提供所需信息的方法，即指定元素区间，这块车通过传递两个指针来完成；一个指针表示数组的开头，另一个指针表示数组的尾部。 double elbuod[20]; 则指针elbuod和elbuod+20定义了区间。首先，数组名elbuod指向第一个元素。表达式elbuod+19指向最后一个元素，因此elbuod+20指向数组结尾后的一个位置。 arrfun4.cpp #include &lt;iostream&gt; const int ArSize = 8; int sum_arr(int * begin, int * end); using namespace std; int main() { int cookies[ArSize] = {1,2,4,8,16,32,64,128}; cout &lt;&lt; cookies &lt;&lt; &quot; = array address, &quot; &lt;&lt; sizeof(cookies) &lt;&lt; &quot; = sizeof cookies.\n&quot;; int sum = sum_arr(cookies, cookies+ArSize); cout &lt;&lt; &quot;Total cookies eaten: &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies, cookies+3); cout &lt;&lt; &quot;First three eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; sum = sum_arr(cookies+4, cookies+8); cout &lt;&lt; &quot;Last four eaters ate &quot; &lt;&lt; sum &lt;&lt; endl; return 0; } int sum_arr(int * begin, int * end) { const int * pt; int total = 0; for (pt = begin; pt != end; pt++) total += *pt; return total; } 结果 Total cookies eaten: 255 First three eaters ate 7 Last four eaters ate 240 程序中，将pt设置为指向第一个元素的指针，并将*pt加入到total扎。然后，循环通过递增操作来更新pt，使之指向下一个元素。 7.3.5 指针和const可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值；第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。 1. const int *int age = 39; const int * pt = &amp;age; 该声明指出，pt指向一个const int，因此不能使用pt来修改这个值。即，*pt的值为const，不能被修改： *pt += 1; //非法 cin &gt;&gt; *pt; //非法 一个微妙的问题，pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。比如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，但是不能使用pt指针来修改它： *pt = 20; //非法 age = 20; //合理 还有两种可能：第一种，将const变量的地址赋给指向const的指针；第二种，将const的地址赋给常规指针。第一种可行，第二种不可行： cont float g_earth = 9.80; cont float * pe = &amp;g_earth; //合理 const float g_moon = 1.63; float *pm = &amp;g_moon; //非法 对于第一种情况，既不能修改g_earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因：如果将g_moon的地址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const状态很荒诞。 如果将指针指向指针，则情况更复杂。假如涉及的是一级间接关系，则将非const指针赋给const指针是可以的： int age = 39; int *pd = &amp;age; const int * pt = pd; 然而，进入两级间接关系时，与一级间接关系一样，将const和非const混合的指针赋值方式将不再安全。如果允许这样做，则可以编写这样的代码： const int **pp2; int *p1; const int n = 13; pp2 = &amp;p1; //非法，但是假设其成立 *pp2 = &amp;n; //合理 *p1 = 10; //合理 上述代码将非const地址(&amp;p1)赋给了指向const指针(pp2)，因此可以使用p1来修改const数据。因此，仅当只有一层间接关系时，才可以将非const地址或指针赋给const指针。 假设一个由const数据组成的数组： const int monthes[5] = {31, 28, 31, 30, 31}; 则禁止将常量数组的地址赋给非常量指针，这意味着不能将数组名作为参数传递给非常量形参的函数： int sum(int arr[], int n); // 应该写为： const int arr[] int j = sum(months, 12); //不被允许 上述函数调用试图将const指针赋给非const指针，编译器将禁止这种函数调用。 另一个微妙之处，声明： int age = 39; const int * pt = &amp;age; 第二个声明种的const只能防止修改pt指向的值，但不能修改pt的值，即可以将一个新地址赋给pt: int sage = 40; pt = &amp;sage; 但仍然不能使用pt来修改它指向的值。 2. int * const使用const的方式使得无法修改指针的值： int sloth = 3; const int *ps = &amp;sloth; int * const finger = &amp;sloth; 最后一个声明，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但可以将ps指向另一位置。即，finger和$\ast$p都是const，而$\ast$finger和ps不是。 如果愿意还可以声明指向const对象的const指针： double trouble = 2.0E30; const double * const stick = &amp;trouble; 其中，stick只能指向troulbe，而stick不能用来修改trouble的值。即const和$\ast$const都是const。 7.4 函数和二维数组为编写将二维数组作为参数的函数，必须牢记，数组名被视为其地址，因此响应的形参是一个指针。比如： int data[2][4] = {{1,2,3，4},{4,5,6，7}}; int total = sum(data, 3); data是一个数组名，该数组有2个元素。第一个元素本身就是一个数组，有4个int值组成。因此data的类型是指向由4个int组成的数组的指针，正确的原型如下： int sum(int (*ar2)[4], int size); 其中的括号是必不可少的，因为下面声明将声明一个由4个指向int的指针组成的数组，而不是由一个指向由4个int组成的数组的指针；林伟函数不能是数组： int *ar2[4]; //4个指针指针组成的数组 还有另一个种格式，这种格式与上述原型的含义完全相同，但可读性更强: int sum(int ar2[][4], int size); 上述两个原型都指出，ar2是指针而不是数组。指针类型指出，它指向由4个int组成的数组。因此，指针类型指定了列数。 由于指针类型指定了列数，因此sum()函数只能接受由4列组成的数组。但长度变量指定了行数，因此sum()对数组的行数没有限制： int a[100][4]; int b[60][4]; int total1 = sum(a, 100); int total2 = sum(b, 60); 对于参数ar2是指向数组的指针，在函数定义中使用它，最简单的办法是将ar2看作一个二维数组的名称。 同样行数被传递给size参数，当无论是参数ar2的声明或是内部for循环中，列数都是固定的–4列。 ar2[r]是编号为r的元素，由于该元素本身就是一个由4个int组成的数组，因此ar2[r]是由4个int组成的数组的名称。将下标用于数组名将得到一个数组元素，因此ar2[r][c]是由4个int组成的数组中的一个元素，是一个int值。必须对指针ar2执行两次解除引用，才能得到数据。也可以使用运算符*两次： ar2[r][c] = *(*(ar2+r)+c) 7.5 函数和C-风格字符串C-风格自身串由一系列字符组成，以空值字符结尾。 7.5.1 将C-风格字符串作为参数的函数假设要将字符串作为参数传递给函数，则表示字符串的方式有三种： char数组 用引号括起来的字符串常量（字符串字面值） 被设置为字符串的地址的char指针 但上述3中选择的类型都是char指针（准确地说是char$\ast$），因此可以将其作为字符串处理函数的参数： char ghost[15] = &quot;galloping&quot;; char * str = &quot;galumphing&quot;; int n1 = strlen(ghone); int n2 = shrlen(str); 可以说，将字符串作为参数来传递，但实际上传递的是字符串第一个字符的地址。这意味着字符串函数原型将其表示字符串的形参声明为char$\ast$类型。 C-风格字符串与常规数组之间的重要区别是：字符串有内置的结束字符（不以空值字符结尾的char数组只是数组，而不是字符串）。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空字符为止。 strfun.cpp #include &lt;iostream&gt; unsigned int c_in_str(const char * str, char ch); using namespace std; int main() { char mmm[15] = &quot;minimum&quot;; const char *wail = &quot;ululate&quot;; unsigned int ms = c_in_str(mmm, &apos;m&apos;); unsigned int us = c_in_str(wail, &apos;u&apos;); cout &lt;&lt; ms &lt;&lt; &quot; m characters in &quot; &lt;&lt; mmm &lt;&lt; endl; cout &lt;&lt; us &lt;&lt; &quot; u characters in &quot; &lt;&lt; wail &lt;&lt; endl; return 0; } unsigned int c_in_str(const char * str, char ch) { unsigned int count = 0; while(*str) { if (*str == ch) count ++; str++; } return count; } 结果： 3 m characters in minimum 2 u characters in ululate 为了防止c_in_str()函数修改原始字符串，因此在函数声明形参str时使用了限定符const。 str最初指向字符串的第一个字符，因此*str表示的第一个字符。 7.5.2 返回C-风格字符串的函数strgback.cpp #include &lt;iostream&gt; char * buildstr(char c, int n); using namespace std; int main() { int times; char ch; cout &lt;&lt; &quot;Enter a character: &quot;; cin &gt;&gt; ch; cout &lt;&lt; &quot;Enter a integer: &quot;; cin &gt;&gt; times; char * ps = buildstr(ch, times); cout &lt;&lt; ps &lt;&lt; endl; delete [] ps; ps = buildstr(&apos;+&apos;, 20); cout &lt;&lt; ps &lt;&lt; &quot;-DONE-&quot; &lt;&lt; ps &lt;&lt; endl; delete [] ps; return 0; } char * buildstr(char c, int n) { char * pstr = new char [n+1]; pstr[n] = &apos;\0&apos;; while(n--) pstr[n] = c; return pstr; } 结果： Enter a character: V Enter a integer: 46 VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV ++++++++++++++++++++-DONE-++++++++++++++++++++ 要创建包含n个字符的字符串，需要能够存储n+1个字符的空间，以便能够存储空值字符。程序中请求分配了n+1个字节的内存来存储字符串，并将最后一个字节设置为空值字符。 n–表示先在测试条件中比较，然后将其值递减。因此，当n=20时，首先20大于0，然后将其值递减1，于是循环体里面的n=19。 注意pstr的作用为buildstr函数内，因此该函数结束时，pstr使用的内存将被释放。但由于函数返回了pstr的值，因此程序仍可以通过main()中的指针ps来访问新建的字符串。当该字符串不再需要时，使用delete释放该字符串所占用的内存。 7.6 函数和结构使用结构编程时，最直接的方式就像处理基本类型那样来处理结构；即将结构作为参数传递，并在需要时将结构用作返回值使用。在这种情况下，函数将使用原始结构的副本，与处理数组不同。如果结构非常大，则复制结构将增大内存要求，降低系统运行速度。出于这些愿意，许多C程序倾向于传递结构的地址，然后使用指针来访问结构的内容。C++提供了第三种选择—按引用传递（下一章介绍）。 7.6.1 传递和返回结构当结构比较小时，按值传递结构最合理。第一个例子处理行程时间，比如从Falls到Bingo需要3小时50分钟，而Bingo到Gotesquo需要1小时25分钟。对于这种时间，可以使用结构表示–一个成员表示小时值，另一个成员表示分钟值。将两个时间加起来需要一些技巧，因为可能需要将分钟值转换为小时。具体如下： travel.cpp #include &lt;iostream&gt; using namespace std; struct travel_time { int hours; int mins; }; const int Mins_per_hr = 60; travel_time sum(travel_time t1, travel_time t2); void show_time(travel_time t); int main() { travel_time day1 = {5, 45}; travel_time day2 = {4, 55}; travel_time trip = sum(day1, day2); cout &lt;&lt; &quot;Two-day total: &quot;; show_time(trip); return 0; } travel_time sum(travel_time t1, travel_time t2) { travel_time total; total.mins = (t1.mins + t2.mins) % Mins_per_hr; total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr; return total; } void show_time(travel_time t) { cout &lt;&lt; t.hours &lt;&lt; &quot; hours, &quot; &lt;&lt; t.mins &lt;&lt; &quot; mins.\n&quot;; } 结果 Two-day total: 10 hours, 40 mins. 其中，travel_time就像一个标准类型名，可被用来声明变量、函数的返回类型和函数参数类型。 7.6.2 另一个处理结构的函数示例表示二维坐标中的一个点的方法有两种：一种是指出该点相对远点的水平偏移和垂直便宜（x-y）；另一个种是指出它偏离远点的距离和方向（极坐标）。实现表示两种表示方法，以及之间的相互转换，如下程序： atrctfun.cpp #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; struct rect { double x; double y; }; struct polar { double distance; double angle; }; polar rect_to_polar(rect xypos); void show_polar(polar dapos); int main() { rect rplace; polar pplace; cout &lt;&lt; &quot;Enter the x and y value: &quot;; while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) { pplace = rect_to_polar(rplace); show_polar(pplace); cout &lt;&lt; &quot;Nest two number(q to quit): &quot;; } return 0; } polar rect_to_polar(rect xypos) { polar answer; answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y); answer.angle = atan2(xypos.y, xypos.x); return answer; } void show_polar(polar dapos) { const double Rad_to_deg = 57.29577951; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; dapos.distance; cout &lt;&lt; &quot;, Angle = &quot; &lt;&lt; dapos.angle * Rad_to_deg &lt;&lt; &quot; degrees.\n&quot;; } 结果 Enter the x and y value: 30 40 Distance = 50, Angle = 53.1301 degrees. Nest two number(q to quit): -100 100 Distance = 141.421, Angle = 135 degrees. Nest two number(q to quit): q 7.6.3 传递结构的地址需要修改的滴很： 调用函数时，将结构的地址(&amp;pplace)而不是结构本身(pplace)传递给它； 将形参声明为指向polar的指针，即polar$\ast$类型，由于函数不应该修改结构，因此使用了const修饰符； 由于形参是指针而不是结构，因此应使用间接成员运算符(-&gt;)，而不是成员运算符（句点）。 strctptr.cpp #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; struct rect { double x; double y; }; struct polar { double distance; double angle; }; void rect_to_polar(const rect *xypos, polar *dapos); void show_polar(const polar *dapos); int main() { rect rplace; polar pplace; cout &lt;&lt; &quot;Enter the x and y value: &quot;; while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) { rect_to_polar(&amp;rplace, &amp;pplace); show_polar(&amp;pplace); cout &lt;&lt; &quot;Nest two number(q to quit): &quot;; } return 0; } void rect_to_polar(const rect *xypos, polar *dapos) { dapos-&gt;distance = sqrt(xypos-&gt;x * xypos-&gt;x + xypos-&gt;y * xypos-&gt;y); dapos-&gt;angle = atan2(xypos-&gt;y, xypos-&gt;x); } void show_polar(const polar *dapos) { const double Rad_to_deg = 57.29577951; cout &lt;&lt; &quot;Distance = &quot; &lt;&lt; dapos-&gt;distance; cout &lt;&lt; &quot;, Angle = &quot; &lt;&lt; dapos-&gt;angle * Rad_to_deg &lt;&lt; &quot; degrees.\n&quot;; } 结果同上 遇到的问题(待解决)在编写时，发现如果开始将结构初始为结构指针，如下： rect *rplace; polar *pplace; 而这样在输入x,y的之后出现段错误(吐核)。根据网上教程，在./a.out之前，加上strace，即 strace ./a.out，看不懂到底是什么原因。而使用上述程序种的方式不会有问题。 7.7 函数核string对象虽然C-风格字符串和string对象的用途几乎相同，但与数组相比，string对象与结构的更相似。例如：可以将一个结构赋给另一个结构，也可以将一个对象赋给另一个对象。可以将结构作为完整的实体传给函数，也可以将对象作为完整的实体进行传递。如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。 topfive.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; const int SIZE = 5; void display(const string sa[], int n); int main() { string list[SIZE]; cout &lt;&lt; &quot;Enter your &quot; &lt;&lt; SIZE &lt;&lt; &quot; favorite astronomicla sights: \n&quot;; for (int i = 0; i &lt; SIZE; i++) { cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; getline(cin, list[i]); } cout &lt;&lt; &quot;Your list: \n&quot;; display(list, SIZE); return 0; } void display(const string sa[], int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; i + 1&lt;&lt; &quot;: &quot; &lt;&lt; sa[i] &lt;&lt; endl; } 结果 Enter your 5 favorite astronomicla sights: 1: Mon 2: Jupiter 3: Saturn 4: M13 5: Orion Nebula Your list: 1: Mon 2: Jupiter 3: Saturn 4: M13 5: Orion Nebula 7.8 函数和array对象假设要使用一个array对象来存储一年四个季度的开支： std::array&lt;double, 4&gt; expenses; 要使用array类，需要包含头文件array，而名称array位于名称空间std中。如果函数来显示expenses的内容，可按值传递expenses: show(expenses); 但如果函数要修改对象expenses，则需将对象的地址传给函数： fill(&amp;expenses); 声明上述两个函数为array&lt;double, 4&gt;，因此必须在函数原型中指定这种类型： void show(std::array&lt;double, 4&gt; da); void fill(std::array&lt;doulbe, 4&gt; * pa); 首先，使用符号常量替换4： const int Seasons = 4; 使用一个const array对象，该对象包含4个string对象，用于表示几个季度： const std::array&lt;std::string, Season&gt; Sname = {&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;}; arrobj.cpp #include &lt;iostream&gt; #include &lt;array&gt; #include &lt;string&gt; using namespace std; const int Seasons = 4; const array&lt;string, Seasons&gt; Sname = {&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;}; void fill(array&lt;double, Seasons&gt; * pa); void show(array&lt;double, Seasons&gt; da); int main() { array&lt;double, Seasons&gt; expenses; fill(&amp;expenses); show(expenses); return 0; } void fill(array&lt;double, Seasons&gt; *pa) { for (int i = 0; i&lt; Seasons; i++) { cout &lt;&lt; &quot;Enter &quot; &lt;&lt; Sname[i] &lt;&lt; &quot; expenses: &quot;; cin &gt;&gt; (*pa)[i]; } } void show(array&lt;double, Seasons&gt; da) { double total = 0.0; cout &lt;&lt; &quot;EXPENSES\n&quot;; for (int i = 0; i &lt; Seasons; i++) { cout &lt;&lt; Sname[i] &lt;&lt; &quot;: $&quot; &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; } cout &lt;&lt; &quot;Total expenses: $&quot; &lt;&lt; total &lt;&lt; endl; } 结果 Enter Spring expenses: 1000 Enter Summer expenses: 2000 Enter Fall expenses: 2000 Enter Winter expenses: 4000 EXPENSES Spring: $1000 Summer: $2000 Fall: $2000 Winter: $4000 Total expenses: $9000 注意，String是C++11中的内容，在使用Linux编译时，需要告诉编译器使用C++11的编译器，如下： g++ -std = c++ arrobj.cpp 因为在代码最前面添加了编译指令using，因此可以不适用std::来限定array和string。 7.9 递归C++函数有一种有趣的特点–可以自己调用自己，这种功能被称为递归。 7.9.1 包好一个递归调用的递归如果递归函数调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容。通常的方法将递归调用放在if语句中。如下： void recurs(argumentlist) { statements1 if (test) recurs(arguments) statements2 } test为false，调用链断开。只要if语句为true，每个recurs()调用都将执行statements1，然后再调用recurs()，而不会执行statements2。当if语句为false时，当前调用执行statements2。当前调用结束后，程序控制权将返回给调用它的recurs()，而该recurs()将执行其statements2部分，然后结束，并将控制权返回给前一个调用，依次类推。因此，如果recurs()进行了5次递归调用，则第一个statements1部分将按函数调用的顺序执行5次，然后，statements部分将以与函数调用相反的顺序执行5次。进入5层递归后，程序将沿进入的路径返回。 recur.cpp #include &lt;iostream&gt; void countdown(int n); using namespace std; int main() { countdown(4); return 0; } void countdown(int n) { cout &lt;&lt; &quot;Count down ... &quot; &lt;&lt; n &lt;&lt; endl; if (n &gt; 0) countdown(n-1); cout &lt;&lt; n &lt;&lt; &quot;: Kaboom!\n&quot;; } 结果 Count down ... 4 Count down ... 3 Count down ... 2 Count down ... 1 Count down ... 0 0: Kaboom! 1: Kaboom! 2: Kaboom! 3: Kaboom! 4: Kaboom! 注意，每个递归调用都创建自己的一套变量，因此当程序达到第5次调用时，将有5个独立的变量n，其中每个变量的值都不同。为了验证这一点，使之显示n的地址和值： cout &lt;&lt; &quot;Count down ... &quot; &lt;&lt; n &lt;&lt; &quot;(n at&quot; &lt;&lt; &amp;n &lt;&lt; &quot; )&quot; &lt;&lt; endl; if (n &gt; 0) countdown(n-1); cout &lt;&lt; n &lt;&lt; &quot;: Kaboom!&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;(n at&quot; &lt;&lt; &amp;n &lt;&lt; &quot; )&quot; &lt;&lt; endl; 程序输出结果为： Count down ... 4(n at0x7ffc9be6862c ) Count down ... 3(n at0x7ffc9be685fc ) Count down ... 2(n at0x7ffc9be685cc ) Count down ... 1(n at0x7ffc9be6859c ) Count down ... 0(n at0x7ffc9be6856c ) 0: Kaboom! (n at0x7ffc9be6856c ) 1: Kaboom! (n at0x7ffc9be6859c ) 2: Kaboom! (n at0x7ffc9be685cc ) 3: Kaboom! (n at0x7ffc9be685fc ) 4: Kaboom! (n at0x7ffc9be6862c ) 7.9.2 包含多个递归调用的递归在需要将一定工作不断分为两项较小的、类似的工作时，递归非常有用。例如：考虑使用这种方法来绘制绘制标尺的情况。标出两端，找到重点并将其标出。然后，将同样的操作用于标尺的左半部分和右半部分。如果要进一步细分，同将同样的操作用于当前的每一部分。递归方法有时被称为分而治之策略。 下面程序使用subdivide()演示了这种方法，该函数使用一个字符串，该字符串处两端为|字符为，其他都为空格。main函数使用循环调用subdivide()函数6次，每次见递归层编号加1，并打印得到的字符。这样，每行输出表示一层递归。 ruler.cpp #include &lt;iostream&gt; const int len = 66; const int Divs = 6; void subdivide(char ar [], int low, int hight, int level); using namespace std; int main() { char ruler[len]; int i ; for (i = 1; i &lt; len - 2; i++) ruler[i] = &apos; &apos;; ruler[len-1] = &apos;\0&apos;; int max = len - 2; int min = 0; ruler[min] = ruler[max] = &apos;|&apos;; cout &lt;&lt; ruler &lt;&lt; endl; for (i = 1; i &lt;= Divs; i++) { subdivide(ruler, min, max, i); cout &lt;&lt; ruler &lt;&lt; endl; for (int j = 1; j &lt; len -2; j++) ruler[j] = &apos; &apos;; } return 0; } void subdivide(char ar[], int low, int high, int level) { if (level == 0) return ; int mid = (high + low) / 2; ar[mid] = &apos;|&apos;; subdivide(ar, low, mid, level-1); subdivide(ar, mid, high, level-1); } 结果 | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| subdivide()使用变量level来控制递归层。函数调用自身时，将把level减1，当level为0时，该函数将不再调用自己。注意，subdivide()调用自己两次，一次针对左半部分，另一个针对右半部分。最初的中点被用作一次调用的右端点和另一次调用的左端点。调用次数从指数级增长。如果要求的递归层次很多，这种递归方式将是一种糟糕的选择；然而对于递归层次较少，这将是一种精致而简单的选择。 7.10 函数指针与数据项类似，函数也有地址。函数的地址是存储器机器语言代码的内存的地址。通常，这些地址对于用户而言，既不重要，也没有什么用处，但对程序而言，却很重要。可以编写将另一个函数第地址作为参数的函数。这样第一个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同的函数的地址，这意味着可以在不同的时间使用不同的函数。 7.10.1 函数指针的基础知识通过一个例子来阐述这一过程。假设要设计一个名为estimate()函数，估算编写执行函数的代码所需的时间，并且希望不同的程序员都可以使用这个函数。对于所有用户来说，estimate()中一部分代码都是相同的，但该函数允许每个程序员提供自己的算法来估算时间。为实现这个目标，采用的机制是，将程序员使用的算法函数的地址传给estimate()。为此，必须完成如下工作： 获取函数地址 声明一个函数指针 使用函数指针来调用函数 1.获取函数地址获取函数的地址很简单：只要使用函数名(后面不跟参数)即可。即，如果think()是一个函数，则think就是该函数的地址。 要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值： process(think); process(think());//传递的是函数的返回值 2.声明函数指针声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指出函数的返回类型以及函数的特征标(参数列表)。即声明应像函数原型一样指出函数信息。一个函数原型如下： double pam(int); 则正确的指针类型声明如下： double (*pf) (int); 这与pam()声明类似，这是将pam替换为了($\ast$pf)。由于pam是函数，因此($\ast$pf)也是函数。而如果($\ast$pf)是函数，则pf就是函数指针。 括号的优先级比$\ast$的运算符高，因此$\ast$pf(int)意味着pf()是一个返回指针的函数，而($\ast$pf)(int)意味着pf是一个指向函数的指针： double (*pf)(int); double * pf (int); //一个返回指针的函数pf() 正确声明pf后，便可以将相应函数的地址赋给它： pf = pam; 现在，给出estimate()函数的原型： void estimate(int lines, double (*pf)(int)); 使用estiemate()如下： estimate(50, pam); pam为函数pam()的指针。 3.使用指针来调用函数使用指针来调用被指向的函数。($\ast$pf)扮演的角色与函数名相同，因此使用($\ast$pf)时，只需将它看作函数名： double pam(int); double (*pf) (int); double x = pam(3); double y = (*pf)(3); 实际上，C++也允许像使用函数名一样使用pf: double y = pf(3); 7.10.2 函数指针示例下面的程序，两次调用estimate()函数，一次传递betsy()函数的地址，另一次则传递pam()函数地址。 fun_ptr.cpp #include &lt;iostream&gt; double betsy(int); double pam(int); using namespace std; void estimate(int lines, double (*pf)(int)); int main() { int code; cout &lt;&lt; &quot;How many lines of code do you need? &quot;; cin &gt;&gt; code; cout &lt;&lt; &quot;Here&apos;s Betsy&apos;s estimate:\n&quot;; estimate(code, betsy); cout &lt;&lt; &quot;Here&apos;s Pam&apos;s estimate:\n&quot;; estimate(code, pam); return 0; } double betsy(int lns) { return 0.05 * lns; } double pam(int lns) { return 0.03 * lns + 0.0004 * lns * lns; } void estimate(int lines, double (*pf)(int)) { cout &lt;&lt; lines &lt;&lt; &quot; lines will take &quot;; cout &lt;&lt; (*pf)(lines) &lt;&lt; &quot; hour(s)\n&quot;; } 结果 How many lines of code do you need? 30 Here&apos;s Betsy&apos;s estimate: 30 lines will take 1.5 hour(s) Here&apos;s Pam&apos;s estimate: 30 lines will take 1.26 hour(s) 7.10.3 深入探讨函数指针下面一些函数的原型，它们的特征标（参数列表）和返回类型相同： const double * f1(const double ar[], int n); const double * f2(const double [], int); const double * f3(const double *, int); 这些函数特征标看似不同，但实际上相同。前面说过，在函数原型中，参数列表const double ar[]与const double $\ast$ar的含义相同。其次，在函数原型中，可以省略标识符（参数名）。因此，const double ar[]可简化为const double []，而const double $\ast$ar可简化为const double $\ast$。因此，上述的函数特征标的含义都相同。另一方面，函数定义必须通过标识符，因此需要使用const double $\ast$ar或const double ar[]。 接下来，声明一个指针，它可指向这三个函数之一。假设该指针名为pa，则只需要将目标函数原型中的函数名替换为($\ast$pa): const double * (*pa)(cosnt double * , int); 可在声明的同时初始化： const double * (*pa)(cosnt double * , int) = f1; 使用C++的自动类型推断功能时，代码要简单得多： auto p2 = f2; 将于使用三个函数，如果有一个函数指针数组将很方便。这种声明声明类似于单个函数指针的声明，但必须在某个地方加上[3]，以指出一个包含三个函数指针的数组： const double * (*pa[3])(const double *, int) = {f1, f2, f3}; pa是一个包含三个元素的数组，而要声明这样的数组，首先需要使用pa[3]。该声明的其他部分指出了数组包含的元素是什么样的。运算符[]的优先级高于$\ast$，因此$\ast$pa[3]表明pa是一个包含三个指针的数组。在此不能使用auto，自动类型推断只能用于单值初始化，而不能用于初始化列表。但是声明数组pa后，声明同样类型的数组就简单了： auto pb = pa; 使用它们来调用函数：pa[i]和pb[i]表示数组中的指针，因此可将任何一种函数调用表示法用于它们： const double * px = pa[0](av,3); const double * py = (*pb[1])(av,3); 获取指向的double值，可使用运算符$\ast$: double x = *pa[0](av,3); double y = *(*pb[1])(av,3); 可做的另一件事是创建指向整个数组的指针。由于数组名pa是指向函数指针的指针，因此指向数组的指针将是这样的指针，即它指向数组指针的指针。由于可使用单个值对其进行初始化，因此可以使用auto: auto pc = &amp;pa; 如果指针名为pd，则需要指出它是一个指针，而不是数组。这意味着声明的核心部分应为($\ast$pd)[3]，其中的括号让标识符pd与$*$先结合： *pd[3]// 一个数组有三个指针 (*pd)[3] //一个指针指向三个元素 即pd是一个指针，它指向一个包含三个元素的数组。由pa的声明的其他部分描述，如果如下： const double *(*(*pd)[3])(const double *, int) = &amp;pa; 要调用函数，需要认识：pd指向数组，$\ast$pd就是数组，而($*$pd)[i]是数组中的元素，即函数指针。因此，较简单的函数调用是($\ast$pd)i，而$\ast$($\ast$pd)i是返回的指针所指向的值。也可以使用第二种使用指针调用函数语法：使用($\ast$($\ast$pd[i]))(av,3)，而$\ast$($\ast$($\ast$pd))i是指向的double值。 pa和&amp;的区别：pa都是数组第一个元素的地址，即&amp;pa[0]，因此，它是单个指针的地址。但&amp;pa是整个数组的地址（即三个指针块）。从数字上来说，pa和&amp;pa的值相同，但它们的类型不同，一种差别是，pa+1为数组中的下一个元素，而&amp;pa+1为数组pa后面的12字节内存块的地址(假定地址为4字节)。另一个差别是，要得到第一个元素的值，对pa解除一次引用，但需要对&amp;pa解除两次引用： **&amp;pa == *pa == pa[0] arfupt.cpp #include &lt;iostream&gt; using namespace std; const double * f1(const double ar[], int n); const double * f2(const double [], int); const double * f3(const double *, int); int main() { double av[3] = {1112.3, 1542.6, 2227.9}; const double *(*p1)(const double *, int) = f1; auto p2 = f2; cout &lt;&lt; &quot;Using pointers to functions:\n&quot;; cout &lt;&lt; &quot;Address Value\n&quot;; cout &lt;&lt; (*p1)(av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*p1)(av,3) &lt;&lt; endl; cout &lt;&lt; p2(av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *p2(av,3) &lt;&lt; endl; const double *(*pa[3])(const double *, int) = {f1, f2, f3}; auto pb = pa; //const double *(**pb)(const double *, int) = pa; cout &lt;&lt; &quot;\nUsing an array of pointers to functions:\n&quot;; cout &lt;&lt; &quot;Address Value\n&quot;; for (int i = 0; i &lt; 3; i++) cout &lt;&lt; pb[i](av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *pb[i](av,3) &lt;&lt; endl; cout &lt;&lt; &quot;\nUsing pointers to an array pointers:\n&quot;; cout &lt;&lt; &quot;Address Value\n&quot;; auto pc = &amp;pa; cout &lt;&lt; (*pc)[0](av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*pc)[0](av,3) &lt;&lt; endl; const double *(*(*pd)[3])(const double *, int) = &amp;pa; const double * pdb = (*pd)[1](av,3); cout &lt;&lt; pdb &lt;&lt; &quot;: &quot; &lt;&lt; *pdb &lt;&lt; endl; cout &lt;&lt; (*(*pd)[2])(av,3) &lt;&lt; &quot;: &quot; &lt;&lt; *(*(*pd)[2])(av,3) &lt;&lt; endl; return 0; } const double * f1(const double * ar, int n) { return ar; } const double * f2(const double ar[], int n) { return ar+1; } const double * f3(const double ar[], int n) { return ar+2; } 结果: Using pointers to functions: Address Value 0x7fff5fac4b50: 1112.3 0x7fff5fac4b58: 1542.6 Using an array of pointers to functions: Address Value 0x7fff5fac4b50: 1112.3 0x7fff5fac4b58: 1542.6 0x7fff5fac4b60: 2227.9 Using pointers to an array pointers: Address Value 0x7fff5fac4b50: 1112.3 0x7fff5fac4b58: 1542.6 0x7fff5fac4b60: 2227.9 auto在C++11才有，所以编译时使用： g++ -std=c++11 arfupt.cpp 7.10.4 使用typedef进行简化除auto外，C++还提供了简化声明的工具。关键字typedef能够创建类型别名： typedef double real; //real为double的别名 这里采用的方法是，将别名当作标识符进行声明，并在开头使用关键字typedef。因此，可将p_fun声明为程序中使用的函数指针类型的别名： typedef const double *(*p_fun)(const double *, int); p_fun p1 = f1; 然后使用这个别名来简化代码： p_fun pa[3] = {f1,f2,f3}; p_fun (*pd)[3] = &amp;pa; 7.11 总结函数原型 参数传递和返回值 函数指针]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Public Proof of Cloud Storage from Lattice Assumption∗]]></title>
    <url>%2F2018%2F10%2F03%2FPublic%20Proof%20of%20Cloud%20Storage%20from%20Lattice%20Assumption%2F</url>
    <content type="text"><![CDATA[摘要存储可以提供灵活、可伸缩的数据存储服务。然而，一旦数据上传至云服务器，本地计算机没有拷贝，用户失去了对数据的物理控制。因此，研究一种方法来确保用户数据的完整性是有必要的。避免检索大量存储数或避免由用户检验数据，一种基于格加密的公开审计存储协议证明被提出。用户计算数据块的的标签，并且上传它们至云服务器。云服务器提供联合的块。第三方审计者通过联合的数据和标签来验证所有数据块的完整性。基于小整数解假设，给出的方案可以抵抗来自云服务器的丢失攻击和篡改攻击。基于错误假设的学习，给出的方案可以抵抗来自第三方审计者的好奇攻击。该方案是高效的，仅仅需要几个矩阵向量乘法和离散高斯函数的抽样。 关键词： 云存储 存储证明 格加密 公开审计 一、前言云存储作为云计算的一个基础服务，例如，微软的Azure存储服务和亚马逊的简单存储服务，已经提供给用户使用。在云上，用户可以在任何地方任何时间访问数据，享受更可靠的服务。云存储服务被设想为下一代存储服务。同时，云存储也带来一些新的和具有挑战性的安全问题【1-2】。一旦用户将数据上传至云，数据被云服务提供商控制（CSP）。引用的案例【3】说明了云存储不仅受到外部或外部数据安全威胁，尽管CSP声明了数据的完整性。因此，安全问题成为了影响用户选择云存储服务的主要因素。 在互联网上，数据的丢失或篡改可以有用户执行数据完整性验证来检验。然而，云存储服务有一些特殊的特征首先，存储在云上的数据都是巨大的，由于昂贵的I/O和传输成倍，通过恢复数据来验证数据的完整性是不可行的。其次，云存储服务使用分布式存储系统，于是数据存储在一系列云服务器上。互联网上的数据完整验证方案不再适应于云存储系统。一些针对云的安全方案被研究【4-5】。在云存储系统，存储证明可以可以分为两类：私有审计【6，7】和公开审计【8-10】。对于私有审计，仅仅用户自己检验他们外包的数据的完整性，其引起了巨大的开销。为了避免CSP或数据拥有者任意一方执行审计，公开审计，将审计程序移交给第三方审计者（TPA）,这是一个自然的选择。正如【9，10】所示，同态是公开审计一个有用的工具。 最近，基于格加密已经成为了热点研究课题，因为它在量子攻击（quantum attacks）下是安全的【11】。因为新的格难题的陷门函数(Trapdoor function)被成功的提出在【12】，对于云，许多基于格的方案被提出，其展示了格加密的数学优雅，实现的简单性，可证明的安全性降低，效率显著提高。一个简单有效的签名方叫做GPV签名【12】被提出与一个行的陷门函数。随后，Boneh和Freeman【13】提出了第一个在$F_2$上线性同态签名算法，其的不可伪造性是基于小整数解（SIS）问题。Boneh和Freeman【14】提出了第一个的同态签名方案，该方案能做在Eurocrypt2011上签署数据的多元多项式。其不可伪造性基于理想格上的SIS问题。在【15】中，基于加法的同态的韩系函数，给出了一个效率上的改进。 文献【17】尝试使用基于格的加密方案来验证云存储系统中数据完整性。一个来自格假设的线性同态签名被提出，第一个基于格的存储协议证明基于它被构造。然而，怎么利用$(W_i)_{i=1}^k$和$\sum_i c_i f_i$来计算$\sum_i c_i H(W_i) f_i$没有被解释。$\sum_i c_i f_i$可能泄漏一些关于文件$F=(f_1,\dots,f_k)$的信息给验证者TPA，因此该方案不支持公开审计。 本文旨在提出一种基于格加密的云存储数据的公开审计。本文余下阻止如下：在第二节，本文研究需要的技术知识被给出。系统模型、攻击模型和公开审计的设计目标在第三节给出。第四节，一种云存储数据的公开验证协议被提出，没有文献【17】的缺陷。在第五节，分析了提出方案的安全性和性能。在第六节，给出了结论和未来工作。 二、预备知识1.格对于任何整数$q \geq 2$，设$Z_p$表示模数位$q$的整数环。设$Z_q^{n \times m}$表示元素在$Z_p$中大小为$n \times m$的矩阵集合。 整数格的点的坐标为$Z^m$。对于任何整数$q \geq 2$，$u \in Z_q^n$和矩阵$A \in Z_q^{n \times m}$，定义整数格如下： 对任何$t \in \Lambda_q^u(A)$，$\Lambda_q^u(A) = \Lambda_q^{\bot}(A) + t$ 2. 离散高斯抽样格应用在密码学上是有效的，因为它的自然陷门特征。事实上，所有基于格的加密方案给出了怎么通过一种理论上可靠的方法去使用一个陷门函数。格的一个短基是一个陷门。 定理一 生成一个短基【12】：设$q$是一个整数，$m \geq 5nlogq$。一个概率多项式时间算法$TrapGen(q,n)$，其输出$(A \in Z_q^{n \times m}, T \in Z^{m \times m})$: (1) $A$在$Z_q^{n \times m}$统计地上服从一个一致矩阵。 (2) $T$是$\Lambda_q^{\bot}(A)$的一个基。 (3) $T(||T||)$中所有行的欧几里德范式以$O(nlogn)$为界。 定理二 从离散高斯分布抽样【12】：一个概率多项式时间算法$asmpePre(A,T,\sigma)$，给定一个矩阵$A \in Z_q^{n \times m}$，$\Lambda_q^{\bot}(A)$的一个基$T$，一个系数$\sigma \geq ||\check{T}|| \cdot w(\sqrt{logn})$，一个向量$u \in Z^n$，输出是来自一个分布的抽样，该分布统计地趋近于$D_{\Lambda_q^u(A)},\sigma$。$D_{\Lambda_q^u(A)},\sigma$是$\Lambda_q^u(A)$上系数为$\sigma$的离散高斯分布。 3. 困难假设经典的基于格的困难问题主要包括：最短向量问题、最近向量问题和最小基问题。进一步，为了提出加密方案，小整数解问题$SIS_{q,m,\beta}$被减少，如下： 给定一个整数$q$，一个矩阵$A \in Z_q^{n \times m}$和一个实数$\beta$，找一个非零向量$e \in Z^m $，满足： $A \cdot e = 0 mod q$和$||e|| \leq \beta$。 文献【12】已经证明平均情况问题$SIS_{q,m,\beta}$的难度近似跟最近想问题相等，在最糟的情况，对于任何有边界的特征$m,\beta$和任何素数$q \geq /beta \cdot w(\sqrt{nlogn})$。 错误学习假设【18】$LWE_{q,m,\chi}$以一种适合我们应用的方式被描述。 一个正整数$n$，整数$m \geq n $，$q \geq 2$，一个向量$s \in Z_q^q$，在$Z_q^m$上一个概率分布$\chi$。选择一致矩阵$A \leftarrow Z_q^{n \times m}$，向量$e \leftarrow \chi$，和向量$y \leftarrow Z^m_q$。分布$(A,A^T,s+e)$和分布$(A,y)$是难以区分的。 文献【18】已经证明$LWE_{q,m,\chi}$的难度跟利用量子算法解决几个标准的最糟情况的格问题一样。 三、提出的模型1、系统模型对于公开审计，一个代表性的系统模型见图1。公开审计的系统模型中有三个不同的实体。 用户：拥有大量数据文件需要存储到云上，依赖云来进行数据维护和计算，其可以是个人消费者也可以是组织。 云服务器提供商(CSP)：其是管理云服务器的实体，拥有大量的存储空间和计算资源来维护和计算用户的数据。 第三方审计者(TPA):其拥有用户没有的能力和专业知识，被信任来代表用户评估和揭露云存储服务的危险。 在云系统中，通过将大数据文件上传至云服务器，用户可以释放存储和计算的负担。首先，用户计算数据的标签，并发送数据和标签给云服务器。在云 存储系统中，用户存储他们的数据到一系列云服务器中，它们以一种协作和分布式的方式工作。然后，用户不再本地地处理他们的数据。如果用户想去检验数据是否完整的存在的服务器中，执行审计工作，如图1。 初始化 用户与CSP和TPA协商加密密钥。 挑战 收到来自用户的审计请求后，TPA生成并发送挑战给CSP。 证据 一收到来自TPA的挑战，CSP生成存储数据的证据并发送它给TPA。 验证 使用一些公开参数，TPA验证来自CSP证据的正确性，并返回TRUE/FALSE给用户。 2、攻击模型在云存储系统中，TPA被认为是诚实的和好奇的。在审计过程中，它诚实的执行审计程序，但它对收到的数据好奇。CSP被认为是不诚实的。一些破坏系统的攻击存在： 好奇攻击 TPA通过分析公开参数和来自CSP的证据尝试恢复用户的数据。 丢失攻击 CSP丢失用户的数据，希望通过TPA的审计。 篡改攻击 CSP可能篡改用户的数据为其他非法的数据，并尝试通过TPA的审计。 3、设计目标根据系统模型和攻击模型，公开审计方案的设计目标可以总结如下： 不可伪造性 攻击者无法伪造用户的标签 公开验证 任何人都可以执行审计，不仅仅存在数据到云服务器的用户，有能力去验证存储数据的完整性。 隐私保护 在审计过程中，没有数据块被审计者TPA恢复。 四、提出的方案1. 同态标签方案同态对于云存储证明是一个非常有用的工具。现在描述文献【15】提出的同态标签$(KeyGen,Sign,Combine,Verify)$方案，其包括如下四个多项式时间算法。$H:\lbrace 0,1\rbrace^{\ast} \rightarrow Z^m_q$是一个坑碰撞的哈希函数。 密钥生成 输入一个安全参数$n$。对任何整数$q$，Alice运行定理一中的$TrapGen(q,n)$算法来生成$A \in Z_q^{n \times m}$和陷门基$T \in Z^{m \times m}$分别当作公钥和私钥。 标签 对于给定消息$F=\lbrace u_1,\dots,u_l \rbrace \in Z^m_q$，Alice执行如下操作： 定义消息$F$的表促成为$id \in \lbrace 0,1 \rbrace ^{\ast}$。 计算$n$个向量$\alpha_j = H(id||j) \in Z^m_q$，其中$j \leq n$。 计算内积$h_{ij} = &lt;u_i, \alpha_j&gt;$，并组成向量$\vec{h_i}=(h_{i1},\dots,h_{in})^T$。 对于每个$i \in \lbrace 1,\dots, l \rbrace$，Alice运行定理二中的$SamplePre(A,T,\sigma,\vec{h_i})$生成向量$\vec{h_i}$标签$\vec{e_i}$。 联合 给定公钥$A$，身份标识$id$和一系列$(c_i,e_i)$，输出向量： $e_C = \sum_{i=1}^l c_i e_i$ $u_C = \sum_{i=1}^l c_i u_i$ $e_c$是消息$u_c$的签名。 验证 一收到联合的消息$u_C$和联合的标签，Bob执行如下操作： 计算$\alpha_j = H(id||j) \in Z^m_q$，其j \leq n$$。 计算联合消息$u_c = \sum_{i=1}^l c_i u_i$。 计算内积$h_{C_j} = &lt;u_C,\alpha_j&gt;$，并组成向量$h_C = (h_{C_1},\dots,h_{C_n})^T$。 当且仅当如下的条件满足，则接受联合标签$e_C$: $A_{e_C}=h_C(mod q)$ $||e_C|| \leq l \sigma \sqrt{m}$ 2. 云存储公开审计方案当同态标签被用来公开地检验云存储数据完整性时，一个事实必须被考虑。首先，验证没有标签的文件，并且不知道任何关于文件的任何信息。然后，同态标签方案指出批量验证，为了避免CSP存储联合信息，于是TPA必须根据由自己生成的挑战$chal$来验证。基于系统模型，云存储的公开审计方案如下： 初始化 云存储服务以一种协作和分布式的方式工作。为了存储用户的数据$F$到一系列云服务器上，$f$需要分成$l$个数据块$u_1,\dots,u_l,u_i \in Z^m_q$。 运行密钥$KeyGen$算法来获得用户的公钥$pk=\lbrace A \rbrace$和私钥$sk = \lbrace T \rbrace$。 对于$l$个数据块$u_1,\dots,u_l$，用户运行$Sign$算法，并输出相应的标签$e_1,\dots,e_l$。 用户发送文件$F=\lbrace u_1,\dots, u_l \rbrace$和相应的标签$e_1,\dots,e_l$到CSP，并删除本地数据文件$F=\lbrace u_1,\dots, u_l \rbrace$。 挑战]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NP问题理解]]></title>
    <url>%2F2018%2F10%2F02%2FNP%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[P问题、NP问题、NP难问题、NP完全问题 P问题：一个问题可以在多项式（O(n^k)）的时间复杂度内解决。 时间复杂度如(n^2, n^4, n(log(n)))都是多项式时间的，指数级别的如(2^n，n^n)这些就不是多项式时间了。 NP问题：给定一个解，我们可以在多项式时间内检查他正确与否的决策问题，为NP问题。 之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。 很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。 NP难问题：NP-hard问题：所有的NP问题都可以约化到它。 NP-hard问题是这样的问题，只要其中某个问题可以在P时间内解决，那么所有的NP问题就都可以在P时间内解决了。NP-c问题就是NP-hard问题。但注意NP-hard问题它不一定是NP问题，比如，下围棋就是NP-hard问题，但不是NP问题，我们要在一个残局上找一个必胜下法，告诉我们下一步下在哪里。显然，我们找不到这个解，而且更难的是，就算有人给我了一个解，我们也无法在P时间内判断它是不是正确的。 任意NP问题都可以在多项式时间内归约为该问题，但该问题本身不一定是NP问题。归约的意思是为了解决问题A，先将问题A归约为另一个问题B，解决问题B同时也间接解决了问题A。 归约为了说明NPC问题，引入–约化(规约)概念。 一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。 《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。 “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。 从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。 NP完全问题(NP-C问题)NP-c问题是这样的一类问题，首先他是属于NP的，而且他是NP问题里面最难解决的问题。难到什么程度？只要其中某个问题可以在P时间内解决，那么所有的NP问题就都可以在P时间内解决了。 NP-C问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。 既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P了。因此，给NPC找一个多项式算法太不可思议了。 NP-C问题既是NP问题，也是NP-hard问题。 四者关系 P问题属于NP问题，NP-C问题属于NP问题。 NP-C问题同时属于NP难问题，是NP与NP难问题的交集。 参考： 什么是NP问题，什么是NP hard问题，什么是NP完全问题 https://blog.csdn.net/u013089961/article/details/50069779 P、NP、NPC和NP-Hard相关概念的图形和解释： https://blog.csdn.net/huang1024rui/article/details/49154507]]></content>
      <tags>
        <tag>NP问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格理论与密码学--数学基础（一）]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6--%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍一些基本的数学概念和符号。 1.1 数论基础1.1.1 整除性和最大公因子若$a,b$是整数，则可以分别计算$a+b,a-b,a \cdot b$，且所得结果均是整数，这种性质称为对元素运算的封闭性。 但是对于除法运算并不能总是满足这种 运算封闭性。例如，不能用2去除3，因为3/2并不是整数，由此引出了整除性的基本概念。 定义1.1 设$a,b$是整数，$b \neq 0$。若存在整数$c$，满足$a=bc$，则称$b$整除$a$或$a$被$b$整除，即为$b|a$。 命题1.1 设$a,b,c \in Z$，则有： （1）若$a|b,b|c$，则$a|c$; （2）若$a|b,b|a$，则$a=\pm b$; （3）若$a|b,a|c$，则$a|(b+c)$且$a|(b-c)$。 定义1.2 $a$和$b$的公因子是能够同时整除二者的正整数。即，最大公因子就是满足$d|a,d|b$的最大的正整数$d$，用$gcd(a,b)$来表示。 定义1.7 记整数模$m$同余类环为： $Z/m ,Z={10,1,2,\dots,m-1}$ 注意到在同余类环种所进行的运算，所得结果均需模$m$以保持运算的封闭性。 群群是一种抽象的代数结构。简单地说，一个集合和在集合上满足某种性质的运算就构成了一个群。 定义1.13 群包含一个非空集合$G$和一个运算$\ast$，运算保持封闭性，即对与$a,b \in G$，有$a \ast b \in G$，并且要求运算$\ast$满足下述性质： 单位元：任取$a \in G$，存在$e \in G$，满足$e \ast a=a \ast e=a$。 逆元：任取$a \in G$，存在唯一的$a^{-1} \in G$，满足$a \ast a^{-1}=a^{-1} \ast a=e$。 结合律：任取$a,b,c \in G$，有$a \ast(b \ast c) = (a \ast b) \ast c$。 此外，，若满足交换律：任取$a,b \in G$，有$a \ast b = b \ast a$，则称$G$为交换群或阿贝尔群。 若$G$包含有限个元素，则称$G$为有限群。用$|G|$或$#G$来表示群中元素的数量，称为$G$的阶。 群相关的例子： 当$G=Z$，* = 加法，单位元$e=0$，$a$的逆元是$-a$，则$G$是无限群。 当$G=Z$，* = 乘法，则$G$不是群，因为$Z$的大多数元素在$Z$中并不存在乘法逆元。，比如2的乘法逆元1/2，不属于$Z$。 定义 1.14 设$G$是群，$a \in G$，假设存在正整数$d$满足$a^d = e$，则其中最小的$d$成为元素$a$的阶。若这样的阶不存在，则称$a$的阶位无穷大。 命题1.7 设$G$是一个有限群，则群中元素的阶都有限。此外，设$a \in G$且$a$的阶为$d$，当$a^k = e$，有$d|k$。 定理1.7 (Lagrange定理) 设$G$是有限群，$a \in G$，则$a$的阶能够整除$G$的阶。确切来说，设群$G$的阶位$n$，元素$a$的阶位$d$，则有$a^n = e,d|n$。 循环群 若—个群G的每—个元都是G的某—个固定元a的乘方，则称G为循环群，记作$G=(a)=\lbrace am |m∈Z \rbrace$，a称为G的—个生成元。特别地，如果G的代数运算采用加号表示时，则有 $(a)=\lbrace ma |m∈Z \rbrace$ 环群是在一个集合上定义了一种运算，这种运算可以令两个元素“相乘”并得到第三个元素。而环是在一个集合上定义“加法”和“乘法”两种运算，并存在分配律将他们联系起来。 定义1.15 环$R$就是在一个集合上定义了两种运算，分布用$+,*$来表示，并满足如下运算性质： 加法 单位元：任取$a \in R$，存在加法单元$0 \in R$，满足$0+a=a+0=a$。 负源：任取$a \in R$，存在加法负元$ \in R$，满足$a+b=b+a=0$。 结合律：任取$a,b,c \in R$，有$a+(b+c)=(a+b)+c$。 交换律：任取$a,b \in R$，有$a+b=b+a$。 简而言之，在加法运算的意义下，$R$可视为单位元为0的交换群。 乘法 单位元：任取$a \in R$，存在乘法单位元$1 \in R$，满足$1 \ast a=a \ast 1=a$。 结合律：任取$a,b,c \in R$，有$a \ast (b \ast c) = (a \ast b) \ast c$。 交换律：任取$a,b \in R$，有$a \ast b = b \ast a$。 注意到并没有要求元素具有乘法逆元。此外加法和乘法之间还满足分配律：任取$a,b,c \in R$，有$a \ast (b+c) = a \ast b + a \ast c$。 定义1.16 若环$R$中每个非零元素都要乘法逆元，则称$R$为域。 环和域的例子： R=Q，$\ast$ = 乘法，+ =加法。乘法单位元为1，且每个非零元都有乘法逆元，所以$Q$是一个域。 R=Z, $\ast$ = 乘法，+ =加法。乘法单位元为1，但只有1和-1有乘法逆元，所以Z只是环而不是域。 多项式环：若R是环，则可以构成系数取自R中的多项式环： $R[x] = \lbrace a_0 + a_1 x + a_2 x^2 + \dots + a_n x^n: n \geq 0, a_0, a_1, \dots, a_n \in R \rbrace$]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--分支语句和逻辑运算符（六）]]></title>
    <url>%2F2018%2F10%2F02%2FC%2B%2B%20Primer%20Plus--%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++提供了if和switch语句来进行决策，还有逻辑运算符和条件运算符。 6.1 if语句使用if语句来统计语句中的空格总数，实现如下： if.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int spaces = 0; int total = 0; cin.get(ch); while (ch != &apos;.&apos;) { if (ch == &apos; &apos;) spaces++; total++; cin.get(ch); } cout &lt;&lt; spaces &lt;&lt; &quot; spaces, &quot; &lt;&lt; total ; cout &lt;&lt; &quot; charachers total in sentence.\n&quot;; return 0; } 结果： The balloonist was an airhead with lofty goals. 6 spaces, 46 charachers total in sentence. 只要当ch为空格时，语句spaces++才被执行。因为语句total位于if语句的外面，因此每轮循环中都被执行。 6.1.1 if else语句if (test-condition) statement1 else statement2 如果测试条件为true，则程序将执行statement1，跳过statement2；如果测试条件为false，则程序将跳过statement1，执行statement2。 6.1.2 格式化if else语句如果操作部分需要多条语句，需要使用大括号将它们括起来，组成一个语句块。 if (ch == &apos;z&apos;) { zorro++; cout &lt;&lt; &quot;Another zorro candidate\n&quot;; } else { dull++; cout &lt;&lt; &quot;Not a Zorro candidate\n&quot;; } 6.1.3 if else if else结构实际中，可能需要程序提供两个以上的选择： if (ch == &apos;A&apos;) a_grade++; else if (ch == &apos;B&apos;) b_grade++; else soso++; 可以写成如下形式： if (ch == &apos;A&apos;) a_grade++; else if (ch == &apos;B&apos;) b_grade++; else soso++; 修改后的格式更为清晰。 ifelseif.cpp #include &lt;iostream&gt; using namespace std; const int Fave = 27; int main() { int n; cout &lt;&lt; &quot;Enter a number in the range 1-00 to find my favorite nmber: \n&quot;; do { cin &gt;&gt; n; if (n &gt; Fave) cout &lt;&lt; &quot;Too high -- guess again:&quot;; else if (n &lt; Fave) cout &lt;&lt; &quot;Too low -- guess agin: &quot;; else cout &lt;&lt; Fave &lt;&lt; &quot; is right!\n&quot;; }while (n != Fave); return 0; } 结果： Enter a number in the range 1-00 to find my favorite nmber: 22 Too low – guess agin: 44 Too high – guess again:27 27 is right! 错误防范： 表达式variable == value反转写成value == varibale。这样，可以捕获将相等运算符误写成赋值运算符的错误。 if (3 = var) 将一个变量赋给一个常量，编译器将生成错误信息。 if (var = 3) 这样，将3赋给一个变量，正确的语法，编译不会报错，于是会导致程序出错。 6.2 逻辑表达式C++提供了三种逻辑运算符，分别是：逻辑OR(||)、逻辑AND(&amp;&amp;)和逻辑NOT(!)。 6.2.1 逻辑OR运算符如果表达式中的任意一个或全部都为true，则得到的表达式为true。 5 == 5 || 5 == 9 //true 3 &lt;= 5 || 5 &gt;= 3 //true 1 &gt; 2 || 2 &gt; 3 //False ||运算符的优先级比关系运算符低，因此不需要添加括号。 C++规定，||运算符是个顺序点。即，先修改左侧的值，再对右侧的值进行判定。例如: i++ &lt; 6 || i == j 假设i越来的值为10，则在对i和j进行比较时，i的值将为11。另外，如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只要一个表达式为true，则整个逻辑表达式为true。 6.2.2 逻辑AND运算符仅当两个表达式都为true时，得到的表达式才为true。 5 == 5 &amp;&amp; 4 == 4//true 5 &lt; 3 &amp;&amp; 3 &gt; 2 //false &amp;&amp;运算符的优先级低于关系运算符，因此没必要添加括号。和||运算符一样，&amp;&amp;运算符也是顺序点，因此将先判定左侧，并且在右侧判定之前产生所有的副作用。如果左侧为false，则整个逻辑表达式为false，这种情况下，C++将不会再对右侧进行判定。 6.2.3 用&amp;&amp;来设置取值范围&amp;&amp;运算符还允许建立一系列if else if else语句，其中每种选择都对应一个特定的取值范围。 if (age &gt; 17 &amp;&amp; age &lt; 35) index = 0; else if (age &gt;= 35 &amp;&amp; age &lt; 50) index = 1; else if (age &gt;= 50 &amp;&amp; age &lt; 65) index = 2; else index = 3; 注意，下面语句： if (17 &lt; age &lt; 35) 编译器不会捕获这种错误，因为它仍然是合法的C++语法。&lt;运算符是从左向右结合，因此表达式含义如下： if ((17 &lt; age) &lt; 35) 但（17&lt;age）的结果要么为1，要么为0。不管哪种情况，表达式的值17&lt;age都要小于35，所以整个测试的结果总是true。 6.2.4 逻辑NOT运算符!运算符将它后面的表达式的真值取反。!运算符的优先级高于所有的关系运算符和算术运算符。因此，要对表达式取反，必须使用括号将其括起来，如下： !( x &gt; 5); !x &gt; 5; // 该表达式总是为false，!x为1或0，总是小于5 !运算符对于返回true-false值或可以被解释为true-false值的函数是很有用的。比如： !strcmp(s1,s2); 下面的程序来筛选可赋给int变量的数字输入。 not.cpp #include &lt;iostream&gt; #include &lt;climits&gt; using namespace std; bool is_int(double); int main() { double num; cout &lt;&lt; &quot;Enter an integer value:&quot;; cin &gt;&gt; num; while (! is_int(num)) { cout &lt;&lt; &quot;Out of range -- please try again:&quot;; cin &gt;&gt; num; } int val = int(num); cout &lt;&lt; &quot;You&apos;ve entered the integer &quot; &lt;&lt; val &lt;&lt; endl; return 0; } bool is_int(double x) { if (x &lt;= INT_MAX &amp;&amp; x &gt;= INT_MIN) return true; else return false; } 结果： Enter an integer value:1000000000000000 Out of range -- please try again:-1000000000000 Out of range -- please try again:444 You&apos;ve entered the integer 444 布尔函数is_int()使用了climits文件中定义的两个符号常量INT_MIN和INT_MAX来确定int类型的范围。 6.2.5 逻辑运算符细节AND和OR运算符的优先级都低于关系运算符。 !运算符的优先级都高于所有关系运算符和算符运算符。 逻辑AND运算符的优先级高于逻辑OR运算符，因此: age &gt; 30 &amp;&amp; age &lt; 45 || weight &gt; 300 被解释为： (age &gt; 30 &amp;&amp; age &lt; 45) || weight &gt; 300 当然，还可以使用括号来将所希望的解释告诉程序。例如： (age &gt; 30 || weight &gt; 300) &amp;&amp; donation &gt; 1000 C++确保程序从左向右进行逻辑运算表达式，并在知道了答案立刻停止。 6.2.6 其他表示方式使用标识符and、or和not来表示三种逻辑运算符。 运算符 另一种表示方式 &amp;&amp; and OR ! NOT 6.3 字符函数库cctypeC++继承了一个与字符相关的、非常方便的函数软件包，他可以简化如确定字符是否为大小写字母、数字、标点符号等工作，这些函数的原型在头文件cctype(老式的风格ctype.h)中定义。 下面使用AND和OR来测试字符ch是不是字母字符的代码： if (ch &gt;= &apos;a&apos; and ch &lt;= &apos;z&apos;) || (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) 与使用isalpha()相比： if (isalpha(ch)) isslpha()不仅更容易使用，而且更通用。 下面程序演示cctype库函数。 cctypes.cpp #include &lt;iostream&gt; #include &lt;cctype&gt; using namespace std; int main() { cout &lt;&lt; &quot;Enter text for analysis and type @ to terminate input:&quot;; char ch; int whitespace = 0; int digits = 0; int chars = 0; int punct = 0; int others = 0; cin.get(ch); while (ch != &apos;@&apos;) { if (isalpha(ch)) chars ++; else if (isspace(ch)) whitespace++; else if (isdigit(ch)) digits++; else if (ispunct(ch)) punct++; else others++; cin.get(ch); } cout &lt;&lt; chars &lt;&lt; &quot; letters, &quot; &lt;&lt; whitespace &lt;&lt; &quot; whitespace, &quot; &lt;&lt; digits &lt;&lt; &quot; digits, &quot; &lt;&lt; punct &lt;&lt; &quot; punctuations, &quot; &lt;&lt; others &lt;&lt; &quot; others.\n&quot;; return 0; } 结果： Enter text for analysis and type @ to terminate input: AdrenalVision Internationsl producer Adrienne Vismonger announced production of their new 3-D film, a remake of &quot;My Dinner with Andre,&quot; scheduled for 2013. @ 123 letters, 23 whitespace, 5 digits, 6 punctuations, 0 others. cctype中的字符函数： 函数名称 返回值 isalnum() 如果参数是字母数字，即字母或数字，该函数返回true isalpha() 如果参数是字母，该函数返回true iscntrl() 如果参数是控制字符，该函数返回true isdigit() 如果参数是数字(0~9),该函数返回true isgraph() 如果参数是除空格之外的打印字符，该函数返回true islower() 如果参数是小写字母，该函数返回true isprint() 如果参数打印字符（包括空格），该函数返回true ispunct() 如果参数是标点符号，该函数返回true isspace() 如果参数是标准空白字符，如空格、换行符、回车、制表符，该函数返回true isupper() 如果参数是大写字母，该函数返回true isxdigit() 如果参数是十六进制，该函数返回true tolower() 如果参数是大写字母，则返回小写字母 toupper() 如果参数是小写字母，则返回大写字母 6.4 ?:运算符C++常用?:运算符来代替if else语句，它C++中唯一的3个操作数的运算符。通用格式如下： expression1 ? expression2 : expression3 如果expression1为true，则整个表达式的值为expression2；否则，整个表达式的值为expression3。如下： 5 &gt; 3 ? 10 : 12 //5&gt;3为true，所以该表达式的值为19 3 == 0 ？ 25 : 18 // 3==0为false，所以表达式的值为18 condit.cpp #include &lt;iostream&gt; int main() { using namespace std; int a, b; cout &lt;&lt; &quot;Enter two integers: &quot;; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; &quot;The larger of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b; int c = a &gt; b ? a :b; cout &lt;&lt; &quot; is &quot; &lt;&lt; c &lt;&lt; endl; return 0; } 结果: Enter two integers: 2 3 The larger of 2 and 3 is 3 将条件表达式嵌套在另一个条件表达式中，如下： const char x[2][20] = {&quot;Jason &quot;, &quot;at your serviece\n&quot;}; const char * y = &quot;Quillstone &quot;; for (int i = 0; i &lt; 3; i++) cout &lt;&lt; ((i &lt; 2) ? !i ? x[i]:y : x[i]); 这是一种费解的方式，他按下面的顺序打印3个字符串： Jasn Qullstone at your service 从可读性来说，条件运算符最适合简单关系和简单表达式的值。 6.5 switch语句用户从5个选项中选择一个，虽然可以扩展if else if else来处理，但C++的switch语句能够更容易地从大型列表中进行选择。switch语句的通用格式： switch (integer-expression) { case label1: statement(s); case label2: statement(s); default: statement(s); } switch.cpp #include &lt;iostream&gt; using namespace std; void showmenu(); void report(); void comfort(); int main() { showmenu(); int choice; cin &gt;&gt; choice; while (choice != 5) { switch (choice) { case 1 : cout &lt;&lt; &quot;\a\n&quot;; break; case 2 : report(); break; case 3 : cout &lt;&lt; &quot;The boss was in all day.\n&quot;; break; case 4 : comfort(); break; default : cout &lt;&lt; &quot;That&apos;s not a choce.\n&quot;; } showmenu(); cin &gt;&gt; choice; } cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } void showmenu() { cout &lt;&lt; &quot;Please enter 1,2,3,4,5:\n&quot; &quot;1) alarm 2) report\n&quot; &quot;3) alibi 4) comfort\n&quot; &quot;5) quit\n&quot;; } void report() { cout &lt;&lt; &quot;It&apos;s been an excellent week for business.\n&quot;; } void comfort() { cout &lt;&lt; &quot;Your employees think you are the fines CEO in the induesty.\n&quot;; } 当用户输入5时，while循环结束。输入1到4将执行switch列表中相应的操作，输入6将执行默认语句。 同时，也可以使用字符(而不是整数)作为菜单选项和switch标签，则可以为大写标签和小写标签提供相同的语句： char choice; switch (choice) { case &apos;a&apos; : case &apos;A&apos; : cout &lt;&lt; &quot;\a\n&quot;; break; case &apos;b&apos; : case &apos;B&apos; : report(); break; case &apos;c&apos; : case &apos;C&apos; : cout &lt;&lt; &quot;The boss was in all day.\n&quot;; break; case &apos;d&apos; : case &apos;D&apos; : comfort(); break; default : cout &lt;&lt; &quot;That&apos;s not a choce.\n&quot;; } 由于case ‘a’后面没有break语句，因此程序将执行下一行–case ‘A’后面的语句。 6.5.1 将枚举用作标签使用enum定义了一组相关常量，然后在switch语句中使用这些常量。通常，cin无法识别枚举类型，因此该程序要求用户选择选项时输入一个整数。将switch语句将int值和枚举标签进行对比时，将枚举类型提升为int。 enum.cpp #include &lt;iostream&gt; enum {red, orange, yellow, green, blue, violet, indigo}; using namespace std; int main() { cout &lt;&lt; &quot;Enter color code(0-6):&quot;; int code; cin &gt;&gt; code ; while (code &gt;= red and code &lt;= indigo) { switch(code) { case red : cout &lt;&lt; &quot;Her lips were red.\n&quot;; break; case orange : cout &lt;&lt; &quot;Her hair was orange.\n&quot;; break; case yellow : cout &lt;&lt; &quot;Her sheos were yellow.\n&quot;; break; case green : cout &lt;&lt; &quot;Her nails were green.\n&quot;; break; default : cout &lt;&lt; &quot;Others.\n&quot;; } cout &lt;&lt; &quot;Enter color code (0-6):&quot;; cin &gt;&gt; code; } cout &lt;&lt; &quot;Bye!\n&quot;; return 0; } 结果： Enter color code(0-6):0 Her lips were red. Enter color code (0-6):2 Her sheos were yellow. Enter color code (0-6):6 Others. Enter color code (0-6):7 Bye! 6.5.2 switch和if elseswitch语句和if else语句都允许程序从选项中进行选择。if else更通用，它可以处理取值范围。而switch并不是为处理范围而设计的，switch语句中的每一个case标签都必须时一个单独的值。另外，这个值必须是整数（包括char）,因此switch无法处理浮点测试。另外，case标签值必须是常量。 6.6 break和continuebreak和continue语句都是程序能过跳过部分代码。可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行。continue语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环。如下图： jump.cpp #include &lt;iostream&gt; const int ArSize = 80; int main() { using namespace std; int letter = 0; char line[ArSize]; cout &lt;&lt; &quot;Enter a line of text:\n&quot;; cin.get(line, ArSize); cout &lt;&lt; &quot;Complete line:\n &quot; &lt;&lt; line &lt;&lt; endl; cout &lt;&lt; &quot;Line through first period:\n&quot;; for (int i = 0; line[i] != &apos;\0&apos;; i++) { cout &lt;&lt; line[i]; if (line[i] == &apos;.&apos;)//遇到句号，结束循环 break; if (line[i] == &apos; &apos;) //只统计字母个数，空格跳过，则下面的语句将不会执行 continue; letter++; //统计字母个数 } cout &lt;&lt; endl &lt;&lt; letter &lt;&lt; &quot; letters.\n&quot;; return 0; } 结果： Enter a line of text: Let&apos;s do lunch today. you can pay! Complete line: Let&apos;s do lunch today. you can pay! Line through first period: Let&apos;s do lunch today. 17 letters. 程序说明 虽然continue语句导致该程序跳过循环体的剩余部分，但不会跳过循环的更新表达式。在for循环中,continue语句使程序直接跳到更新表达式，然后跳到测试表达式。然而，对于while循环，continue将使程序直接跳到测试表达式，因此while循环中位于continue之后的更新表达式都被跳过。在某些情况下，这是一个问题。 6.7 读取数字的循环将一系列数字读入数组中，并允许用户在数组填满之前结束输入，利用如下代码： int n; cin &gt;&gt; n; 如果用户输入一个单词，而不是一个数字，发送这种类型匹配情况时，将发生4种情况： n的值保持不变 不匹配的输入将留在输入队列种 cin对象中的一个错误标记被设置 对cin方法的调用将返回false 假设编写一个程序，来计算每天捕获的鱼的重量。这里假设每天最多捕获5条鱼，因此一个包含5个元素的数组将足以存储所以的数据，但也可能没有捕获这么多。如果数组被填满或输入了非数字输入，循环将结束。 cinfish.cpp #include &lt;iostream&gt; using namespace std; const int Max = 5; int main() { double fish[Max]; cout &lt;&lt; &quot;Please enter the weights of your fish.\n&quot;; cout &lt;&lt; &quot;You may enter up to &quot; &lt;&lt; Max &lt;&lt; &quot; fish &lt; q to terminate&gt;.\n&quot;; cout &lt;&lt; &quot;fish #1: &quot;; int i = 0; while (i &lt; Max and cin &gt;&gt; fish[i]) { if (++i &lt; Max) cout &lt;&lt; &quot;fish # &quot; &lt;&lt; i+1 &lt;&lt; &quot;: &quot;; } double total = 0.0; for (int j= 0; j&lt; i; j++) total += fish[j]; if (i == 0) cout &lt;&lt; &quot;No fisht.\n&quot;; else cout &lt;&lt; total / i &lt;&lt; &quot; average weight of &quot; &lt;&lt; i &lt;&lt; &quot; fish.\n&quot;; return 0; } 结果： Please enter the weights of your fish. You may enter up to 5 fish &lt; q to terminate&gt;. fish #1: 10.2 fish # 2: 2.3 fish # 3: 4.5 fish # 4: q 5.66667 average weight of 3 fish. [root@localhost ~]# ./a.out Please enter the weights of your fish. You may enter up to 5 fish &lt; q to terminate&gt;. fish #1: q No fisht. 上述程序中，cin&gt;&gt;fish[i]实际上是一个cin方法函数调用，该函数返回cin。如果cin位于测试条件中，则将被转化为bool类型。如果输入成功，则转换后为true，否则为false。 当用户输入的不是数字时，该程序将不再读取输入。下面再看一个例子，假设程序要求用户提供5个高尔夫得分，以计算平均分。如果用户输入非数字，程序拒绝，并要求用户继续输入数字。可以看到，可以使用cin输入表达式来检测输入是不是数字。程序发现用户输入了错误内容时，应采取3个步骤： 重置cin以接受新的输入 删除错误输入 提示用户重新输入 cingolf.cpp #include &lt;iostream&gt; const int Max = 5; using namespace std; int main() { int golf[Max]; cout &lt;&lt; &quot;Enter your golf scores.\n&quot;; cout &lt;&lt; &quot;You must enter &quot; &lt;&lt; Max &lt;&lt; &quot; rounds.&quot;; for (int i = 0; i &lt; Max; i++) { cout &lt;&lt; &quot;Round# &quot; &lt;&lt; i+1 &lt;&lt; &quot; : &quot; ; while (!(cin &gt;&gt; golf[i])) { cin.clear(); while(cin.get()!=&apos;\n&apos;) continue; cout &lt;&lt; &quot;Please enter a number: &quot;; } } double total = 0.0; for (int i = 0; i&lt; Max; i++) total += golf[i]; cout &lt;&lt; total/Max &lt;&lt; &quot; = average score &quot; &lt;&lt; Max &lt;&lt; &quot; rounds.\n&quot;; return 0; } 结果： Enter your golf scores. You must enter 5 rounds. Round# 1 : 88 Round# 2 : i Please enter a number: k Please enter a number: 4 Round# 3 : 5 Round# 4 : 9 Round# 5 : ? Please enter a number: 44 30 = average score 5 rounds. clear()方法重置输入，如果省略这条语句，程序将拒绝继续读取输入。程序中如下代码的作用是： while(cin.get()!=&apos;\n&apos;) continue; 读取行尾之前的所有输入，从而删除这一行的错误输入。 6.8 简单文件输入/输出C++使得将读取键盘输入和在屏幕上显示输出的技巧用于文件输入/输出(文件I/O)非常简单。 6.81 文本I/O和文本文件使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据–文本数据。然后，cin对象负责将文本转换为其他类型。 char ch; cin &gt;&gt; ch; 输入实例为： 38.5 19.2 输入行中的第一个字符被赋给ch。在这里第一个字符是数字3，其字符编码(二进制)被存储在变量ch中。输入和目标变量都是字符，因此不需要进行转换。注意，这里存储的不是数值3，而是字符3的编码。 int n; cin &gt;&gt; n; 在这种情况下，cin将不断读取，直到遇到非数字符号。也就是说，它读取3和8，这样句点将成为输入队列中的下一个字符。cin通过计算发现，这两个字符对应数字是38，因此将38的二进制编码复制到变量n中。 接下来看double类型： double x; cin &gt;&gt; x; 在这种情况下，cin将不断读取，直到遇到第一个不属于浮点数的字符。即，cin读取3、8、句点和5，使得空格成为输入队列中的下一个字符。cin通过计算发现，这四个字符对应数字38.5，因此将38.5的二进制编码复制到变量x中。 接下来看看char数组的情况： char word[50]; cin &gt;&gt; word; 在这种情况下，cin将不断读取，直到遇到空白字符。即，它读取3、8、句点和5，使得空格成为输入队列中的下一个字符。然后，cin将这4个字符编码存储到输入word中，并在末尾加上一个空字符，这里需要进行任何转换。 最后，看一下另一种使用char数组来存储输入的情况： char word[50]; cin.getline(word,50); 在这种情况下，cin将不断读取，直到遇到换行符。所有字符都将被存储到数组word中，并在末尾添加一个空字符。换行符被丢弃，输入队列中的下一个字符是下一行的第一个字符。这里不进行任何转换。 对于输出，将执行相反的操作。即整数被转换为数字字符序列，浮点数被转换为数字字符和其他字符组成的字符序列。字符数据不需要做任何转换。 这里的要点是：输入一开始都是文本。因此，控制台输入的文件版本是文本文件，即每个字节都存储了一个字符编码的文件。并非所有的文件都是文本文件，比如，数据块和电子表格以数值格式（即二进制整数或浮点格式）存储数值数据。 6.8.2 写入的文本文件中文件输出： 必须包含头文件fstream; 头文件fstream定义了一个用于处理输出的ofstream类； 需要声明一个或多个ofstream变量，并以自己喜欢的方式对其进行命名； 必须指明命名空间std; 需要将ofstream对象与文件关联起来，为此方法之一是使用open()方法； 使用完文件后，应使用方法close()将其关闭； 可结合使用ofstream和运算符&lt;&lt;来输出各种类型的数据。 iostream头文件提供了一个预先定义好的名为cout的ostream对象，但您必须声明自己的ofstream对象，为其命名，并将其同文件关联。声明对象如下： ofstream outFile; 关联文件如下： outFile.open(&quot;fish.txt&quot;); char filename[50]; cin &gt;&gt; filename; outFile.open(filename); open()接受一个c-风格字符串作为输入，可以是字面字符串，也可以是存储在数组中的字符串。 使用文件输出的主要步骤如下： 包含头文件fstream; 创建一个ofstream对象； 将该ofstream对象同一个文件关联起来; 将像使用cout那样使用该ofstream对象。（如：&lt;&lt;,endl和setf()都可用于ofstream对象）。 outfile.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { char automobile[50]; int year; double a_price; double b_price; ofstream outFile; outFile.open(&quot;carinfo.txt&quot;); cout &lt;&lt; &quot;Enter the amke and model of automobile: &quot;; cin.getline(automobile, 50); cout &lt;&lt; &quot;Enter the model year: &quot;; cin &gt;&gt; year; cout &lt;&lt; &quot;Enter the original asing price: &quot;; cin &gt;&gt; a_price; b_price = 0.913 * a_price; cout.precision(5); cout.setf(ios_base::showpoint); cout &lt;&lt; &quot;Make and model: &quot; &lt;&lt; automobile &lt;&lt; endl; cout &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; endl; cout &lt;&lt; &quot;Was asing: $&quot; &lt;&lt; a_price &lt;&lt; endl; cout &lt;&lt; &quot;Now asking: $&quot; &lt;&lt; b_price &lt;&lt; endl; outFile.precision(5); outFile.setf(ios_base::showpoint); outFile &lt;&lt; &quot;Make and model: &quot; &lt;&lt; automobile &lt;&lt; endl; outFile &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt; endl; outFile &lt;&lt; &quot;Was asking: $&quot; &lt;&lt; a_price &lt;&lt; endl; outFile &lt;&lt; &quot;Now asking: $&quot; &lt;&lt; b_price &lt;&lt; endl; outFile.close(); return 0; } 结果： 在程序运行之前，并不存在carinfo.txt文件。在这种情况下，open()将新建一个名为carinfo.txt的文件。如果在此程序运行前，该文件已存在。默认情况下，open()将首先截断该文件，即将其长度截断为零—丢弃原有的内容，然后将新的输入加入到该文件中。 6.8.3 读取文本文件文件输入： 必须包含头文件fstream; 头文件fstream定义了一个用于处理输入的ifstream类； 需要声明一个或多个ifstream变量，并以自己喜欢的方式对其进行命名； 必须指明命名空间std; 需要将ifstream对象与文件关联起来，为此方法之一是使用open()方法； 使用完文件后，应使用方法close()将其关闭； 可结合使用ifstream和运算符&gt;&gt;来输出各种类型的数据; 可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符； 可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功； ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将转换为true，否则为false。 ifstream对象的声明： ifstream inFile; 关联文件： inFlie.open(&quot;bowling.txt&quot;); 如果试图打开一个不存的文件用于输入，这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的方法：is_open()。 inFile.open(&quot;bowling.txt&quot;); if (!inFile.is_open()) exit(EXIT_FAILURE); 函数exit()的原型在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数数值EXIT_FAILURE。函数exit()终止程序。 方法is_open()是C++中比较新的内容。可以使用方法good()来代替。 sumafile.cpp #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdlib&gt; using namespace std; const int SIZE = 60; int main() { char filename[SIZE]; ifstream inFile; cout &lt;&lt; &quot;Enter name of data file: &quot;; cin.getline(filename,SIZE); inFile.open(filename); if (!inFile.is_open()) { cout &lt;&lt; &quot;Could not open the file &quot; &lt;&lt; filename &lt;&lt; endl; cout &lt;&lt; &quot;Program terminating.\n&quot;; exit(EXIT_FAILURE); } double value; double sum = 0.0; int count = 0; inFile &gt;&gt; value; while (inFile.good()) { ++count ; sum += value; inFile &gt;&gt; value; } if (inFile.eof()) cout &lt;&lt; &quot;End of file reached.\n&quot;; else if (inFile.fail()) cout &lt;&lt; &quot;Input terminatd by data mismatch.\n&quot;; else cout &lt;&lt; &quot;Input terminated for unknown reasion.\n&quot;; if (count == 0) cout &lt;&lt; &quot;No data processed.\n&quot;; else { cout &lt;&lt; &quot;Items read: &quot; &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;Average: &quot; &lt;&lt; sum/count &lt;&lt; endl; } inFile.close(); return 0; } 结果： 文件循环读取设计时，需要注意几点。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof()返回true。其次，程序可能遇到类型不匹配，方法fail()返回true(如果遇到EOF，该方法也返回true)。最后，可能出现意外的问题，如文件损坏或硬件故障。如果最后一次读取文件出现了这样的问题，方法bad()将返回true。不要分布检查这些情况，一种更简单的方式是使用good()方法，该方法在没有发送任何错误时返回true。同时，可以使用其他方法来确定循环终止的原因，如下： if (inFile.eof()) cout &lt;&lt; &quot;End of file reached.\n&quot;; else if (inFile.fail()) cout &lt;&lt; &quot;Input terminatd by data mismatch.\n&quot;; else cout &lt;&lt; &quot;Input terminated for unknown reasion.\n&quot;; 方法god()指出最后一次读取输入的操作成功与否。标准的做法： inFile &gt;&gt; value; while (inFile.good()) { ++count ; sum += value; inFile &gt;&gt; value; } 由于表达式inFile &gt;&gt; value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为inFile().good()，即true或false。于是，两条输入语句用一条用作循环测试的语句代替。因此可以简化上面标准做法，如下： while(inFile &gt;&gt; value) { sum += value; ++count; } 6.9 总结if语句、if else语句和switch语句 逻辑运算符 文件输出和输入]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格-数据基础]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%A0%BC-%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[格密码是一类备受关注的抗量子计算攻击的公钥密码体制。格密码理论的研究设计的密码数学问题很多。 引用：王小云, 刘明洁. 格密码学研究[J]. 密码学报, 2014, 1(1): 13–27. 1.前言格理论的研究源于1611年开普勒提出的如下猜想：在一个容器中堆放等半径的小球所能达到的最大密度是$\pi/ \sqrt(18)$。1840年前，高斯引进了格的概念并证明：在三维空间堆球，如果所有的球心构成一个格，那么堆积密度所能达到的最大值是$\pi/ \sqrt(18)$。 格是$R^m$中一类具有周期性结构离散点的集合。严格地说，格是m维欧式空间$R^m$的$n(m /geq n)$个线性无关向量组$b_1,b_2,\dots,b_n$的所有整系数线性组合，即： 向量组$b_1,b_2,\dots,b_n$称为格的一组基。同一个格可以用不同的格基表示，$m$称为格的维数，$n$称为格的秩。当满足$m=n$的格称为满秩的。通常只考虑满秩的格。下面介绍一些格理论的基本概念和困难问题：]]></content>
      <categories>
        <category>格理论与密码学</category>
      </categories>
      <tags>
        <tag>格理论与密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(三)--数据链路层]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E4%B8%89)--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[数据链路层属于计算机网络的底层，数据链路层使用的信道主要有以下两种类型：(1)点对点信道；(2)广播信道。 3.1 点对点信道的数据链路层3.1.1 数据链路和帧链路：从一个点到相邻节点的一段物理链路，而中间没有任何其他的交换节点。 数据链路：在一条线路上传输数据时，除了一条必须的物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。把实现这些协议的硬件和软件加到链路上，构成了数据链路。 数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据去除并上交给网络层。在因特网中，网络层协议数据单元就是IP数据报（或简称数据报、分组或包）。 点对点信道的数据链路层进行通信时的主要步骤： 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。 结点A把封装好的帧发送给结点B的数据链路层。 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则丢弃这个帧。 3.1.2 三个基本问题数据链路层协议有许多种，但有三个基本问题则是共同的。这三个问题是：封装成帧、透明传输和差错检测。 1、封装成帧封装成帧就是在一段数据的前后分别添加首部和尾部。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。 首部和尾部的一个重要作用就是进行帧界定。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧的首部开始发送。为了提高效率，应当使帧的数据部分长度大于首部和尾部的长度，但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送单元MTU。 当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。ASCII码是7位编码，一个可组成128个不同的ASCII码，其中可打印的有95个，而不可打印的控制字符有33个。如下图，可以说明帧定界的概念，一个控制符SOH放在一个帧的最前面，表示帧的首部开始。另一个控制符EOF表示帧的结束。请注意SOH和EOT都是控制字符的名称。它们的十六进制编码分别为01(二进制00000001)和04(00000100)。 当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。当随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，在接收端知道前面收到的数据是个不完整的帧（只有首部开始符SOH，而没有传输结束符EOT），必须丢弃。 2.透明传输由于帧的开始和结束的标记是使用专门指明的控制字符，因此在所传输的数据中的任何8个比特的组合一定不允许和帧界定的控制字符的比特编码一样，否则就会出现帧定界的错误。 当传送的帧是文本文件组成的时，其数据部分不会出现像SOH或EOT这样的帧定界控制字符。但当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和EOT和SOH这种控制字符一样，如下图，数据链路层就会错误地找到帧的边界。 像上图这样的传输就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”被错误地解释为“传输结束”的控制符，而在其后面的数据应找不到“SOH”被接收端当作无效帧而丢弃。 透明表示：某一个实际存在的事物看起来却是好像不存在一样。在数据链路层透明传送数据，表示无论什么样的比特组合的数据都能够通过这个数据链路层。 为了解决透明传输问题，就必须设法将数据中可能出现的控制字符”SOH“和”EOT“在接收端不被解释未控制字符。具体的方法是： 发送端的数据链路层在数据中出现控制字符”SOH“和”EOT“的前面插入一个转义字符”ESC“（其十六进制编码是1B,二进制是00011011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充或字符填充。 如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此当接收端连续收到两个转义字符时，就删除其中前面的一个。 3.差错检测比特在传输的过程中可能回产生差错：1可能会变成0，而0可能变成1，这就是比特差错。 在一段时间内，传输错误的比特占所所传输比特总数的比率为误码率BER。误码率与信噪比有很大关系，如果设法提高信噪比，就可以使误码率减小。实际的通信链路并非是理想的，不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施，目前在数据链路层广泛采用了循环冗余检验CRC的检错技术。 下面通过一个简单的例子来说明循环冗余检验的原理： 在接收端，先把数据划分为组，假定每组k个比特。现假定带传送的数据$M=101001(k=6)$。CRC运算就是在数据$M$的后面添加供差错检验用的$n$位冗余码，然后构成一个帧发送出去，一共发送$(k+n)$位。在所要发送的数据后面增加n位的冗余码，虽然增加了数据传输的开销，但却可以进行差错检验。 这n位冗余码可用以下方法得出：用二进制的模2运算进行$2^n$乘$M$的运算，这相当于在$M$后面添加$n$个0。得到的$(k+n)$位的数除以收发双方事先设定的长度位$(n+1)$位的除数$P$，得出商是$Q$而余数是$R$(n位，比P少一位)。在下图所示的例子中，M=101001(即k=6)。假定除数P=1101(即n=3)。经模2除法运算后的结果是：商Q=110101(这个商并没有什么用处)，而余数R=001。这个余数R就作为冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码被称为帧检验序列FCS。因此加上FCS后发送的帧是101001001（即$2^nM+FCS$）,共有(k+n)位。 CRC是一种检错方法，而FCS是添加在数据后面的冗余码，在检错方法上可以选用CRC，但也可不是CRC。 在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以相同的除数$P$(模2运算)，然后检验得到的余数R。 如果传输过程中误差错，那么经过CRC检验后得出的余数R肯定是0。但如果出现错码，那么余数R仍等于零的概率是非常非常小的。 总之，在接收端对收到的每一帧经过CRC检验后，有以下两种情况： 若得出的余数R=0，则判定这个帧没有差错，就接收。 若余数$R \seq 0$，则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错）。 在数据链路层，发送端帧检验序列FCS的生成和接收端的CRC检验都是硬件完成的，处理很迅速，因此并不会延误数据的传输。 现在并没有要求数据链路层向网络层提供”可靠传输“的服务，所谓可靠传输就是:数据链路层的发送端发送什么，在接受端就收到什么。 传输差错可分为两大类： 一类是最基本的比特差错； 另一类传输差错更复杂些，帧没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。 在数据链路层使用CRC检验，能过实现无比特差错的传输，但这还不是可靠传输。OSI：必须让数据链路层向上提供可靠传输，因此在CRC检错的基础上，增加了帧编码、确认和重传机制。 3.2 点对点协议PPP在通信线路质量较差的年代，使用能实现可靠传输的高级数据链路控制HDLC就成为当时比较流行的数据链路层协议。但现在HDLC已很少使用了。对于点对点的链路，简单得多得点对点协议PPP(Point-to-Point Protocol)则是目前使用得广泛得数据链路层协议。 3.2.1 PPP协议的特点因特网用户通过要连接到某个ISP才能接入到因特网。PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议。 PPP协议有三个组成部分： 一个将IP数据封装到串行链路的方法。PPP既支持异步链路（无奇偶检验的比特数据），也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元MTU的限制。 一个用来建立、配置和测试数据链路连接的链路控制协议LCP。 一套网络控制协议NCP，其中的每一个协议支持不同的网络层协议。 3.2.2 PPP协议的帧格式1. 各字段的意义PPP的帧格式如下图，PPP帧的首部和尾部分别为四个字段和两个字段。 首部的第一个字段和尾部的第二个字段都是标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是十六进制，十六进制的7E的二进制表示是01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是PPP帧的定界符。 首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011）。最初曾考虑以后再对这两个字段的值进行其他定义，但至今也没有给出。 PPP首部的第四个字段2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021，则信息字段是PPP链路控制协议LCP的数据，而0x8021表示这是网络层的控制数据。 信息字段的长度是可变的，不超过1500字节。 尾部中的第一个字段(2字节)是使用CRC的帧检验序列FCS。 2. 字节填充当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些使用形式上和标志字段一样的比特组合不出现在信息字段中。 当PPP使用异步传输时，它把转义符定义为0x7D（即01111101），并使用字节填充。RFC 1662规定了如下所述的填充方法: 把信息字段中出现的每一个0x7E字节转变成2字节序列（0x7D,0x5E）。 若把信息字段中出现一个0x7D的字节（即出现了和转义字符一样的比特组合），则把0x7D转变成2字节序列(0x7D,0x5D)。 若信息字段中出现ASCII码的控制字符(即数值小于0x20的字符)，则在该字符前面加入一个0x7D字节。例如：出现0x03(在控制字符中式”传输结束“ETX)就要把他转变为2字节序列(0x7D,0x23)。 3. 零比特填充PPP协议用在SONET/SDH链路时，是使用同步传输(一连串的比特连续传送)而不是异步传输(逐个字符地传送)。在这种情况下，PPP协议采用零比特填充方法来实现透明传输。 零比特填充的具体做法是：在发送端，向扫描整个信息字段。只要发现有5个连续1，则立即填入一个0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段F以确定一个帧的边界，紧接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。 这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。 3.3 使用广播信道的数据链路层3.3.1 局域网的数据链路层局域网的数据链路层拆分成两个子层：逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层。与接入到传输媒体有关的内容放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的。 适配器的作用： 计算机与外界局域网的连接是通过通信适配器。适配器本来是在主机箱内插入的一块网络接口板（或者是在笔记本电脑中插入一块PCMCIA卡—个人计算机存储器卡接口适配器）。这种接口板又称为网络接口卡NIC。 在适配器上面装有处理器和存储器(包括：RAM和ROM)。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的I/O总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。 3.3.2 CSMA/CD协议最早的以太网就是将许多计算机连到一个总线上。 总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。这种就是广播通信方式。 但是不总是要在局域网上进行一对多的广播通信，为了在总线上实现一对一的通信，可以使计算机的适配器拥有一个与其他适配器都不同的地址。在发送数据帧时，在帧的首部写明接收站的地址。仅当数据帧中的目的地址与适配器ROM中存放的硬件地址一致时，该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧丢弃。这样，具有广播特性的总线上实现了一对一的通信。 为了通信方便，以太网采用两种措施： 采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编码，也不要求对方发回确认。 以太网发送的数据都使用曼切斯特编码的信号。 CSMA/CM协议的要点： “多点接入”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。 “载波监听”就是用电子技术检测总线上有没有其他计算机也在发送。其实总线上并没有什么“载波”，这里只不过借用“载波”这个名词。因此载波监听就是检测新的。不管在发送前，还是在发送中，每个站都必须不停地检测信道。在发送前检测信道，是为了获得发送权。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。 “碰撞检测”也就是“边发送边监听”，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。如果几个站同时在总线上发送数据，总线上的信号电压幅度会增大（相互叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值，就认为总线上至少有两个站同时发送数据，表明产生了碰撞。所谓“碰撞”就是发送了冲突。因此碰撞检测，也称为“冲突检测”。如果发现总线出现了碰撞，其适配器就要立即停止发送，免得继续进行无效发送，浪费网络资源，然后等待一段随机时间再次发送。 既然每一个站在发送数据之前已经监听到信道为“空闲”，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波在总线上总是以有限的速率传播的。下图说明了这种情况。设图中的局域网两端的站A和B相局1km，用同轴电缆相连。电磁波在1km电缆的传播时延为5$\mu s$。因此，A向B发出的数据，在约5$\mu s$后才能传到B。换言之，B若在A发送的数据到达B之前发送自己的帧（因为这时B的载波监听检测不到A所发送的信息），则必然要在某个时间和A发送的帧发送碰撞。碰撞的结果是两个帧都变得无用。 在局域网的分析中，常把总线上的单程端到端传播时延记为$\tau$。发送数据的站希望尽早知道是否发生了碰撞。从图中可知，最多是两倍的总线端到端的传播时延$(2\tau)$，发送者知道自己的数据和其他站发送的数据有没有发生碰撞。 显然，在使用CSMA/CD协议时，一个站不可能同时进行发送和接受（但必须边发送边监听信道）。因此使用CSMA/CD协议的以太网不可能进行全双工通信，而只能进行双向交替通信(半双工通信)。 从上图可以看出，最先发送数据帧的A站，在发送数据帧后至多经过时间$2\tau$就可知道所发送的数据帧是否遭受了碰撞。这就是$\delta \rightarrow 0$的情况。因此以太网的端到端往返时间$2\tau$称为争用期。争用期又称为碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发送碰撞。这时，就可以放心把这一帧数据顺序发送完毕。 以太网使用截断二进制指数退避算法来确定碰撞后重传的时机。这种算法让发送碰撞的站在停止发送数据后，不是等待信道变为空闲后立即再发送数据，而是推迟一个随机的时间。这点很容易理解，因为如果几个发送碰撞的站都再监听信道，那么都会同时发现信道变为了空闲。如果大家同时再重新发送，那么肯定又发送了碰撞。为了使各站进行重传时再发送冲突的概率减少，具体的退避算法如下： （1）协议规定了基本退避时间为争用期$2\tau$，具体的争用期时间是$51.2\mu s$。对于$10Mb/s$以太网，再争用期内可发送$512bit$，即64字节。也可以说争用期是512比特时间。1比特时间就是发送1比特所需的时间。 （2）从离散的整数集合$[0,1,\dots, (2^k-1)]$中随机取出一个数，即为$r$。重传应推后的时间就是$r$倍的争用期。上面的参数$k$的计算如下： $k = Min[重传次数，10]$ 可见当重传次数不超过10时，参数$k$等于重传次数；但当重传的次数超过10时，$k$就不再增大而一直等于10。 （3）当重传达16次仍不能成功时（这表明同时打算发送数据的站太多，以至连续发送冲突），则丢弃该帧，并向高层报告。 3.4 使用广播信道的以太网3.4.1 使用集线器的星形拓扑传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub)。如下图所示，双绞线以太网总是和集线器配合使用的。每个站需要用两对无屏蔽双绞线（放在一根电缆内），分别用户发送和接受。双绞线的两端使用RJ-45插头。由于集线器使用了大规模集成电路芯片，因此集线器的可靠性就大大提高了。1990年，IEEE指定了星形以太网10BASE-T的标准802.3i。“10”代表10Mb/s的数据率，BASE表示连接线上的信号是基带信号，T代表双绞线。 但10BASE-T以太网的通信距离稍短，每个站到集线器的距离不超过100m。 使双绞线能够传送高速数据的主要措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀减少失真，而且大大减少了电磁波辐射和无线电频率得干扰。 集线器的特点： 使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA\CD协议。 一个集线器有许多接口，例如8至16个，每个接口通过RJ-45插头用两对双绞线于一个工作站上的适配器相连。 集线器工作在物理层，它的每个接口仅仅简单地转发比特–收到1就转发1，收到0转发0，不仅碰撞检测。 集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使转发出去的较强信号不致对该接口收到的较弱信号产生干扰。 3.4.2 以太网的信道利用率3.4.3 以太网的MAC层1.MAC层的硬件地址在局域网中，硬件地址又称为物理地址或MAC地址（因为这种地址用在MAC帧中）。 IEEE802标准为局域网规定了一种48位的全球地址，是指局域网上的每一计算机中固化在适配器的ROM中的地址。 2.MAC帧的格式常用的以太网MAC帧格式有两种格式，一种是DIX Ethernet V2标准（即以太网V2标准），另一种是IEEE的802.3。这里只介绍使用最多的以太网V2的MAC帧格式，如下图。图中，假定网络层使用的是IP协议。 以太网V2的MAC帧比较为简单，由5个字段组成。前两个字段分别为6个字节的目的地址和源地址。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。第四个字段是数据字段，其长度在46到1500字节之间（最小长度64字节减去18字节的首部和尾部就得出数据字段的最小长度）。最后一个字段是4字节的帧检验序列FCS(使用CRC检验)。 MAC帧其首部没有一个帧长度（或数据长度）的字段。曼切斯特编码的每一个码元的正中间一定有一次电压的转换（从高到低或低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方可以很容易地找到以太网帧的结束位置，在这个位置往前数4字节（FCS字段长度是4字节），就能确定数据字段的结束位置。 当数据字段的长度小于46字节，MAC层就会在数据字段的后面加入一个整数字节的填充，以保证以太网的MAC帧长不小于64字节。MAC帧的首部没有指出数据字段的长度是多少。在有填充时，接收端的MAC子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。上层协议具有识别有效的数据字段长度的功能。当上层使用IP协议时，其首部有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于MAC帧数据字段的长度。例如，当IP数据报的总长度为42字节时，填充字段共有4字节。当MAC帧把46字节的数据上交给IP层后，IP层就把其中最后4字节的填充字段丢弃。 从上图可知，在传输媒体上实际传送的要比MAC帧还多8个字节。这是因为当一个站在刚开始接收MAC帧时，由于适配器的时钟尚未与达到的比特流达到同步，因此MAC帧的最前面的若干位无法接受，结果使整个的MAC成为无用帧。为了接收端迅速实现位同步，从MAC子层向下传到物理层时还要在帧的前面插入8个字节，它由两个字段构成。第一个字节是7个字节的前同步码（1和0交替码），它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时针频率，使它和发送端的时针同步，即“实现位同步”。第二个字段是帧开始定界帧，定义为10101011。它的前六位的作用和前同步码一样，最后的两个连续的1就是告诉接收端适配器：“MAC帧的信息马上就来，请适配器注意接收”。 IEEE802.3标准规定如下情况为无效的MAC帧： 帧的长度不是整数个字节 用收到的帧检验序列FCS查出由差错 收到的帧的MAC客户数据字段的长度不在46~1500字节之间。考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间 对于检查无效的帧就简单的丢弃，以太网不负责重传丢弃的帧。 IEEE 802.3规定的MAC帧的第三个字段是“类型和长度”。（1）当这个字段值大于0x0600（十进制1536）时，就表示类型，这样的帧和以太网V2 MAC帧完全一样。（2）只有当这个字段小于0x0x600时才表示“长度”，即MAC帧的数据部分长度。这种情况下，若数据字段的长度于长度字段的值不一致时，则该帧为无效的MAC帧。由于以太网采用曼切斯特编码，长度字段并无实际意义。 当”长度/类型“字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧。 3.5 扩展的以太网以太网的覆盖范围扩展 3.5.1 在物理层扩展以太网以太网的主机之间的距离不能太远（10BASE-T以太网的两个主机之间的距离不超过200米），否则主机发送的信号经过铜线传输衰减到使CSMA/CD协议无法正常工作。 扩展主机和集线器之间的距离的一种简单方法就是使用光纤和一对光纤调制解调器，如下图： 光纤调制解调器的作用就是：进行电信号和光信号的转换。由于光纤带来的实现很小，并且带宽高，因此这种方法可以很容易地使主机和几公里以外的集线器相连。 如果使用多个集线器，就可以连接覆盖更大范围的多级星形结果的以太网。例如，一个学院三个系各有一个10BASE-T的以太网，如下图： 可通过一个主干集线器把各系的以太网连接起来，成为一个更大的以太网： 这样的两个好处：（1）扩大了以太网覆盖的地理范围；（2）使这个学院不同系的以太网的计算机能够进行跨系的通信。 3.5.2 在数据链路层扩展以太网在数据链路层扩展以太网要使用网桥。网桥工作在数据链路层。它根据MAC帧的目的地址对收到的帧进行转发和过滤。当网桥收到一个帧时，并不是所有的接口转发此帧，而是先检查此帧的目的MAC帧，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。 1.网桥的内部结构下图给出了一个网桥的内部结构要点。两个以太网通过网桥连接起来，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可以称为一个网段(segment)。图中接口1和接口2各连到一个网段。 网桥依靠转发表来转发帧。转发表也叫做转发数据库或路由目录。如上图，（1）若网桥从接口1收到A发给E的帧，则在查找转发表后，把这个帧送到接口2转发到另一个网段，使E能够收到这个帧。（2）若网桥从接口1收到A发给B的帧，就丢弃这个帧，因为转发表指出，转发给B的帧应当从接口1转发出去，而现在正是从接口1收到这个帧，这说明A和B处在同一个网段上，B能够之间收到这个帧而不需要借助于网桥来实现。 网桥的好处： 过滤通信量，增大吞吐量 扩大了物理范围 提高了可靠性 可互连不同的物理层、不同MAC子层和不同速率的以太网 缺点： 增加了时延，由于网桥对接收的帧要先存储和查找转发表，然后才转发，而转发之前，还鄙视执行CSMA/CD算法。 没有流量控制，当网络上的负载很重时，网桥中的缓存的存储可能不够而发生溢出，以至产生帧丢失的现象。 广播风暴，网桥只适合于用户不太多和通信量不太大的以太网，否则有时还会音传播过多的广播信息而产生网络拥堵。 2.透明网桥目前使用最多的网桥就是透明网桥。其标准是IEEE 802.1D。”透明“指以太网上的站点不知道所发送的帧将经过哪几个网桥。透明网桥是一个种即插即用设备，意思是就只要把网桥接入局域网，不用人配置转发表网桥就能工作。 当网桥刚刚连接到以太网时，其转发表是空的。这时若网桥收到一个帧，网桥就按照以下自学习算法处理收到的帧（这样就逐步建立起转发表），并且按照转发表把帧转发出去。这种自学习算法比较简单，因为：若从某个站A发出的帧从接口x进入了某网桥，那么从这个接口出发沿着相反方向一定可以把一个帧传送到A。所以网桥只要每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。转发表中没有”源地址“这一栏，而只有”地址“这一栏。在建立转发表时，把帧首部的源地址写在地址这一栏。在转发帧时，则根据收到的帧首部中的目的地址来转发。这时把在”地址“栏下面记下的源地址当作目的地址，而把记下的进入接口当作转发接口。 网桥和集线器的区别 网桥是按存储转发方式工作的，一定是先把帧收下来（但集线器或转发器逐比特转发）再进行处理，而不管其目的地址是什么。此外，网桥丢弃CRC检验有差错的帧以及帧长过短或过长的无效帧。 A向B发送帧：连接在同一个局域网上的站点B和网桥1都能收到A发送的帧。网桥1先按源地址A查找转发表，网桥1的转发表中没有A的地址，于是把地址A和收到此帧的接口1写入转发表。这就表示，以后若收到要发给A的帧，就应当从这个接口1转发出去。接着再按目的地址B查找。转发表中没有B的地址，于是就通过除收到此帧的接口1以外的所有接口（现在就是接口2）转发该帧。网桥2从其接口1收到追个转发过来的帧。 网桥2按同样的方式处理收到的帧。网桥2的转发表中没有A的地址，因此在转发表中写入地址A和接口1.网桥2的转发表中没有B的地址，因此网桥2通过除收到此帧的接口1以外的所有接口转发这个帧。 B本来可以之间收到A发送的帧，让网桥1和网桥2盲目地转发这个帧的原因是：这两个网桥当时并不知道网络拓扑，因此要通过自学习过程才能逐步弄清楚所连接的网络拓扑，建立起自己的转发表。 自学习和转发的一般步骤 网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目。如有，则把原有的项目进行更新。 转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。如没有，则通过所有其他接口进行转发。如有，则按转发表中给出的接口进行转发。但应注意，若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃该帧。 透明网桥还使用了一个生成树算法。即互连在一起的网桥在进行批次通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。 找出一个生成书的目的：为了避免产生转发的帧在网络中不断地兜圈子。 3. 源路由网桥透明网桥的最大优点是容易安装，一接上就能工作。但是，网络资源的利用还不充分。因此，另一种由发送帧的源站负责路由选择的忘记就问世了，这就是源路由网桥。 源路由网桥是在发送帧时，把详细的路由信息放在帧的首部中。 源站选择路由的原理：为了发现合适的路由，源站以广播的方式向欲通信的目的站发送一个发现帧作为探测之用。发现帧将在整个扩展的以太网中沿着所有可能的路由传送。在传送过程中，每个发现帧都记录所经过的路由。当这些帧到达目的站时，就沿着各自的路由返回源站。源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。以后，凡从这个源站向该目的站发送的帧的首部，都必须携带源站所确定的这个路由信息。 发现帧还有另一个作用，就是帮助源站确定整个网络可以通过的帧的最大长度。 源路由网桥对主机不透明，主机必须直到网桥的表示以及连接到哪一个网段上。若在两个以太网之间使用并联的源路由网桥，则可使通信较平均地分配给每一个网桥。 4.多接口网桥–以太网交换机交换式集线器常称为以太网交换机或第二层交换机，表明这种交换机工作在数据链路层。 网桥的接口数很少，一般只有2~4个，而以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，和工作在物理层的转发器、集线器有很大的差别。 以太网交换机和透明网桥一样，也是一种即插即用设备，其内部的帧转发表也是通过自学习算法自动逐渐建立起来的。当两个站通信完成后就断开连接。以太网交换机由于使用了专门的交换结构芯片，其交换速率就教高。 利用以太网交换机可以很方便实现虚拟局域网VLAN。虚拟局域网是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的工作站属于哪一个VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 利用以太网交换机可以很方便地将这10个工作站划分为三个虚拟局域网：$VLAN_1$,$VLAN_2$,$VLAN_3$。在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员发出的广播。例如:当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到广播的信息。B1 发送数据时，工作站 A1, A2 和 C1都不会收到 B1 发出的广播信息。 虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即“广播风暴”)而引起性能恶化。 1988年IEEE批准了802.3ac标准，这个标准定义了以太网的帧格式的扩展，以便支持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入4个字节的标识符，称为VLAN标记（tag）,用来指明发送该帧的工作站属于哪一个虚拟局域网。 VLAN标记字段的长度是4个字节，插入在以太网MAC帧的源地址字段和类型字段中间。VLAN标记的前两个字节总是设置为0像100，称为IEEE 802.1Q标记类型。当数据链路层检测到MAC帧的源地址字段后面的两个字节的值是0x8100，就知道插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。后面两个字节中，前三位是用户优先级字段，接着的一位是规范格式指示符，最后的12位是该虚拟局域网VLAN标识符VID，它唯一地标志了这个以太网帧是属于哪一个VLAN。 3.6 高速以太网速率达到或超过100Mb/s的以太网称为高速以太网。 3.6.1 100BASE-T 以太网在双绞线上传送 100 Mb/s 基带信号的星型拓扑以太网，仍使用 IEEE 802.3 的CSMA/CD 协议。100BASE-T 以太网又称为快速以太网(Fast Ethernet)。 100BASE-T 以太网特定： 可在全双工方式下工作而无冲突发生。因此，不使用 CSMA/CD 协议。 MAC 帧格式仍然是 802.3 标准规定的。 保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。 帧间时间间隔从原来的 9.6$\mu$s 改为现在的 0.96$\mu$s。 3.6.2 吉比特以太网 允许在 1 Gb/s 下全双工和半双工两种方式工作。 使用 802.3 协议规定的帧格式。 在半双工方式下使用 CSMA/CD 协议（全双工方式不需要使用 CSMA/CD 协议）。 与 10BASE-T 和 100BASE-T 技术向后兼容。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典、列表、元组、数组]]></title>
    <url>%2F2018%2F09%2F27%2FPython%E5%AD%97%E5%85%B8%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[介绍Python字典、列表、元组、数组的函数和方法。 一、字典1 、内置函数1、cmp(dict1, dict2) 比较两个字典元素。 2、len(dict) 计算字典元素个数，即键的总数。 3、str(dict) 输出字典可打印的字符串表示。 4、type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 2、内置方法1、dict.clear() 删除字典内所有元素 2、dict.copy() 返回一个字典的浅复制 3、dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4、dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5、dict.has_key(key) 如果键在字典dict里返回true，否则返回false 6、dict.items() 以列表返回可遍历的(键, 值) 元组数组 7、dict.keys() 以列表返回一个字典所有的键 8、dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9、dict.update(dict2) 把字典dict2的键/值对更新到dict里 10、dict.values() 以列表返回字典中的所有值 11、pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12、popitem() 随机返回并删除字典中的一对键和值 数组转换为字典： 1、现在有两个列表，list1 = [‘key1’,’key2’,’key3’]和list2 = [‘1’,’2’,’3’]，把他们转为这样的字典：{‘key1’:’1’,’key2’:’2’,’key3’:’3’} list1 = [&apos;key1&apos;,&apos;key2&apos;,&apos;key3&apos;] list2 = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;] list2 = range(len(list1)) dict(zip(list1,list2)) {&apos;key1&apos;:&apos;1&apos;,&apos;key2&apos;:&apos;2&apos;,&apos;key3&apos;:&apos;3&apos;} 2、将嵌套列表转为字典，有两种方法， new_list= [[&apos;key1&apos;,&apos;value1&apos;],[&apos;key2&apos;,&apos;value2&apos;],[&apos;key3&apos;,&apos;value3&apos;]] dict(list) {&apos;key3&apos;: &apos;value3&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key1&apos;: &apos;value1&apos;} 二、列表列表初始化 1.初始化递增的list： list1 = range(10) print(list1) [0,1,2,...,9] 2.初始化每项为0的一维数组： list2 = [0] * 5 print(list2) [0,0,0,0,0] 3.初始化固定值的一维数组： initVal = 1 listLen = 5 list3 = [ initVal for i in range(5)] print(list3) [1,1,1,1,1] list4 = [initVal] * listLen print(list4) [1,1,1,1,1] 4.初始化一个5x6每项为0（固定值）的数组（推荐使用）： multilist = [[0 for col in range(5)] for row in range(6)] 5.初始化一个5x6每项为0（固定值）的数组 multilist = [[0] * 5 for row in range(3)] 看到了以上的方法，那初始化一个二维数组时，是否可以这样做呢： multi = [[0] * 5] * 3 其实，这样做是不对的，因为[0] * 5是一个一维数组的对象，* 3的话只是把对象的引用复制了3次，比如，我修改multi[0][0]： multi = [[0] * 5] * 3 multi[0][0] = &apos;Hello&apos; print(multi) 输出的结果将是： [[&apos;Hello&apos;, 0, 0, 0, 0], [&apos;Hello&apos;, 0, 0, 0, 0], [&apos;Hello&apos;, 0, 0,0, 0]] 我们修改了multi[0][0]，却把我们的multi[1][0]，multi[2][0]也修改了。这不是我们想要的结果。 但是如下写法是对的： multilist = [[0] * 5 for row in range(3)] multilist[0][0] = &apos;Hello&apos; print(multilist) 我们看输出结果： [[&apos;Hello&apos;, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] 恩，没问题。但是，由于使用 * 的方法比较容易引起混淆导致Bug，所以还是推荐使用上面方法4，即： multilist = [[0 for col in range(5)] for row in range(6)] 三、元组初始化L = 3, 4, 5 或 L = (3,4,5) del(L) //删除元组 (1,2) + (3,4) //得到一个新的元组 元组索引，截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示： 元组： L = (&apos;spam&apos;, &apos;Spam&apos;, &apos;SPAM!&apos;) Python 表达式 结果 描述 L[2] ‘SPAM!’ 读取第三个元素 L[-2] ‘Spam’ 反向读取，读取倒数第二个元素 L[1:] (‘Spam’, ‘SPAM!’) 截取元素 内置函数cmp(tuple1, tuple2) 比较两个元组元素。 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 数组数组创建import numpy as np a = np.array([2,3,4]) b = np.array([2.0,3.0,4.0]) c = np.array([[1.0,2.0],[3.0,4.0]]) d = np.array([[1,2],[3,4]],dtype=complex) # 指定数据类型 print(a) #打印数组 创建数组的常用函数np.arange(0,7,1,dtype=np.int16) # 0为起点，间隔为1时可缺省(引起歧义下不可缺省) np.ones((2,3,4),dtype=np.int16) # 三维数组，2页，3行，4列，全1，指定数据类型 np.zeros((2,3,4)) #三维数组， 2页，3行，4列，全0 np.empty(3) #值取决于内存 np.arange(0,10,2) # 起点为0，不超过10，步长为2 np.linspace(-1,2,5) # 起点为-1，终点为2，取5个点 np.random.randint(0,3,(2,3)) # 大于等于0，小于3，2行3列的随机整数 b = np.ones((2,3,4),dtype=np.int16) print(b.shape) #输出a的形状 print(b.shape[0]) #页数 ， 1行数，2列数 print(b.ravel()) # 输出平坦化后的a（a本身不改变） b.shape = (6,2); print(b)# 改变a的形状 print(a.transpose()) # 输出a的转置]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--循环和关系表达式（五）]]></title>
    <url>%2F2018%2F09%2F27%2FC%2B%2B%20Primer%20Plus--%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++提供三种循环：for循环、while循环和do while循环。 5.1 for循环int i; for (i = 0; i &lt; 5; i++) cout &lt;&lt; &quot;C++ knows loops.\n&quot;; 该循环首先将整数变量i设置为0： i = 0 这是循环的初始化部分，然后，循环测试部分检查i是否小于5： i &lt; 5 如果确实小于5，则程序执行接下来的语句–循环体： cout &lt;&lt; &quot;C++ knows loops.\n&quot;; 然后程序使用循环更新部分将i加1： i++ 接下来，循环开始了新的周期，将新的i值与5比较。 5.1.1 for循环组成部分for循环的组成部分完成步骤： 1、设置初始值；2、执行测试，判断循环是否应当继续进行；3、执行循环操作；4、更新用于测试的值。 1.表达式和语句 for语句的控制部分使用了3个表达式。 maids = (cooks = 4) + 3; 表达式cooks=4的值为4，因此maids的值为7。下面的语句由也是允许的： x = y = z = 0; 这种方法可以快速地将若干个变量设置为相同的值。优先级表表明，赋值运算符是从右向左结合的，因此首先将0赋给z,然后将z=0赋给y，依次类推。 从表达式到语句的转换很容易，只要加上分号即可，因此下面是一个表达式： age = 100 而下面一条语句： age = 100; 更准确地说，这是一条表达式语句。只要加上分号，所有的表达式都可以成为语句，但不一定编程有意义。例如： roents + 6; 编译器允许这样的语句，但它没有完成任何有用的工作。程序仅仅计算和，而没有使用得到的结果。 2.非表达式和语句 下面语句是一个表达式： int toad; 而int toad不是表达式，因为它没有值。因此，下面的代码非法： eggs = int toad * 1000; 同样不能把for循环赋给变量，for循环不是表达式，因此没有值，也不能给它赋值。 3、修改规则 C++对C循环的基础上添加了一项特性，要求对for循环句法做一些微妙的调整： for (int i = 0; i &lt; 5; i++) 也就是说，可以在for循环的初始化部分中声明变量。 5.1.2 回到for循环使用for循环计算并存储前n个阶乘: formore.cpp #include const int ArSize = 16; int main() { using namespace std; long long f[ArSize]; f[0] = f[1] = 1; for (int i = 2; i &lt; ArSize; i++) f[i] = i * f[i-1]; for (int i = 0; i &lt; ArSize; i++) cout &lt;&lt; i &lt;&lt; “! = “ &lt;&lt; f[i] &lt;&lt; endl; return 0; } 结果： 0! = 1 1! = 1 2! = 2 3! = 6 4! = 24 5! = 120 6! = 720 7! = 5040 8! = 40320 9! = 362880 10! = 3628800 11! = 39916800 12! = 479001600 13! = 6227020800 14! = 87178291200 15! = 1307674368000 定义一个const值来表示数组中的元素个数是个好办法。如果要扩展处理20个阶乘，则只需要修改ArSize的值为20，而不需要在程序将16修改为20。 5.1.3 修改步长到现在为止，循环示例每一轮循环计数加1或减1。可以通过修改更新表达式来修改步长： int by = 3; for (int i = 0; i &lt; 9; i = i + by) cout &lt;&lt; i &lt;&lt; endl; 5.1.4 使用for循环访问字符串for循环提供了一种依次访问字符串随的每个字符的方式。 forstr1.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { cout &lt;&lt; &quot;Enter a word:\n&quot;; string word; cin &gt;&gt; word; for (int i = word.size() - 1; i &gt;= 0; i--) cout &lt;&lt; word[i]; cout &lt;&lt; &quot;\nBye.\n&quot;; return 0; } 结果： Enter a word: animal lamina Bye. 在本例子中，可以使用string对象，也可以使用char数组，因为它们都可以使用数组表示法来访问字符串中的字符。 5.1.5 递增运算符(++)和递减运算符(–)两个运算符都要两种变体，前缀版本位于操作数前面，如++x；后缀版本位于操作数后面，如x++，两个版本对操作数的影响是相同的，但是影响的时间不同。 plus_one.cpp #include &lt;iostream&gt; int main() { using namespace std; int a = 20; int b = 20; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;; b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;a++ = &quot; &lt;&lt; a++ &lt;&lt; &quot;; ++b = &quot; &lt;&lt; ++b &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;; b = &quot; &lt;&lt; b &lt;&lt; endl; return 0; } 结果： a = 20; b = 20 a++ = 20; ++b = 21 a = 21; b = 21 a++意味着使用a当前值计算，然后将a的值加一；而b++的意思是先将b的值加1，然后使用新的值来计算表达式。例如： int x = 5; int y = ++x; //y的值为6 int z = 5; int y = z++; //y的值为5 递增和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次。问题在于，规则“使用后修改”和“修改后使用”可能变得模糊不清。下面的语句在不同的系统中将生成不同的结果： x = 2 * x++ * (3 - ++x); 对于这种语句，C++没有定义正确的行为。 5.1.6 副作用和顺序点副作用指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点是程序执行过程中的一个点。在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行所有的修改都必须完成。 完整的表达式：不另一个更大表达式的子表达式。完整的表达式例子有：表达式语句中的表达式部分以及用作while循环中检测条件的表达式。 while (guest++ &lt; 10) cout &lt;&lt; guest &lt;&lt; endl; 在这里，可以认为“使用值，然后递增”，意味着先在cout语句中使用guest的值，再将其值加1。然而，表达式guest++ &lt; 10是一个完整的表达式，因为它是一个while循环的测试条件，因此该表达式的末尾是一个顺序点。所以，C++确保副作用（将guest加1）在程序进入cout之前完成。然而，通过使用后缀格式，可确保将guest同10进行比较后再将其值加1。 现在看如下语句： y = (4 + x++) + (6 + x++); 表达式4 + x++不是一个完整的表达式，因此C++不保证x的值在计算子表达式4+x++后立刻增加1。在这个例子中，整条赋值语句是一个完整表达式，而分号表示了顺序点，因此C++只保证程序执行到下一条语句之前，x的值将被递增两次。 C++中，没有规定是在计算每个子表达式之后将x的值递增，还是整个表达式计算完毕才将x的值递增，鉴于此，应避免使用这样的表达式。 在C++11文档中，不再使用术语”顺序点“，因为这个概念难以用于讨论多线程执行。反而，使用了术语”顺序“，他表示有些事情在其他事件前发生。 5.1.7 前缀格式和后缀格式x++; ++x; 从逻辑上说，上述情形下，使用前缀和后缀表达式没有区别，即当表达式的值未被使用时，因此只存在副作用。 C++允许针对类定义这些运算符，在这种情况下，用户定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加去，然后将复制的副本返回。因此，对于类而言，前缀版本的效率比后缀版本的效率高。 总之，对于内置类型，采用哪种格式都不会有差别；但对于用户定义的类型，如果有用户定义的递增和递减运算符，作为前缀格式的效率高。 5.1.8 递增/递减运算符和指针将递增运算符用户指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于指针递增和递减： double arr[5] = {1.1, 2.2, 3.3, 4.4, 5.5}; double *pt = arr; ++pt; 也可以结合使用这些运算符和*运算符来修改指针所指向的值。 前缀运算符的从右到左结合规则意味着$\ast$++pt的含义如下：现将++应用于pt（因为++位于$\ast$的右边），然后将$\ast$应用于被递增后的pt: double x = *++pt; //指向arr[2],值为23.4 另一方面，++*pt意味着先取pt所指向的值，然后将这个值加1： ++*pt; //指向arr[2],值为24.4 接下来，看看下面的组合： (*pt)++; 圆括号指出，首先对指针解除引用，得到24.4，然后，运算符将这个值递增到25.4，pt仍指向arr[2]。最后，看下面组合： x = *pt++; 后缀用算符的优先级高，这意味着将运算符用户pt，而不是$\ast$pt，因此对指针递增。然而，后缀运算符意味着将对原来的地址（&amp;arr[2]）而不是递增后的新地址解除引用，因此$\ast$pt++的值为arr[2],即25.4，当该语句执行完毕后，pt的值将为arr[3]。 5.1.9 组合赋值运算符C++有一种合并加法和赋值的运算符： i += by; int pa[3] = {1,2,3}; pa[1] += 1; *(pa + 1) += 2; pa += 1; 组合赋值运算符 操作符 作用(L为左操作数，R为右操作数) += L+R赋给L -= L-R赋给L $\ast$= L$\ast$R赋给L /= L/R赋给L %= L%R赋给L 5.1.10 复合语句(语句块)int sum = 0; int number; for (int i =1; i &lt;= 5; i++) { cout &lt;&lt; &quot;Value: &quot; &lt;&lt; i &lt;&lt; &quot;: &quot;; cin &gt;&gt; number; sum += number; } 编译器将忽略缩进，因此需要使用花括号来说明是for中的语句块。如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量存在。执行完该语句块，变量将被释放。 注意，在外部定义的变量，在语句块内部也是被定义了。 5.1.11 逗号运算符语句块允许把两条或更多条语句放到按C++句法只能放到一条语句的地方。逗号运算符对表达式完成同样的任务，允许将两个表达式放到C++句法只允许放一个表达式的地方。例如：假设有一个循环，每轮都将一个变量加1，而另一个变量减1： ++j,--i 逗号并不总是逗号运算符，例如，下面这个声明中的逗号将变量列表中的相邻的名称分开： int i, j; 实现将一个string类对象的内容反转。 forstr2.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { cout &lt;&lt; &quot;Enter a word: &quot;; string word; cin &gt;&gt; word; char temp; int i,j; for(j = 0, i = word.size() - 1; j &lt; i; --i, ++j) { temp = word[i]; word[i] = word[j]; word[j] = temp; } cout &lt;&lt; word &lt;&lt; endl; return 0; } 结果： Enter a word: animal lamina 注意声明i,j的位置在循环之前，因为不能用逗号运算符将两个声明组合起来。这是因为声明已经将逗号用于其他用途–风格列表中的变量。也可以使用一个声明语句表达式来创建并初始化两个变量，但这样看起来有点乱： int j = 0, i = word.size() - 1; 在这种情况下，逗号只是一个分隔符。 如果在for内部声明temp: char temp = word[i]; 这样，temp在每轮循环中都将被分配和释放，这比在循环外声明temp的速度慢一些。另一方面，如果在循环内部声明，则它将在循环结束后释放。 逗号运算符其他用途 i = 20, j = 2 * i //其中i=20,j=40 首先，它确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。其次C++规定，逗号表达式的值是第二部分的值。例如，上面表达式的值为40，因为j=2$\ast$i的值为40。 在所有的运算符中，逗号运算符的优先级最低。例如，下面的语句： cata = 12, 120; 被解释为： (cata = 12), 120; 也就是说cata为12，120不起作用。然而，由于括号的优先级最高，下面的表达式： cats = (12, 120); 将cats设置为120—逗号右侧的表达式值。 5.1.12 关系表达式不等于: !=等于： ==小于等于： &lt;=大于等于： &gt;= 关系运算符的优先级比算术运算符地： x + 2 &gt; y -2 5.1.13 赋值、比较和可能犯的错误观察下面两者的输出： itn A[5] = {20, 20, 10, 20 ,1} for (int i = 0 ; A[i] == 20; i++) //输出前两个20 cout &lt;&lt; i &lt;&lt; endl; for (int i = 0; A[i] = 20; i++) //因为这里使用赋值，所有程序会一直输出20，导致程序崩溃 cout &lt;&lt; i &lt;&lt; endl; 第二个循环，一直输出20，直到程序崩溃，电脑死机。 5.1.14 C-风格字符串比较由于C++将C-风格字符串视为地址，因此如果使用关系运算符来比较它们，将无法得到满意的结果。相反，应使用C-风格字符串库的strcmp()函数来比较。该函数接受两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，则函数返回0；如果第一个字符串按字母排在第二个字符串前面，则函数返回一个负数；如果第一个字符串按字幕顺序排在第二个字符串之后，则函数返回一个正数。 实际上，”按系统排序顺序“比”按字母顺序“更准确，这意味着字符根据字符的系统编码来进行比较。例如：使用ASCII码时，所有大写字母的编码都要小于小写字母，所以按排序顺序，大写字母将位于小写字母前面。因此，字符串”Zoo“在字符串”aviary“之前。根据编码进行比较还意味着大写字母和小写字母是不同的。 虽然不能用关系运算符来比较字符串，但可以用来比较字符，因为字符实际上是整型。 for (ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) cout &lt;&lt;ch; compstr1.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; int main() { using namespace std; char word[5] = &quot;?ate&quot;; for (char ch = &apos;a&apos;; strcmp(word, &quot;mate&quot;); ch++) { cout &lt;&lt; word &lt;&lt; endl; word[0] = ch; } cout &lt;&lt; &quot;After loop ends, word is :&quot; &lt;&lt; word &lt;&lt; endl; return 0; } 结果： ?ateaatebatecatedateeatefategatehateiatejatekatelateAfter loop ends, word is :mate 如果str1和str2相等，作则下面的表达式为true: strcmp(str1,str2) == 0 如果str1和str2不相等，则下面两个表达式都是true: strcmp(str1,str2) != 0 strcmp(str1,str2) 如果str1在str2的前面，则下面表达式为true: strcmp(str1,str2) &lt; 0; 如果str在str2的后面，则下面表达式为true: strcmp(str1,str2) &gt; 0; 5.1.15 比较string类字符串如果使用sting类字符串而不是C-字符串，比较起来简单些。 compstr2.cpp #include &lt;iostream&gt; int main() { using namespace std; string word = &quot;?ate&quot;; for (char ch = &apos;a&apos;; word != &quot;mate&quot;; ch++) { cout &lt;&lt; word &lt;&lt; endl; word[0] = ch; } cout &lt;&lt; &quot;After loop ends, word is :&quot; &lt;&lt; word &lt;&lt; endl; return 0; } string类重载运算符！=的方式可以在下面条件下使用它：至少一个操作数为string对象，另一个操作数可以是string对象，也可以是C-风格字符串。 5.2 while循环while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体： while (test-condition) body 首先，程序计算圆括号内的测试条件表达式，如果该表达式为true，则执行循环体中的语句。如果希望循环最终能够结束，循环体中的代码必须完成某种影响测试条件表达式的操作。 while.cpp #include &lt;iostream&gt; const int ArSize = 20; int main() { using namespace std; char name[ArSize]; cout &lt;&lt; &quot;Your first name: &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;Here is your name, verticalized and ASCIIized:\n&quot;; int i = 0; while(name[i] != &apos;\0&apos;) { cout &lt;&lt; name[i] &lt;&lt; &quot; : &quot; &lt;&lt; int(name[i]) &lt;&lt; endl; i++; } return 0; } 结果： Your first name: zxp Here is your name, verticalized and ASCIIized: z : 122 x : 120 p : 112 如果没有循环体中的i++来更新测试表达式的值，循环会一直停留在第一个数组元素上，导致死循环。测试条件还可以修改为： while(name[i]) 程序的工作方式不变，对于编译器生成代码的速度将更快。由于name[i]是常规字符，其值为该字符的编码–非零值或true，当name[i]为空值时，其编码值为0或false。 打印字符的ASCII码，必须通过强制类型转换将name[i]转换为整型。 5.2.1 for与while在C++中，for和while循环本质上是相同的，例如: for (init-expression; test-expression; update-expression) { statements } 可以改写成: init-expression; while (test-expression) { statements update-expression } 两者区别： for循环中省略测试条件时，将认为条件为true; 在for循环中，可使用初始化语句声明一个局部变量，但在while循环中不能这样做； 如果循环体中包括 continus语句，情况将稍有不同，后续讨论。 通常，使用for循环来循环计数，因为for循环格式允许将所有相关的信息—初始值、终止值和更新计算的方式放在同一个地方。在无法预先直到循环执行次数时，使用while循环。 设计循环时，三条原则： 指定循环终止的条件； 在首次测试之前初始化条件； 在条件被再次测试之前更新条件。 注意分号使用： while (i &lt; 10); { cout &lt;&lt; i; i++; } 这将是一个空循环，分号将结束while循环。 5.2.2 编写延时循环有时候，让程序等待一段时间很有用。while循环可用于这个目的。早期的技术是让计算机进行计数，以等待一段时间： long waite = 0; while (waite &lt; 10000) waite++; 这种方法的问题是，当计算机处理的速度发生变化，必须修改计数限制。更好的办法是让系统时钟来往常这种工作。 C++库中有一个函数有助于完成这项工作，这个函数名叫clock()，返回程序开始执行后所用的系统时间。这有两个复杂的问题：首先，clock()返回时间的单位不一定是秒，其次，该函数的返回类型在某些系统可能是long，在另一些习俗可能是unsigned long或其他类型。 但头文件ctime(早期的time.h)提供了解决这些问题的解决方案。首先，定义一个符号常量—CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数，因此系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCKS_PER_SEC，可以得到系统时间单位为单位的时间。其次，ctime将clock作为clock()返回类型的别名，这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型。 waiting.cpp #include &lt;iostream&gt; #include &lt;ctime&gt; int main() { using namespace std; cout &lt;&lt; &quot;Enter the delay time, in seconde: &quot;; float secs; cin &gt;&gt; secs; clock_t delay = secs * CLOCKS_PER_SEC; cout &lt;&lt; &quot;starting\a\n&quot;; clock_t start = clock(); while (clock() - start &lt; delay); cout &lt;&lt; &quot;done \a\n&quot;; return 0; } 结果： Enter the delay time, in seconde: 5 starting done 该程序以系统时间单位为单位计算延迟时间，避免了在每轮循环中将系统时间转换为秒。 类型别名 C++为类型建立别名的方式有两种。一种是使用预处理器： #define BYTE char //注意没有分号 这样，预处理器将在编译程序时使用char替换所有的BYTE，从而使BYTE成为char的别名。 第二种方式是使用C++（和C）的关键字typedef来创建别名。例如，将byte作为char的别名，可以这样做： typedef char byte; 要让byte_pointer成为char指针的表明，可以将byte_pointer声明为char指针，然后在前面加上关键字typedef: typedef char * byte_pointer; 也可以使用#define，不过声明一系列变量时，这种方法不适用，例如： #define FLOAT_POINTER float *; FLOAT_POINTER pa pb; 预处理器置换该声明为这样： float *pa, pb; typedef方法不会有这样的问题。它能够处理更复杂的类型别名，这使得与使用#define相比，typedef是一种更佳的选择。 注意，typedef不会创建新类型，只是为已有的类型建立一个新名称。 编写程序对比两者： #include &lt;iostream&gt; #define char_point char * typedef char * byte_pointer; int main() { using namespace std; byte_pointer pa, pb; cout &lt;&lt; &quot;typedef: \n&quot;; cout &lt;&lt; sizeof(pa) &lt;&lt; endl; cout &lt;&lt; sizeof(pb) &lt;&lt; endl; char_point pc, pd; cout &lt;&lt; &quot;#define:\n &quot;; cout &lt;&lt; sizeof(pc) &lt;&lt; endl; cout &lt;&lt; sizeof(pd) &lt;&lt; endl; return 0; } 结果： typedef: 8 8 #define: 8 1 5.3 do while循环do while循环不同于介绍过的两种循环，因为它是出口条件循环，即这种循环将首先执行循环体，然后判定测试表达式，决定是否应该继续执行循环。句法如下： do body while (test-expression); 通常，入口条件循环比出口条件循环好，因为入口条件循环在循环开始之前对条件进行检查。但有时do while测试更合理，例如，请求用户输入时，程序必须先获取输入然后对它进行测试。 dowhile.cpp #include &lt;iostream&gt; using namespace std; int main() { int n; cout &lt;&lt; &quot;Enter number: &quot;; do{ cin &gt;&gt; n; } while(n != 7); cout &lt;&lt; &quot;Yes, 7 is my favorite.\n&quot;; return 0; } 结果： Enter number: 3 4 7 Yes, 7 is my favorite. 奇特的for循环 int i = 0; for (;;) { i++; if (30 &gt;= i) break; } 另一种变体： int i = 0; for(;;i++) { if (30 &gt;= i) break; } 上述代码基于这样一个事实：for循环中的空测试条件被视为true。这些例子不易于阅读，也不能用作编写循环的通用模型。第一个例子的功能在do while循环中将表达得更清晰： int i = 0; do{ i++ } while(i &lt;= 30); 第二个例子使用while循环可以表达得更清晰： while(i &lt; 30) { i++; } 5.4 基于范围的for循环（C++11）基于范围的for循环，简化了一种常见的循环任务：对数组或容器类（vector或array）的每个元素执行相同的操作： double prices[5] = {4.99, 10.99, 1.99, 7.99, 8.99}; for (double x: price) cout &lt;&lt; x &lt;&lt; endl; 其中x最初表示数组price的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素。 要修改数组的元素，需要使用不同的循环变量语法： for (double &amp;x : prices) x = x * 0.80; 符号&amp;表明x是一个引用变量。还可以结合使用基于for循环和初始化列表： for (int x : {3, 5, 2, 6}) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; Linux下使用C++11编译程序(rangefor.cpp): g++ -std=c++11 rangefor.cpp 5.5 循环和文本输入cin对象支持3种不同模式的单字符输入，其用户接口各不相同。下面介绍while循环中使用这三种模式： 5.5.1 使用原始的cin进行输入程序通过选择某个特殊的字符–哨兵字符，来作为停止表示，程序知道合适停止读取。例如下面程序遇到#字符时停止输入。 textcin1.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int count = 0; cout &lt;&lt; &quot;Enter characters, enter # to quit: \n&quot;; cin &gt;&gt; ch; while (ch != &apos;#&apos;) { cout &lt;&lt; ch; ++ count; cin &gt;&gt; ch; } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read. \n&quot;; return 0; } 结果： Enter characters, enter # to quit: zxp is handsome # read here zxpishandsome 13 characters read. 程序在输出时省略了空格，原因是cin在读取char值时，与读取其他类型一样，cin将忽略空格和换行。因此输入中的空格没有被回显，也没有被包括在计数内。 只有按下回车键，用户输入的内容才会被发送给程序，这就是在运行程序时，可以在#后输入字符的原因。 5.5.2 使用cin.get(char)补救通常，逐个字符读取时，程序需要检查每个字符，包括空格、制表符和换行符。cin所属的istream类中包括一个能够满足这种要求的成员函数。具体说，成员函数cin.get(char)读取输入中的下一个字符（即使它是空格），并将其赋值给变量ch。 textcin2.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int count = 0; cout &lt;&lt; &quot;Enter characters, enter # to quit: \n&quot;; cin.get(ch); while (ch != &apos;#&apos;) { cout &lt;&lt; ch; ++ count; cin.get(ch); } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read. \n&quot;; return 0; } 结果： Enter characters, enter # to quit: zxp is handosome # read here zxp is handosome 17 characters read. 现在程序回显了每个字符，并将全部字符计算在内，其中包括空格。 cin.get(ch)调用一个值放在ch变量中，这意味着将修改该变量的值。在C语言中，要修改变量的值，必须将变量的地址传递给函数，即cin.get(&amp;ch)。当在C++中，只要函数将参数声明为引用即可。引用是C++在C上新增的一种类型。 5.5.3 使用哪一个cin.get()前面使用过： cin.get(name, ArSize).get(); 相当于两行： cin.get(name., ArSize); cin.get(); 而本节，使用的为： cin.get(ch); 从上面可以看出，cin.get()的参数可以为空，可以是一个char类型的变量，甚至还可以是两个参数：一个整型，一个char型。这是因为C++支持函数重载。函数重载允许创建多个同名函数，条件是它们的参数列表不同。例如：如果在C++中使用cin.get(name, Arsize)，则编译器将找到使用char*和int作为参数的cin.get()版本；如果使用cin.get(ch)，则编译器将使用接受一个char参数的版本。 5.5.4 文件末尾前面的输入程序通过使用#符号来表示输入结束，这样难令人满意，因为这样的符号可能就是合法的输入的组成部分。如果输入来自一个文件，则可以使用一种功能更强大的计数—检测文件末尾(EOF)。C++输入工具和操作系统协同工作，来检测文件末尾并将这种信息告知程序。 检测到EOF后，cin将两位(eofbit和failbit)都设置为1。可以通过成员函数eof()来查看eofbit是否被设置；如果检测到EOF，则cin.eof()将返回true，否则返回false。同样，如果failbit被设置为1，则fail()成员函数返回true，否则返回false。注意：eof和fail方法报告最近读取的结果；即它们事后报告，而不是预先报告，因此应当cin.eof()或cin.fail()测试应放在读取后。一般使用fail()，其可用于更多的实现中。 textcin3.cpp #include &lt;iostream&gt; using namespace std; int main() { char ch; int count = 0; cout &lt;&lt; &quot;Enter characters, enter # to quit: \n&quot;; cin.get(ch); while (cin.fail() == false) { cout &lt;&lt; ch; ++ count; cin.get(ch); } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read. \n&quot;; return 0; } 结果： Enter characters, enter # to quit: yes yes it is very good yes yes it is very good no no i don&apos;t agree no no i don&apos;t agree //此处使用快捷键ctrl+d(Linux系统)，windows系统使用Ctrl+z 44 characters read. 注意：Windows下面Ctrl+z就相当于EOFLinux下面Ctrl+d相当于EOF。 1. EOF结束输入 cin方法检测到EOF时，将设置cin对象中一个指示EOF条件的标记。设置这个标记后，cin将不读取输入，再次调用cin也不管用。对于文件输入是有道理，因为程序不应读取超出文件末尾的内容。 然而对于键盘输入，有可能使用模拟EOF来结束循环，但稍后要读取其他输入，cin.clear()方法可能清除EOF标记，使输入继续进行。不过在某些系统中（比如：Linux），输入快捷键将结束输入和输出，而cin.clear()将无法恢复输入和输出。 2. 常见的字符输入做法 cin.get(ch); while (cin.fail() == false) { cout &lt;&lt; ch; ++ count; cin.get(ch); } 可以将上述代码使用一些简洁方式。!运算符将true切换为false或将false切换为true。比如: while (!cin.fail()) 方法cin.get(char)的返回值是一个cin对象。然而，istream类提供了一个可以将istreamd对象(cin)转换为bool值得函数；但cin出现在需要是bool值得地方（while循环得测试条件中）时，该转换函数被调用。意味着可以改写为： while (cin) 这比cin.eof()和cin.fail()更通用，因为cin还可以检测到其他失败的原因，比如磁盘故障。 最后，由于cin.get(char)的返回值为cin，因此可以将循环简写为： while (cin.get(ch)) {} 这样，cin.get(char)只被调用一次，而不是两次：循环前一次，循环后一次。为判断循环测试条件，程序必须先调用cin.get(ch)，如果成功，则将值放入ch中，然后，程序获得函数的返回值，即cin。接下来，程序对cin进行bool转换，如果输入成功，则结果为true，否则为false。 5.5.5 另一个cin.ge()版本C语言中字符I/O函数–getchar()和putchar()，它们仍旧适用，只要包含头文件stdio.h(或cstdio)即可。也可以使用istream和iostream中类似的成员。 不接受任何参数的cin.get()成员函数将返回输入中的下一个字符： int ch; ch = cin.get(); 该函数的工作方式与C语言中getchar()相似，将字符编码作为int值返回，而cin.get(ch)返回一个对象，而不是读取的字符。同样，可以使用cout.put()函数来显示字符： cout.put(ch); 该函数的工作方式与C语言中的putchar()类似，只不过其参数类型为char，而不是int。C++实现提供了三种原型：put(char),put(signed char),put(unsigned char)。给put一个int类型将导致错误类型，但可以通过强制类型转换实现：cin.put(char(ch))。 当函数到达EOF时，cin.get()将返回一个符号常量EOF表示的特殊值。该常量是在头文件iostream中定义的。通常，EOF被定义为-1，但没必要知道实际值，而必需在程序中使用EOF即可。 cin.get(ch); while (ch != EOF) { cout &lt;&lt; ch; ++ count; cin.get(ch); } 由于EOF表示的不是有效字符编码，因此可能不与char类型兼容，例如：在有些系统中，char类型是没有符号的，因此char变量不可能为EOF值(-1)。由于这种原因，如果使用cin.get()并测试EOF，则必须将返回值赋给int类型，而不是char类型。但是，如果将ch的类型声明为int，而不是char，则必须在显示ch时强制转换为char类型。 textcin5.cpp #include &lt;iostream&gt; using namespace std; int main() { int ch; int count = 0; while ((ch = cin.get()) != EOF) { cout.put(ch); count++; } cout &lt;&lt; endl &lt;&lt; count &lt;&lt; &quot; characters read.\n&quot;; return 0; } 结果: the smalller the smalller good boy good boy //按下快捷键ctrl+d 22 characters read. 循环条件，如果写成如下形式： while ( ch = cin.get() != EOF) 由于！=的优先级高于=，因此程序首先对cin.get()的返回值和EOF进行比较。比较的的结果为false或true，而这些bool值被转换为0或1，并赋值给ch。 ch=cin.get()和cin.get(ch)的区别 属性 cin.get(ch) ch = cin.get() 传递输入字符的方式 赋给参数ch 将函数返回值赋给ch 用于字符输入时函数的返回值 istrem对象(执行bool转换后为true) int类型的字符编码 达到EOF时函数的返回值 istream对象(执行bool转换后为false) EOF cin.get(ch1).get(ch2) 这是可行的，因为函数cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)。 5.6 嵌套循环和二维数组二维数组的声明如下： int maxtemps[4][5]; 该声明意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组成的数组。表达式maxtemps[0]是maxtemps数组e第一个元素，因此maxtemps[0]本身就是一个由5个int组成的数组。maxtemps[0]数组的第一个元素是maxtemps[0][0]，该元素是int元素。可以认为第一个下标表示行，第二个下标表示列。 假设要打数组的所有内容： for (int row = 0; row &lt; 4; row++) { for (int col = 0; col &lt; 5; col++) cout &lt;&lt; maxtemps[row][col] &lt;&lt; &quot;\t&quot;; cout &lt;&lt; endl; } 5.6.1 初始化二维数组创建二维数组时，可以初始化其所有元素： int maxtemps[4][5] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7}, {4,5,6,7,8}, }; 5.6.2 使用二维数组nested.cpp #include &lt;iostream&gt; using namespace std; const int Cities = 5; const int Years = 4; int main() { const char * cities[Cities] = { &quot;Griblle&quot;, &quot;Gribbletown&quot;, &quot;New Gribble&quot;, &quot;San Gribble&quot;, &quot;Gribble Vista&quot; }; int maxtemps[Years][Cities] = { {1,2,3,4,5}, {2,3,4,5,6}, {3,4,5,6,7}, {4,5,6,7,8}, }; cout &lt;&lt; &quot;Maximum tempeartures for 2008-2011\n&quot;; for (int city = 0; city &lt; Cities; city++) { cout &lt;&lt; cities[city] &lt;&lt; &quot;: \t&quot;; for (int year = 0; year &lt; Years; year++) cout &lt;&lt; maxtemps[year][city] &lt;&lt; &quot;\t&quot;; cout &lt;&lt; endl; } return 0; } 结果： Maximum tempeartures for 2008-2011 Griblle: 1 2 3 4 Gribbletown: 2 3 4 5 New Gribble: 3 4 5 6 San Gribble: 4 5 6 7 Gribble Vista: 5 6 7 8 5.7 总结C++提供三种循环：for循环、while循环和do while循环。]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(二)--物理层]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E4%BA%8C)--%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层 一、数据通信系统模型通信系统包括：原系统（发送端）、传输系统（传输网络）、目的系统（接收端）。 源系统包括以下两部分： 源点：源点设备产生要传输的数据，例如，从PC键盘输入函数，PC产生输出的数字比特流。 发送器：源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。 目的系统一般包括两个部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器。 终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出。 通信的目的是传送信息。数据是运送信息的实体。 根据信号中代表信息的参数的取值方式不同，信号可分为两类： 模拟信号，或连续信号–代表消息的参数的取值是连续的。 数字信号，或离散信号–代表消息的参数的取值是离散的。，在使用时间域(或简称为时域)的波形表示数字信号时，则代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一种代表1状态。 通信的双方信息交互的方式来看，可以有三种基本方式： 单工通信：即只能有一个方向的通信而没有方向的交互。比如:无线电广播 半双工通信: 通信的双方都可以发送信息，但不能双方同时发送。 全双工通信： 通信的双方可以同时发送和接收信息。 二、信道复用技术2.4.1 频分复用和时分复用频分复用最简单，如下图中左图。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。可见频分复用的所有用户在同样的时间占用不同的带宽资源（这里的带宽是频率带宽而不是数据的发送速率）。 时分复用，则是将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每个一个TDM帧中所占用固定序号的时隙。在下图右图中，只画出了4个用户A、B、C、D。每个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）。因此TDM信号也称等时信号。可见，时分复用的所有用户是在不同的时间所占用同样的频带宽度。 这两种复用方法的优点是技术比较成熟，但缺点 是不够灵活。时分复用则更有利于数字信号的传输。 在进行通信时，复用器和分用器成对使用。在复用器和分用器之间是用户共享的高速信道。分用器的作用和复用器的作用刚好相反，它把高速信道传送过来的数据进行分用，分别送交到相应的用户。 由于时分复用中，每个用户所分配到的时隙长度缩短了。当某些用户暂时无数据发送，在时分复用帧中分配给该用户的时隙只能处于空间状态，其他用户即使一直有数据发送，也不能使用这些空闲的时隙。这就导致复用后的信道利用率不高。 统计时分复用（STDM）是一种改进的时分复用，它能够明显提高信道的利用率。集中器常用这种统计时分复用。下图是统计时分复用的原理图。一个使用统计时分复用的集中器连接4个低速用户，然后将它们的数据集中起来通过高速路线发送到一个远地计算机。 统计时分复用使用STDM帧来传送复用的数据。但每一个STDM帧的时隙数小于连接在集中器上的用户数。个用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中。对没有数据的缓存就跳过。当一个帧放满了，就发送出去。可见，STDM帧不是固定分配时隙，而是按需动态地分配时隙。 在输出线路上，某个用户所占用的时隙并不是周期性地出现，因此统计时分复用又称为异步时分复用，而普通的时分复用称为同步时分复用。 使用统计时分复用的集中器也叫做智能复用器，他能提高对整个报文的存储转发能力，通过排队方式使各用户更合理地共享信道。此外，许多集中器还可能具有路由选择、数据压缩、前向纠错等功能。 2.4.2 波分复用波分复用WDM就是光的频分复用。光纤技术的应用使得数据的传输速率空前提高。使用一根光纤来同时传输多个频率很接近的光载波信号，这样就使光纤的传输能力成倍地提高。由于光载波的频率很高，因此习惯用波长而不是频率来标识所使用的光载波，因此使用波分复用这个名词。 波分复用只能在一根光纤上传输两路光载波信号，现在已经能做到一根光纤上复用几十路或更多的光载波信号，于是称为密集波复用(DWDM)。 ###2.4.3 码分复用 码分复用(CDM)是另一个种共享信道的方法，实际上常用的是码分多址(CDMA)。每一个用户可以在同样的时间使用同样的频带进行通信。 由于各用户使用经过挑选的不同码型，因此各用户之间不会造成干扰。 在CDMA中，每一个比特时间再划分为$m$个短的间隔，称为码片。通常$m$的值为64或128。为了简单，设$m$为8。 使用CMDA的每一个站被指派一个唯一的$m$bit码片序列。一个站如果发送比特1，则发送它自己的$m$bit码片序列。如果发送比特0，则发送该码片序列的二进制反码。例如，指派给S站的8个bit码片00011011，当S发送比特1，他就发送序列00011011，而当S发送比特0时，就发送11100100。为了方便，按惯例将码片中的0写为-1，1写为+1。因此S站的码片序列是（-1-1-1+1+1-1+1+1）。 假设S站要发送信息的数据率为$b$b/s。由于每一个比特要转换成$m$个比特的码片，因此S站实际上发送的数据率提高到$mb$b/s，同时S站所占用的频带宽度也提高到原来数值的$m$倍。这种通信方式是扩频通信中的一种。扩频通信有两大类： 直接序列扩频DSSS,上述使用的码片序列就是这一类； 跳频扩频FHSS。 CDMA系统的一个重要特点就是这种体制给每一个站分配的码片序列不仅必须各不相同，并且还必须相互正交，在实际系统中是使用伪随机码序列。 令向量S表示站S的码片向量，向量T表示其他站的码片向量。两个不同站的码片序列正交，就是向量S和T的规格化内积都是0： $S /cdot T = \frac{1}{m}\sum_{i=1}^mS_iT_i = 0$ 任何一个码片向量和该码片向量自己的规格化内积都是1： $S /cdot S = \frac{1}{m}\sum_{i=1}^mS_iS_i = \frac{1}{m}\sum_{i=1}^mS_i^2 = \frac{1}{m}\sum_{i=1}^m(\pm)^2= 1$ 而一个码片向量和该码片反码的向量的规格化内积值是-1。 下图是码分复用的例子： 当接受站打算收S站发送的信号时，就用S站的码片序列与收到的信号求规格化内积。这相当于分别计算$S \cdot S_x$和$S \cdot T_x$。显然，$S \cdot S_x$就是S站发送的数据比特，因此在计算规格化内积时，相加各项，得到的结果都是+1，或者都是-1；而$S \cdot T_x$一定是零，因为相加的各项中的+1和-1各占一般，因此总和一定是零。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(一)--概论]]></title>
    <url>%2F2018%2F09%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E4%B8%80)--%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[五层协议体系结构、计算机网络性能 一、计算机网络的性能1.速率比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。bit来源于binary digit,意思是一个“二进制数字”。一个比特就是二进制数字中的一个1或0。速率指的是连接在计算机网络上的主机在数字信道上传输数据的速率。速率的单位b/s(比特每秒)或(bit/s)，有时也写为bps，即bit per second。 2.带宽 带宽本来指某个信号具有的频带宽度。 在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，网络带宽表示单位时间内从网络中的某一点到另一点所能通过的最高数据率。 二、五层协议体系结构OSI的七层协议体系结构的概念清楚，理论完整，但是它既复杂又不实用。TCP/IP体系结构则不同，它现在已经广泛应用。TCP/IP是一个四层的体系结构，包括：应用层、运输层、网际层和网络接口层。但是TCP/IP只有最上面的三层，因为最下面的网络接口层基本和一般的通信链路在功能上没有多大的差别，对于计算机网络，网络接口层并没有声明特别新的具体内容。因此，综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。 (1)应用层 应用层时体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互规则。这里的进程指的是正在运行的程序。对于不同的网络应用需要有不同的应用层协议，比如：支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传输的FTP协议。 (2)运输层 运输层的任务就是负责两个主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。多种应用可以使用同一个运输层服务，由于同一台主机可同时运行多个进程，因此运输层有复用和分用的功能。 运输层主要使用的协议： 传输控制协议TCP–提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段。 用户数据报协议UDP–提供无连接的、尽最大努力的数据传输服务，其数据传输的单位是用户数据报。 (3)网络层 网络层负责为分组交换网上的不同主机通过通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。 网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。 (4)数据链路层 数据链路层简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这需要使用专门的链路层协议。在两个相邻结点之间传送数据时，数据链路层间网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。 在接收数据时，控制捏成使接收端能够知道一个帧从哪个比特开始和到哪个比特阶数。这样，数据链路层收到一个帧后，就可从中提出取数据部分，上交给网络层。 控制信息还使接收端能够检测所接收到的帧中有无差错。如果发现差错，则丢弃差错帧。如果需要改正数据在数据链路层传输时出现的差错，那么需要采用可靠传输协议来纠正差错。 (5)物理层 在物理层上所传数据的单位时比特。 实体，表示任何可发送或接受信息的硬件或软件进程。 协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议，还需要使用下一层所提供的服务。协议是”水平的“，服务是“垂直的”。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--复合类型（四）]]></title>
    <url>%2F2018%2F09%2F12%2FC%2B%2B%20Primer%20Plus--%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复合类型介绍 4.1 数组数组是一种数据格式，能过存储多个同类型的值。例如，数组可以存储60个int类型的值。 创建数组，可使用声明语句，声明输入应指出以下三点： 存储在每个元素种的值的类型 数组名 数组种的元素数 C++中，可以通过修改简单变量的声明，添加中括号来完成数组声明。例如，下面的声明创建一个名为months的数组，该数组有12个元素，每个元素都可以存储一个short类型的值: short months[12] 事实上，可以将数组中的每个元素看作一个简单变量。声明数组的通用格式如下： typename arrayName[arraySize]; 表达式arraySize指定元素数目，它必须是整型或const值，也可以是常量表达式（如：8*sizeof(int)）,即其中所有的值在编译时都是已知的。具体说，arraySize不能时变量，变量的值时程序运行时设置。稍后，介绍如何使用new运算符来避免这种限制。 数组之所以称之为复合类型，是因为它是可以使用其他类型来创建的。不能仅仅将某种东西声明为数组，它必须是特定类型的数组。没有通用的数组类型，当存在很多特定的数组类型，如char类型或long数组。例如： float loans[20]; loans的类型不是“数组”，而是“float数组”。这强调loans数组是使用float类型创建的。 数组的很多用途都是基于这样一个事实：可以单独访问数组的元素。方法是使用下标或索引来对元素进行编号。C++数组从0开始编号。C++使用带索引的括号表示法来指定数组的元素。例如，months[0]是months数组的第一个元素，months[11]是最后一个元素。注意最后一个元素的索引比数组长度小1。因此，数组声明能过使用一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。 有效下标的重要性：编译器不会检查使用的下标是否有效。但是程序运行后，这种赋值可能引发问题，他可能破坏数据或代码，也可能导致程序异常终止。 数组初始化： int y[3] = {0,1,2}; sizeof运算符返回类型或数据对象的长度（单位为字节）。 sizeof(y); 4.1.1 数组初始化只有定义数组时才能初始化，此后就不能使用了，也不能将一个数组赋给另一个数组： int cards[5] = {3,6,8,10}; int hand[4]; hand[4] = {5,6,7,9}; //错误做法，hand[4] = 5;这样是替换低4个元素的值为5 hand = cards; //错误语法 然而，可以使用下标分别给数组中的元素赋值。 初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化hotelTips的前两个元素： float hotelTips[5] = {5.0, 2.5}; 如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。将数组中所有的元素初始化为0非常简单，只要显式地将第一个元素初始化0。然后编译器将其他元素都初始化为0即可： long totals[500] = {0}; 如果初始化数组方括号内([])为空，C++编译器将计算元素个数，例如，对于下面的声明： short things[] = {1,5,3,8}; 编译器将使things数组包含4个元素。 4.1.2 C++11数组初始化方法初始化时可以省略等号： double earning[3] {100.1, 112.2,133.2}; 可以在花括号中不包括任何内容，这将把所有元素都设置为零： float blances[100] {}; 列表初始化禁止缩窄转换： long plifs[] = {25, 3.0}; //错误语法，3.0为float无法转换为long char slifs[] = {&apos;h&apos;, &apos;i&apos;, 1122011}; //最后一个元素太大，char无法容纳，char变量的长度为8位 char tilfs[4] = {&apos;h&apos;, &apos;i&apos;, 24}; //正确做法 4.2 字符串字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种： 来自C语言，常被称为C-风格字符串 基于string类库的方法 存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。C-风格字符具有一种特殊的性质：以空字符结尾，用字符被写作\0,其ASCII码为0，用来标记字符串的结尾。例如： char dog[4] = {&apos;b&apos;,&apos;e&apos;,&apos;a&apos;,&apos;x&apos;}; //不是一个字符串 char cat[4] = {&apos;f&apos;,&apos;s&apos;,&apos;a&apos;,&apos;\0&apos;}; //是一个字符串 这两个数组都是char数组，但只有第二个数组是字符串。空字符对C-风格字符串而言至关重要。例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数，它们都逐个地字符串中的字符，直到到达一个空字符为止。如果使用cout显式cat这样的字符串，则将前3个字符，发现空字符后停止。如果使用cout显式上面的dog数组（他不是字符串），cout将打印出数组中的4个字符，并接着将内存中随后的各个字节解释为要打印的字符，直到遇到控制符为止。由于空字符（实际上是被设置为0的字节）在内存中是常见的，因此这一过程很快就停止。 一种更好的、将字符数组数组初始化为字符串的方法–只需使用一个引号括起来的字符即可，这种字符串被称为字符串常量或字符串字面值，如下： char bird[11] = &quot;Mr. Cheeps&quot;; char fish[] = &quot;Bubbles&quot;; 用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。 C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上末尾的空字符。当然应确保数组足够大，能过存储字符串中的所有字符—包括空字符。 注意：在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。 字符串常量（使用双引号）不能与字符常量（使用单引号）互换。字符常量（如‘S’）是字符串编码的简写表示。在ASCII系统上，‘S’只是83的另一种写法，因此，下面的语句将83赋给shirt_size: char shirt_size = &apos;S&apos;; 但”S”不是字符常量,它表示的是两个字符（字符S和\0）组成的字符串。更糟糕的是，”S”实际上表示的是字符串所在的内存地址。因此，下面的语句试图将一个内存地址赋给shirt_size: char shirt_size = &quot;S&quot;;//错误的做法 由于地址在C++中是一种独立的类型，因此编译器不允许这种不合理的做法。 4.2.1 拼接字符串常量但字符串很长无法放到一行时，C++允许拼接字符串字面值，即将两个用引号括起来的字符串合并为一个。 事实上，任何两个有空白（空格、制表符、换行符）分割的字符串常量都将自动拼接成一个。下面语句等价： cout &lt;&lt; &quot;I&apos;d give my right arm to ba &quot; &quot;a great violinist.\n&quot;; cout &lt;&lt; &quot;I&apos;d give my right arm to ba a great violinist.\n&quot;; cout &lt;&lt; &quot;I&apos;d give my right ar&quot; &quot;m to ba a great violinist.\n&quot; 注意，拼接时不会再被连接的字符串之间添加空格，第二个字符串的第一个字符将紧接在第一个字符串的最后一个字符（不考虑\0）后面。第一个字符串中的\0会被第二个字符串中的第一个字符取代。 4.2.2 在数组中使用字符串将字符串存段数组中，常用的两种方法： 将数组初始化为字符串常量 将键盘或文件输入读入到数组中 string.cpp #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; int main() { const int Size = 15; char name1[Size]; char name2[Size] = &quot;C++owboy&quot;; cout &lt;&lt; &quot;Howdy! I&apos;m &quot; &lt;&lt; name2; cout &lt;&lt; &quot;! What&apos;s your name? \n&quot;; cin &gt;&gt; name1; cout &lt;&lt; &quot;Well, &quot; &lt;&lt; name1 &lt;&lt; endl; cout &lt;&lt; &quot;Your name has &quot; &lt;&lt; strlen(name1) &lt;&lt; &quot; letters and is stored&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Your name has &quot; &lt;&lt; sizeof(name1) &lt;&lt; &quot; bytes. \n&quot; ; name2[3] = &apos;\0&apos;; //第四个字符设置为空字符，打印字符串时，到此结束 cout &lt;&lt; &quot;First 3 characters of my name: &quot; &lt;&lt; name2 &lt;&lt; endl; return 0; } 结果：Howdy! I’m C++owboy! What’s your name? zxphelloWell, zxphelloYour name has 8 letters and is storedYour name has 15 bytes. First 3 characters of my name: C++ sizeof运算符指出整个数组的长度：15字节；但strlen()函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。另外，strlen()只计算可见的字符，空字符不计算在内。如果存储字符串cosmic,数组的长度不能短于strlen(comisc) + 1。 注意：使用符合常量表示数组长度，当修改程序以使用不同数组长度时，工作变得非常简单。 4.2.3 字符串输入程序inst1.cpp #include &lt;iostream&gt; using namespace std; int main() { const int Size = 20; char name[Size]; char dessert[Size]; cout &lt;&lt; &quot;Enter your name: \n&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;Enter your favorite dessert: \n&quot;; cin &gt;&gt; dessert; cout &lt;&lt; name &lt;&lt; &quot; like &quot;&lt;&lt; dessert &lt;&lt; endl; return 0; } 结果： [root@localhost ~]# ./a.out&lt;/br&gt; Enter your name: &lt;/br&gt; zxp&lt;/br&gt; Enter your favorite dessert:&lt;/br&gt; kk&lt;/br&gt; zxp like kk&lt;/br&gt; [root@localhost ~]# ./a.out&lt;/br&gt; Enter your name: &lt;/br&gt; zxp zxp1&lt;/br&gt; Enter your favorite dessert: &lt;/br&gt; zxp like zxp1&lt;/br&gt; 对于第二种情况，我们还没有对“输入甜点的提示”做出反应，程序便他把显示出来。 由于不能通过键盘输入空字符，因此cin需要用别的方法来字符串的结尾位置。cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。 这个例子的实际结果是，cin把zxp作为第一个字符串，并将它放到name数组中。把zxp1留在队列中，当cin在输入队列中搜索用户喜欢的甜点时，它发现了zxp1,因此cin读取zxp1,并将它放到dessert数组中。 4.2.4 每次读取一行字符串输入当程序要求用户输入城市名，用户输入New York,希望完整的存储城市名，而不仅仅是New。 istream中的类（如cin）提供了面向行的类成员：getline()和get()。这两个函数都读取一行输入，直到到达换行符。然而，随后getline()将丢弃换行符，而get()将换行符保留在输入序列中。 1、getline() 使用cin.getline()调用。该函数有两个参数： 用来存储输入行的数组的名称参数 要读取字符数的参数，getline()成员函数，在读取指定数目的字符或遇到换行符时停止读取。 例如，使用getline()将姓名读取到一个包含20个元素的name数组中： cin.getline(name, 20); 如果一行读入不超过19个字符，将全部读取到name数组中。 将instr1.cpp程序修改为使用cin.getline(),而不是简单的cin。 #include &lt;iostream&gt; using namespace std; int main() { const int Size = 20; char name[Size]; char dessert[Size]; cout &lt;&lt; &quot;Enter your name: \n&quot;; cin.getline(name, Size); cout &lt;&lt; &quot;Enter your favorite dessert: \n&quot;; cin.getline(dessert, Size); cout &lt;&lt; name &lt;&lt; &quot; like &quot;&lt;&lt; dessert &lt;&lt; endl; return 0; } 结果： [root@localhost ~]# ./a.out Enter your name: zxp zxp1 Enter your favorite dessert: kk dd zxp zxp1 like kk dd 该程序可以读取完整的姓名和用户喜欢的甜点。getline()函数每次读取一行，通过换行符来确定行尾，但不保存换行符。 2、get() get()函数的参数跟getline()相同，解释参数的方式也相同，并且都读取到行尾。但get()不丢弃换行符，而是将其留在输入队列中。假设，连续两次调用get(): cin.get(name, Arsize); cin.get(dessert, Arsize); 由于第一次调用后，换行符还在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get()默认已到达行尾，而没有读取到任何内容。 一种方法是通过使用get()的变体，使用不带参数的cin.get()调用可读取下一个字符（即使换行符），因此可以用它来处理换行符： cin.get(name, Arsize); cin.get() cin.get(dessert, Arsize); 另一种使用get()的方式是将两个类成员函数拼接起来（合并）： cin.get(name, Arsize).get(); 这样做，是由于cin.get(name, Arsize)返回一个cin对象，该对象随后调用get()函数。 下面语句跟两次调用getline()效果相同: cin.getline(name1, Arsize).getline(name1,Arsize); 使用get()使输入更仔细。例如，假设用get()将一行读入到数组中，如何直到停止的原因是由于已经读取了整行，而不是由于数组已填满。查看下一个输入字符，如果是换行符，说面已读取了整行，否则，说明该行中还有其他输入。 3、空行和其他问题 当getline()和get()读取空行时，最初的做法，下一条输入语句将在前一条getline()或get()结束读取的位置开始读取。当前做法，当get()（而不是getline()）读取空行后，将设置失效位（failbit）,这意味着接下来的输入被阻断，但可以使用如下命令来恢复输入： cin.clear() 另一个问题是：输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则getline()和get()将把余下的字符保留在队列中，而getline()还会设置失效位，并关闭后面的输入。 4.2.5 混合输入字符串和数字numstr.cpp #include &lt;iostream&gt; using namespace std; int main() { int year; char address[80]; cout &lt;&lt; &quot;Enter year:\n&quot; ; cin &gt;&gt; year; cout &lt;&lt; &quot;Enter address:\n&quot;; // cin &gt;&gt; address; cin.getline(address,80); cout &lt;&lt; &quot;Year: &quot; &lt;&lt; year &lt;&lt;endl; cout &lt;&lt; &quot;Address: &quot; &lt;&lt; address &lt;&lt; endl; return 0; } 结果： Enter year:1991Enter address:Year: 1991Address: 用户根本没有输入地址。问题在于cin读取年份，将回车生成的换行符留在的输入队列中。后面的cin.getline()看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。解决的办法是：在读取地址之前先读取并丢弃换行符。具体方法是： cin.get();//调用一个没有参数的get() 或者 cin.get(ch); //调用一个接受参数的get() 或者 (cin &gt;&gt; year).get(); 或者 (cin &gt;&gt; year).get(ch); 4.3 string类简介string类型的变量可以存储字符串，不是使用字符数组的方式存储。string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表达方式。 使用string类，必须在程序中包含头文件string。string类位于命名空间std中，因此必须通告一条using编译指令，或者使用std::string来引用它。string来定义隐藏了字符串的数组特性。 strtype1.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { char ch1[20]; char ch2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; cout &lt;&lt; &quot;Enter a king of feline:\n&quot;; cin &gt;&gt; ch1; cout &lt;&lt; &quot;Enter another king of faline: \n&quot;; cin &gt;&gt; str1; cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; &quot;ch2: &quot; &lt;&lt; ch2 &lt;&lt; endl; cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl; return 0; } 结果：Enter a king of feline:ocelotEnter another king of faline: tigerch1: ocelotch2: jaguarstr1: tigerstr2: panther string类设计让程序能够处理string的大小。例如：str1的声明创建一个长度为0的string对象，当程序将输入读取到str1中时，将自动调整str1的长度。这跟数组相比，使用string更安全方便。 char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。 C++11字符串初始化C++11也允许将列表初始化用于字符串和string对象： char ch1[] = {&quot;aaaa, 11&quot;}; string str1 = {&quot;bbb, 22&quot;} 赋值、拼接和附加使用string类时，一些操作比数组更简单。比如：不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。 char ch1[20]; char ch2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; ch1 = ch2; str1 = str2; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { char ch1[20]; char ch2[20] = &quot;jaguar&quot;; string str1; string str2 = &quot;panther&quot;; ch1 = ch2;//语法错误 str1 = str2; cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; &quot;ch2: &quot; &lt;&lt; ch2 &lt;&lt; endl; cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl; return 0; } 报错：strtype1.cpp: 在函数‘int main()’中:strtype1.cpp:14:6: 错误：无效的数组赋值 ch1 = ch2; string类简化了字符串的合并操作。可以使用+运算符将两个string对象合并，还可以将字符串附加到string对象的末尾。即： string str3; str3 = str1 + str2; str1 += str2; string类的其他操作C-风格字符串一些常用函数（包含在cstring头文件中）： 字符串赋值到字符数组中：使用strcpy()函数 将字符串附加到字符数组末尾：使用strcat()函数 获取数组字符串长度：strlen(ch1) 获取string类字符串长度： str1.size()，size()是一个类方法，只能通过所属类的对象进行调用。 strtype3.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; int main() { char ch1[20]; char ch2[20] = &quot;jaguar&quot;; int len1 = strlen(ch2); string str1 = &quot;12345&quot;; int len2 = str1.size(); strcpy(ch1, ch2 ); strcat(ch1, &quot;ccc&quot;); cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; &quot;ch2: &quot; &lt;&lt; ch2 &lt;&lt; endl; cout &lt;&lt; &quot;len1: &quot; &lt;&lt; len1 &lt;&lt; endl; cout &lt;&lt; &quot;len2: &quot; &lt;&lt; len2 &lt;&lt; endl; return 0; } 结果： ch1: jaguarccc ch2: jaguar len1: 6 len2: 5 4.3.4 string类I/Ostrtype2.cpp #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; int main() { char ch1[20]; string str1; cout &lt;&lt; &quot;ch1&apos;s length before input: &quot; &lt;&lt; strlen(ch1) &lt;&lt; endl; cout &lt;&lt; &quot;str&apos;s length before input: &quot; &lt;&lt; str1.size() &lt;&lt; endl; cout &lt;&lt; &quot;Enter a line of text: \n&quot;; cin.getline(ch1,20); cout &lt;&lt; &quot;Enter another line of text: \n&quot;; getline(cin,str1); cout &lt;&lt; &quot;ch1: &quot; &lt;&lt; ch1 &lt;&lt; &quot; it&apos;s length: &quot; &lt;&lt; strlen(ch1) &lt;&lt; endl; cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; &quot; it&apos;s length: &quot; &lt;&lt; str1.size() &lt;&lt; endl; return 0; } 结果： ch1&apos;s length before input: 6 str&apos;s length before input: 0 Enter a line of text: abc Enter another line of text: kkkk ch1: abc it&apos;s length: 3 str1: kkkk it&apos;s length: 4 用户输入之前，指定了ch1的长度为20，而输出为6，这是因为： 初始化的数组的内容未定义 函数strlen()从数组的第一个元素开始计算字节数，直到遇到空字符 在本例中，在数组中第6个字节遇到空字符。对于未被初始化的数据，第一个空字符出现的位置是随机的，也可能出现数组规定字节外，这样数组的长度大于20。 getline(ch1, 20)是一个istream类的一个类方法，第一个参数为目标数组，第二参数为数组长度。 getline(cin, str1)表明getline（）不是类方法(类方法使用句点表示法),它将cin作为参数，指出从哪里查找输入。另外，没有规定字符串的长度，string对象会根据字符串的长度自动调整大小。 getline()一个是istream的类方法，而另一个不是。在引入string之前，C++就有istream类，因此istrem设计考虑了int、double等数据类型，但没有考虑string类型，所以没有处理string对象的方法。但处理string对象的代码使用string类的一个友元函数。 4.3.5 其他形式的字符串字面值除char类型外，C++还有类型wchar_t，C++新增了char16_t和char32_t。可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分布使用前缀L、u和U来表示，如下： wchar_t a[] = L&quot;aaaa&quot;; char16_t b[] = u&quot;bbbb&quot;; char32_t c[] = U&quot;cccc&quot;; C++11还支持Unicode字符编码方案UTF-8。在这种方案中，根据编码的数字值，字符可能存储为1~4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。 C++11还增加了另一种新类型是原始(raw)字符串。在原始字符串中，字符表示的就是自己。例如：\n不表示换行符，而是两个常规的字符–斜杠和n。还有在字符中使用”,不用\”来表示。原始字符串使用”(和)”来做定界符，并使用前缀R来标识。 cout &lt;&lt; R&quot;(Jim &quot;King&quot; \n instead of endl.)&quot; &lt;&lt; &apos;\n&apos;; 输出为： Jim &quot;King&quot; \n instead of endl. 原始字符串的界定符还可以自己设定，比如：有时候需要在字符串中输入”(或者)”,这是需要自定义界定符。可以在”和(之间添加任意符号，这样在字符串结尾的)和”之间也要添加这些字符。比如：使用R”+#(标识字符串的开头，必须使用)(+#”作为原始字符串的结尾。因此由： cout &lt;&lt; R&quot;+#(Jim Keing&quot;(hello world)&quot;)+=&quot; &lt;&lt; endl; 4.4 结构简介结构是一种比较灵活的数据格式，同一个结构中可以存储多种类型的数据。结构也是C++面向对象(类)的基石。结构是用户自定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。创建一个结构包括两步：定义结构描述；按描述创建结构变量。 结构描述如下： struct inflatable { char name[20]; float volume; double price; } 其中关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称，因此新类型的名称为inflatable。定义结构后，便可以创建这种类型的变量： inflatable hat; inflatable mainframe; C中要求添加struct关键字,如下： struct inflatable hat; 因为hat的类型为inflatable，因此可以是一个.操作符访问各个成员。比如：hat.volume指的是结构得volume成员。 4.4.1 程序中使用结构体structur.cpp #include &lt;iostream&gt; using namespace std; struct inflatable { char name[20]; float volume; double price; }; int main() { inflatable guest = {&quot;gloria&quot;, 1.88, 29.99}; inflatable pal = {&quot;Arthur&quot;, 3.12, 32.99}; cout &lt;&lt; &quot;Guest: &quot; &lt;&lt; guest.name &lt;&lt; &quot; &quot; &lt;&lt; guest.volume &lt;&lt; &quot; &quot; &lt;&lt; guest.price &lt;&lt; endl; cout &lt;&lt; pal.price + guest.price &lt;&lt; endl; return 0; } 结果：Guest: gloria 1.88 29.9962.98 结果声明声明得位置有两种选择，第一，放在main()函数中；第二，放在main()函数的前面，其他函数也可以访问。变量也可以在函数内部和外部定义，外部定义由所有函数共享。 C++结构初始化与数组踹坏，C++也支持列表初始化用于结构，且等号是可选的： inflatable duck {&quot;Daphe&quot;, 0.12, 9,89}; 其次，如果大括号内为空，各个成员初始化为零。如下： inflatable mayor {}; 最后，不允许缩窄转换。 结构可以使用string类o成员struct inflatable { std::string name; float volume; double price; }; 其他结构属性 结构变量之间可以使用赋值运算符; 结构可以作为参数传递给函数，也可以让函数返回一个结构； assgn_st.cpp #include &lt;iostream&gt; using namespace std; struct inflatable { char name[20]; float volume; double price; }; int main() { inflatable bou = {&quot;sun&quot;, 0.2, 12.49}; inflatable choice; choice = bou; cout &lt;&lt; &quot;choice: &quot; &lt;&lt; choice.price &lt;&lt; endl; return 0; } 结果： choice: 12.49 从中可见成员赋值是有效的，choice结构中的成员值与bouquet结构中存储的值相同。 可以同时完成定义结构和创建结果的工作，如下： struct perks { int key_num; char car[12]; }mr_smith, ms_jones; 甚至可以初始化以这种方式创建的变量： struct perks { int key_num; char car[12]; }mr_smith ={7, &quot;Packard&quot;}; 还可以声明没有名称的结构体，这样以后无法创建这种类型的变量，如下： struct { int key_num; char car[12]; }mr_smith; 创建了一个mr_smith变量，可以访问其中的成员。 4.4.5 结构数组可以创建结构数组，比如，创建一个包含100个inflatable结构的数组，如下： inflatable gifts[100]; 这样gifts是一个inflatable数组，其中的每个元素(如gifts[0])都是inflatable对象，可以与成员运算符一起使用： cin &gt;&gt; gifts[0].volume; gifts本身是一个数组，不是一个结构。因此gifts.price是无效的。 初始化结构数组，可以结合使用初始化数组的规则，具体如下： inflatable guests[2] = { {&quot;zzz&quot;, 1.2, 33.4}, {&quot;ddd&quot;, 0.4, 33,2} }; 4.4.6 结构中的位字段C++允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段(bit field)。下面是一个例子： struct torgle_register { unsigned int SN : 4; ussigned int :4 ; bool goodIn : 1; bool goodTorgle : 1; } 可以先通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段： torgle_register tr = {14, true, false}; cout &lt;&lt; tr.goodIn; 位字段一般使用在低级编程中。 4.5 共用体共用体(union)是一种数据格式，它能够存储不同的数据格式，但只能同时存储其中的一种类型。即，结构体可以同时存储int、long和double,共用体只能存储int、long或double。共用体的句法与结构体相似，但含义不同。 union one4all { int int_val; long long_val; double double_val; } 可以使用one4all变量来存储int、long或double，条件是在不同的时间进行： one4all pail; pail.int_val = 15; cout &lt;&lt; pail.int_val; pail.double_val = 2.2; //int_val的值丢失 cout &lt;&lt; pail.double_val; 因此，pail有时可以是int变量，而有时是double类型的变量。通用体每次只能存储一个值，因此必须有足够大的空间来存储最大的成员，所以共用体的长度为其最大成员的长度。 共用体的用处之一是，但数据项使用两种或多种格式时，可节省空间。例如：管理一个小商品目录，其中一些商品的ID为整型，而另一些为字符串。在这种情况可以如下： struct widget { char brand[20]; int tyep; union id { long id_num; char id_char[20]; } id_val; }; widget prize; if (prize.type == 1) cin &gt;&gt; prize.id_val.id_num; else cin &gt;&gt; prize.id_val.id_char; 匿名共用体没有名称，其成员将成为位于相同地址出的变量，显然，每次只有一个成员是当前的成员： struct widget { char brand[20]; int tyep; union { long id_num; char id_char[20]; } ; }; widget prize; if (prize.type == 1) cin &gt;&gt; prize.id_num; else cin &gt;&gt; prize..id_char; 由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。共用体用于节省内存。但C++用于嵌入式编程，如控制烤箱或火星漫步者的处理器，内存非常宝贵。 4.6 枚举C++的enum工具提供了另一种创建符号常量的方式，这种方式可以替代const。它还允许定义新类型，但必须按照严格的限制进行。使用enum句法与使用结构相似。例如: enum spectrum {red, orange, yellow, green, blue, violet, indigo ultraviolet}; 该语句完成了两个工作: 让spectrum成为新类型的名称：spectrum被称为枚举(enumeration) 将red、orange等作为符号常量，它们对应整数值0~7，这些常量叫做枚举量。 利用枚举类型来声明这种类型的变量： spectrrm band; 对于枚举类型，只定义了赋值运算符，具体说，没有为枚举定义算术运算： band = orange; ++band; //非法 band = orange + yellow; //非法 band = 2000; //非法，2000不是一个枚举类型 枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型： int color = bule; band = 3; //非法 color = 3 + red; 如果int值是有效的，则可以通过强制类型转换，将它赋值给枚举变量： band = spectrum(3); 如果试图对一个适当的值进行强制类型转换，结果是不确定的，不会报错： band = spectrum(5000); 如果只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称，如下： enum {red, orange, yellow, green, blue, violet, indigo ultraviolet}; 4.6.1 设置枚举量的值可以使用赋值运算符来显示地设置枚举量的值： enum bits {one = 1, two = 2, four = 4, eight = 8}; 指定的值必须是整数，也可以只显示地定义其中一些枚举量地值： enum bigstep {first, second = 100, third}; 这里，first在默认情况下为0，后面没有被初始化地枚举量地值将比其前面的枚举量大1.因此third的值为101。 最火，可以创建多个值相同的枚举量： enum {zero, null = 0, one, numero_nuo = 1}; 其中，zero,null的值都没零，one和numero_nuo都为1。在早期，只能将int值赋给枚举类型，但这种限制取消了，因此可以使用long甚至long long类型的值。 4.6.2 枚举的取值范围对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都要取值范围，通过强制类型转换，可以将取值范围中的任何整数赋值给枚举变量，即使这个值不是枚举类型，如下: enum bits{one=1, two=2, four=4, eight=8}; bits myflag; 下面的代码合理： myflag = bits(6); 其中6不是枚举类型，但它位于枚举定义的取值范围内。 取值的范围定义如下：首先，找出上限，需要知道枚举的最大值。找出大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。计算下限，需要知道枚举量的最小值，如果它不小于0，则取值范围的下限为0；否则采用与寻找上限方式相同的方式，但加上负号。 例如:前面定义的bigstep的最大枚举值是101。在2的幂中，比这个数大的最小值是128，因此取值范围的上限为127。对于下限，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8，因此下限为-7。 4.7 指针和自由存储空间使用&amp;地址运算符，获取变量的地址。例如，如果home是一个变量，则&amp;home是它的地址。 #include &lt;iostream&gt; int main() { using namespace std; int donuts = 6; double cups = 4.5; cout &lt;&lt; &quot;donuts&apos;s addresss: &quot; &lt;&lt; &amp;donuts &lt;&lt; endl; cout &lt;&lt; &quot;cups&apos;s addresss: &quot; &lt;&lt; &amp;cups &lt;&lt; endl; return 0; } 结果：donuts’s addresss: 0x7ffe74cc89b8cups’s addresss: 0x7ffe74cc89b4 显示地址时，该实现的cout使用十六进制表示法，因为这是常用于描述内存的表示法。两个地址的差为：0x7ffe74cc89b8-0x7ffe74cc89b4（即4）,在实现中，donuts的存储位置比cups低，而这种类型使用4个字节。当然，不同的系统，存储的顺序以及字节大小都不同。 指针与C++基本原理： 面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段进行决策。运行阶段指的是程序正在运行，编译阶段指的是编译器将程序组合起来。运行阶段是做决策，程序应该如何运行，而编译阶段是安全预先设定的程序运行。 运行阶段决策提供了灵活性，可以根据当时的情况进行调整。比如：考虑为数组分配内存的情况。 一种特殊的变量–指针用于存储地址的值。$\ast$运算符被称为间接值或解除引用。 pointer.cpp #include &lt;iostream&gt; int main() { using namespace std; int updates = 6; int *p_updates; p_updates = &amp;updates; cout &lt;&lt; &quot;*p_updates: &quot; &lt;&lt; *p_updates &lt;&lt; endl; cout &lt;&lt; &quot;p_updates: &quot; &lt;&lt; p_updates &lt;&lt; endl; *p_updates = 1 + *p_updates; return 0; } 结果：$\ast$p_updates: 6p_updates: 0x7ffc6c803fa4$\ast$p_updates + 1: 7 从中可知，p_updates表示地址，使用$\ast$号运算符来获得值。$\ast$p_updates和updates完全等价。可以像int变量一样使用$\ast$p_updates。 4.7.1 声明和初始化指针声明指针，计算机需要跟踪指针指向的值的类型。比如：char的地址和double的地址，看上去一样，但char和double使用的字节数不同，它们存储值得内部格式不同。 int * p_updates; 或 int *p_updates; 或 int* p_updates; //int* 是一种类型--指向int的指针。 或 int*p_updates; 这表明，$\ast$updates的类型为int。由于$\ast$运算符被用于指针，因此p_updates变量本身必须是指针。 int* p1, p2; 注意上面的语句是创建一个指针(p1)和一个int变量(p2)。对于每个指针变量名，都需要使用一个$\ast$。 double * tax; char* str; 将tax声明为一个指向double的指针，编译器知道$\ast$tax是一个double类型的值。即$\ast$tax是一个以浮点数格式存储的值，这个值占据8个字节（不同系统可能不同）。指针变量不仅仅是指针，而且是指向特定类型的指针。虽然，tax和str指向两种不同长度的叔叔类型，但这两个变量本身的长度是相同的，即char的地址和double的地址的长度相同。 可以在声明语句中初始化。 int h = 5; int *ph = &amp;h; 被初始化的是指针，而不是它指向的值，即pt的值设为&h;而不是$\ast$pt的值。 4.7.2 指针的危险在C++中创建地址时，计算机分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步是错误的，如下： long * fellow; *fellow = 222; fellow确实是一个指针。上述代码没有将地址赋给fellow,那么222将被存放在哪里？由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储222的地址。 注意：一定要在对指针应用解除引用运算符（$\ast$）之前，将指针初始化为一个确定的、适当的地址。 4.7.3 指针和数字指针不是整型，索然计算机通常把地址当作整数处理。指针没有加减乘除运算，指针描述的是位置。不能简单的对将整数赋给地址： int *pt; pt = 0xB8000000; 在C++中，编译器将显示错误信息，类型不匹配。要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型： int *pt; pt = (int*) 0xB8000000; 这样，赋值语句两边都是整型的地址，因此赋值有效。pt是int值的地址，并不意味着pt本身的类型是int。 4.7.4 使用new来分配内存在C语言中，可以使用库函数malloc()来分配内存；而在C++让可以这样做，但C++提供了更好的方法—new运算符。 在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值： int *pn = new int; new int告诉程序，需要适合存储int的内存。new运算符根据类型确定需要多少字节的内存，然后找到这样的内存，并返回其地址，并将地址赋给pn，pn是被声明为指向int的指针。现在pn是地址，$\ast$pn存储那里的值。将这种方法于将变量的地址赋给指针进行对比: int h = 5; int *ph = &amp;h; 在这两种情况下，都是将一个int变量的地址赋给了指针。在第二种情况，可以通过变量名了访问该int值，而第一种情况只能通过指针进行访问。 为数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式： typeName *pointer_name = new typeName; use_new.cpp #include &lt;iostream&gt; int main() { using namespace std; int nights = 1001; int *pt = new int; *pt = 1001; cout &lt;&lt; &quot;*pt: &quot; &lt;&lt; *pt &lt;&lt; endl; cout &lt;&lt; &quot;pt: &quot; &lt;&lt; pt &lt;&lt; endl; cout &lt;&lt; &quot;&amp;nights: &quot; &lt;&lt; &amp;nights &lt;&lt; endl; return 0; } 结果：*pt: 1001pt: 0x220c010&amp;nights: 0x7ffc241baf94 new为int数据对象分配内存，这是在程序运行时进行的。指针必须声明所指向的类型的原因是：地址本身只指出了对象存储的地址开始，而没有指出其类型(使用的字节数)。 对于指针，new分配的内存块于常规变量声明分配的内存块不同。变量nights的值存储在被称为栈的内存区域中，new从被称为堆或自由存储区的内存区域分配内存。 4.7.5 使用delete释放内存需要内存时，使用new来请求。使用完内存后，使用delete运算符将其归还给内存池。一定要配对使用new和delete，否则会发送内存泄漏，即被分配的内存再也无法使用。如果泄漏严重，则程序将由于不断寻找更多内存而终止。 int *ps = new int; delete ps; 不用使用delete释放已经释放的内存，这样做结果是不确定的。另外，不要使用delete来释放声明变量所获得的内存： int jugs = 5; int *pi = &amp;jugs; delete pi; //不允许，错误的做法 注意：只能用delete释放使用new分配的内存，然后，对空指针使用delete是安全的。 使用delete的关键在于，将它用于new分配的地址，而不意味着要使用用于new的指针，而是用户new的地址： int *ps = new int; int *pq = ps; delete pq; 一般来说，不要创建两个指向同一个内存块的地址，因为这样增加错误地删除同一个内存块两次的可能性。但，对于返回指针的函数，使用另一个指针是有道理的。 4.7.6 使用new来创建动态数组在编程时给数组分配内存被称为静态联编，意味着数组在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它，如果不需要，则不创建。还可以在程序运行时选择数组的长度，这种被称为动态联编，意味着数是在程序运行时创建的。这种数组叫作动态数组。 1、使用new创建动态数组 在C++中创建动态数组：只要将数组元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素的数目： int *psome = new int[10]; delete [] psome; 创建了一个包含10个int元素的数组。并使用delete对分配的内存进行释放。释放内存时，方括号告诉程序，应该释放整个数组，而不仅仅是指针指向的元素。 程序确实跟踪了分配的内存量，以便以后使用delete []正确地释放这些内存，但这种信息是不公用的。例如:不能使用sizeof运算符来确定动态数组分配的数组包含的字节数。 2、使用动态数组 *psome是第1个元素的值,psome[0]同样是第一个元素的值。psome[1]是第2个元素的值，以此类推。 arraynew.cpp #include &lt;iostream&gt; int main() { using namespace std; double *p3 = new double [3]; p3[0] = 0.2; p3[1] = 0.5; p3[3] = 0.8; cout &lt;&lt; &quot;p3[1]: &quot; &lt;&lt; p3[1] &lt;&lt; endl; p3 = p3 + 1; cout &lt;&lt; &quot;p3+1,p3[0]: &quot; &lt;&lt; p3[0] &lt;&lt; endl; p3 = p3 - 1; delete [] p3; return 0; } 结果：p3[1]: 0.5p3+1,p3[0]: 0.5 从中可知，程序将指针p3当作数组名来使用，p3[0]表示第1个元素，依次类推。不过指针和数组名之间有差别的，不能更改数组名的值，但指针是变量，因此可以修改它的值： p3 = p3 + 1; 将p3加1的效果，是将p3[0]指向数组中的第2个元素。将它减1后，指针将指向原来的值，这样程序可以给delete[]提供正确的地址。 4.8 指针、数组和指针算术指针和数组基本等级的原因在于指针运算符和C++内部处理数组的方式。将指针加1后，增加的量等于它所指向的类型的字节数。比如：将double类型的指针加1后，如果系统double使用8个字节存储，则数值将加8。另外，C++将数组名解释为地址。 addpntrs.cpp #include &lt;iostream&gt; int main() { using namespace std; double wages[3] = {1000.0, 2000.0, 3000.0}; short stacks[3] = {3, 2, 1}; double *pw = wages; short *ps = &amp;stacks[0]; cout &lt;&lt; &quot;pw = &quot; &lt;&lt; pw &lt;&lt; &quot;, *pw = &quot; &lt;&lt; *pw &lt;&lt; endl; pw = pw + 1; cout &lt;&lt; &quot;Add 1 to the pw pointer:\n&quot;; cout &lt;&lt; &quot;pw = &quot; &lt;&lt; pw &lt;&lt; &quot;, *pw = &quot; &lt;&lt; *pw &lt;&lt; endl; cout &lt;&lt; &quot;ps = &quot; &lt;&lt; ps &lt;&lt; &quot;, *ps = &quot; &lt;&lt; *ps &lt;&lt; endl; ps = ps + 1; cout &lt;&lt; &quot;Add 1 to the ps pointer:\n&quot;; cout &lt;&lt; &quot;ps = &quot; &lt;&lt; ps &lt;&lt; &quot;, *ps = &quot; &lt;&lt; *ps &lt;&lt; endl; cout &lt;&lt; &quot;stacts[0] = &quot; &lt;&lt; stacks[0] &lt;&lt; endl; cout &lt;&lt; &quot;*(stacks + 1) = &quot; &lt;&lt; *(stacks+1) &lt;&lt; endl; cout &lt;&lt; &quot;Wages array size: &quot; &lt;&lt; sizeof(wages) &lt;&lt; endl; cout &lt;&lt; &quot;pw pointer size: &quot; &lt;&lt; sizeof(pw) &lt;&lt; endl; return 0; } 结果： pw = 0x7ffedfcf9060, *pw = 1000 Add 1 to the pw pointer: pw = 0x7ffedfcf9068, *pw = 2000 ps = 0x7ffedfcf9050, *ps = 3 Add 1 to the ps pointer: ps = 0x7ffedfcf9052, *ps = 2 stacts[0] = 3 *(stacks + 1) = 2 Wages array size: 24 pw pointer size: 8 4.8.1 程序说明在多数情况下，数组名解释为数组的第一个元素的地址。因此，下面语句将pw声明为指向double类型的指针，然后将它初始化为wages—wages数组中第一个元素的地址： double *pw = wages; 和所有数组一样，有： wages = &amp;wages[0]; //第一个元素的地址 程序查看了pw和$\ast$pw的值，前者是地址，后者是存储在该地址的值。pw加1，数字地址值增加8（double类型）这样pw指向数组中第二个元素。而对于ps(short类型)，ps+1,其地址值将增加2。 注意：将指针变量加1后，其增加的值等于指向的类型所占用的字节数。 stacks[1]和$\ast$(stacks+1)等价，$\ast$(stacks+1意味着先计算数组第2个元素的地址，然后找到存储在那里的值。（运算符优先级要求使用括号，如果不使用将给$\ast$stacks的值加1）。 对于数组和指针，c++可以执行下面的转换： arrayname[i]; -&gt; *(arrayname+1); pointername[i]; -&gt; *(pointername+1); 数组和指针的区别在于，数组名是常量，而指针可以修改其值。如下： arrayname = arrayname + 1;//错误 pointername = pointername + 1; 另一个区别，对于数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof运算符得到的指针的长度，即使指针指向一个数组。在上述程序中有体现。 数组的地址数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址： short tell[10]; cout &lt;&lt; tell &lt;&lt; endl; //第一个元素的地址 cout &lt;&lt; &amp;tell &lt;&lt; endl; //整个数组的地址 从数字上说，这两个值是相等的；但概念上，tell(&amp;tell[0])是一个2字节内存块的地址，而&amp;tell是一个20字节的内存块地址。因此表达式tell+1将地址值加1，而表达式&amp;tell+2将地址加20。即：tell是一个short指针($\ast$short),而&amp;tell是一个指向包含20个元素的short数组（short($\ast$)[20]）的指针。 short (*pas)[20] = &amp;tell; pas的类型为short($\ast$)[20]，由于pas被设置为&amp;tell,因此*pas于tell等价，即($\ast$pas)[0]为tell数组的第一个元素。其中括号不能少，否则，pas是一个short指针数组，它包含20个元素。 4.8.2 指针小结1、声明指针 typeName * pointername; double *pn; char *pc; 2、给指针赋值 对变量使用&amp;运算符，来获取被命名的内存的地址，new运算符返回未命名的内存的地址。 double *pn; char * pc; couble * pa; double bud = 2.33; pn = &amp;bud; pc = new char; pa = new double [10]; 3、对指针解除引用 对指针解除引用意味着获取指针指向的值。 cout &lt;&lt; *pn; *pc = &quot;s&quot;; pa[1] = 2.11; 决不要对未被初始化为适当地址的指针解除引用。 4、区分指针和指针指向的值 pt是指向int的指针，则$\ast$pt是指向int类型的变量的值。 int *pt = new int; *pt = 3; 5、数组名 在多数情况下，C++将数组名视为数组第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度。 6、指针算术 C++允许将指针和整数相加。还可以将一个指针减去另一个指针，获得两个指针的差，仅当两个指针指向同一个数组时，运算才有意义。 int tacos[10] = {2,3,4,5,6,8,9,1,0,7}; int *pt = tacos; pt = pt + 1; int *pe = &amp;tacos[9]; pe = pe - 1; int diff = pe - pt; 7、数组的动态联编和静态联编 使用数组声明来创建数组时，采用静态联编，即数组的长度在编译时给定： int tacos[10]; 使用new[] 运算符创建数组时，将采用动态联编，即将在运行时为数组分配空间，其长度也在运行时设置： int size; cin &gt;&gt; size; int *pz = new int [size]; delete [] pz; 8、数组表示法和指针表示法 tacos[0]; 等价于 *tacos; tacos[3]; 等价于 *(tacos+3); 数组名和指针变量都是如此，因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。 4.8.3 指针和字符串cout对象认为char的地址是字符串的地址，因此它打印该地址处的地址，然后继续打印后面的字符，知道遇到空字符(\0)为止。如果要获取字符串数组的地址，需要进行强制转换，如（int*）flower。而且，”are red”字符串常量，为了保持输出一致，这个引号括号起来的字符串也是一个地址。 注意：在cout和多数C++表达式中，char数组名、char指针以及引号括起来的字符串常量都被解释为字符串第一个字符的地址。 ptrstr.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; int main() { using namespace std; char animal[20] = &quot;bear&quot;; const char *bird = &quot;wren&quot;; char *ps; cout &lt;&lt; animal &lt;&lt; &quot; and &quot; &lt;&lt; bird &lt;&lt; endl; //cout &lt;&lt; ps &lt;&lt; endl; cout &lt;&lt; &quot;Enter a kind of animal:&quot;; cin &gt;&gt; animal; ps = animal; cout &lt;&lt; ps &lt;&lt; endl; cout &lt;&lt; &quot;Before using strcpy():\n&quot;; cout &lt;&lt; animal &lt;&lt; &quot; at &quot; &lt;&lt; (int *)animal &lt;&lt; endl; cout &lt;&lt; ps &lt;&lt; &quot; at &quot; &lt;&lt; (int*)ps &lt;&lt; endl; ps = new char[strlen(animal) + 1]; strcpy(ps, animal); cout &lt;&lt; &quot;After using strcpy():\n&quot;; cout &lt;&lt; animal &lt;&lt; &quot; at &quot; &lt;&lt; (int *)animal &lt;&lt; endl; cout &lt;&lt; ps &lt;&lt; &quot; at &quot; &lt;&lt; (int*)ps &lt;&lt; endl; return 0; } 结果： bear and wren Enter a kind of animal:fox fox Before using strcpy(): fox at 0x7ffd1b868460 fox at 0x7ffd1b868460 After using strcpy(): fox at 0x7ffd1b868460 fox at 0xe91010 其中”wren”实际表示的是字符串的地址，因此”const char $\ast$bird = “wren”;”语句是将”wren”的地址赋给了bird指针。程序中将bird指针声明为const，因此编译器将禁止改变bird指向的位置中的内容。 获得字符串副本，首先，需要分配内存来存储该字符串，这可以通过声明一个数组或使用new来完成。后一种方法使得能够根据字符串长度来指定所需的空间： ps = new char[strlen(animal) + 1]; 然后，需要将animal数组中的字符串复制到新分配的空间中。将animal赋给ps是不可行的，因为这样只能修改存储在ps中的地址，从而失去程序访问新分配内存的唯一途径，需要使用库函数strcpy(): strcpy(ps, animal); strcpy()函数接收两个参数，第一个是目标地址，第二个是要赋值的字符串的地址。通过使用new和strcpy()，将获得”fox”两个独立的副本。 fox at 0x7ffd1b868460 fox at 0xe91010 经常需要将字符串放到数组中。初始化数组时，使用”=”运算符；否则使用strcpy()或strncpy()。 char food[20] = &quot;carrots&quot;; strcpy(food, &quot;flan&quot;); strcpy(food, &quot;a picnic basket filled with many goodies&quot;);//导致问题，food数组比字符串小。 对于最后一种情况，函数将字符串剩余的部分复制到数组后面的内存字节中，这可能覆盖程序正在使用的其他内存。要避免这种问题，使用strncpy()。该函数接收第3个参数–要复制的最大字符数。 strncpy(food, &quot;a picnic basket filled with many goodies&quot;, 19); food[19] = &apos;\0&apos;; 这样最多将19个字符复制到数组中，然后最后一个元素设置为空字符。如果该字符串少于19个字符，则strncpy()将在复制完成字符串之后加上空字符，以标记字符串的结尾。 4.8.4 使用new创建动态结构在运行时创建数组优于在编译时创建数组，对于结构也如此。对于new用于结构由两步组成：创建结构和访问其成员。创建结构，需要同时使用结构类型和new。如下： inflatable *ps = new inflatable; 这样把足以存储inflatable结构的一块可用内存的地址赋给ps。这种句法和C++内置类型完全相同。接下来是成员访问，创建动态结构时，不能使用运算符句点用于结构，因为这种结构没有名称，只知道其地址。C++专门提供了箭头成员运算符（-&gt;）。该运算符由连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结构名一样。例如：ps-&gt;price。 另一种访问结构的方法是，如果ps是指向结构的指针，则$\ast$ps就是被指向的值—结构本身。由于$\ast$ps是一个结构，因此($\ast$ps).price是该结果的price成员。C++的运算符优先级规则要求使用括号。 newstrct.cpp #include &lt;iostream&gt; struct inflatable { char name[20]; float volume; double price; }; int main() { using namespace std; inflatable *ps = new inflatable; cout &lt;&lt; &quot;Enter name of infaltable item: &quot;; cin.get(ps-&gt;name, 20); cout &lt;&lt; &quot;Enter volume of inflatable item: &quot;; cin &gt;&gt; (*ps).volume; cout &lt;&lt; &quot;Enter price of inflatable item: &quot;; cin &gt;&gt; ps-&gt;price; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; (*ps).name &lt;&lt; endl; cout &lt;&lt; &quot;Volume: &quot; &lt;&lt; ps-&gt;volume &lt;&lt; endl; cout &lt;&lt; &quot;Price: &quot; &lt;&lt; ps-&gt;price &lt;&lt; endl; return 0; } 结果： Enter name of infaltable item: Frodo Enter volume of inflatable item: 1.4 Enter price of inflatable item: 27.99 Name: Frodo Volume: 1.4 Price: 27.99 1. 一个使用new和delete的示例 delete.cpp定义了一个函数getname()，该函数返回输入字符串的指针。该函数将输入读入到一个大型临时数组中，然后使用new[]来创建一个刚好存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以大大节省内存。 假设程序需要读取100个字符串，其中最大的字符串包含79个字符，而大多数字符串都短得多。如果用char数组来存储这些字符串，则需要100个数组，其中每个数组的长度为80个字符，总共需要8000多个字节，而其中大部分内存没有被使用。 另一种方法，创建一个数组，它包含100个指向char的指针，然后使用new根据字符串的需要分配相应数量的内存。还可以使用new根据需要的指针数量来分配空间。 delete.cpp #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; char * getname(void); int main() { char *name; name = getname(); cout &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; (int*)name &lt;&lt; endl; delete [] name; name = getname(); cout &lt;&lt; name &lt;&lt; &quot; at &quot; &lt;&lt; (int*)name &lt;&lt; endl; delete [] name; return 0; } char * getname() { char temp[80]; cout &lt;&lt; &quot;Enter last name: &quot;; cin &gt;&gt; temp; char *pn = new char [strlen(temp)+1]; strcpy(pn, temp); return pn; } 结果： Enter last name: Fred Fred at 0x1c76010 Enter last name: Zll Zll at 0x1c76010 2. 程序说明 getname()函数，使用cin将输入的字符串放到temp数组中，然后使用new分配行内存，以存储该字符串。程序需要strlen(temp)+1个字符（包括空字符）来存储该字符串，将这个值提供给new。获得空间后，getname()使用标准库函数strcpy()将temp中的字符串复制到新的内存块中。最后返回pn，这是字符串副本的地址。 在main()中，返回值（地址）被赋值给name。该指针是在main()中定义的，但它指向getname()函数中分配的内存块。接下来，在释放name指向的内存快后，main()再次调用getname()。C++不保证新释放的内存就是下一次使用new时选择的内存，但该例子中刚好是的。 在这个例子中，getname()分配内存，而main()释放内存，将new和delete放在不同的函数通常不是一个好办法，因为这样容易忘记使用delete。不过这样做确实可以。 4.8.5 自动存储、静态存储和动态存储根据用户分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存储时间的长短方面，以这3种方式分配的数据对象各不相同。 1、自动存储 在函数内存定义的常规变量使用自动存储空间，被称为自动变量。即它们在所属的函数被调用时自动产生，在该函数结束时消亡。例如delete.cpp中的temp数组仅当getname()函数活动时存在。当程序控制权回到main()时，temp使用的内存自动释放。 实际上，自动变量是一个局部变量，其作用域为包含它的代码块。自动变量通常存储在栈中，这意味着执行代码块时，其中的变量将依次加入栈中，而在离开代码时，将按照相反的顺序释放这些变量。这被称为后进先出（LIFO）。 2、静态存储 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态存储的方式有两种: 在函数外面定义它 在声明使用关键字static static double fee = 44.3; 自动存储和静态存储的关键在于：这些方法严格限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是特定函数被执行时存在（自动变量）。 3、动态存储 new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++被称为自由存储空间或堆。该内存池同用于静态变量和自动变量的内存是分开的。 数据的生命周期不完全受程序或函数的生存控制。与常规的变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。在栈中，自动添加和删除机制使得占用的内存是连续，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪内存的位置更困难。 内存泄漏 如果使用new运算符在自由存储空间（堆）上创建变量后，没有调用delete，则即使包好指针的内存由于作用域和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间的结构，因为指向这些内存的指针无效。这将导致内存泄漏。泄漏的内存，将在程序整个生命周期内不可使用，这些内存被分配出去，无法回收。极端情况，内存泄漏可能导致程序崩溃。 4.9 类型组合struct antarctica_year_end { int year; }; 可以创建这种类型的变量： antarctica_year_end s01, s02, s03; 然后，使用成员运算符来访问其成员： s01.year = 1998; 可以创建指向这种结构的指针： antarctica_year_end *pa = &amp;s02; 将指针设置为有效地址后，就可以使用间接成员运算符来访问成员： pa-&gt;year = 1999; 可创建结构数组： antarctica_year_end trio[3]; 然后，使用成员运算符来访问元素的成员： trio[0].year = 2003; 由于数组名是一个指针，因此可以使用间接成员运算符： (trio+1)-&gt;year = 2004; 可创建指针数组： const antarctica_year_end *arp[3] = {&amp;s01,&amp;s02,&amp;s03}; arp是一个指针数组，arp[1]就是一个指针，可将间接运算符应用于它： cout &lt;&lt; arp[1]-&gt;year &lt;&lt; endl; 可创建指向上述数组的指针： const antarctica_year_end **ppa = arp; 其中arp是一个数组名，因此它是第一个元素的地址。但其第一元素为指针，因此ppa是一个指针，指向const antarctica_year_end的指针。这样容易出错，比如忘记const，搞错顺序或结构类型，C++11提供了auto，编译器知道arp的类型能过正确地推断出ppb的类型： auto ppb = arp; ppa是一个指向结构指针的指针，因此*ppa是一个结构指针，可间接成员运算符应用于它： cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; endl; cout &lt;&lt; (*(ppa+1))-&gt;year &lt;&lt; endl; mixtype.cpp #include &lt;iostream&gt; struct antarctica_year_end { int year; }; int main() { using namespace std; antarctica_year_end s01, s02, s03; s01.year = 1998; antarctica_year_end *pa = &amp;s02; pa-&gt;year = 1999; antarctica_year_end trio[3]; trio[0].year = 2003; cout &lt;&lt; trio-&gt;year &lt;&lt; endl; const antarctica_year_end *arp[3] = {&amp;s01,&amp;s02,&amp;s03}; cout &lt;&lt; arp[1]-&gt;year &lt;&lt; endl; const antarctica_year_end **ppa = arp; cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; endl; cout &lt;&lt; (*(ppa+1))-&gt;year &lt;&lt; endl; return 0; } 结果： 2003 1999 1998 1999 4.10 数组的替代品4.10.1 模板类vector模板类vector类类似于string类，也是一种动态数组。可以运行阶段设置vector对象的长度，可在末尾附加新数据，还可以在中间插入新数据。实际上，vector使用new和delete来管理内存，但这种工作是自动完成的。 首先，使用vector类，必须包含头文件vector；其次，vector包含在命名空间std中，因此可以使用using编译指令、using声明或std::vector；然后，模板使用不同的语法来指出它存储的数据类型；最后，vector类使用不同的语法来指定元素数。 #include &lt;vector&gt; using namespace std; vector&lt;int&gt; vi; //创建一个int类型空数组 int n; cin &gt;&gt; n; vector&lt;double&gt; vd(n); //创建一个double类型n个元素的数组 其中vi是一个vector对象，vd是一个vector对象。由于vector对象在插入或添加值时自动调整长度，因此可以在将vi的长度初始化为0。但要调整长度，需要使用vector包中的各种方法。 一般而言，创建一个名为vt的vector对象，它可存储n_elem个类型typeName的元素： vector&lt;typeName&gt; vt(n_elem); 4.10.2 模板类array(C++11)vector类的功能比数组强大，但付出的代价是效率低。如果需要的是固定长度的数组，使用数组是更佳的选择，但代价是不那么方便。鉴于此，C++新增了模板类array，它也位于命名空间std中。与数组一样，array对象的长度也是固定，也使用栈（静态内存分配），而不是自由存储区，因此效率与数组相同，但更方便，更安全。需要包含头文件array。创建arry对象的语法： #include &lt;array&gt; using namespace std; array &lt;int,5&gt; ai; array&lt;double,4&gt; ad = {1.2, 1.3, 2.2, 2.3}; 创建一个名为arr的array对象，它包含n_elem个类型为typeName的元素： array &lt;typeName, n_elem&gt; arr; 4.10.3 数组、vector对象、array对象比较choices.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;array&gt; int main() { using namespace std; double a1[4] = {1.2, 1.4, 2.2, 2.3}; vector&lt;double&gt; a2(4); a2[0] = 1.0/3.0; a2[1] = 1.0/5.0; a2[2] = 1.0/7.0; a2[3] = 1.0/9.0; array&lt;double, 4&gt; a3 = {3.14, 2.72, 1.62, 1.41}; array&lt;double, 4&gt; a4; a4 = a3; cout &lt;&lt; &quot;a1[2]:&quot; &lt;&lt; a1[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a1[2] &lt;&lt; endl; cout &lt;&lt; &quot;a2[2]:&quot; &lt;&lt; a2[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a2[2] &lt;&lt; endl; cout &lt;&lt; &quot;a3[2]:&quot; &lt;&lt; a3[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a3[2] &lt;&lt; endl; cout &lt;&lt; &quot;a4[2]:&quot; &lt;&lt; a4[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a4[2] &lt;&lt; endl; a1[-2] = 20.2; cout &lt;&lt; &quot;a1[-2]:&quot; &lt;&lt; a1[-2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a1[-2] &lt;&lt; endl; cout &lt;&lt; &quot;a3[2]:&quot; &lt;&lt; a3[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a3[2] &lt;&lt; endl; cout &lt;&lt; &quot;a4[2]:&quot; &lt;&lt; a4[2] &lt;&lt; &quot; at &quot; &lt;&lt; &amp;a4[2] &lt;&lt; endl; return 0; } Linux下使用C++11版本运行:g++ -std=c++11 choices.cpp 结果： a1[2]:2.2 at 0x7ffdefd049f0 a2[2]:0.142857 at 0x16f2020 a3[2]:1.62 at 0x7ffdefd04a10 a4[2]:1.62 at 0x7ffdefd04a30 a1[-2]:20.2 at 0x7ffdefd049d0 a3[2]:1.62 at 0x7ffdefd04a10 a4[2]:1.62 at 0x7ffdefd04a30 程序说明： 首先，注意到无论数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象，存储在另一个区域（自由存储区域或堆）中。 a1[-2] = 20.2; 索引-2，找出a1指向的地方，向前移两个double元素，并将20.2存储到目的地。即将信息存储到数组的外面，与C语言一样，C++也不检查这种越界错误。vector和array对象仍可以编写这种不安全的代码。 对于vector和array对象还可使用at()成员函数: a2.at(1) = 2.3; 使用at()时，将在运行期间捕获非法索引，而程序默认将终端。这种额外检查的代价是运行的时间更长，这就是C++允许使用任何一种表示法的原因。另外，这些类还能够降低意外超界错误的概率，例如，它们包含成员函数begin()和end()，能够确定边界，以免无意超界。 4.11 总结数组、结构和指针是C++的3种复合类型。 字符串 共用体 枚举 指针 new和delete vector和array对象]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别绪论(一)]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[模式识别 模式识别系统组成单元： 信息输入与数据获取 预处理 特征抽取、选择和提取：高维测量空间 $ \rightarrow $ 低维的特征空间 分类规则训练 分类决策 模式识别分类按理论分类 统计模式识别： 采用概念和统计的方法，采用判别函数，使判识概念最小 句法模式识别：根据识别对象的结构特征，以形式语言理论为基础的一种模式识别方法。 模糊模式识别：以隶属度位基础，运用模糊数学的“关系”判别 神经网络模式识别 按实现方法分类： 监督分类： 需要足够的先验知识 无监督分类]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别(二)--聚类分析]]></title>
    <url>%2F2018%2F09%2F11%2F%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[物以俱类，人以群分 2.1 距离聚类的概念物以俱类”物以俱类，人以群分“，反映了聚类分析的基本思想。 聚类分析属于非监督分类，即基本上无先验知识可依据或参考。 聚类分析根据模式之间的相似性对模式进行分类，对一批没有标出类别的模式样本集，将相似的归为一类，不相似的归为一类。 相似性当研究一个复杂对象时，可以对其特征进行各种可能的测量，将测量值组成向量形式，称为该样本的特征向量，有$n$个特征值组成的就是$n$维向量，相当于空间中的一个点，整个模式样本集的特征向量可以看作分布在特征空间中的一些点。 可以将特征空间中点与点之间的距离函数作为模式相似性的测量，以“距离”作为模式分类的依据，距离越小，越相似。 2.2 相似度测量和距离准则2.2.1 相似性测度相似性测度是衡量模式之间相似性的一种尺度。距离就是一种相似性的测度，他可以用来度量同一类模式之间的类似性和不属于同一类的模式之间的差异性。下面介绍几种距离： 1.欧式距离 设$X_i,X_j$为两个$n$维模式，$X_i=(x_{i1},x_{i2}, \dots, x_{in})^T$，$X_j=(x_{j1},x_{j2}, \dots, x_{jn})^T$，则定义欧式距离为： $D(X_i,X_j)=|||X_i-X_j||=\sqrt{(X_i-X_j)^T(X_i-X_j)}=\sqrt{(x_{i1}-x_{j1})^2+\dots+(x_{in}-x_{jn})^2}$ 2.马氏距离 马氏距离常用平方形式表示。设$X$为模式向量，$M$为某类模式的均值向量，$C$为该类模式总体的协方差矩阵，则马氏距离定义为： $D^2 = (X-M)^TC^{-1}(X-M)$ 对$n$为向量可表示为：$X=(x_{1},x_{2}, \dots, x_{n})^T$,$M=(m_{1},m_{2}, \dots, m_{n})^T$,$C=E{(X-M)(X-M)^T}。 协方矩阵C表示的是各分量上模式样本到均值的距离，也就是在各维上模式的分散情况。 3.明氏距离 设$X_i, X_j$为$n$维模式向量，$X_i, X_j$之间的明氏距离$D_m$表示为： $D_m(X_i,X_j)=[\sum_{k=1}^n|x_{ik}-x_{jk}|^m]^{\frac{1}{m}}$ 当$m=2$时，明氏距离就是欧式距离。当$m=1$时，可得： $D_1(X_i,X_j)=\sum_{k=1}^n|x_{ik}-x_{jk}|$ 称其为“街坊”距离。 4.汉明距离 如果模式向量各分量的值仅取1或（-1），即二值模式，则可用汉民距离衡量模式间的相似性。设$X_i, X_j$为$n$维二值模式向量，$X_i, X_j$之间的汉明距离$D_m$表示为： $D_h(X_i,X_j)=\frac{1}{2}(n-\sum_{k=1}^nx_{ik} \cdot x_{jk})$ 由定义可知，若两个模式向量的每个分量取值都不同，则汉明距离为n；若两个模式向量的各分量取值都相同，则汉明距离为零。 5.角度相似性函数 角度相似性函数表示为： 它是模式之间的余弦。 2.2.2 聚类准测聚类准则：根据相似性测度确定的，衡量模式之间是否相似的标准。即把不同模式聚为一类还是归为不同类的准则。 确定聚类准则的两种方式： 1.阈值准则：根据规定的距离阈值进行分类的准则。 2.函数准则：利用聚类准则函数进行分类的准则。 聚类准则函数：在聚类分析中，表示模式类间相似或差异性的函数。 一种常用的指标是误差平方之和，聚类准则函数定义如下： $J = \sum_{j=1}^c \sum_{x \in S_j} ||X-M_j||^2$ 其中，$c$表示共有$c$个模式类；$M_j = \frac{1}{N_j} \sum_{X \in S_j}X$,为$S_j$中模式样本的均值向量，$N_j$为$S_j$中的模式样本数量。 J代表了分属于c个聚类类别的全部模式样本与其相应类别模式均值之间的误差平方和。 2.3 基于距离阈值的聚类算法2.3.1 近邻聚类算法问题：有N个待分类的模式$\lbrace X_1,X_2, \dots, X_N \rbrace$，要求按距离阈值T分类到以$Z_1, Z_2,\dots$为聚类中心的模式类中。 算法描述1、任取样本Xi作为第一个聚类中心的初始值，如令$Z_1 = X_1$。 2、算样本X2到Z1的欧式距离$D_{21}= ||X_2 - Z_1||$，若$D_{21}&gt;T$，定义一新的聚类中心$Z_2 = X_2%；否则$X2 \in$以$Z_1$为中心的聚类。 3、假设已有聚类中心$Z_1,Z_2$，计算$D_{31}=||X_3 - Z_1||$和$D_{32}=||X_3 - Z_2||$，若$D_{31}&gt;T$且$D_{32}&gt;T$，则建立第三个聚类中心$Z_3 = X_3$；否则$X3 \in$离$Z_1$和$Z_2$中最近着（最近邻的聚类中心）。 ……以此类推，直到将所有的N个样本都进行分类。 算法特点局限性：很大程度上依赖于第一个聚类中心的位置选择、待分类模式样本的排列次序、距离阈值T的大小以及样本分布的几何性质等。 优点：计算简单。（一种虽粗糙但快速的方法） 2.3.2 最大最小距离算法问题：有N个待分类的模式$\lbrace X_1,X_2, \dots, X_N \rbrace$，要求按距离阈值T分类到以$Z_1, Z_2,\dots$为聚类中心的模式类中。 算法描述1、任取样本Xi作为第一个聚类中心的初始值，如令$Z_1 = X_1$。 2、选择离$Z_1$距离最远的模式样本作为第二个聚类中心$Z_2$。 3、逐个计算每个模式样本与已确定的所有聚类中心之间的距离，并选出其中最小距离。 例当聚类中心数k=2时，计算 $D_{i1} = ||X_i-Z_1||$, $D_{i2} = ||X_i-Z_2||$ 并求出： $\min{(D_{i1},D_{i2})}$ 因为共有N个模式样本，所以此时得到N个最小距离。 4、在所有最小距离中选出一个最大距离，如果该最大值达到$||Z_1-Z_2||$的一定分数以上，则将产生最大距离的那个模式样本定义定义为新增的聚类中心，并返回上一步。否则，聚类中心的计算步骤结束。这里的“$||Z_1-Z_2||$的一定分数比值”就是阈值$T$,即 $T = \theta ||Z_1-Z_2||$ 同样，即$k=2$为例，若$\max{\lbrace \min{(D_{i1},D_{i2})}, i=1,2,\dots, N \rbrace} &gt; T$，则$Z_3$存在，并取为相应的模式向量，返回步骤三；否则寻找聚类中心结束。 5、重复步骤3和步骤4，直到没有聚类中心出现为止。 6、寻找聚类中心的运算结束后，将模式样本$\lbrace X_i, i =1,2,\dots,N \rbrace$按最近距离划分到相应聚类中心所代表的类别中。 2.4 层次聚类层次聚类法也称为系统聚类法或分级聚类法。这种方法同样采用距离与之作为决策聚类数目的标准，基本思路：每个样本先自成一类，然后按距离准则逐步合并，减少类数，直到达到分类要求为止。 算法描述1、N个初始化模式样本自成一类，即建立N类$G_1(0),G_2(0),\dots,G_N(0)$。计算各类之间（各样本间）的距离，得到一个$N \times N$维的距离矩阵$D(0)$。标号$(0)$表示是聚类开始运算前的状态。 2、如在前一步聚类运算中，以求得距离矩阵$D(n)$(n为逐次聚类合并得次数)，则找出$D(n)$中得最小元素，将其对应得两类合并为一类。由此建立新的分类：$G_1(n+1),G_2(n+1),\dots$。 3、计算合并后新类别之间得距离，得到距离矩阵$D(n+1)$。 4、 跳至第2步，重复计算及合并。 结束条件：设定一个距离阈值$T$，当$D(n)$的最小值分量超过给定值$T$时，算法停止。 在第3步中，计算合并后的聚类与其他没有合并的模式类之间的距离，或者两个合并后的聚类之间的距离时，应如何计算？下面介绍几种不同的类间距离计算准则： （1）最短距离法 （2）最长距离法 （3）中间距离法 （4）重心法 （5）类平均距离法 2.5 动态聚类法动态聚类法首先选择若干个模式样本作为聚类中心，再按照实现确定的聚类准则进行聚类。在聚类过程中，根据聚类准则对聚类中心进行反复修改，直到分类合理为止。 2.5.1 K-均值算法K-均值算法又称为C-均值算法，时根据函数准则进行分类的聚类算法，基于使聚类准则函数最小化。 算法描述设共有$N$个模式样本，计算步骤如下： 1、 任选$K$个初始化聚类中心$Z_1(1),Z_1(2),Z_K(1), K &lt; N$。括号内的序号代表寻找聚类中心的迭代次序号。一般选择样本集中前$K$个样本作为初始聚类中心。 2、 按最短距离原则将其余样本分配到$K$个聚类中心中的某一个，即 若 $\min{\lbrace ||X-Z_i(k)||, i =1,2,\dots, K\rbrace} = ||X-Z_j(k)||=D_j(k)$则，$X \in S_j(k)$ 式中，$k$即为迭代运算的次序号。 3、计算各个聚类中心的新向量值$Z_j(k+1),j =1,2,\dots,K$ $Z_j(k+1) = \frac{1}{N_j} \sum_{X \in S_j(k)}X, j = 1,2,\dots, K$ 即以均值向量作为新的聚类中心。这一步要分别计算$K$个聚类中的样本均值向量，故称算法为K-均值聚类。 4、如果$Z_j(k+1) \neq Z_j(k),j =1,2,\dots,K$，则回到步骤2，将模式样本逐个重新分类，并重复迭代计算，如果$Z_j(k+1) = Z_j(k),j =1,2,\dots,K$，算法收敛，计算完毕。 K均值聚类算法的思想是：首先随机选取K个对象作为初始的聚类中心，然后，计算每个对象距聚类中心的距离，把每个对象归到距离它最近的聚类中心。如果全部对象被分配完，则每个聚类的聚类中心将根据现有的对象重新计算。直到满足某个终止条件。K均值聚类算法是一种无监督学习算法。具体算法实现如下： 代码import numpy as np import random import matplotlib.pyplot as plt #计算样本到中心的距离,采用欧式距离 def distEC(data,center,k): num = np.array(data) hang = num.shape[0] #数据个数 lie = num.shape[1] #指标个数 dist = [[0]*k for row in range(hang)] for i in range(hang): for l in range(k): s = 0 for j in range(lie): s = (center[l][j] - data[i][j])**2 + s dist[i][l] = s**0.5 return dist #根据计算得到的距离对样本分类 def Cluter(dist): num = np.array(dist) hang = num.shape[0] #数据个数 k = num.shape[1] #中心个数 clu = [[] for row in range(k)] #初始化存放样本标号的距离 for i in range(hang): temp = dist[i][:].index(min(dist[i][:]))#求样本距离哪个聚类中心最近 for j in range(k):#判断样本属于哪个距离中心 if temp == j: clu[j].append(i) break return clu #重新计算聚类中心 def clu_center(clu,data,k): for i in range(k): for j in range(2):#(np.array(data).shape[1]): temp = 0 for k in range(len(clu[i])):#len(clu[i])为每个聚类中心样本的个数 temp = data[clu[i][k]][j] + temp center[i][j] = temp / len(clu[i]) #重新计算得到的聚类中心 return center if __name__ == &quot;__main__&quot;: k =3#聚类中心个数 data = [[0,0],[3,8],[2,2],[1,1],[5,3],[4,8],[6,3],[5,4],[6,4],[7,5]] #center = random.sample(data,k)#随机选取初始聚类中心 center = [[0,0],[3,8],[2,2]]#固定初始聚类中心 dist = distEC(data,center,k)#计算样本与聚类中心的距离 clu = Cluter(dist)#聚类 center1 = clu_center(clu,data,k)#重新计算聚类中心 center2 = [] while center1 != center2: #当聚类中心相同时，停止聚类 dist = distEC(data,center1,k) clu = Cluter(dist) center2 = center1 center1 = clu_center(clu,data,k) print(center1,center2) #画图 plt.figure() for j in range(10): plt.plot(data[j][0],data[j][1],&apos;b.&apos;) for i in range(k): plt.plot(center1[i][0],center[i][1],&apos;ro&apos;) plt.xlabel(&apos;x&apos;) plt.ylabel(&apos;y&apos;) plt.show() 2.5.2 ISODATA算法（迭代自组织的数据分析算法）K—均值算法比较简单，但它的自我调整能力也比较差。这主要表现在类别数不能改变，受代表点初始选择的影响也比较大。 ISODATA算法的功能与K—均值算法相比，在下列几方面有改进： 可以改变类别数目。通过类别的合并与分裂来实现。 合并主要发生在某一类内样本个数太少的情况，或两类聚类中心之间距离太小的情况。为此设有最小类内样本数限制，以及类间中心距离参数。 分裂则主要发生在某一类别的某分量出现类内方差过大的现象，因而宜分裂成两个类别，以维持合理的类内方差。给出一个对类内分量方差的限制参数，用以决定是否需要将某一类分裂成两类。 由于算法有自我调整的能力，因而需要设置若干个控制用参数。，如聚类数期望值K、每次迭代允许合并的最大聚类对数L、及允许迭代次数I等。 2.6 聚类结果评价可考虑用以下几个指标来评价聚类效果： 聚类中心之间的距离：距离值大，通常可考虑分为不同类 聚类域中的样本数目：样本数目少且聚类中心距离远，可考虑是否为噪声 聚类域内样本的距离方差： 方差过大的样本可考虑是否属于这一类]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动通信技术]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[介绍第二代至第四代移动通信技术，以及正在研发的第五代移动通信技术 第几代 移动 电信 联通 2G GSM CDMA GSM 3G TD-SCDMA CDMA2000 WCDMA 4G TD-LTE FDD-LTE和TD-LTE FDD-LTE和TD-LTE 第五代移动通信系统，采用高频段，传输距离缩短，所以需要部署比较密集的基站。 5G关键技术 高频传输技术：目前全球使用的3G和4G使用的频段是2GHz左右，频段越低则覆盖率越高，但是低频段谱往往是有限的。为了传输速度更快，高频段需要更宽的带宽与之匹配。 大规模天线传输技术（MIMO） 密集网络技术 5G三大场景 eMBB:3D/超高清视频等大流量移动宽带业务 mMMT：大规模物联网业务 URLLC：如无人驾驶、工业自动化等需要低延时、高可靠连接的业务 5G三种标准(信道编码) LDPC方案：高通牵头 Polar方案：华为牵头 Turbo方案：LG牵头]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DAC-MACS Effective Data Access Control for Multiauthority Cloud Storage Systems]]></title>
    <url>%2F2018%2F09%2F06%2FDAC-MACS-Effective%20Data%20Access%20Control%20for%20Multiauthority%20Cloud%20Storage%20Systems%2F</url>
    <content type="text"><![CDATA[论文一 多权威云存储系统的有效数据访问控制摘要数据访问控制是确保云上数据安全的有效方法。然而，由于数据外包和不可信的云服务器，在云存储系统中，数据访问控制成为了一个挑战性问题。现有的访问控制方案不再适合云存储系统，因为它们针对相同的数据生成多个加密副本，并且要求云服务器完全可信。基于密文策略的属性加密（CP-ABE），对于加密数据的访问策略，是个比较好的技术。但是，由于低效的解密和撤销，现有的CP-ABE方案不能直接应用来构造一个适合多权威中心的云存储系统的访问控制方案。在本文，作者提出了针对多权威云存储系统的访问控制（DAC-MACS）,其是一个高效安全的访问控制方案，并且解密和撤销效率高。另外，作者构造了一个新的多权威（CP-ABE）方案，解密效率高，同时设计一个有效的属性撤销方法，可是保证前向安全和后向安全。进一步，作者给出了一个扩展数据访问控制方案（EDAC-MACS）,其在一个弱安全假设下是安全的。 一、介绍（Introduction）云存储是云计算一个重要的服务。它允许数据拥有者上传数据到云服务器，利用云服务器先用户提供数据访问。数据访问控制是保证数据安全的有效方法。然而由于数据外包，云服务器可能无法完全被信任来提供数据访问控制服务，这意味着存在的基于服务的访问控制方法不再适应于云存储。为了实现不可信服务器的数据访问控制，传统方案经常加密数据并只有用户拥有密码来解密。尽管这种方案可以提供安全访问控制，但是当系统用户变多，密钥管理非常复杂。数据拥有者不得不保持在线来发送密钥给新的用户。甚至，对于每一个数据，存在多个密文副本对于拥有不同密钥的用户，这将因此巨大的存储开销。 基于密文策略的属性加密（CP-ABE）[2-6]是一种最适合于云存储系统数据访问控制的技术之一，由于它使数据拥有者可以直接的控制访问策略，并不要求数据拥有者去分发密钥。在CP-ABE方案中，有一个权威机构来负责密钥的分发和属性管理。权威中心可以是一个大学的注册办公室，公司的人力部门等等。根据属性每个用户被分配一个私钥。每个用户仅可以解密其属性满足访问策略的密文。 在云存储系统中，一个用户可能拥有多个权威中心分配的属性，数据拥有者与不同权威机构管理的用户共享数据。例如：在一个电子医疗系统中，医疗数据可能仅分享给被医院分发有“医生”属性的用户，和被医院研究中心分发有“医药研究元”属性的用户。一些CP-ABE方案[7-10]被提出针对多权威系统。然而，由于计算量较大，他们无法直接应用来构造数据访问控制方案。主要，在访问控制中，加密和解密操作要求计算量小。 用户撤销：在云存储系统中，数据访问不是静态的，正如员工的雇佣和解聘，升职和降职，改变用户的属性是非常有必要的。为了保证用户撤销的安全性，满足如下两个要求：1）后向安全：撤销用户（其属性被撤销）不能解密新的密文，解密新的密文需要被撤销的属性。2）前向安全：新加入的拥有足够属性的用户能过解密以前发布的密文。为了实现者两个要求，一个普通的方法市重新加密所有数据。当数据量非常大时，计算开销也是巨大的。这促使我们去研究一种新的方法，可以高效地处理用户的属性撤销。 解密效率：在CP-ABE系统中，用户需要使用自己的私钥去解密数据。不过，现在，用户通常使用移动设备（比如：智能手机、笔记本等等）来获取云数据，移动设备的计算能力不想PC一样强大。这促使我们去外包主要的解密计算量给云服务器，同时保证云服务器无法获取数据。 本文，我们首先构造了一个新的多权威CP-ABE方法，解密效率高，并为其提出了高效的属性撤销方案。然后，我们运用它来为多权威云存储系统设计一个高效的访问控制方法。本文的主要贡献可以总结如下： 1）提出了DAC-MACS（多权威云存储系统的数据访问控制），其是针对多权威中心的云存储系统的，一个高效地，安全地数据访问控制方案。其在预言机模型中是安全的，并且性能优于现有的方案。 2）构造了一个新的多权威CP-ABE方案，解密效率高。尤其，我们通过使用基于令牌的解密方法来外包解密过程的大部分计算量。 3）针对多权威CP-ABE方案，设计了一个高效及时的属性撤销方案，可以实现前向安全和后向安全。甚至，在属性撤销过程的通信开销和计算量大大降低。 与之前的方案[11]相比，我们大大提高了DAC-MACS的安全性，使其更适合于多权威中心的云存储系统。尤其，我们主要研究了由未撤销用户和被破坏用户AA之间共谋引起的安全问题。首先，通过一个安全假设，即未撤销用户不会将其收到的更新密钥发送给撤销用户，来给出一个简单的解决方案。进一步，我们抛弃上面的假设，提出了一种扩展数据访问控制方案（EDAC-MACS），其可以实现同样的安全性能。在EDAC-MACS方案中，即使在任意破坏用户AA帮助下e，撤销用户也无法获取非法的数据访问。没有上面的假设，EDAC-MACS是更符实际的来运用到云存储系统。同时，我们也给出了EDAC-MACS方案的安全分析，证明其在弱安全假设下是安全的。 论文余下部分内容如下：在第二节，我们定义了系统模型，方案架构以及安全模型。在第三节，我们提出了一种新的多权威CP-ABE方案，具有高效的解密和撤销，并被运用来构造DAC-MACS。在第四节，就安全和性能，我们分析了DAC-MACS。第五节，进一步提出了扩展DAC-MACS方案来保证弱假设下的安全性。第六节，给出了相关工作总结。最后，在第七节，给出了结论。详细地安全证明在附录中给出。 二、系统模型和安全模型A. 系统模型考虑到一个云存储系统有多个权威中心，正如图1所示。系统模型包括五部分：全局证书机构（CA）、属性权威中心（AAs）、云服务器（server）、数据拥有着（owners）、数据使用者（users）。 CA.在系统种，CA是一个全局被信任的证书颁发机构。它建立系统，并接受系统种所有用户和AAs的注册。对于每个合法用户，对于每个合法的用户，CA分配一个全局唯一身份标识给他，同时生成一个公私钥对给该用户。然后，CA不参与任何属性管理和任何与属性有关私钥的生成。 AA.每一个AA是一个独立的属性权威中心，负责根据用户的角色和身份来分发、撤销和更新用户的属性。每一个AA负责为每个其管理的属性生成一个公开属性密钥，并为他们属性所对应的每个用户生成一个私钥。 Server.云服务器存储数据拥有着的数据，并向用户提供数据访问控制服务。它也帮助用户进行解密密文，其是通过生成一个解密符合实现。同时，当存在一个属性撤销时，云服务器也帮助用户更新密文。 Owners.在外包数据之前，每个数据拥有者通过对称加密技术使用内容密钥（content keys）来加密数据。然后，数据拥有者针对多个AAs的属性定义一个访问控制策略，并在该策略下加密内容密钥。数据拥有者不信任服务器来做数据访问控制。相反，在系统种，他们假设服务器可能将数据给所有用户。但是，访问控制发现生在加密内部。只有当用户属性满足在密文中定义的访问策略，用户才能解密密文。 Users.每个用户被分配有一个来自CS的全局用户身份，可以自由地查询来自服务器的密文。为了解密密文，每个用户提交有某些AAs一起发布给它的私钥和全部公钥给云服务器，来请求一个解密令牌。然后，用户使用收到的解密令牌和自己的全局公钥来解密密文。仅仅当用户属性满足在密文中定义的访问策略时，服务器才会生成正确的解密令牌。私钥和用户的全部公钥可以存储在服务器中，随后，如果没有更新密钥用于进一步的解密令牌生成，则用户不需要提交任何密钥。 B. 框架定义1（DAC-MACS）:DAC-MACS架构包括如下几个步骤： 步骤一：系统初始化：该阶段包括如下算法： $CASetup(1^\lambda)\rightarrow (MSK, SP, (sk_{CA},vk_{CA}))$. CA初始化算法的输入仅仅为隐式安全参数$\lambda$。输出为主密钥MSK，系统系数SP,以及一对CA的签名和验证密钥$key(sk_{CA},vk_{CA})$。 $UserReg(SP,sk_{CA},Info_u) /rightarrow (uid,GPK_{(uid)},GSK_{(uid)},Cert_{(uid)})$.用户注册算法以系统参数SP，CA的签名密钥$sk_CA$和用户信息$Info_u$（即名字、生日等等）作为输入。它验证用户身份，并分配一个全局唯一用户标识$uid$给该用户。其输出用户的标识$uid$,公私钥对$\lbrace GPK_{uid},GSK_{uid} \lbrace$和一个由CA签发的证书$Cert(uid)$。 $AAReg(Info_{AA}) \rightarrow (aid)$. 属性权威注册算法将属性权威信息作为输入。它验证AA并输出一个全局权威标识$aid$给该AA。 $AASetup(SP, aid) \rightarrow (SK_{aid}, PK_{aid}, VK_{x_{uid}}, PK_{x_{uid}})$.属性权威初始化算法以系统参数SP和全局权威标识$aid$作为输入。输出一私\公权威密钥对$(SK_{aid},PK_{aid})$,每个属性$x$的版本密钥和公权威密钥集合$\lbrace VK_{x_{aid}},PK_{x_{aid}} \lbrace$。 步骤二：密钥生成 -$SKeyGen(SK_{aid},SP,{P_{x_{aid}}},S_{uid,aid},Cert(uid)) \rightarrow SK_{uid,aid}$.私钥生成算法以权威私钥$SK_{aid}$，系统参数$SP$,属性公钥集合%(PK_{x——{aid}})%，描述密钥的属性集合$S_{uid,aid}$和用户的证书$uid$。其输出针对用户$uid$的密钥$SK_{uid,aid}$。 步骤三： 数据加密 $Encrypt(SP, \lbrace PK_{k} \rbrace_{k \in I_{A}} \lbrace, PK_{x_k} \rbrace)^{k \in I_A}_{x_{k} \in S_{A_k}},m, \alpha) \rightarrow CT$.加密算法以系统参数$SP$、来自相关权威集合$I_{A}$的公钥集合$\lbrace PK_{k} \rbrace_{k \in I_{A}}, \lbrace$、属性公钥$\lbrace, PK_{x_k} \rbrace)^{k \in I_A}_{x_{k} \in S_{A_k}}$、数据$m$和一个来自相关AAs中所有的被选属性的访问结构$alpha$。首先，该算法利用内容密钥$\kappa$使用对称加密方案加密数据$m$；然后，在访问结构$alpha$下加密内容密钥，并输出一个密文$CT$。假设密文隐含地包含访问结构。 步骤四：数据解密：数据解密阶段包括云服务器生成解密令牌和用户的数据解密，具体算法如下： $TKGen(CT,GPK_{uid}, \lbrace SK_{uid,k} \rbrace_{k \in I_A}) \rightarrow TK$.解密令牌生成算法以密文CT为输入，密文包括访问结构$alpha$、用户的全局公钥$GPK_{uid}$以及用户私钥集合$\lbrace SK_{uid,k} \rbrace_{k \in I_A}$。如果用户uid拥有足够满足访问结构$alpha$的属性，算法能够为密文CT成功地计算出正确的令牌TK。 $Decrypt(CT,KT,GSK_{uid}) \rightarrow m$. 解密算法的输入为密文CT、解密令牌TK和用户的全局私钥$GSK_{uid}$。其首先解密内容密钥，进一步使用内容密钥来解密数据。输出为数据m。 步骤五：属性撤销：这个阶段包括三步：由AAs更新密钥生成、未撤销用户私钥更新和服务器密文更新。 $UkeyGen(SK_{aid}, \lbrace u_j \rbrace, VK_{x_{aid}}) \rightarrow (KUK_{j,x_{aid}}, CUK_{x_{aid}})$. 更新密钥生成算法的输入是权威密钥$SK_{aid}$、用户私钥集合$\lbrace u_j \rbrace$和撤销属性的以前的密钥$VK_{x_{aid}}$。其输出用户密钥的更新密钥$KUK_{j,x_{aid}}$以及密文更新密钥$ CUK_{x_{aid}}$。 $SKUpdate(SK_{uid,aid}, KUK_{uid,x_{aid}}) \rightarrow SK^{‘}{aid,uid}$. 用户密钥更新算法以当前用户私钥$SK{uid,aid}$和它的密钥更新密钥$KUK_{uid,x_{aid}}$为输入。输出一个新的密钥$SK^{‘}_{aid,uid}$。 $CTUpdate(CT,CUK_{x_{aid}}) \rightarrow CT^{‘}$. 密文更新算法输入为当前的密文$CT$和密文更新密钥$CUK_{x_{aid}}$。输出为一个新密文$CT^{‘}$。 C 每个实体的安全假设在DAC-MACS中，有如下假设： CA是可信的，但其不允许解密任何密文。 每个AA是可信的，但它可以被攻击者破坏。 服务器是半可信的（好奇但诚实）。它将不会拒绝任何授权用户的服务，并正确地执行AA分配的任务。但它对数据内容或收到的数据是好奇的。 用户是不诚实的，可能与共谋来获得未授权的数据访问。 所有未撤销用户不会收到更新密钥发送给撤销用户。（该假设在EDAC-MACS中移除该假设） D 决策q并行Diffie-Hellman指数假设 Decisional q-Parallel Bilinear Diffie-Hellman Exponent Assumption引用文献[5]中关于qDiffie-Hellman指数假设的定义。设$a,s,b_1, \dots b_q \in Z_p$为随机数，$g$为G的一个生成元。如果攻击者被给定： 很难从随机元素R（$G_T$中）区分出一个有效元素$e(g,g^{a^{q+1}}s)$。 一个算法B,其输出为$z \in {0,1}$,如果满足： 则在求解q阶BDHE有优势$\epsilon$。 定义2： 如果没有多项式时间算法在解决q并行BDHE问题方面具有不可忽视的优势，那么决策q并行BDHE假设成立。 E 安全模型现在，通过挑战者和攻击者之间的游戏来描述DAC-MACS的安全模型。安全模型允许攻击者去查询任意不能用来解密挑战的密文私钥和更新密钥。与文献[10]相似，假设攻击者可以静态地破坏权威中心，但是密钥的查询是动态的。设$S_A$表示所有的权威中心集合。安全游戏定义如下： 初始化:通过运行CA初始算法生成系统参数。攻击者指定了一组损坏的属性权威中心$S^{‘}_A \subset S_A$。挑战者通过查询AA初始化预言机生成一个公钥，通过查询私钥生成预言机生成一个私钥。对于正常的权威中心$S_A - S_A^{‘}$，挑战者仅发送公钥给攻击者。对于S^{‘}_A中破坏的权威中心，挑战者发送公钥和私钥给攻击者。 步骤一：攻击者通过提交$(uid, S_{uid})$对给挑战者来发起密钥查询，其中$S_{uid} = \lbrace S_{uid,k} \rbrace _{k \in S_A - S_A^{‘}}$是属于正常AAs的属性集合。挑战者响应对应私钥$\lbrace SK_{uid,k} \rbrace$给挑战者。挑战者通过发送属性集合$S_{aid}^{‘}$来发起更新密钥查询请求。挑战者将对应的更新密钥发送给攻击者。 挑战：攻击者提交两个长度相同的消息$m_0$和$m_1$。另外，攻击者发起一个挑战,获取必须满足以下约束的访问结构$(M^\ast,\rho^\ast)$。设$V$表示由属于破坏AAs属性标记的$M^\ast$行的子集。对于每个$uid$,$V_{uid}$表示由攻击已经查询的属性标记的$M^\ast$的行。对于每个$uid$,要求由$V \cup V_{uid}$组成的子空间不包括$(1,0, \dots ,0)$。即，攻击者不能结合从AA获得的任何密钥，以及请求密钥集合来解密。攻击者生成一个随机数b,并在访问结构$(M^\ast, \rho^\ast)$下加密$m_b$。 步骤二： 攻击者可能查询更多的私钥和更新密钥，只要它们不违反挑战访问结构$(M^\ast,\rho^\ast)$上的约束和如下约束：不存更新密钥（通过查询更新密钥和查询私钥生成）可以解密挑战密文。换句话说，攻击者不能查询一个能更新查询密钥成新密钥的更新密钥，其中的新密钥可以解密挑战密文。 猜测： 攻击者输出b的猜测$b^{‘}$。在游戏中，攻击者$A$的优势定义：$Pr[b^{‘} = b] - (1/2)$ 定义3：如果所有多项式时间对手在上述安全游戏中具有最多可忽略的优势，则DAC-MACS对于权威中心的静态损坏是安全的。 定义4：当单个用户用子集的属性无法解密数据时，如果没有多项式时间攻击者利用不同用户的属性一起来解密数据，则DAC-MACS是共谋弹性。 三、DAC-MACS：针对多权威云存储的数据访问控制本节开始给出了我们方案的回顾，然后，我们描述了DAC-MACS，包括五个阶段。 A 回顾尽管，由Lewko和Waters提出的多权威CP-ABE方案[10]有很高的理解力，并被扩展来支持属性撤销[12],由于解密和撤销的效率低，仍然无法应用来解决多权威云存储的访问控制。这样，主要的挑战是构造一种新的底层多权威CP-ABE方案，其支持高效的解密和撤销。 为了涉及一个对权威CP-ABE方案，主要的挑战是如何将不同私钥联系在一起但仍可以组织共谋攻击。与[7]相似，在DAC-MACS中， 我们将权威分为一个全局整数权威(CA)和多个属性权威中心（AAs）。CA负责初始化系统和分配每个用户一个全局身份标识$uid$,并分配每个属性权威一个全局权威标识$aid$。全局唯一标识$uid$可以结合不同AAs分出的私钥一起进行解密，全局唯一标识$aid$可以区分不同AAs分发的属性。这样，通过使用$uid$和$aid$，可以抵抗共谋攻击。然而，不同于文献[7]，在DAC-MACS中的CA步牵涉任何属性管理，和用户属性对应的私钥生成。DAC-MACS也要求所有的AAs生成它们子集的公钥，其可以结合全局公开参数去加密数据，而不是仅仅使用系统唯一公钥来加密。这解决了[7]中的安全问题，即它能阻止了CA解密密文。 为了实现用户的高效解密，提出了一种令牌解密外包方案。解密外包思路来自文献[12],通过使CA生成一对全局私钥和全局公钥给每个合法用户，来扩展其到多权威系统。在解密期间，用户提交由AAs分发的私钥给服务器来计算密文的解密令牌。用户通过使用解密令牌和全局私钥来解密密文。 为了解决用户撤销的问题，我们为每个属性分配一个版本号，这样对于每个属性的撤销，只需要更新密钥和密文中的被撤销属性相关联的那些组件。当一个属性被从一个用户撤销，相应的AA将针对撤销的属性生成一个新的版本密钥，并计算一个更新密钥，包括：一个密文更新密钥（CUK）和用户密钥更新密钥（KUKs）。对于KUKs，每个未撤销用户可以使用这个私钥更新当前的版本，而撤销用户无法更新自己的私钥，甚至使用其他用户的更新私钥，因为每个KU是与uid相关的（后向安全）。密文也可以使用CUK被更新成当前版本。这样，拥有足够属性的新加入的用户也可以解密以前提交的数据（前向安全）。更为甚者，所有用户仅仅需要拥有最新的私钥，而不要先前的私钥。为了提高效率，使用代理重加密方案将密文更新工作委托给服务器。 B 系统初始化这个阶段包括两个步骤:CA初始化和AA初始化。 1) CA初始化：设$S_A$和S_U分别表示属性权威和系统用户集合。设$G$和$G_T$是两个具有相同阶数q的乘法群。$e:G \times G \rightarrow G_T$是一个线性映射。设$g$是群$G$的生成元。$H: \lbrace 0,1 \rbrace^\ast \rightarrow G$是一个哈希函数，并且在预言机下是安全的。 CA运行CA初始化算法，以一个安全系数作为输入。首先，CA生成一个对签名和验证密钥$(sk){CA},vk{CA})$,然后，其选择一个随机数$a \in Z_p $作为系统的主密钥MSK，并计算系统的参数如下： $SP = (g,g^a,G,G_T,H).$ CA接受用户和AA的注册： 用户注册在系统初始化阶段，每个用户需要向CA注册它自己。CA运行用户注册算法UserReg,其以系统参数和用户信息作为输入。如果用户是合法的，CA分配一个全局用户标识$uid$给用户，并生成全局公钥$GPK_{uid} = g^{u_{uid}}$和全局私钥$GSK_{uid} = z_{uid}$,$u_{uid} \in Z_p$和$z_{uid} \in Z_p$是随机选择的两个元素。同时，CA生成一个证书$Cert(uid)$,其包含了$Sign_{sk_{CA}}（uid,u_{uid},g^{1/z_{uid}}）$。然后，CA将全局公私钥对$(GPK_{uid},GSK_{uid})$和证书$Cert(uid)$发送给用户。 AA注册同样，在系统初始化阶段，AA需要向CA注册自己。CA运行AA注册算法AAReg，以AA的信息作为输入。如果AA是一个合法的权威中心，CA分配器一个全局权威标识$aid$。然后，CA发送它自己的验证密钥$vk_{CA}$和系统参数$SP$给AA。 2）AA初始化 每个$AA_k(k \in S_A)$运行AA初始化算法AASetup。设$S_{A_k}$表示由权威$AA_k$管理的所有属性集合。它选择三个随机数$$\alpha_k \beta_k \Gamma_k$作为私权威密钥$SK_k = (\alpha_k \beta_k \Gamma_k)$。对于每个属性$x_k \in S_{A_k}$，权威生成一个私钥，如下： $PK_{x_k} = (g^{v_{x_k}}H(x_k))^{\Gamma_k}$ 显示地选择一个属性版本密钥$VK_{x_k}=v_{x_k}$。$AA_k$也炯穿公钥如下： $PK_{k} = (e(g,g)^{\alpha_k},g^{1/\beta_k},g^{\Gamma_k/\beta_k})$ 所有的属性公钥和权威公钥都发布在$AA_k$的公布栏中。 C AAs生成私钥对于每个用户$U_j(j \in S_U)$,每个$AA_k(k \in S_A)$首先使用验证密钥通过用户证书来判断用户是否合法。如果是非法用户，将终止。否则，$A_k$将根据用户的在管理系统的角色或身份，分配一个属性集合$S_{j,k}$给该用户。然后，$AA_k$运行私钥生成算法SKeyGen来生成用户的私钥$SK_{j,k}$。 该算法的输入为：权威私钥$SK_{aid}$和系统参数$SP$,属性公钥集合$\lbrace PK_{x_{aid}}\rbrace$,描述私钥的属性集合$S_{uid,aid}$和用户$uid$的证书。如下： 其中$j \in S_U$，$k \in S_A$。 D 拥有者加密数据在外包数据$m$到云上之前，数据拥有通过数据加密算法加密数据。其以系统参数$SP$、来自相应权威集合$I_A$的公钥集合$\lbrace PK_k \rbrace _{k \in I_A}$、属性公钥集合$\lbrace PK_{x+k} \rbrace^{k \in I_A}_{x_k \in S_{A_k}}$、数据$m$以及一个与$AAs$相关的所有被选择属性的访问结构$(M, \rho)$。设矩阵$M$是一个$l \times n$维的矩阵，其中$l$表示所有属性的总数。函数$\rho$与$M$的行对应的属性相关。（不懂） 首先，该算法将根据逻辑粒度数据分为几个块如：$m= \lbrace m_1, \dots , m_n $。例如，个人数据可以分为{name,addres,secutity number, employer, salary}。然后，通过对称加密算法加密数据的块，使用不同对称内容密钥$\lbrace \kappa_1, \dots , \kappa_n \rbrace$，其中$\kappa_i$用户加密$m_i(i=1,\dots,n)$。 然后，数据拥有者定义一个访问结构$M_i$，并在这个结构下加密内容密钥$\kappa_i(i=1,\dots,n)$。显然，本文余下部分仅仅考虑一个数据块$m$和一个内容密钥$\kappa$。加密算法随机选择一个加密指数$s \in Z_p$和一个随机向量$\vec{v} = {s,y-2, \dots, y_n} \in Z_{p}^n$，其中$y-2, \dots, y_n$被使用来分享加密指数$s$。对于，$i=1$至$l$,计算$\lambda_i = \vec{v}\cdot M_i$，其中$M_i$是矩阵$M$对应第$i$行的向量。然后，随机选择$r_1,r_2,\dots,r_l \in Z_p$,并计算密文如下： 在实际系统中，如果数据$m$被分为$n$个数据块，同样，密文$CT$也包括$n$部分$CT = \lbrace CT_1,\dots,CT_n \rbrace$。 E 用户解密数据（在云辅助下）在系统，所有合法的用户可以自由的查询来自云服务器的完整密文。但是，仅仅但用户的属性满足嵌套在密文中的访问结构，他或她才能解密内容密钥，进一步使用它解密数据。这个过程包括两步：云服务器生成令牌和用户解密数据。 1)云服务器生成令牌： 用户$U_j(j \in S_U)$发送他自己的密钥$\lbrace SK_{j,k} \rbrace_{s \in S_A}$给云服务器，请求一个用户解密密文的令牌。仅仅当用户$U_j$拥有的属性满足定义在密文CT中的访问结构，服务器才会成功的计算正确解密令牌TK。 服务器运行令牌生成算法TKGen,其输入为：密文（包括一个访问结构$A$）、用户的全局公钥$GPK_j$和用户私钥集合$\lbrace SK_{j,k} \rbrace_{k \in I_A}$。设$I=\lbrace I_{A_k} \rbrace_{k \in I_A}$是所有包括在密文中的属性的下标集合，其中$I_{A_k} \subset \lbrace 1,\dots,l\rbrace$是来自$AA_k$的属性的下标的子集，定义为：$I_{A_k} = \lbrace i: \rho(i) \in S_{A_k} \rbrace$。设$N_A = |I_A|$是在密文中牵涉到的AAs数量。选择一个常数集合\lbrace \omega_i \in Z_p \rbrace_{i \in I}，如果$\lbrace \lambda_i\rbrace$是M的秘密s的有效份额，则重新构造加密指数：$s= \sum_{i \in I} \omega_i\lambda_i $。 计算解密令牌TK的算法如下： 其输出针对密文CT和用户$U_j$的解密令牌TK。 2）用户解密数据： 一旦收到解密令牌TK，用户$U_j$能够使用其和自己的全局私钥$GSK_j = z_j$解密密文。如下： 然后，用户使用内容密钥密钥$\kappa$来解密数据，如下： F. 有效的属性撤销假设用户$U_{\mu}$的一个属性$\check(x)_k$从$AA_k$被撤销。属性撤销包括三个阶段：AAs更新密钥生成、未撤销用户私钥更新、云服务器更新密文。私钥更新可以阻止撤销用户来解密新的密文（后向安全），新的密文使用新的属性公钥加密。密文更新也能保证新加入的用户仍可以访问先前发布的数据（后向安全），新用户拥有足够的属性。 1）AAs更新密钥生成： 相应的权威$AA_k$运行更新密钥算法UKeyGen来计算更新密钥。算法的输入为：权威私钥$SK_k$，当前属性版本密钥$v_{\check(x)_k}$和用户全局公钥$GPK_j$。它生成一个新的属性版本密钥$VK_{\check(x)k}^{‘}=v{\check(x)k}^{‘}$。首先，其计算属性更新密钥：$AUK{\check(x)_k} = \gamma_k(v_{\check(x)k}^{‘}-v{\check(x)_k})$，然后，运用其来计算用户密钥的更新密钥如下： 密文更新密钥如下: 然后，$AA_k$更新的撤销属性$\check(x)k$的属性公钥:$PK^{‘}{\check(x)k} = PK{\check(x)k} \cdot g{\check(x)_k}^{AUK}$，并向所有用户发布一条信息:属性$\check(x)_k$的公钥被更新。最火，所有用户可以得到新的属性公钥，密钥来自$AA_k的公布$。 2)为撤销用户的密钥更新：对于每个未撤销用户$U_j(j \in S_U, j \neq \mu)$，其拥有已撤销属性$\check(x)_k$，$AA_k$发送相应用户密钥更新密钥$KUK_{j,\check(x)k}$给它。一旦收到$KUK{j,\check(x)_k}$，用户$U_j$运行密钥更新算法SKUpate来更新其私钥，如下： 注意，每个$KUK_{j,\check(x)k}$与$uid$相关联，以至于他们将不同的未撤销用户区分开来。这样，撤销用户$U{\mu}$无法使用任何其他用户的私钥来了更新私钥。 3)云服务密文更新：$AA_k$发送密文更新密钥$CUK_{\check(x)k}$给云服务器。一旦收到$CUK{\check(x)_k}$,服务器运行密文更新算法CTUpdate，来更新与撤销属性$\check(x)k$相关的密文。其的输入为：当前密文CT和$CUK{\check(x)_k}$。仅需要去更新一个密文与属性$\check(x)_k$相关的几个部分。新的密文$CT^{‘]$为： DAC-MACS要求仅仅更新一些部分，这些部分与撤销属性相关联，而其他部分不需要改变。这提高了属性撤销的效率。 密文更新不仅可以保证属性撤销的前向安全，而且还可以减少用户的存储开销（即所有的用户仅仅需要保存最新的私钥，而不许可记录所有先前的密钥）。 四、DAC-MACS分析这节给出了DAC-MACS的综合分析，包括安全和性能分析。 A. 综合分析设$|p|$是阶数为p的群的元素个数。设$t_c$是一个密文中总的属性数量，$t_u$一个用户拥有的属性总数。设$n_u$表示系统中用户的数量。位于撤销属性$x$，设$n_{non,x}$是拥有撤销属性的未撤销用户的数量，$n_{c,x}$是包括撤销属性的密文数量。 表1展示了DAC-MACS和其他两种现有方案的比较，它们都是依靠密文重加密来实现属性撤销。从表中可知，DAC-MACS方案的用户计算量和撤销的通信开销更小。在DAC-MACS中，属性撤销有每个AA独立强制执行，但是密文的更新由半可信的服务器执行，这大大降低了用户的工作量。对于属性撤销的安全性，DAC-MACS可以实现前向安全和后向安全。在系统中，云服务器要求是可信的。即使，在某些场景中，云服务器不可信，云服务器将不会正确的更新密文。在这种情况下，前向安全不能保证，但是系统还可以时间后向安全，即撤销用户不能解密新密文，其要求撤销属性来解密。 B. 安全性分析在第二节定义的安全模型下，证明DAC-MACS具有可证明的安全性和共谋弹性。总结为如下定理： 定理一：判定性q双线性BDHE假设成立，不存在一个多项式时间算法可以选择性的破坏DAC-MACS，使用一个大小为$l^{\ast} \times n^{\ast}$,其中$ n^{\ast} \le q$。 证明： 假设存在一个算法$A$,对于选择性安全游戏来攻击我们的构造有一个不可忽略的优势$\varepsilon = Adv_{A}$,假设其选择一个至少有$q-1$行的挑战矩阵$M^{\ast}$。在安全游戏种，攻击者可以查询任何私钥和更新密钥，但是都不能与其他私钥结合来解密，其他密钥来自破坏的AAs。在这种限制下，多权威系统种的安全游戏可以看作是一个单权威中心的。相似地，可以构建一个模拟$B$，来结局判定性qBDHE问题，其有一个不可忽略的优势。详细的证明在文献[15]给出。 定理二：DAC-MACS可以抵抗用户的共谋攻击。 证明：在DAC-MACS中，系统中的每个用户都分配有一个全局唯一身份$uid$，分发来自不同的AAs，同一个用户的所有私钥是与该用户的$uid$相关。这样，两个或更多用户共谋和解密密文是不可能的。更为甚者，由于每个AA的唯一$aid$，所有属性是不同的，即使一些AAs分发相同的属性。这可以阻止用户利用一个AA分发的私钥来取代另一个AA分发的私钥。 隐私保证： 由于解密外包，服务器可以得到用户的私钥。然而，服务器没有用户的全局私钥，仍然不可以解密密文。更为甚至，密文的更新通过代理重加密的方式执行。这样服务器不需要去解密密文。 性能分析比较DAC-MACS和Ruj的DACC方案的性能，对存储开销、通信开销和计算开销进行分析。 1)存储开销： 在云存储系统中，存储开销是访问控制访问最重要的问题之一。假设系统中有$N_A$个AAs。设$|p|$是$G,G_T,Z_p$的大小。设$n_{a,k}$和$n_{a,k,aid}$分布表示由$AA_k$管理的属性总量和$AA_k$分发给用户$uid$的属性数量。比较系统中每个实体的存储开销，如表2： 在DAC-MACS中，每个$AA_k$的存储开销包括每个属性的版本号和权威性私钥；而DACC包括所有属性的私钥。公开参数由所有者贡献主要的存储开销。另外，DACC需要系统中拥有者持有每个密文的加密私钥，因为拥有者需要去重加密密文。这引发了数据拥有者的巨大存储开销，特别当系统中的密文的数量特别大时。在DAC-MACS中，每个用户的存储开销来自由CA签发的全局私钥和由所有AAs分发的私钥。然后，在DACC中，每个用户的开销包括由所有AAs分发的私钥和与撤销属性相关的密文部分。这是因为当密文被重加密，与撤销撤销属性相关的组件可能被发送给每个未被撤销的用户，这些用户拥有撤销撤销属性。服务器上的存储开销主要是密文存储（不考虑由对称内容密钥加密的数据组件）。 2)通信开销：在DAC-MACS和Ruj的DACC方案中的访问控制的通信开销时基本相同的。这里，仅仅比较属性撤销的通信开销。正如表3所示。显而易见，Ruj的方案属性撤销的通信开销与包含撤销属性的密文数量呈线性关系。由于云系统中密文数量巨大，Ruj的方案，在属性撤销过程中的通信开销巨大。 3)计算开销:对DAC-MACS和Ruj的DACC方法，仿真加密、解密和密文重加密\更新的计算时间。在Linux系统上仿真，采用英特尔酷睿2双核3.16GHz处理器,4.00GB的运行内存。代码使用基于配对的密码库版本0.5.12来模拟访问控制方案。使用对称椭圆曲线-$\alpha$曲线，其中基本字段大小为512比特，嵌入度为2。$\alpha$曲线有一个阶数为160比特的群，这意味着$p$是一个长度为160比特的素数。所有的仿真结果取20次实验的均值。 使用两个标准来比较加密和解密的计算效率：权威的数量和每个权威的属性数量。正如图2所示。图2(a)描述的是拥有者加密时间与AAs数量的关系比较，其中每个AA的属性数量为10。图2(b)给出了拥有者加密时间与每个AA所拥有的属性数量的关系比较，其中AAs的数量为10。图2(c)展示了用户解密时间与AAs数量的关系比较，其中每个用户的属性数量为10。图2(d)描述的是用户的解密时间与每个AA拥有的属性数量之间的关系比较，其中针对该用户的权威的数量为10。图2(e)给出了密文重加密或更新与出现在密文中撤销属性数量的关系比较。仿真结果表明，DAC-MACS方案在拥有者加密数据、用户解密数据、密文重加密时的计算量都比较小。 五、扩展DAC-MACS（EDAC-MACS）在DAC-MACS方案中，有一个安全假设：所有未撤销用户不会将收到的更新私钥发送给撤销用户。然而，这是一个强假设，在实际中，撤销用户可能与其他用户共谋来获得更新私钥。本节首先提出一个扩展的数据访问控制方案（EDAC-MACS），然后给出了安全性分析，证明在没有假设下，EDAC-MACS可以实现同样的安全目标。 A.EDAC-MACS如果移除这个假设，DAC-MACS方案的后向安全无法再保证。即当攻击者$\mu$（撤销用户）破坏任意AA，他或她可能获得所有的用户私钥$\lbrace u_uid \rbrace$，使用它来转换其他用户的私钥更新密钥$KUK_{j,\check(x)_k}$来得到自己的更新私钥： 然后，通过运行私钥更新算法SKUpdate，攻击者可以用其更新自己的私钥的最新的版本。 为了解决这个安全问题，修改私钥生成算法SKeyGen，填加一个新内容到$K_{j,x_k}$。它生产用户私钥如下： 其中$j \ in S_U, k \in S_A$。 加密算法跟DAC-MACS的相同，但是在解密期间，解密令牌TK由新的解密令牌生成算法TKGen生成，如下： 正确性： 观察得到： 对于每个$i \in I$，假设$\rho(i) \in S_k$，计算： 然后，计算： 解密算法跟DAC-MACS相同。 在属性撤销阶段，权威同样需要生成更新私钥。密文更新私钥$CUK_{\check(x)_k}$跟DAC-MACS相同。然而，用户私钥更新密钥生成如下： B. 安全性分析 总结EDAC-MACS的安全性为如下的两个定理： 定理三：在EDAC-MACS中，撤销用户无法更新自己的私钥，即使它可以破坏多个AAs（没有撤销属性队形的AA）和与一些为撤销用户共谋。 证明：在EDAC-MACS中，每个私钥的更新与用户身份标识$uid$相关。并且在私钥中的$(g^{v_{x_k}H(x_k)^{\gamma_k}^2$项可以阻止用户使用其他用户的更新密钥来更新它们的私钥，因为$\gamma_k$是仅仅AA_k知道，所有用户都用户无法获取。 定理四：当判定性qBDHE问题假设成立，不存在一个多项式时间算法可以选择性的破坏EDAC-MACS，使用一个大小为$l^{\ast} \times n^{\ast}$,其中$ n^{\ast} \le q$。 证明： 基于定理三，EDAC-MACS的安全性证明跟DAC-MACS相似，如定理一。主要的不同是在EDAC-MACS中怎么去仿真新的私钥。详细的证明在附录A中给出。 六、相关工作问题：安全模型不是理解，定义3、4的理解 访问结构如何构造 属性在加密和解密中没有体现]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 日志系统]]></title>
    <url>%2F2018%2F09%2F05%2FLinux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[日志数据可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。它可以记录下系统产生的所有行为，并按照某种规范表达出来。可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。收集你想要的数据，分析出有价值的信息，可以提高系统、产品的安全性，还可以帮助开发完善代码，优化产品。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。 一、常见的日志日志是一个系统管理员，一个运维人员，甚至开发人员不可或缺的东西，系统永久了偶尔会出现一些错误，需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，需要日志来做问题定位，日志还是过往时间的记录表，可以通过它知道是否被不明用户登陆过等等。 在linux中大部分的发行版都内置使用syslog系统日志，常见的日志一般存放在var/log中，来看看其他有哪些日志： ll /var/log 根据图中所显示的日志，可以根据服务对象粗略的将日志分为两类： 系统日志：主要存放系统内置程序或系统内核之类的日志信息如alternative.log,btmp等等； 应用日志：主要是安装第三方应用所产生的日志，如：tomact7,apache3等等 系统日志具有有哪些，都记录了怎样的信息： 日志名称 记录信息 alternatives.log 系统的一些更新替代信息记录 apport.log 应用程序崩溃信息记录 apt/history.log 使用 apt-get 安装卸载软件的信息记录 apt/term.log 使用 apt-get 时的具体操作，如 package 的下载、打开等 auth.log 登录认证的信息记录 boot.log 系统启动时的程序服务的日志信息 btmp 错误的信息记录 Consolekit/history 控制台的信息记录 dist-upgrade dist-upgrade 这种更新方式的信息记录 dmesg 启动时，显示屏幕上内核缓冲信息,与硬件有关的信息 dpkg.log dpkg 命令管理包的日志。 faillog 用户登录失败详细信息记录 fontconfig.log 与字体配置有关的信息记录 kern.log 内核产生的信息记录，在自己修改内核时有很大帮助 lastlog 用户的最近信息记录 wtmp 登录信息的记录。wtmp可以找出谁正在进入系统，谁使用命令显示这个文件或信息等 syslog 系统信息记录 只闻其名，不见其人，并不能明白这些日志记录的内容。首先我们来看 alternatives.log 中的信息： 从中得到的信息有程序作用，日期，命令，成功与否的返回码 对于Debain系统，使用apt-get安装软件，因在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了哪个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。 其他的日志格式也都类似于之前所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog。 查看的方法是使用 last 与 lastlog 工具来提取其中的信息 二、配置的日志这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。 这样的实现可以通过两种方式： 一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具 rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。 这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd 因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看 sudo apt-get update sudo apt-get install -y rsyslog sudo service rsyslog start ps aux | grep syslog 既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务 首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个， 一个是 /etc/rsyslog.conf：主要是配置的环境，即rsyslog加载什么模块 一个是 /etc/rsyslog.d/50-default.conf：主要是配置的Filter Conditions。 /etc/rsyslog.conf /etc/rsyslog.d/50-default.conf 看看 rsyslog 的结构框架，数据流的走向，如下图： 通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。 Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。 第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages。而Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看。 配置中 rsyslog 支持三种配置语法格式： sysklogdlegacy rsyslogRainerScriptsysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 $ModLoad 还有一些插件和特性只在此语法下支持。而以 $ 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置 老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。 注释有两种语法: 井号 # C-style / .. / 执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。 模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。 legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么 模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement） 如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。 了解了 rsyslog 环境的配置文件之后，再看向 /etc/rsyslog.d/50-default.conf 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 Parser &amp; Filter Engine,它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，facility 与 priority，其配置格式如下: facility.priority log_location 其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 , 分割开,具体可见上图 rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有： | kern | 内核消息 || user | 用户信息 || mail | 邮件系统消息 || daemon | 系统服务消息 || auth | 认证系统 || authpriv | 权限系统 || syslog | 日志系统自身消息 || cron | 计划安排 || news | 新闻信息 || local0~7 | 由自定义程序使用 | 而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有一下几种： 类别 解释 emergency 系统已经无法使用了 alert 必须立即处理的问题 critical 很严重了 error 错误 warning 警告信息 notice 系统正常，但是比较重要 informational 正常 debug debug的调试信息 panic 很严重但是已淘汰不常用 none 没有优先级，不记录任何日志消息 auth,authpriv.* /var/log/auth.log 这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 /var/log/auth.log 日志中 而其中有类似于这样的配置信息意思有细微的差别 kern.* -/var/log/kern.log -代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。 与日志相关的还有一个还有常用的命令 logger,logger 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。 #首先将syslog启动起来 sudo service rsyslog start #向 syslog 写入数据 ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp; #查看是否有数据写入 sudo tail -f /var/log/syslog 从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板 我们可以通过 man 来查看 logger 的其他用法， 参数 内容 -i 在每行都记录进程 ID -t 添加 tag 标签 -p 设置日志的 facility 与 priority 三、转储的日志在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。 logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。 大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。 显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件 cat /etc/logrotate.conf # see &quot;man logrotate&quot; for details //可以查看帮助文档 # rotate log files weekly weekly //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 ) # keep 4 weeks worth of backlogs rotate 4 //最多转储4次 # create new (empty) log files after rotating old ones create //当转储后文件不存在时创建它 # uncomment this if you want your log files compressed compress //通过gzip压缩方式转储（nocompress可以不压缩） # RPM packages drop log rotation information into this directory include /etc/logrotate.d //其他日志文件的转储方式配置文件，包含在该目录下 # no packages own wtmp -- we&apos;ll rotate them here /var/log/wtmp { //设置/var/log/wtmp日志文件的转储参数 monthly //每月转储 create 0664 root utmp //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664 rotate 1 //最多转储一次 } 当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程管理]]></title>
    <url>%2F2018%2F09%2F05%2FLinux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[介绍一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。 一、进程查看 top:实时的查看进程的状态 ps:静态查看当前的进程信息 pstree:查看当前活跃进程的属性结构 1.1 top工具的使用top工具是常用的一个查看工具，能实时的查看系统的一些关键信息： top top是一个在前台执行的程序，所以执行后变进入到这样的一个交互界面，正因交互界面我们才可以实时的获取到系统于进程的信息，在交互界面我们eyi通过一些指令来操作和筛选，在此之前想了解显示的内容： 看到top显示的第一排： 内容 解释 top 表示当前的程序名称 09：12：35 表示当前的系统时间 up 16 days, 1:09 表示当前机器已经启动了多长时间 1 user 表示当前系统中只有一个用户 load average: 0.86,0.14,0.19 分别对应1，5，15分钟内cpu的评价负载 load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。 我们该如何看待这个load average 数据呢？ 假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。 load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务； load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足； load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已； load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了 这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数 #查看物理cpu的个数 cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l #每个cpu的核心数 cat /proc/cpuinfo | grep &quot;physical id&quot; | grep &quot;0&quot; | wc -l 通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了 若是 load &lt; 0.7 并不会去关注他； 若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了； 若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了； 若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了 通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。 top 的第二行数据，基本上第二行是进程的一个情况统计 内容 解释 Tasks: 28 total 进程总数 1 running 1个正在运行的进程数 26 sleeping 25个睡眠的进程数 1 stopped 没有停止的进程数 0 zombie 没有僵尸进程数 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计 | 内容 | 解释 || Cpu(s): 0.6us | 用户空间进程占用CPU百分比（0.6%）|| 0.2 sy | 内核空间运行占用CPU百分比（0.2%） || 0.0 ni | 用户进程空间内改变过优先级的进程占用CPU百分比（0.0%） || 98.6 id | 空闲CPU百分比 || 0.6 wa | 等待输入输出的CPU时间百分比 || 0.0 hi | 硬中断(Hardware IRQ)占用CPU的百分比 || 0.0 si | 软中断(Software IRQ)占用CPU的百分比 || 0.0 st | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 | CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。 top的第四行数据，这一行基本是内存的一个使用情况的统计 内容 解释 8175596 total 物理内存总量 1677840 free 空间的物理内存总量 1806640 used 使用的物理内存总量 4691116 buff/cache 用作内存缓存的内存量 注意：系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计 内容 解释 0 total 交换区总量 0 free 空闲的交换区总量 0 used 使用的交换区总量 60208884 avail Mem 可用交换区总量 再下面就是进程的一个情况： 列名 解释 PID 进程id USER 该进程的所属用户 PR 该进程执行的优先级 priority 值 NI 该进程的 nice 值 VIRT 该进程任务所使用的虚拟内存的总数 RES 该进程所使用的物理内存数，也称之为驻留内存数 SHR 该进程共享内存的大小 S 该进程进程的状态: S=sleep R=running Z=zombie %CPU 该进程CPU的利用率 %MEM 该进程内存的利用率 TIME+ 该进程活跃的总时间 COMMAND 该进程运行的名字 注意 NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低 PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。 其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同 VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数 top是一个前台程序，所以是一个可以交互的： 常用交互命令 解释 q 退出程序 I 切换显示平均负载和启动时间的信息 P 根据CPU使用百分比大小进行排序 M 根据驻留内存大小进行排序 i 忽略闲置和僵死的进程，这是一个开关式命令 k 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 1.2 ps工具的使用ps也是常用查看进程的工具之一，罗列出所有信息如下： ps aux 还可以在查看时，将连同部分的进程呈树状显示出来 ps axjf 内容 解释 F 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员root权限 USER 进程的拥有用户 PID 进程的 ID PPID 其父进程的 PID SID session 的 ID TPGID 前台进程组的 ID %CPU 进程占用的 CPU 百分比 %MEM 占用内存的百分比 NI 进程的 NICE 值 VSZ 进程使用虚拟内存大小 RSS 驻留内存中页的大小 TTY 终端 ID S or STAT 进程状态 WCHAN 正在等待的进程资源 START 启动进程的时间 TIME 进程消耗CPU的时间 COMMAND 命令的名称和参数 TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程 STAT表示进程的状态，而进程的状态有很多，如下表所示 状态 解释 R Running.运行中 S Interruptible Sleep.等待调用 D Uninterruptible Sleep.不可中断睡眠 T Stoped.暂停或者跟踪状态 X Dead.即将被撤销 Z Zombie.僵尸进程 W Paging.内存交换 N 优先级低的进程 &lt; 优先级高的进程 s 进程的领导者 L 锁定状态 l 多线程状态 + 前台进程 使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来 ps -l 若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用 ps aux | grep zsh 当然如果觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示 ps -afxo user,ppid,pid,pgid,command 1.3 pstree工具的使用通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。 pstree pstree -up #参数选择： #-A ：各程序树之间以 ASCII 字元來連接； #-p ：同时列出每个 process 的 PID； #-u ：同时列出每个 process 的所屬账户名称。 二、 进程管理2.1 kill命令当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。 前面使用 kill 命令来管理一些 job，这里将尝试用 kill 来操作下一些不属于 job 范畴的进程 #使用9这个信号强制结束 gedit 进程 kill -9 1608 2.2 进程的控制顺序在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？ 当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了 而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制 #打开一个程序放在后台，或者用图形界面打开 nice -n -5 vim &amp; #用 ps 查看其优先级 ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim 还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试 renice -5 pid]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016百度校招面试题]]></title>
    <url>%2F2018%2F09%2F02%2F2016%E7%99%BE%E5%BA%A6%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[对前面学习命令的一个总结 2016百度校招面试题在linux中，对于文本的处理和分析是极为重要的，现在有一个文件叫做data1，同学们可以在这里下载， wget http://labfile.oss.aliyuncs.com/courses/1/data1 里面记录是一些命令的记录，现在需要你从里面找出出现频率次数前3的命令并保存在/home/shiyanlou/result。 目标 处理文本data 将结果写入result 结果包含次数和命令，如“100 ls” 提示 cut截取(-c 8明白含义吗) uniq -dc去重 sort 的参数选择-k1 -n -r 答案类似于 cat data|....|....|.... &gt; /home/shiyanlou/result cat data1 | cut -c 8- | sort | uniq -dc | sort -n -r &gt; result 解释： 在去重之间，必须先排序，否则，内容为空，具体原因不太清楚，希望清楚的可以留言，谢谢 cut -c 8-： 截取第8个字符之后的字符（包括第8个） sort: 默认排序 uniq -dc: 去重并，-c在输出行前面加上每行在输出文件中出现的次数，-d仅显示重复行 sort -n -r: 按数值从大到小的顺序排列，-r以相反的顺序排序，默认从小到大，-n依照数值的大小排序 head -n -3 显示头三条 附件： sort -t -k: -t后面可以设定间隔符，指定间隔符之后，就可以用-k来指定列数 将如下日期按月份排序 2017-12-092017-01-202017-04-242017-10-23 sort -n -k 2 -t&apos;-&apos;]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程概念]]></title>
    <url>%2F2018%2F09%2F01%2FLinux%20%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。 而在此之前，我们需要对进程的基础知识有一定的了解，才能更好、更有效率的使用Linux 提供的工具。 一、概念理解1.1 程序与进程程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如vim程序。而进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下特点： 动态性： 进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性： 进程可以做到一个时间段内，有多个进程在运行。程序只是静态的实体，所以不存在并发性。 独立性： 进程可以独立分配资源，独立接受调查，独立地运行。 异步性： 进程以不可预知的速度向前推进。 结构性： 进程拥有代码段、数据段、PCB(进程控制块，进程存在的唯一标识)。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都在执行过） 并行：在每一个瞬间，都有多个程序在同时执行，这个必须多个CPU才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 二、进程的属性2.1 进程分类进程的分类，可以从两个角度来分： 以进程的功能与服务的对象来分； 以应用程序的服务类型来分。 第一个角度来看，可以分为用户进程与系统进程： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此来进程可以在用户的控制下运行或关闭。 系统进程： 通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。 第二个角度来看，可以将进程分为交换进程、批处理进程、守护进程 交换进程：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在Linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有进程用的cron（在centos系列为crond）进程，这个进程为crontab的守护进程，可以周期性的执行用户设定的某些任务。 2.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少，感兴趣的同学可以查查为什么。 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 pstree 还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 2.3 进程组于Sessons每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 2.4 工作管理bash（Bourne-Again shell）支持工作控制（job control）,而sh(Bourne shell)不支持。 并且每个终端或者说bash只能管理当前终端中的job，不能管理其他终端中的job，比如我们当前存在两个bash分别为bash1、bash2，bash1只能管理其自己里面的job并不能管理bash2里面的job。 当知道一个进程在前台运行时，可以同用Ctrl+C来终止它，但是若在后台的话，则不行。 可以通过&amp;符号，让命令在后台运行： ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令 #后面不加参数提取预设工作，加参数提取指定工作的编号 #ubuntu 在 zsh 中需要 %，在 bash 中不需要 % fg [%jobnumber] Ctrl+z使得工作停止放置在后台，如果想让其在后台运行，可以使用如下命令： #与fg类似，加参则指定，不加参则取预设 bg [%jobnumber] 既然有办法让放置在后台的工作提至前台或让它从停止变成继续运行在后台，当然也有办法删除一个工作，或者重启等： #kill的使用格式如下 kill -signal %jobnumber #signal从1-64个信号值可以选择，可以这样查看 kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 注意: 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作 若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍grep，sed，awk这三个命令，而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）。 概念正则表达式，又被正规表示式、正规表示法、针对表达式、规格表达式、常规表达法（Regular Expression,或regex、regexp、RE）。正则表达式使用单个字符来描述、匹配一系列符合某个句法规则的字符串。在很多编辑器里，正则表达式通常用来检索、替换那些符合某个模式的文本。 注意区分正则表达式与通配符的差别。 在文本过滤工具里，都是用正则表达式，比如像awk，sed，等，是针对文件的内容的 而通配符多用在文件名上，比如查找find，ls，cp，等等 具体内容对比，可以参考：https://blog.csdn.net/zgqxiexie/article/details/51184602 例子： 一个文件中，包含“shiyanlou”和“shilouyan”这两个字符，同样一个表达式： shi* 如果上述表达式作为正则表达式，它将只能匹配shi；而如果不是正则表达式，而是作为一个通配符，则将同时匹配两个字符串。 原因：在正则表达式中，*表示匹配前面的子表达式零次或多次，比如它可以匹配”sh”,”shi”,”shii”,”shishi”等等，而作为通配符*表示匹配通配符后面任意多个字符，所以可以匹配文本中的字符串。 基本语法一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。 选择|表示分割，比如： boy | gril可以匹配“boy”或者“girl” 数量限定数量限定出了上面讲过的*，还有+和?,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次： +表示前面的字符必须出现至少一次（一次或多次），例如，”goo+gle”可以匹配‘goooogle’,’gooooogle’等； ?表示前面的字符最多出现一次（零次或一次），例如，“colou?r”可以匹配‘colour’和‘color’； *表示前面的字符可以不出现，也出现一次或者多次，例如，‘0*42’可以匹配42，042，0042，00042等等。 范围和优先级()圆括号可以用来定义模式字符串的范围和优先级，可以简单的理解位是否将括号内的模式串作为一个整体。例如，”gr(a|r)y”等价于gray|grey；”(grand)?father”匹配father和grandfather。 语法部分正则表达式有多种不同的风格，下面举例一下常用的作为PCRE子集的适合于perl和python编程语言及grep或egrep的正则表达式匹配规则。 PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库，比Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。 字符 描述 \ 建一个字符标记为一个特殊字符，或一个原义字符，比如，”n”匹配字符“n”, “/n”匹配一个换行符，序列”\“匹配”\”而“(”匹配”(“。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 {n} n是一个非负整数，匹配确定的n次，例如：”o{2}”不能匹配“Bob”种的“o”,但是能匹配“book”种的两个”o” {n,} n是一个非负整数，至少匹配n次，例如：“o{2,}“不能匹配‘bob’，但可以匹配”foooood“种的所有‘o’, &quot;o{1,}&quot;等价于”o+“,&quot;o{0,}&quot;等价于”o*“ {n,m } m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次，比如“o{1，3}”将匹配“fooooodv”种的前三个o * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除了”\n“之外的任何单个字符，要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。 （pattern） 匹配pattern并获取这一匹配的子字符串。该子字符串用户向后引用。要匹配圆括号字符，请使用“(”或“)”。 x竖线y 匹配x或y。 例如”z竖线food“能匹配”z“或”food”.”(z竖线f)oood”则匹配”zood“或”food“。 [xyz] 字符集合（character class）。匹配所包含的任意一个字符。例如，”[abc]“可以匹配”plain“中的”a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。 [^xyz] 排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意：由于markdown的语法问题，表格中的竖线无法显示，会被编译成表格的一列，所以在表格中使用竖线（’|‘）的地方，写成了中文的“竖线” 优先级优先级为从上到下从左到右，依次降低： 运算符 说明 \ 转义符 (), (?:), (?=), [] 括号和中括号 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$、\任何元字符 定位点和序列 ｜ 选择 grep模式匹配命令基本操作grep命令用户打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定： 参数 说明 -E POSIX扩展正则表达式，ERE -G POSIX基本正则表达式，BRE -P Perl正则表达式，PCRE 在通过grep命令使用正则表达式之前，先介绍一下它的常用参数： 参数 说明 -b 将二进制文件作为文本来进行匹配 -c 统计以模式匹配的数目 -i 忽略大小写 -n 显示匹配文本所在行的行号 -v 反选，输出不匹配行的内容 -r 递归匹配查找 -A n n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行 -B n n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行 –color=auto 将输出中的匹配项设置为自动颜色显示 使用正则表达式使用基本正则表达式：BRE 位置 查找/etc/group文件中以”shiyanlou“为开头的行 grep &apos;shiyanlou&apos; /etc/group grep &apos;^shiyanlou&apos; /etc/group 数量 #匹配以‘z’开头以‘o’结尾的所有字符串 echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.*o&apos; #匹配以‘z’开头以‘o’结尾，中间包含一个任意字符的字符串 echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.o&apos; #匹配以‘z’开头，以任意多个‘o’结尾的字符串 echo &apos;zero\nzo\nzoo&apos; | grep &apos;zo*&apos; 选择 #grep默认区分大小写，这里将匹配所有的小写字母 echo &apos;1234\nabcd&apos; | greap &apos;[a-z]&apos; #将匹配所有的数字 echo &apos;1234\nabcd&apos; | greap &apos;[0-9]&apos; #匹配所有数字 echo &apos;1234\nabcd&apos; | greap &apos;[[:digit]]&apos; #匹配所有小写字母 echo &apos;1234\nabcd&apos; | greap &apos;[[:lower:]]&apos; #匹配所有大写字母 echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:upper:]]&apos; #匹配所有的数字和字母，包括：0-9，a-z,A-Z echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:alnum:]]&apos; #匹配所有的字母 echo &apos;1234\nabcd\nABCD&apos; | greap &apos;[[:alpha:]]&apos; 下面包含完整的特殊符号及说明： 特殊符号 说明 [:alnum:] 代表英文大小写字母及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字母，亦即 A-Z, a-z [:blank:] 代表空白键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字母，亦即 a-z [:print:] 代表任何可以被列印出来的字符 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字母，亦即 A-Z [:space:] 任何会产生空白的字符，包括空白键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节 # 排除字符 echo &apos;geek\ngood&apos; | grep &apos;[^o]&apos; 使用扩展正则表达式要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。 数量 #只匹配”zo“ echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo{1}&apos; #匹配以&apos;zo&apos;开头的所有单词 echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo{1,}&apos; 注意：推荐掌握{n,m}即可，+,?,*，这几个不太直观，且容易弄混淆。 选择 # 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot; $ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -E &apos;www\.(shiyanlou|google)\.com&apos; # 或者匹配不包含&quot;baidu&quot;的内容 $ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -Ev &apos;www\.baidu\.com&apos; sed流编辑器sed工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text “，意即，用于过滤和转换文本的流编辑器。 在 Linux/UNIX 的世界里敢称为编辑器的工具，大都非等闲之辈，比如前面的”vi/vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”这些个编辑器。sed与上述的最大不同之处在于它是一个非交互式的编辑器。 sed常用参数介绍sed命令基本格式 sed [参数] [执行命令] [输入文件] ... #形如 sed -i &apos;s/ad/happy&apos; test #表示将test文件中的&quot;sad&quot;替换成happy 参数 说明 -n 安静模式，只打印受影响的行，默认打印输入数据的全部内容 -e 用于在脚本中添加多个执行命令一次执行，在命令行中多个命令通过需要加该参数 -f filename 指定执行filename文件中的命令 -r 使用扩展正则表达式，默认为标准正则表达式 -i 直接修改输入文件内容，而不是打印到输出标准设备 sed编译器的执行命令sed 执行格式： [n1][,n2]command [n1][~step]command # 其中一些命令可以在后面加上作用范围，形如： $ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围 $ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串 其中n1,n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令： 命令 说明 s 行内替换 c 整行替换 a 插入到指定行的后面 i 插入到指定行的前面 p 打印指定行，通常与-n参数配合使用 d 删除指定行 sed操作举例打印指定行#打印2-5行 nl passwd | sed -n &apos;2,5p&apos; #打印奇数行 nl passwd | sed -n &apos;1~2p&apos; 注意：nl 可以将输出的文件内容自动的加上行号 行内替换#文本中”shiyanlou“全局替换成’hehe‘，并纸打印替换的那一行，注意这里不能省略最后的”p“命令 sed -n &apos;s/shiyanlou/hehe/gp&apos; passwd 注意： 行内替换可以结合正则表达式使用。 行间替换nl passwd | grep &apos;shiyanlou&apos; #删除第21行 sed -n &apos;21c\www.shiyanlou.com&apos; passwd （这里我们只把要删的行打印出来了，并没有真正的删除，如果要删除的话，请使用-i参数） awk文本处理语言AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。 在大多数linux发行版上面，实际我们使用的是gawk（GNU awk，awk的GNU版本）。 nawk： 在 20 世纪 80 年代中期，对 awk语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得; gawk： 是 GNU Project 的awk解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序，但不断地对其进行了更新，以包含 NAWK 的特性; mawk 也是awk编程语言的一种解释器，mawk遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言，包含了一些没有在AWK 手册中提到的特色，同时 mawk 提供一小部分扩展,另外据说mawk是实现最快的awk。 awk的基础概念awk所有的操作都是基于pattern（模式）—action(动作)对来完成的，如下面的形式： pattern {action} 它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。 awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。 awk命令基本格式awk [-F fs] [-v var=value] [-f prog-file] | &apos;program text&apos;] [file...] 其中-F参数用于预先指定前面提高的字段分隔符（还有其他指定字段的方式），-v用户预先为awk程序指定变量，-f参数用户指定awk命令要执行的程序文件，或者在不加’-f’参数的情况下直接间程序语句放在这里。最后为awk需要处理的文本输入，且可以同时输入多个文本文件。 awk操作体验vim test #输入文本 cat test 使用swk将文本打印到终端awk &apos;{ print }&apos; test #或者写成一行 awk &apos;{print}&apos; test 说明:在这个操作中我是省略了pattern，所以awk会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即print打印所有匹配项，这里是全部文本内容 将test的第一行中的每个字段单独显示为一行$ awk &apos;{ &gt; if(NR==1){ &gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3 &gt; } else { &gt; print} &gt; }&apos; test # 或者 $ awk &apos;{ &gt; if(NR==1){ &gt; OFS=&quot;\n&quot; &gt; print $1, $2, $3 &gt; } else { &gt; print} &gt; }&apos; test 说明:你首先应该注意的是，这里我使用了awk语言的分支选择语句if,它的使用和很多高级语言如C/C++语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是NR与OFS，这两个是awk内建的变量，NR表示当前读入的记录数，你可以简单的理解为当前处理的行数，OFS表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为\n换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是$N其中N为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了$3。除此之外另一个这里没有出现的$0，它表示引用当前记录（当前行）的全部内容。 将test的第行以点为分段的字段换成以空格为风格$ awk -F&apos;.&apos; &apos;{ &gt; if(NR==2){ &gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3 &gt; }}&apos; test # 或者 $ awk &apos; &gt; BEGIN{ &gt; FS=&quot;.&quot; &gt; OFS=&quot;\t&quot; # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开 &gt; }{ &gt; if(NR==2){ &gt; print $1, $2, $3 &gt; }}&apos; test 说明：这里的-F参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的\t，print打印的非变量内容都需要用””一对引号包围起来。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用BEGIN，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是FS赋值了新的”.”点号代替默认的” “空格 awk常用的内置变量 变量名 说明 FILENAME 当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串 $0 当前记录的内容 $N N表示字段号，最大值为NF变量的值 FS 字段分隔符，由正则表达式表示，默认为” “空格 RS 输入记录分隔符，默认为”\n”，即一行为一个记录 NF 当前记录字段数 NR 已经读入的记录数 FNR 当前输入文件的记录数，请注意它与NR的区别 OFS 输出字段分隔符，默认为” “空格 ORS 输出记录分隔符，默认为”\n”]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7设置默认进入图形界面和命令行界面]]></title>
    <url>%2F2018%2F09%2F01%2FCentos%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E8%BF%9B%E5%85%A5%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[相比7之前的版本，在centos7版本中，设置OS启动默认进入图形界面还是文本界面有了点变化。 查看当前默认设置 systemctl get-default graphical.target #默认图形界面 设置开始进入命令行界面： systemctl set-default multi-user.target #返回 Removed symlink /etc/systemd/system/default.target. Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target. 设置开始进入图形界面： systemctl set-default grphical.target 阅读/etc/inittab，也可以发现如下内容 [root@rems2 ~]# cat /etc/inittab # inittab is no longer used when using systemd. # # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM. # # Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target # # systemd uses &apos;targets&apos; instead of runlevels. By default, there are two main targets: # # multi-user.target: analogous to runlevel 3 ---&gt;告诉我们multi-user.target相当于以前的runlevel 3 # graphical.target: analogous to runlevel 5 ---&gt;告诉我们graphical.target相当于以前的runlevel 5 # # To view current default target, run: # systemctl get-default # # To set a default target, run: # systemctl set-default TARGET.target # 转自:https://blog.csdn.net/liglewang/article/details/76222642 命令行输入： init 3 进入命令行界面 init 5 进入图形界面 图形界面安装教程： https://www.linuxidc.com/Linux/2018-04/152000.htm]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下软件安装]]></title>
    <url>%2F2018%2F09%2F01%2FLinux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在此简单介绍Linux下软件安装，更多可见：Linux不同版本以及程序包安装 注意本文介绍的都是基于ubuntu 体验比如我们想安装一个软件，名字叫做 w3m(w3m是一个命令行的简易网页浏览器)，那么输入如下命令： sudo apt-get install w3m 它就表示将会安装一个软件包名为w3m的软件。 apt包管理工具介绍 APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的多个工具，如 apt-get apt-cache apt-cdrom 等，在Debian系列的发行版中使用。 当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了： 软件源镜像服务器 软件源 我们需要定期从服务器上下载一个软件包列表，使用 sudo apt-get update 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，我举个例子：我们安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 apt-get 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。 apt-getapt-get 是用于处理 apt包的公用程序集，可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具： 工具 说明 install 其后加上软件包名，用于安装一个软件包 update 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表 upgrade 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update dist-upgrade 解决依赖关系并升级(存在一定危险性) remove 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 autoremove 移除之前被其他软件包依赖，但现在不再被使用的软件包 purge 与remove相同，但会完全移除软件包，包含其配置文件 clean 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/ autoclean 移除已安装的软件的旧版本软件包 下面是一些apt-get常用的参数： 参数 说明 -y 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 -s 模拟安装 -q 静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 -f 修复损坏的依赖关系 -d 只下载不安装 –reinstall 重新安装已经安装但可能存在问题的软件包 –install-suggests 同时安装APT给出的建议安装的软件包 重新安装软件包： sudo apt-get --reinstall install w3m 如果不知软件包完整名的时候，通常使用Tat键补全软件包名。 软件升级 #更新软件源 sudo apt-get #升级没有依赖问题的软件包 sudo apt-upgrade #升级并解决依赖关系 sudo apt-get dist-upgrade 卸载软件 sudo apt-get remove w3m #不保留配置文件的移除 sudo apt-get purge w3m #或者 sudo apt-get --purge remove w3m #移除不再需要的被依赖的软件包 sudo apt-get autoremove 软件搜索 当刚知道了一个软件，想先下载，需要确认仓库里面有没有，就需要用到搜索功能，命令如下： sudo apt-cache search softname1 softname2 .... 使用dpkg dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。 dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。 dpkg常用参数介绍： 参数 说明 -i 安装指定deb包 -R 后面加上目录名，用于安装该目录下的所有deb安装包 -r remove，移除某个已安装的软件包 -I 显示deb包文件的信息 -s 显示已安装软件的信息 -S 搜索已安装的软件包 -L 显示已安装软件包的目录信息 #查看已经安装软件包的安装目录 sudo dpkg -L w3m 从二进制包安装二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux数据流重定向]]></title>
    <url>%2F2018%2F09%2F01%2FLinux%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[你可能对重定向这个概念感到些许陌生，但你应该在前面的课程中多次见过&gt;或&gt;&gt;操作了，并知道他们分别是将标准输出导向一个文件或追加到一个文件中。这其实就是重定向，将原本输出到标准输出的数据重定向到一个文件中，因为标准输出(/dev/stdout)本身也是一个文件，我们将命令输出导向另一个文件自然也是没有任何问题的。 常用重定向操作： echo &apos;hello shiyanlou&apos; &gt; redirect echo &apos;www.shiyanlou.com&apos; &gt;&gt; redirect cat redirect 简单的重定向Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。 文件描述符 设备文件 说明 0 /dev/stdin 标准输入 1 /dev/stdout 标准输出 2 /dev/stderr 标准错误 文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。 将cat的连续输出（heredoc方式）重定向到一个文件： cat &gt; test.cpp &lt;&lt; EOF 输入需要存入test.cpp文件的内容，输入EOF结束 将一个文件作为命令的输入，标准输出作为命令的输出： cat test.cpp 将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出： echo &apos;hi&apos; | cat 将echo命令的输出从默认的标准输出重定向到一个普通文件： echo &quot;hello world&quot; &gt; redirect cat redirect 标准错误重定向重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作： #使用cat同时读取两个文件，其中一个存在，一个不存在 cat test.c hello.c #可以看到上述命令，输出第一个文件的内容，还在末尾处出现了一条错误信息 #下面将输出重定向到一个文件 cat test.cpp hello.cpp &gt; somefile 遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了： #将标准错误重定向到标准输出(2&gt;&amp;1)，再将标准输出重定向到文件，注意要将重定向文件写到前面,2表示标准错误，1表示标准输出， cat test.cpp hello.cpp &gt; somefile 2&gt;&amp;1 #或者只用bash提供的特殊的重定向符号`&amp;`将标准错误和标准输出同时重定向到文件 cat test.cpp hello.cpp &amp;&gt;somefilehell 注意你应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中 使用tee命令同时重定向到多个文件除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用tee命令来实现： echo &quot;hello world;&quot; | tee hello 永久重定向前面的重定向操作都只是临时性的，即对当前命令有效，如何做到重定向对所有命令都有效呢？比如在一个脚本中，仅需要某一部分的命令全部进行重定向，难道要在每个命令上面加上临时重定向的操作吗？当然不需要，可以使用exec命令实现“永久”重定向。exec命令的作用是使用指定的命令替换当前的shell，即使用一个进程替换当前进程，或者指定新的重定向。 #先开启一个子shell zsh #使用exec替换当前进程的重定向，将标准输出重定向到一个文件 exec 1&gt;somefile #下面执行的命令的输出都将重定向到文件中，直到你退出当前shell，或取消exec的重定向 ls ll exit cat somefile 创建输出文件描述符在shell中有9个文件描述符，前面介绍和使用了默认提供的0、1、2文件描述符。另外还可以使用3-8的文件描述符，只是它们默认没有打开而已。 使用如下命令查看当前shell进程中打开的文件描述符： cd /dev/fd/; ls -Al 同样，可以使用exec命令创建新的文件描述符： zsh exec 3&gt;somefile #先进入目录，在查看，否则可能不能得到正确的结果，然后再回到上一次的目录 cd /dev/fd/;ls -Al; cd - #注意下面的命令&gt;和&amp;之间不应该有空格，如果有空格则会报错 echo &quot;this a test&quot; &gt;&amp;3 cat somefile exit 关闭文件描述符上面打开了3号文件描述符，可以使用如下操作将其关闭： exec 3&gt;&amp;- cd /dev/fd;ls -Al;cd - 完全屏蔽命令的输出在Linux中有一个被称为“黑洞”的设备文件，所以导入它的数据都将被“吞噬”。 在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。 可以实利用/dev/null屏蔽命令的输出： cat test.cpp hello.cpp 1&gt;/dev/null 2&gt;&amp;1 上面这样的操作将使你得不到任何输出结果。 使用xargs分割参数列表xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题 这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。 cut -d: -f1 &lt; /etc/passwd | sprt | xargs echo 上面这个命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--开始学习（二）]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C%2B%2B%2F</url>
    <content type="text"><![CDATA[C++基本语法介绍 进入C++C++对大小写敏感，比如：将cout替换成Cout或COUT，都无法通过编译。 C++程序包括的元素： 注释： 由前缀//标识 预处理器编译指令#include 函数头： int main() 编译指令：using namespace 函数体：用{}括起 使用C++的cout工具显示消息的语句 结束main()函数的return语句 main()int main() { statements return 0; } 这几行代码构成了函数的定义。定义由两部分组成： 第一行：int main()叫函数头（functon definition），函数头对函数与程序其他部分之间的接口进行了总结； 花括号中包括的部分叫做函数体，函数体指出函数应该做什么计算机指令。 作为接口的函数头C++函数可以被其他函数调用，函数头描述了函数与调用函数之间的接口。 位于函数名的前部分叫做函数的返回类型，他描述的是从函数返回给调用它的函数的信息。 函数名括号中的部分叫做形参列表，或参数列表，它描述的是从调用函数传递给被调用的函数的信息。 注：main()通常不被程序的其他部分调用，而被启动代码调用，启动代码是由编译器添加到程序中的，是程序和操作系统之间的桥梁。 C++中合法的函数头： int main() int main(void) main（）中如果结尾未遇到返回语句，则默认添加语句结尾：retrun 0;，不适应于其他函数。 注释//表示注释，单行注释 /*注释部分*/ 多行注释 预处理器和iostream文件如果程序中使用到C++的输入或输出工具，必须提供如下两行代码： #include &lt;iostream&gt; using namespace std; 注意：以上代码在C++98标准中实现，如果编译器不接受上述两行代码，说明它没有遵守标准C++98。 #include &lt;iostream&gt;指令导致预处理将iostream文件中的内容添加到程序中。iostream中的io指的是输入和输出。C++的输入/输出方案涉及iostream文件中的多个定义。为了使用cout来显示消息，第一个程序需要这些定义。#include编译指令导致iostream文件的内容随源代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将取代程序中的代码行#include &lt;iostream&gt;。源文件并没有被修改，而是源代码文件和iostream组合成的一个复合文件，编译的下一个阶段将使用到该文件。 头文件名iostream这样的文件叫做包含文件（include file）—由于它被包含在其他文件中，也被叫做头文件（header file）—由于他被包含在文件的起始处。 C++包含了C中的头文件，C中的头文件以h为扩展名，比如：math.h，仍可以使用C中math.h头文件。C++中的头文件没有扩展名。注意，C中的有些头文件被转换为C++头文件，文件被重新命名，去掉扩展名h，并在文件名称前面添加前缀c(表明来自C语言)。例如：C++版本的math.h为cmath。 C++旧式风格，头文件以.h结尾，比如：iostream.h 命名空间如果使用iostream，而不是iostream.h，则应使用下面的命名空间编译指令来使iostream中的定义对程序可用： using namespace std; 这被称之为using编译指令。 命名空间支持是C++的一项特性，旨在让编写大型程序以及将多个厂商现有的代码组合起的程序时更容易，它还有助于组织程序。一个潜在的问题，当使用两个以及封装好的产品，而它们同时使用了wanda()函数。这样当使用wanda()函数的时候，编译器不知道指的哪个版本。 命名空间让厂商将其产品封装在一个叫做命令空间的单元中，这样可以用命名空间来指出想使用哪个厂商的产品。Microflop可以将其定义放到一个名为Microflop的命名空间中。这样，其的wanda（）函数的全称为Microflop::wanda();同样，Piscine公司的wanda()版本表示为：Piscine::wanda()。这样，程序就可以使用命名空间来区分不同的版本。 类、变量和函数是C++编译器的标准组建，它们被放置在命名空间std中。仅当头文件没有扩展h时，情况才是如此。 实际中如上三种方式等级： std:cin&gt;&gt; a; std::cout &lt;&lt;&quot;jjj&quot;; std::cout&lt;&lt;std::endl; using std::cout; using std::endl; using std:cin; using namespace std #偷懒写法 使用cout进行C++输出cout &lt;&lt;&quot;come up&quot; &lt;&lt;表示把字符串发送给cout，该符号指出了信息流动的路径。cout是一个预定义的对象，知道如何显示字符串、数字和单个字符等等。 cout对象表示一个流，其属性是在iostream文件中定义的，cout的对象包括一个插入运算符”&lt;&lt;”,它可以将右侧的信息插入到流中。 上面代码，将字符串插入到输出流中，因此，与其说程序显示了一条消息，不如说它将一个字符串插入到了输出流中。 注意：插入运算符&lt;&lt;跟按位左移运算符&lt;&lt;一样，其实这是一个运算符重载的例子。通过重载，同一个符合将有不同的含义。编译器通过上下文来确定运算符的含义。C本身也有一些运算符重载，比如：&amp;符合既有地址运算符，又表示AND运算符；*既表示乘法，又表示指针解除引用。 控制符endlendl表示重起一行，在输出流中插入endl将导致屏幕光标移到下一行。endl同样也在头文件iostream中定义，且位于命名空间std中。 cout&lt;&lt;&quot;The Good, the&quot;; cout&lt;&lt;&quot;Bad,&quot;; 输出结果：The Good, the Bad, 换行符&#39;/n&#39; cout&lt;&lt;endl; 两者区别：enld确保程序继续运行前刷新输出（即将其立即显示在屏幕上）；而使用’\n’不能提供这样的保证。 C++源代码格式化C++中使用’;’表示语句的结尾。因此在C++中，回车的作用就和空格或制表符相同。也就是几条语句可以放在同一行，用空格或制表符隔开。 C++代码风格： 每条语句占一行 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。 函数中的语句都要相对花括号进行缩进 与函数名相关的圆括号周围没有空白 C++语句C++程序是一组函数，而每个函数又是一组语句。C++有好几种语句：声明语句创建变量，复制语句给变量提供一个值。 声明语句和变量int carrots 这条语句提供了两项信息： 需要的内存以及该内存单元的名称，具体，这条语句指出程序需要足够的存储来存储一个整数。 给存储单元指定名称，该声明语句指出，此后程序将使用名称carrots来标识存储在该单元中的值，carrots被称为变量。 声明变量的重要性： python中，在使用新名称时创建变量，而不用显式地进行声明。看上去比较友好，问题是如果变量名写错，将在不知情的情况下创建一个新的变量。如下： castleDark = 34 castleDank = castleDark + MoreGhosts print(castleDark) 由于castleDank拼写错误，因此所作的修改实践上并没有修改castleDark。这种错误很难发现，因为并没有违反python的任何规则。然后，在C++中，违反了使用变量前必须声明它的规则，因此编译器将捕获这种错误。 C中的变量声明通常位于函数的开头，不过C++的变量声明没有这种限制，C++的通常做法是在首次使用变量前声明它，这样不必再程序中查找，以了解变量的类型。 赋值语句赋值语句将赋值给存储单元，例如： carrots = 25; 将整数25赋给变量carrots表示的内存单元。 符号’=’叫做赋值运算符。C++和C有一项不寻常的特性—可以连续使用赋值运算符。例如： int steinway; int baldwin; int yamaha; yamaha = balwin = steinway = 88; 赋值将从右至左进行。首先，将88被赋值给steinway,然后，steinway的值被赋值给baldwin，继续进行。 赋值之前可以修改变量的值，比如： carrots = carrots - 1; cout的新花样cout前面都是用来打印字符串，而它还可以用来打印变量： cout &lt;&lt; carrots; 程序没有打印carrots，而是打印存储在carrots中的值，即25。实际上，这将两个操作合而为一。首先，cout将carrots替换为其当前值25；然后，把值转换为合适的输出字符。打印之前，cout必须将整数形式转化为字符的形式。 字符串’15‘和整数25有天壤之别： 字符串存储的是书写该该数字时使用的字符，即字符2和5。程序在内部存储的是字符2和字符5的编码。要打印字符串，cout只需要打印字符串中的各个字符即可。 整数25被存储为数值，计算机不是单独存储每个数字，而是将25存储为二进制数。 C语言中，使用特殊代码（%s和%d）来指出打印字符串和整数。如果让printf()打印字符串，但又错误的提供了一个整数，由于printf()不够精密，因此根本发现不了错误，而是输出一串乱码。 printf(&quot;%s&quot;, &quot;25&quot;); printf(&quot;%d&quot;, 25); 而C++中cout比较智能，其智能来自C++的面向对象特性。实际中，C++插入运算符（&lt;&lt;）将根据其后的数据类型相应的调整其行为，这是一个运算符重载的例子。 其他C++语句cincin &gt;&gt; carrots; 从这条语句，可知，信息从cin流向carrots。cin使用&gt;&gt;运算符从输入流中抽取字符，运算符右侧提供一个变量，以接受抽取的信息。”&lt;&lt;”和”&gt;&gt;”用来指示信息流的方向。 cin同样是一个智能对象，它可以将通过键盘输入的一系列字符（即输入）转换为接受信息的变量能过接受的形式。 int carrots; cin &gt;&gt; carrots; 上述例子，程序将carrots声明为一个整性变量，因此输入被转换为计算机用来存储整数的数字形式。 cout进行封装cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots&quot; &lt;&lt; endl; 跟如下代码等价： cout &lt;&lt; &quot;Now you have &quot;; cout &lt;&lt; carrots ; cout &lt;&lt; &quot; carrots&quot;; cout &lt;&lt; endl; 也可写成如下形式： cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots&quot; &lt;&lt; endl; 类简介类是用户定义的一种数据类型。类之于对象就像类型之于变量，即类定义描述的是数据格式及其用法，而对象则是根据数据格式创建的实体。比如：类就好比所有著名演员，则对象就是好比某个著名演员，如，蛙人Kermit。扩展这种类比，表示演员的类中包括该类可执行的操作的定义，如念某句台词，表达悲伤，接受奖励。 int carrotss; 上面的代码创建了一个类型为int的变量（carrots）。也就是说，carrots可以存储整型，可以按特定的方式使用—例如，用户加和减。 又如，cout是一个ostream类对象，ostream类定义描述了ostream对象表示的数据以及可以对它执行的操作。如将数字或字符串插入到输出流中。同样，cin是一个istream类，也定义在iostream中。 注意：类描述了一种数据类型的全部属性，包括可使用它执行的操作，对象是根据这些描述创建的实体。 类描述指定了可对类对象执行的所有操作，要对特定对象执行这些允许的操作，需要给该对象发送一条消息。例如：希望cout对象显示一个字符串，应向它发送一条消息，告诉它，“对象，显示这些内容！”。 C++提供了两种发送消息的方式： 使用类方法（本质上就是函数调用）； 重新定义运算符，cin和cout采用的就是这种方式。 cout &lt;&lt; “I am not a crook”; 上面的语句使用重新定义&lt;&lt;运算符将‘显示的消息’发送给cout。消息带有一个参数—即显示的字符串。 函数C++函数分为两类：有返回值和无返回值。 使用有返回值的函数有返回值的函数将生成一个值，而这个值可赋给变量或在其他表达式中使用。例如，C/C++库中的sqrt()函数，它返回平方根，如下： x = sqrt(6.25); 表达式sqrt(6.25)将调用sqrt()函数，表达式sqrt(6.25)被称为函数调用，被调用的函数被称为被调用函数（called function）,包含函数调用的函数叫做调用函数。 int main() { x = sqrt(6.25) } 其中的main()函数叫做调用函数， sqrt()叫做被调用函数。括号中的值6.25是发送给函数(sqrt())的消息，以这种方式发送给函数的值叫做参数。被调用函数返回的值叫做函数的返回值（return value）。 函数原型之于函数就像变量声明之于变量—指出涉及的类型。例如，C++库将sqrt()函数定义成将一个看（可能）带小数部分的数字（6.25）作为参数，并返回一个相同类型的数字。sqrt()的函数原型如下： double sqrt(double);//函数原型 第一个double意味着sqrt()返回一个double值，括号中的double一位sqrt()需要一个double参数。因此该原型对sqrt()的描述和下面代码中使用的函数相同： double x; x = sqrt(6.25); 原型结尾的分号表明它是一条语句，这使得它是一个原型，而不是函数头。如果省略分号，编译器将把这行代码解释为函数头，并要求提供函数体。 在程序中使用sqrt()是，必须通过原型，可以用两种方式提供来实现： 在源代码文件中输入函数原型 包含头文件cmath（老系统math.h），其中定义了原型 第二种方法更好，因为头文件更有可能使原型正确。对于C++库中的每个函数，都在一个或多个头文件中提供了其原型，可以通过手册或在线帮助查看函数描述来确定应使用哪个头文件。 函数原型和函数定义不要混淆，可以看出： 函数原型只描述函数接口，也就是说，它描述的是发送给函数的信息和返回的信息 而函数定义包含了函数的代码，如计算平方根的代码 C/C++将库函数的这两项特性（原型和定义）分开，库文件中包含了函数的编译代码，而头文件中则包含了原型。 # include &lt;iostream&gt; # include &lt;cmath&gt; int main() { using namespace std; double area; cin &gt;&gt; area; //area = 152 ,cin智能地将其转化为152.0（double类型） double side; side = sqrt(area); //double side = sqrt(area)//初始化 cout &lt;&lt; side; return 0; } 使用函数库C++库函数存储在库文件中，编译器编译程序时，它必须在库文件搜索您使用的函数。至于自动搜索哪个库文件，将因编译器而异。如果运行程序时，得到一条消息，指出_sqrt()是一个没有定义的外部函数，则很可能是由于编译器不能自动搜索math库，（编译器倾向于给函数名添加下划线前缀—提示它们对程序具有最后的发言权）。如果在Linux(Gnu编译器)中遇到该问题，可能需要在命令行末尾添加-lm选项： g++ sqrt.cpp -lm Unix系统，同样添加’-lm’选项。 函数变体有些函数需要多项信息，这些函数使用多个参数，参数间使用都号分开。例如，数据函数pow()接受两个参数，返回值为以第一个参数为底，第二参数为指数的幂，该函数的原型如下： double pow(double,double); double answer = pow(5.0, 8.0); 不接受参数的函数,原型如下： int rand(void) 没有返回值的函数，例如，编写一个函数，它按美元、美分格式蔑视数字，当向它传递参数23.5时，它将在屏幕上显示$23.5。原型如下： void bucks(double) 用户自定义函数#include &lt;iostream&gt; void simon(int); //函数原型 int main() { using namespace std; simon(3)//调用函数simon int count; cin &gt;&gt;count; simon(count); count &lt;&lt; &quot;Done!&quot; &lt;&lt; endl; return 0; } void simon(int n)//定义simon函数 { using namespace std; cout &lt;&lt; &quot;Simon says touch your toes &quot; &lt;&lt; n &lt;&lt; &quot; times.&quot; &lt;&lt;endl; } 函数格式： type functionsname(arguementlist) { statements; } C++中定义的函数一般位于main()之后，不允许将函数定义嵌套在另一个函数定义中，每个函数的定义都是独立的，所有创建的函数的时平等的。 函数头： 上述程序的函数头为： void simon(int n) void表明没有返回值，因此调用simon()不会生成可在main()中将其赋给变量的数字。因此函数调用方式如下： simon(3); 括号中的int n表明，使用simon()时，应提供一个int参数。函数调用时，传递的值将被赋值给n。 int main() 开头的int表明，main()返回一个整数值，空括号表明，main()没有参数。对于有返回值的函数，应使用关键字return来提供返回值，并结束函数。入main()函数末尾： return 0; main()函数的返回值返回给操作系统，并不是返回给程序的其他部分。通常的约定，退出值为0则意味着程序运行成功，为非0则意味着存在问题。如果，C++程序无法打开文件，可以将它设计为返回一个非零值。 关键字 关键字是计算机语言中的词汇，比如：int、void、return和double。因为这心关键字有专用，因此不能用作他用。另外main不是关键字，当最好不要将其用作变量名，不然会引发错误。 用户定义的有返回值的函数# include &lt;iostream&gt; int stonetolb(int); //原型声明 int main() { using namespace std; int stone = 4; int pounds = stonebolb(stont); //接受调用函数的返回值 count &lt;&lt; pounds &lt;&lt; endl; return 0; } int stonetolb(int sts) //函数定义 { return 14 * sts; //函数返回值 } 在多函数程序中使用using编译指令将编译指令放在函数外面，所有函数都可以访问命名空间std: #include &lt;iostream&gt; using neamespace std; void simon(int); int main() { sinmon(3); return 0; } void simon(int n) { cout &lt;&lt; n; } 当前通行的理念是，只让需要访问命名空间std的函数访问它是更好的选择。例如只有mian()函数使用cout，因此没必要让函数stonelb()能过访问命名空间std。因此编译指令放在main()函数中。 总之，让程序能够访问命名空间std的方法有多种，下面是其中的四种： 将using namespace std; 放在函数定义之前，让文件中的所有函数都能够使用命名空间std中的所有的元素。 将using namespace std；放在特定的函数定义中，让该函数能够使用命名空间std中的所有元素。 在特定的函数中使用类似using std::cout;这样的编译指令，而不是using namespace std;，让该函数能过使用指代的元素，如cout。 完全不使用编译指令using，而在需要使用命名空间std中的元素是，使用前缀std::,如下所示：std::cout &lt;&lt; &quot;I am using cout&quot; &lt;&lt; std::endl; 总结C++程序有一个或多个被称为函数的模块组成。程序从main()函数开始执行，因此该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值类型和函数期望通过参数传递给它的信息的类型。 C++语句有多种类型，包括如下6种： 声明语句 赋值语句 消息语句：将消息发送给对象，激发某种行动 函数调用：执行函数 函数原型：声明函数的类型、函数接受的参数数量和类型 返回语句：将一个值从被调用函数那里返回到调用函数 类是用户自定义的数据类型规范，详细描述了如何表示信息以及对数据执行的操作。对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。 C++提过了两个用户处理输入和输出的预定义对象（cin和cout），它们是istream和ostream类的实例，这两个类在iostream文件中定义。]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--数据处理（三）]]></title>
    <url>%2F2018%2F08%2F31%2FC%2B%2B%20Primer%20Plus%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[介绍C++变量的命名规则，以及数据类型 3.1 简单变量int a; a = 5; 上述语句告诉程序，它正在存储整数，并使用名称a来表示该整数的值。实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为a,并将5复制到该内存单元中，然后，可以在程序中使用a来访问该内存单元。可以通过&amp;运算符来检索a的内存地址。 变量名C++提倡使用有一定含义的变量名，如果表示差旅费，应将其命名为cost_of_trip或costOfTrip，而不要命名为a或x等。必须遵循几种简单的C++命名规则： 在名称中只能使用字母字符、数字和下划线(_); 名称的第一个字符不能是数字； 区分大小写 不能将C++关键字用作名称 以两个下划线或下划线和大写字母开头的名称被保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给实现，用作全局标识符； C++对于名称的长度无限制，名称中所有的字符都有意义。 最后两点和前几点不同，因为使用_time_stop或_Donut或__time这样的名称不会导致编译器错误，而会导致不确定性。即，不知道结果将是什么，不出现编译错误的原因是，这样的名称不是非法的，但是要保留给现实使用。全局名称指的是名称被声明的位置。 命名方案 在给变量命名时，可能在变量名中加入其他信息，即描述变量类型或内容的前缀，例如，可以将整型变量命名myWeight命名为intMyWeight或nMyWeight,这样，在阅读代码时，一目了然，每个变量的意义和类型。常以这种方式使用的前缀用：str或sz（表示以空字符结束的字符串）、b（表示布尔值）、p (表示指针)、c（表示单个字符）。 整型整型是没有小数部分的数字，比如：98，-86，0。C++提供了好几种整型来存储整数。使用的内存越大，可以表示的整数值范围也越大。另外，有的类型（符号类型）可以表示正值和负值，而有的类型（无符号类型）不能表示负值。术语宽度用户描述存储整数时使用的内存量，使用的内存越多，则越宽。C++的基本整型（按照宽度递增的顺序排序）： char:该类型有一些特殊属性，常用来表示字符，而不是数字 short int long long long 计算机内存由一些叫做位（bit）的单元组成。C++中short、int、long和long long类型都是通过使用不同数目的位来存储值。 在不同的系统中，每种的类型的宽度都不一样，C++提供了一种灵活的标准，确保了最小长度（从C语言借鉴而来），如下： short至少16位 int至少与short一样长 long至少32位，且至少与int一样长 long long至少64位，且至少与long一样长 实际上short是short int的简称，long是long int的简称。 位与字节 计算机内存的基本单元时位（bit）,字节（byte）通常指的是8位的内存单元。从这个意义上说，字节指的就是描述计算机内存量的度量单位，1KB等于1024字节，1MB等于1024KB。 8位的内存块可以设置出256种不同的组合，因为每一位由两种设置（0和1）,所以8位的总组合位：2^8-256。因此8位单元可以表示0-255或-128到127。每增加一位，组合数变加倍。 C++中对字节的定义与此不同，C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说可能取值的数目必须等于或超过字符数目。在美国，基本字符集通过是ASCII和EBCDIC集，它们都可以用8位来容纳，所以在使用这两种字符集的系统中，C++通常包括8位。然而，国际编程可能需要使用更大的字符集，如Uunicode,因此有些实现可能使用16位甚至32位的字符。 C++中检测类型的长度，sizeof运算符返回类型或变量的长度，单位为字节。 比如：sizeof(int),或者 对一个变量利用sizeof，如：sizeof n_short (short n_short;)。 在头文件climits（旧版本limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种显示的符合名称。比如：INT_MAX 为int的最大值，CHAR_BIT为字节的位数。 SHRT_MAX为short的最大值，LLONG_MAX为long long的最大值，LONG_MAX为long的最大值。INT_MIN为int的最小值。这里只给出了部分，详细的可以查看书籍P41。 符号常量–预处理方式 climits文件中包含于下面类似的语句行： #define INT_MAX 32767 在C++编译过程中，首先将源代码传给预处理器。在这里，#define和#include一样，也是一个预处理编译指令。该编译指令告诉预处理器：在程序中查找INT_MAX，并将所有的INT_MAX替换为32767。 初始化初始化将复制和声明合并在一起。如下： int n_int = INT_MAX; 可以将变量初始化为另一个变量，条件是后者是已经定义过，甚至可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中的所有值都已经定义过： int uncles = 5; int aunts = uncles; int chairs = aunts + uncles + 4; 前面的初始化继承自C语言，C++还有另一个C语言没有的初始化语法： int wrens(432); 注意： 如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值将是它被创建之前，相应内存单元保存的值。 在变量声明时对它进行初始化，可避免以后忘记给它赋值的情况发生。 C++11初始化方式另一种初始化方式，这种方式用户数组和结构，但在C++98中，也可以用于单值变量： int hamburgers = {24}; 将大括号初始化器用于单值变量的情形不多，但在C++标准使得这种情形更多了。首先，采用这种方式时，可以使用等号（=）,也可以不使用： int emus{7}; int rheas = {12} 其次，大括号可以为空，即变量被初始化为零： int rocs = {}; int psychis{}; 无符号类型前面介绍的4种整数都有一种不能存储负数值的无符号变体。其优点是可以增大变量能够存储的最大值。例如：如果short表示的范围为-32768到32767，则无符号版本的表示范围为0-65535。当然，仅当数值不会为负时才应该使用无符号类型，如人口、件数等。创建无符号版本的基本整性，只需要使用关键词unsigned来修改： unsigned short change; unsigned long long lang_lang; 注意：unsigned 本身是 unsigned int 的缩写。 对于一个short变量，取short的最大值（32767），对于符号整型，对最大值加一，则该值将变为-32768。对于无符号整型，对最大值加一，则该值将变为：32768。如果将无符号整数0，减一则该值会变成65535。 可以看出，这些整型变量的行为就像里程表，如果超越了限制，其值将为范围另一端的取值。 选择整型类型int被设置为对目标计算机而言最为“自然”的长度。自然长度指的是计算机处理起来效率最高的长度。如果没有其他要求，则应该使用int。 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用32位。即使系统上int为32位，也应该这样。如果存储的值大于20亿，可使用long long。 如果short比int小，则使用short可以节省内存。通常，仅当有大型整型数组时，才有必要使用short。如果节省内存很重要，则应使用short而不是int，即使它们的长度一样。例如，如果将程序从int为16位的系统移植到int为32的系统，则用户存储int数组的内存量将加倍，但short不会受影响。 如果只需要使用一个字节，可使用char。 整型字面量整型字面量（常量）是显式地书写常量，如212或1776。C++能够以三种不同的计数方式来书写整型：基数为10、8和16。如果第一位为1~9，则基数为10（十进制）；如果第一位为0，第二位1~7，则基数为8（八进制）；如果前两位为0X或0x，则基数为16（十六进制）。具体进制问题：转 在默认情况下，cout以十进制格式显示整数，而不管这些整数在程序中如何书写，如： int waits = 0X42; cout &lt;&lt; waits; //输出结果为66 这些表达方式仅仅是为了表达上的方便。例如：如果CGA视频内存段为十六进制B000，则不必在程序中使用之前将它转换为十进制45056，而只需使用0xB000。但是不管把值书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制。 如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。头文件iostream提供了控制符endl,用于指示cout重起一行。同样，它还提供了控制符dec、hex和oct,分别表示用于指示cout以十进制、十六进制和八进制格式显示整数。 using namespace std; int chest = 42; cout &lt;&lt; hex; cout &lt;&lt; chest; //输出2a cout &lt;&lt; oct; cout &lt;&lt; chest; //输出52 诸如cout&lt;&lt;hex;等代码不会显示在屏幕上显示任何内容，而只是修改cout显示整数的方式。因此，控制符，hex实际上是一条消息，告诉cout采取何种行为。 C++如何确定常量的类型程序的声明中将特定的整型变量的类型告诉了C++编译器，但编译器是如何确定常量的类型呢？假设在程序中使用一个常量表示一个数字： cout &lt;&lt; &quot;Year = &quot; &lt;&lt; 2018 &lt;&lt; endl; 程序将1492存储为int、long还是其他类型呢？答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型存储为int。 关于后缀，后缀是放在常量后面的字母，用于表示类型。具体如下： 后缀 类型 l或L long常量 ul unsigned long常量 ll或LL long long常量 LU或UL ungigned long常量 ull或Ull或uLL或ULL unsigned long long 常量 对于长度，C++中不同进制，采用存储整型的规则不同： 进制 存储类型 十进制 使用后面能过存储该数的最小类型来表示： int、long 、long long 八进制和十六进制 使用后面几种类型中能过存储该数的最小类型来表示： int、unsigned int、long、unsigned long、long long 、unsigned long long 十六进制数0x9C40（40000）将被表示为unsigned int，这是因为十六进制常用来表示内存地址，而内存地址没有符号。 char类型：字符和小整数char类型是专门为存储字符而设计的。编程语言通过使用字母的数值编码来存储字符。因此char类型是另一种整型。它足够长，能过表示计算机系统中的所有字符—字母、数字、标点符号等等。实际上，很多系统支持的字符不操作128个，因此用一个字节就可以表示所有的符号。虽然，char最常用来处理字符，但也可以将它用做比short更小的整型。 在美国，最常用的符号集是ASCII字符集。例如，字符A的编码是65，字母M的编码为77。 char ch; cout &lt;&lt; &quot;Enter a chararcter: &quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; &quot;Thank you for the &quot; &lt;&lt; ch &lt;&lt; &quot; character&quot; &lt;&lt; endl; 输入M,结果输出为 Thank you for the M character.程序打印的是M,而不是77。通过查看内存可知，77是存储在变量ch中的值。这种神奇的力量来自cin和cout,而不是char，这些工具完成了转换工作。输入时，cin将键盘输入的M转换为77；输出是cout将77转换为M。 如果将77存储在int变量中，则cout将把它显示为77(也就是说cout显示两个字符7)。C++中书写字符字面量：将字符用单引号括起来。如’M’。（注意：C++对字符用单引号对字符串使用双引号，这两者差别比较大）。cout引入一项新特性–cout.put()函数，该函数显示一个字符。 char ch = &apos;M&apos;; int i = ch; cout &lt;&lt; i; //结果为77 ch = ch + 1; i = ch; cout &lt;&lt; i //结果为78 cout.put(ch); //结果为N 上面程序中，ch存储的实际上是整数，因此可以对其使用整数操作，如加一。 char ch; cin &gt;&gt; ch; //输入5，实际上ch存储的整数53（5的ASCII编码） 上述代码将读取字符“5”.并将其对应的字符编码存储到ch变量中。 int n; cin &gt;&gt; n; //输入5 上述代码获取字符“5”，并将其转换为对应的数字5，并存储到n变量中。 成员函数cout.put()cout.put()成员函数提供了一种显示字符的方法，可以代替&lt;&lt;运算符。cout.put存在的必要性：在c++的Release2.0之前，cout将字符变量显示为字符，而将字符常量（如‘M’和‘N’）显示为数字。问题是，C++早期版本将字符常量存储为int类型。也就是说，‘M’的编码将被存储在一个16或32为单元中。而char变量一般占8位。下面的语句从常量“M”中赋值左边的8位到变ch中： char ch = &apos;M&apos; 遗憾的是，对于cout来说，‘M’和ch看上去有天壤之别，虽然存储的值一样。下面的语句将打印字符M的ASCII码，而不是字符M: cout &lt;&lt; &apos;M&apos;; 但是下面打印字符M: cout.put(&apos;M&apos;); C++Release2.0之后，将字符常量存储位char类型，而不是int,意味着cout现在可以正确处理字符常量。 char字面值在C++中，书写字符常量的方式有多种，对于常规字符（字母，数字和标点符号），最简单的方法是将字符用单引号括起来。这种表示法代表的是字符的数字编码。例如，ASCII系统中的对应情况如下： ‘A’为65，即字符A的ASCII ‘a’为97 ‘0’为48 ‘ ‘为32 ‘!’为33 这种表示法优于数值编码，更加清晰，而不需要知道编码方。如果系统使用的是EBCDIC,则A的编码值不是65，但’A‘表示的仍然是字符A。 转义字符： 有些字符不能之间通过键盘输入到程序中，比如：回车等。C++提供了一种特殊的表示方法–转义字符。例如：\”将双引号作为常规字符，\t表示水平制表符等等。 将转移字符作为字符常量时，应用单引号括起来；将他放在字符串中不要使用单引号。 基于字符八进制和十六进制编码来使用转义字符。例如，Ctrl+Z的ASCII码为26，对应的八进制编码为032，十六进制编码为0X1a。可以使用下面的转义字符来表示该字符： \032或\x1a。 通用字符名通用字符名的用法类似于转义序列。通用字符名可以以\u或\U开头。\u后面是8个十六进制位，\U后面则是16个八进制位。这些位表示的是字符的ISO 10646码点。（ISO 10646是一种正在制定的国际标准，为大量的字符提供了数字编码）。 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Let them eat g\u00E2teau.\n&quot;; return 0; } 输出为：Let them eat gâteau. Unicode提供了一种表示各种字符集的解决方案—为大量字符和符号提供标准数值编码，并根据类型给他们分类。例如：ASCII码为Unicode的子集，因此在这两种系统中，美国的拉丁字母（如A和Z）表示相同。然后，Unicode还包含其他拉丁字符。 Unicode给每个字符制定一个编号–码点。Unicode码点通常类似于：U-222B。其中U表示这是一个Unicode字符，而222B是该字符的十六进制编码。 国际标准组织（ISO）建立了一个工作组，专门开发ISO 10646—这也是对一个多语言文本进行编码的标准。ISO 10646小组和Unicode小组从1991年开始合租，以确保他们的同步。 signed 和 unsigned char与int不同的是，char默认情况下既不是没有符号，也不是有符号。是否有符号由C++决定。 char fodo //可能为有符号，也可能无符号 unsigned char bar //无符号 signed char snark //有符号 如果char作为数值类型，unsigned char类型表示的范围为0~255，而signed char表示的范围为-128~127。如果使用char变量存储200这样大的值，在某些系统上可以，而在另一些系统上可能不可以。但是使用unsigned char可以在任何系统上达到这种目的。如果使用char存储ASCII字符，则有没有字符都没关系。 wchar_twchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和字符属性相同，对底层系统的选择取决于实现，因此在一个系统中，他可能是unsiged short，而在另一个系统中，则可能是int。 cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t类型。iostream头文件的最新版提供了类似的工具—wcin和wcout,可用于处理wchar_t。另外，可以通过加上前缀L来表示宽字符常量和宽字符串。 wchar_t bob = L&apos;P&apos;; wcout &lt;&lt; L&quot;tall&quot; &lt;&lt; bob &lt;&lt; endl; 本书不使用宽字符类型，但应知道这种类型，尤其是在进行国际编程或使用Unicode或ISO 10646时。 C++11新增类型 char16_t和char32_t随着编程人员的日益熟悉Unicode，类型wchar_t显然不再满足需求。事实上，在计算机系统上惊喜字符和字符串编码时，仅使用Unicode码点并不够。具体说，进行字符串编码时，如果由特定长度和符号特征的类型，将很有帮助，而类型wchar_t的长度和符号特征随实现而已。因此，C++11新增了char16_t和char32_t,两者都无符号，前者长为16为，后者长为32为。使用前缀u表示char16_t字符常量和字符串常量，如u’be goog’；使用前缀U表示char32_t常量，如:U’R’。类型char16_t与/u00F6形式的通用字符名匹配，而类型char32_t与/U0000222B形式的通用字符名匹配。 char16_t ch1 = u&apos;q&apos;; char32_t ch2 = U&apos;\U0000222B&apos;; bool类型在计算中，布尔变量的值可以时true或false。 bool is_ready = true; 字面值true和false都可以通过提升转换为int类型，true被转换为1，false被转换为0。任何非零值可以转换为true,而零被转换为false。 bool start = -100; bool end = 0; 3.2 const限定符使用关键字const来修改变量声明和初始化，例如，假设需要一个表示一年中月份数的符号常量： const int Months =12; 这样，便可以在程序中使用Months,而不是12了。常量（如Months）被初始化后，其值就被固定了，编译器将不允许在修改该常量的值。如果这样做，g++将指出程序视图给一个只读变量赋值。const被叫做限定符，因为它限定了声明的含义。 一种常见的做法是将名称的首字母大写，以提醒Months是一个常量。 const比#define好，首先，它能明确指定类型；其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中；最后，const用户更复杂的类型，后面介绍。 建议使用const而不是#define。 3.3 浮点数对于浮点数，计算机将其分为两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。比如：对于数字34.1245和34124.5，它们处理小数点位置不同外，其他都相同。可以把第一个数表示为0.341245(基准值)和100（缩放因子），而将第二个表表示为0.341245(相同基准值)和100（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过是二进制，因此缩放因子是2的幂，不是10的幂。 3.3.1 书写浮点数C++有两种书写浮点数的方式： 第一种使用常用的标准小数点表示法：12.34 第二种E表示法： 3.45E6指的是3.45与1000000相乘的结果；8.33E-4, 7E5，-8.33E4。 E表示法适合表示非常大和非常小的数。E表示法确保数字以浮点数格式存储，即使没有小数点。注意，既可以使用E也可以使用e,指数可以是正数也可使负数。数字中不能有空格，比如:7.2 E6是非法的。 指数为负数意味着除以10的乘方，而不是乘以10的乘方。因此8.33E-4表示$8.33/10^4$,即0.000833。数值前面的符号用于数值，而指数的符号用户缩放。 3.3.2 浮点类型C++三种浮点类型：float、double和long double.这些类型是按照它们可以表示的有效位数和允许的指数最小范围来描述的。有效位数是数字中有意义的位。例如：14179英尺，使用了5个有效位；13000英尺，使用了2个有效位，其他3位为占位符；1.234，使用了4个有效位。 C++对有效位数的要求是，float至少32位；double至少48位，且不少于float；long double至少跟double一样多。通常，float位32位，double为64位，long double为80、96或128位。另外三种类型的指数范围至少是-37至37。 #include &lt;iostream&gt; using namespace std; int main() { cout.setf(ios_base::fixed, ios_base::floatfield); float tub = 10.0 / 3.0; const float million = 1.0e6; double mint = 10.0 / 3.0; cout &lt;&lt; &quot;tub = &quot; &lt;&lt; tub &lt;&lt;endl; cout &lt;&lt; &quot;tubs = &quot; &lt;&lt; tub * million &lt;&lt; endl; cout &lt;&lt; &quot;mint = &quot; &lt;&lt; mint &lt;&lt; endl; cout &lt;&lt; &quot;mints = &quot; &lt;&lt; mint * million &lt;&lt; endl; return 0; } 结果：tub = 3.333333tubs = 3333333.250000mint = 3.333333mints = 3333333.333333 通常cout会删除结尾的零，例如，将3333333.250000显示为 3333333.25。调用cousetf()将覆盖这种行为。tub和mint都被初始化为10.0/3.0=3.333333333333….,由于cout打印6位小数，因此tub和mint都是精确的。但是当程序将每个数乘以一百万后，tub在第7个3之后就不正确的值有了误差。然后，double类型的变量显示了13个3，因此它至少有13位精确。这是由于float的精度限制。 读取包含文件：程序中的所有文件都存在于计算机中，或位于计算机可以使用的地方。找到使用的包含文件，看看它们包含的内容，很快发现，源文件和头文件都是知识和信息的很好来源。 浮点常量与整型相比，浮点数优点： 可以表示整数之间的值 由于有缩放因子，可以表示的范围大得多 浮点数缺点： 浮点运算的速度通常比整数运算慢 精度将降低 fltadd.cpp程序： #include &lt;iostream&gt; using namespace std; int main() { float a = 2.34e22; float b = a + 1.0; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;a - b = &quot; &lt;&lt; b -a &lt;&lt; endl; return 0; } 结果： a = 2.34e+22a - b = 0 问题在于，2.34e22是一个小数点左边有23位的数字。加上1，就是在第23位加1。但是float类型只能表示数字中的前6或前7位，因此修改第23位对这个值不会有影响。 3.4 C++算术运算符C++中常用的运算符： +运算对操作数执行加法 -运算 *运算 /运算 %运算符求模，生成第一个数除以第二个数后的余数。例如19%6=1。如果其中一个是负数，则结果的符号满足如下规则：（a/b）*b+a%b = a,%的操作数必须是整数。 arith.cpp #include &lt;iostream&gt; using namespace std; int main() { float a = 10.23; float b = 11.22; cout.setf(ios_base::fixed, ios_base::floatfield); cout &lt;&lt; &quot;a = &quot;&lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a + b &lt;&lt; endl; return 0; } 结果：a = 10.230000a + b = 21.450001 这是由于float保证6位有效位。 3.4.1 运算符优先级和结合性先乘除，后加减 *、/和%的优先级相同 float logs = 120 / 4* 5; 对于上式，运算符/和$$的优先级相同，因此优先级本身不能指出程序究竟是先计算120除以4，还是先计算45。两种结果截然不同。 当两个运算符优先级相同时，C++将看操作数的结合性是从左到右还是从右到左。从左到右意味着如果两个优先级相同的运算符被同时用于一个操作数，则首先应用左侧的运算符。查表得，乘除是从左到右结合得，所以上述式子应先计算120/4，得到结果30再除以5。 3.4.2 除法分支除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是整数，则C++将执行整数除法，这意味着小数部分将被丢弃，使得最后的结果是一个整数。如果其中有一个（或两个）操作数是浮点数，则小数部分保留，结果为浮点数。 除法运算符表示了3种不同的运算：int除法、float除法、double除法。C++根据上下文来确定运算符的含义，使用相同的符号进行多种操作叫做运算符重载。 3.4.3 求模运算符求模运算符返回整数除法的余数，它与整数除法先结合，尤其适用于解决要求将一个量分成不同的整数单元的问题，例如：英寸转换为英尺和英寸。 将181镑，转换为英石和镑。一英石等于14磅. #include &lt;iostream&gt; using namespace std; int main() { const int lbs_per_stn = 14; int lbs = 181; int stone = lbs / lbs_per_stn; int pounds = lbs % lbs_per_stn; cout &lt;&lt; lbs &lt;&lt; &quot; pounds are &quot; &lt;&lt; stone &lt;&lt; &quot; stone, &quot; &lt;&lt; pounds &lt;&lt; &quot; pound(s).&quot;&lt;&lt; endl; return 0; } 结果：181 pounds are 12 stone, 13 pound(s). 3.4.4 类型转换C++自动执行类型转换： 将一个算术类型的值赋给另一种算术类型的变量 表达式种包含不同类型 将参数传递给函数 初始化和赋值进行的转换C++允许将一种类型的值赋给另一种类型的变量。值将被转换为接受变量的类型。假设so_long的类型为long,thirty的类型为short,而程序中有： so_long = short 则进行赋值时，程序将thirty的值（short通常为16位）扩展为long值（通常32位）。扩展后将得到一个新值，这个值存储再so_long中，而thirty的内容不变。 将一个值赋给取值范围更大的类型通常不会导致问题。例如，将short值赋给long变量并不会改变值，只是占位符的字节更多而已。 然而，建一个很大的long（如2111222333）值赋给float的变量将降低精度。因为float只有6位有效数字，因此这个值将被四舍五入为2.11122E9。因此，有些转换是不安全的。 潜在的数值转换问题： 将较大的整数转换为较小的整型，如将long转换为short,原来的值可能超出目标类型的取值范围，通常只复制右边的字节； 将浮点数转换为整型，小数部分丢失（不是四舍五入）,原来的值可能超出目标类型的取值范围，在这种情况下，结果可能不确定； 将较大的浮点类型转换位较小的浮点类型，如将double转换为float,精度（有效位位数）降低，,原来的值可能超出目标类型的取值范围，在这种情况下，结果可能不确定； 将0赋值给bool变量，将被转换为false；而非零将被转换为true。 以{}方式初始化时进行的转化（C++11）C++将使用大括号的初始化称为列表初始化，因为这种初始化常用于给复杂的数据类型提供值列表。对类型的转化要求更严格。具体，列表初始化不允许缩窄，即变量的类型可能无法表示赋给它的值。例如，不允许浮点数转换为整型。在不同的整型之间转换或将整型转换为浮点型可能被允许。例如：可见long变量初始化为int类型的值，因为long总是至少与int一样长；相反转换也可能被允许，只要int变量能够存储给它的long常量。 表达式中的转换在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false被转换为0，这些转换称为整型提升。 整型提升还包括：如果short比int短，则unsigned short类型转换为int；如果两种类型的长度相同，则unsigned short类型转换为unsigned int。这种规则保证对unsigned short提升时不会损失数据。 将不同类型进行算术运算时，也会进行一些转换。比如将int和float相加。当运算涉及两种类型时，较小的类型被转换为较大的类型。编译器通过校验表来确定算术表达式中执行的转换，校验表如下： 如果有一个操作数的类型为long double,则将另一个操作数转换为long double; 否则，如果有一个操作数的类型为double,则将另一个操作数转换为double; 否则，如果有一个操作数的类型为float,则将另一个操作数转换为float; 否则，说明操作数都是整型，因此执行整型提升； 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为高级别的类型； 如果一个操作数有符号，另一个操作数无符号，且无符号操作数的级别比有符号操作数的级别高，则将有符号操作数转换为无符号的操作数类型； 否则，如果有符号类型可表示无符号类型的所以可能值，则将无符号类型转换为有符号操作数所属的类型； 否则，将两个操作数都转换为无符号版本。 参数传递的转换传递参数时的类型转换通常由C++函数原型控制。 强制类型转换C++允许通过强制转换机制显示地进行类型转换。强制类型转换格式有两种，例如：为将存储在变量thorn中的int值转换为long类型，如下： (long)thorn//来自C long(thorn)//C++新格式：像函数调用一样 强制转换不会改变thorn本身，而是创建一个新的、指定类型的值。 C++还引入了4个强制类型转换符，对他们的使用要求更严格。后面介绍，在这四种运算符中，static_cast&lt;&gt;可用于将一种数值转换为另一个种数值类型，例如将thorn转换为long类型： static_cast&lt;long&gt; (thorn) 推广之，可以这样做： static_cast&lt;typename&gt; (value) typecast.cpp #include &lt;iostream&gt; using namespace std; int main() { int auks, bats, coots; auks = 11.99 + 19.99; //相加赋值给int变量，被截断为31， bats = int(11.99) + int(19.99);//先截断，在相加 coots = (int) 11.99 + (int) 19.99; cout &lt;&lt; &quot;auks = &quot; &lt;&lt; auks &lt;&lt; &quot;, bats = &quot; &lt;&lt; &quot;bats&quot; &lt;&lt; &quot;, coots = &quot; &lt;&lt; coots&lt;&lt; endl; char ch = &apos;Z&apos;; cout &lt;&lt; &quot;The code for &quot; &lt;&lt; ch &lt;&lt; &quot; is &quot; &lt;&lt; int(ch) &lt;&lt; endl; cout &lt;&lt; &quot;Yes, the code is &quot; &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; endl; return 0; } auks = 31, bats = bats, coots = 30The code for Z is 90Yes, the code is 90 3.4.5 C++11中的auto声明C++新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。auto是C语言的关键子，当很少使用。在初始化声明中，如果使用关键字auto，而不指定变量类型，编译器将把变量的类型设置成与初始值相同： auto n = 100; //n是整型 auto x = 1.5 // x is double auto y = 1.3e12L // y is long double 然而，自动推断类型并非为这种简单情况而设计；事实上，如果将其用于这种简单情形，甚至可能让您误入歧途。例如，假设要将x、y、z都指定为double，并编写了如下代码： auto x = 0.0; //浮点型 double y = 0; //浮点型 auto z = 0; //整型 处理复杂类型，如标准模块库（STL）中的类型，自动类型推断的优势才能显现出来。例如，对于下述C++98代码： std:vector&lt;double&gt; scores; std:vector&lt;double&gt;::iterator pv = scores.begin(); C++允许您将其重写为： std::vector&lt;doble&gt; scores; auto pv = scores.begin() 3.5 总结C++的基本类型分为两组: 由存储为整型的值组成 由存储为浮点格式的值组成 整型通过存储值时的内存量及有无符号来区分。整型从最小到最大依次是： bool \ char \ signed char \ unsigned char \ short \ unsigned short \ int \ unsigned int \ long \ unsigned long \ long long \ unsigned long lon 3种浮点类型： float \ double \ long double]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络与信息安全研究方向]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/zhangvalue/article/details/78056559 1、信息安全算法类：包括密码算法、信息隐藏与检测算法、数字水印嵌入与检测算法、数据挖掘与过滤算法、量子密码算法等。 2、信息安全协议类：包括认证协议、密钥交换与管理协议、电子支付协议、多方安全计算协议以及安全协议的安全性分析理论与方法等。 3、信息系统安全类：包括可信计算、安全体系结构、操作系统安全、数据库安全、服务器安全以及信息系统安全评估理论与方法等。 4、网络安全类：包括信息对抗、网络攻防、入侵检测、网络可生存、网络安全管理、移动网络安全、无线网络安全、物联网安全，以及恶意代码检测、防御与应急处置等。 5、信息安全应用类：包括电子政务、电子商务、信息安全基础设施以及新技术应用带来的安全问题及解决方案等。 6、安全测试与仿真类：网络与信息安全仿真，安全测试理论与模型，安全测试技术等。 7、信息安全技术类：等级保护技术、三网融合与安全管理、信息安全应急响应体系、网络监测与监管技术等。 8、新一代网络技术类：网络体系结构、路由/交换技术、协议工程、网络虚拟化、认知网络、IPv4/IPv6过渡技术、NGN/NGI平台应用等。 9、新一代计算技术：网格计算、并行/分布式计算、适/效用计算、服务计算。 10、安全专用芯片：密码算法与协议实现、安全处理器与协处理器设计、芯片攻击与安全防护、安全芯片应用。 11、数字版权管理安全（DIM）:认证/授权访问控制、安全数据传输、可信管理与可信评估、信息内容安全技术、数字水印、数字权限管理。 12、云计算与物联网安全：云计算/物联网安全模型、云计算/物联网安全需求与策略、云计算/物联网用户隐私保护、云计算/物联网基础设施安全防护]]></content>
      <tags>
        <tag>研究方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus--预备知识（一）]]></title>
    <url>%2F2018%2F08%2F29%2F%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[介绍C++的一些基本概念，起源，以及如何编译执行。 C++简介C++融合了3种不同的编程方式： C语言代表的过程性语言 C++在C语言的基础上添加的类代表面向对象语言 C++模板支持的泛型编程 c演员编程原理计算机语言要处理两个概念–算法和数据，数据是程序使用和处理的信息，而算法是程序使用的方法。 C语言强调的是编程的算法方面，C语言的设计是自顶向下的，其理念是将大型程序分解成小型、便于管理的任务。程序员可以开发程序党单元(函数)来表示各个任务的模块，根据执行的操作来构思一个程序。C语言具有使用结构化编程的特性，比如：while、if、for等语句。 面向对象编程(OOP)OOP强调的是数据，OOP不想过程性编程那样，试图使问题满足语言的过程性，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。 C++中，类是一种规范，描述了这种新型数据格式，对象是根据这种规范（类）构造的特定数据结构。比如：类可以描述公司管理人员的基本特征（姓名，工资，职位等），而对象则代表特定的管理人员（zxp, 1000000,董事长）。 类规定了可使用哪些数据表示对象，以及可以对这些数据执行哪些操作（方法，即函数）。比如：绘制矩形的计算机绘图程序种，定义的数据包括：矩形的顶点位置，长，宽，颜色等，定义的操作可以包括：移动，改变大小，改变颜色等等。当使用该程序绘图时，需要根据类创建一个对象，该对象保存了描述矩形的所有数据值，因此可以使用类方法来修改矩阵。 OOP程序设计，首先设计类，它们准确的表达了程序需要处理的内容。然后，设计一个使用这些类的对象程序。从低级组织（如：类）到高级组织（如：程序）的处理过程叫做自下而上（bottom-up）的编程。 OOP编程不仅仅可以将数据和方法合并成类，还可以创建可重用的代码，多态可以让运算符和函数创建多个定义等。 泛型编程泛型指的是创建独立类型的代码。C++中的数据表示类型包括：整数，小数，字符，字符串，用户定义等等。如果对不同类型的数据进行排序，通常需要为每种类型创建一个排序函数。泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，将其用户各种实际类型。C++模板提供了这种任务的机制。 泛型编程（generic programming）与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。OOP是一个管理大型项目的工具，而泛型编程提成了执行常见任务（如对数据排序和合并）的工具。 起源（了解）C和C++都起源于贝尔实验室。Bjarne Sroustrup于20世纪80年代开发了C++。 名称C++来自C语言中的递增运算符++,该运算符将变量加1。名称表明C++是C的扩展版本。 程序创建过程 使用文本编辑器编写程序，将其保存为文件，这个文件就是源代码； 编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言—机器语言。包含了翻译后的程序的文件就是程序的目标代码。 将目标代码与其他代码链接起来。例如：C++程序通常使用库，C++库包含一系列计算机例程（被称为函数）的目标代码，这些函数可以执行诸如在屏幕显示信息或计算平方根等任务。链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本。包含该最终产品的文件被称为可执行代码。 创建源代码文件在unix系统上，可以使用vi等编辑器编辑，其中只能实现编译和链接，执行程序，要求在系统命令行输入命令。在windows系统中，可以edlIn、edit或其他编辑器 给源文件命名时，必须使用正确的后缀，将文件表示为C++文件，不仅可以表示该文件是C++源代码，还将这种信息告知编译器。 Unix中，区分大小写，C程序使用：c(小写)，C++程序使用：C(大写)，还可以使用cc、cxx表示C++源代码。 编译和链接Linuxg编译和链接 编译test.cpp文件，生成a.out可执行文件： g++ test.cpp 运行可执行文件： ./a.out linux安装gcc: yum install gcc-c++]]></content>
      <categories>
        <category>C++ Primer Plus学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的文本处理]]></title>
    <url>%2F2018%2F08%2F29%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文介绍tr（注意不是tar），col，join，paste命令。实际上是管道操作命令的延续，所以我们依然将结合管道来熟悉这些命令的使用。 tr命令tr命令可以用来删除一段文本信息中的某些文字，或者将其进行转换。 使用方式： tr [option] ... SET1 [SET2] 常用的选项有： 选项 说明 -d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 -s 去除set1指定的在输入文本中连续并重复的字符 #删除hello world中所有的&apos;o&apos;,&apos;l&apos;,&apos;d&apos; echo &quot;hello world&quot; | tr -d &apos;old&apos; #将&quot;hello&quot;中的ll,去重为一个l echo &quot;hello&quot; | tr -s &apos;l&apos; #将输入文本，全部转换为大写或小写输出 echo &apos;input some text heRe&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; #上面的&apos;[:lower:]&apos;&apos;&apos;[:upper:]&apos;,也可以简单的写作&apos;[a-z]&apos;&apos;[A-Z]&apos;,当然反过来将大写变小写也是可以的 echo &apos;input some text heRE&apos; |tr &apos;[:upper:]&apos;&apos;[:lower:]&apos; col命令col命令可以将Tab换成对等数量的空格键，或反转这个操作 格式： cal [option] 常用的选项： 选项 说明 -x 将Tab转换为空格 -h 将空格转换为Tab（默认选项） #查看/etc/protocols中的不可见字符，可以看到很多^I，这其实就是Tab转义成可见字符的符号 cat -A /etc/protocols #使用col -x将/etc/protocols中的Tab转换为空格，然后再使用cat查看，会发现^I不见了 cat /etc/protocols | col -x | cat -A join命令该命令就是用于将两个文件中包含相同内容的那一行合并在一起。在数据库中也有该命令，作用基本相同。 使用方式： join [option] ... file1 file2 常用的选项： 选项 说明 -t 指定分隔符，默认为空格 -i 忽略大小的差异 -1 指定第一个文件要用哪个字段来对比，默认对比第一个字段 -2 指定第二个文件要用哪个字段来对比，默认对比第一个字段 #创建两个文件 echo &apos;1 hello&apos; &gt; file1 echo &apos;2 hello&apos; &gt; file2 join file1 file2 # 将/etc/passwd与/etc/shadow两个文件合并，指定以&apos;:&apos;作为分隔符 sudo join -t&apos;:&apos; /etc/passwd /etc/shadow # 将/etc/passwd与/etc/group两个文件合并，指定以&apos;:&apos;作为分隔符, 分别比对第4和第3个字段 sudo join -t&apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group paste命令paste命令有join命令类似，不过它是在不对比数据的情况下，简单地将多个文件合并在一起，以Tab隔开。 使用格式：paste [option] file ... 常用的选项： 选项 说明 -d 指定合并的分隔符，默认是Tab -s 不合并到一行，每个文件为一行 echo hello &gt; file1 echo shiyanlou &gt; file2 echo www.shiyanlou.com &gt; file3 paste -d &apos;:&apos; file1 file2 file3 paste -s file1 file2 file3 问题Windows/dos 与 Linux/UNIX 文本文件一些特殊字符不一致 如断行符 Windows 为 CR+LF(\r\n)，Linux/UNIX 为 LF(\n)。使用cat -A 文本 可以看到文本中包含的不可见特殊字符。Linux 的\n表现出来就是一个$，而 Windows/dos的表现为^M$，可以直接使用dos2unix和unix2dos工具在两种格式之间进行转换，使用file命令可以查看文件的具体类型。 不过现在希望你在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。 tr -d &apos;^M&apos; https://blog.csdn.net/fan_hai_ping/article/details/8352087]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux不同版本以及程序包安装]]></title>
    <url>%2F2018%2F08%2F28%2FLinux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux版本介绍，以及程序包安装命令介绍 Linux系统版本 RedHat(红帽)系列： Redhat、Centos、Fedora等 Debian(得比恩)系列： Debian、Ubuantu等 程序包安装RedHat系列 常见的安装包格式rpm包，安装rpm包的命令是”rpm -参数” 包管理工具yum 支持tar包 Debian系列 常见的安装包格式deb包，安装deb包的命令是”dpkg -参数” 包管理工具apt-get 支持tar包 tar 只是一种压缩文件格式，所以，它只是把文件压缩打包而已。 rpm 相当于windows中的安装文件，它会自动处理软件包之间的依赖关系。优缺点来说，rpm一般都是预先编译好的文件，它可能已经绑定到某种CPU或者发行版上面了。 yum安装命令YUM（Yellow dog Updater, Modified ）是Yellow Dog Linux开发的。 Yellow Dog Linux原本是一套完全源于Red Hat但运作于先前使用IBM PPC平台的MAC机器，原本以为这个版本已经消失，没想到最新消息是他们推出了在Sony PS3上面运作的版本。 CentOS及Fedora的基本预设安装中即将YUM列入其内。 使用方法： 编辑/etc/yum.conf档案详细设定请参考： 简易APT/YUM伺服器设定 基本指令： （如果yum在工作过程中需要使用者回应，可加上-y参数直接回答yes ） | yum install softwarename1 [softwarename2…..] | 安装套件 || yum update [softwarename 1 softwarename2…] | 更新套件，不指定套件名则更新所有可更新的套件 || yum list | 列出目前在yum server 上面有的套件 || yum info | 类似rpm -qi || yum clean | 移除下载到本机的packages 或headers || yum remove softwarename1 [softwarename2…..] | 移除已经安装的套件 | 注1：Red Hat近年来致力于将一个设定档切割成很多小设定档。 以yum.conf为例，Red Hat将其分割成xxx.repo档放置在/etc/yum.repos.d这个目录下。 并在yum.conf档里增加一行注解： PUT YOUR REPOS HERE OR IN separate files named file.repo in /etc/yum.repos.d。 个人可视喜好决定。 apt安装命令Debian开发，目前也有porting到其他版本，要在Red Hat系的Fedora或CentOS使用也是可以的。 使用方法： 编辑/etc/apt/sources.list ，设定所选用的版本，如stable，testing，unstable及套件来源站台或装置。 档案详细设定请参考： 了解Debian系统的哲学 基本指令： | apt-setup | 设定/etc/apt/souces.list || apt-get update | 软体资料库同步 || apt-get install softwarename1 [softwarename2…..] | 安装软体 || apt-get remove softwarename 1 [softwarename 2…] | 移除软体(保留设定档） || apt-get –purge remove softwarename 1 [softwarename 2…] | 移除软体(不保留设定档） || apt-cache search softwarename | 列出所有sofrwarename的套件 || apt-upgrade [softwarename 1 softwarename2…] | 更新套件，不指定套件名则更新所有可更新的套件 || apt-get clean(autoclean) | 删除系统暂存的deb(autoclean只会将比目前系统旧版的套件删除) || apt-get dist-upgrade | 转换系统的版本（需在/etc/apt/sources.list指定stable，testing或unstable） | 转自：张飞在线]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行顺序控制与管道]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等，高效率使用 Linux 的技巧。 命令执行顺序控制通常情况下，我们每次只能在终端输入一条命令，按下回车执行，执行完成后，我们再输入第二条命令，然后再按回车执行……,当有时候我们会一次输入多条命令，这个时候的执行过程又是如何的呢？下面我们将为大家详细讲解下命令的执行顺序的控制问题。 顺序执行多条命令当我们需要使用apt-get安装一软件时，然后安装完成后立即运行安装软件，又凑巧你的主机才更换的软件源还没有更新软件表，那么可能有如下一系列操作： sudo apt-get update #等待更新 sudo apt-get install somen-tool #some-tool是指具体的软件包 #等待安装 some-tool 如上操作，可以使用一条命令执行完成，不需要多次输入，简单的顺序执行可以使用;来完成，以上操作可以如下输入进行： sudo apt-get update;sudo apt-get install some-tool;some-tool 有选择的执行命令顺序执行多条命令时，可能前面的命令执行不成功，而后面的命令依赖上一条命令的结果，那么就会造成，花了很长的时间，却得到了一个错误的结果，而且有时候只管还无法判断结果是否正确，那么需要有选择性的执行命令。比如上一条执行成功才继续执行下一条，或者不成功又该做出什么样的选择。 使用which来查看是否安装某个命令，如果找到命令，则执行该命令，否则什么也不做： which cowsy&gt;/dev/null &amp;&amp; cowsay -f head-in ihch~ 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果。同时||表示当上一条命令执行结果不为0($?≠0)时则执行后面的命令。 which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&apos;&quot; ||和&amp;&amp;结合使用： which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; 管道管道是一种通信机制，通常用户进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。 管道又分为匿名管道和具名管道；在实际中使用一些过滤程序是经常会用到的就是匿名管道，在命令行中由|分割符表示。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。 管道例子ls -al /etc 将/etc下的文件全部打印出来，内容太多，屏幕不能完全显示，可以使用滚动条或快捷键来查看，不太友好，不过可以使用管道，一行一行查看： ls -al /etc | less 通过管道将前一个命令ls的输出作为下一个命令less的输入，然后一行一行查看 cut命令：打印每一行的某一个字段打印/etc/passwd文件中以’:’为分隔符的第1个字段和第6个字段分布表示用户名和其目录： cut /etc/passwd -d &apos;:&apos; -f 1,6 打印/etc/passwd文件中指定的内容： # 前五个（包含第五个） $ cut /etc/passwd -c -5 # 前五个之后的（包含第五个） $ cut /etc/passwd -c 5- # 第五个 $ cut /etc/passwd -c 5 # 2到5之间的（包含第五个） $ cut /etc/passwd -c 2-5 grep: 在文本中或stdin中查找匹配字符串grep命令非常强大，相当常用的一个命令，结合正则表达式可以实现非常复杂却很高效的匹配和查找。 grep命令的一般格式： grep 【命令选项】 ... 用户匹配的表达式 [文件]... 例子：查找/home/shiyanlou目录下的包行“shiyanlou”文本的文件 grep -rnI &quot;shiyanlou&quot; -r参数表示递归搜索子目录中的文件，-n表示打印匹配先行号,’-I’表示忽略二进制文件。 使用正则表达式的例子： export | grep &quot;.*yanlou$&quot; 其中$就表示一行的末尾,*匹配前面的子表达式任意次,.匹配除“\n”和”\r”之外的任何单个字符 wc命令：计数工具wc命令用户统计并输出一个文件中行、单词和字节的数目，比如输出/etcpasswd文件中的统计信息： wc /etc/passwd 输出行数、单词数、字节数： 分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数： # 行数 $ wc -l /etc/passwd # 单词数 $ wc -w /etc/passwd # 字节数 $ wc -c /etc/passwd # 字符数 $ wc -m /etc/passwd # 最长行字节数 $ wc -L /etc/passwd 注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的 结合管道来操作，统计/etc下面所有目录数： ls -dl /etc/*/ | wc -l sort排序命令该命令功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。 默认为字典排序： cat /etc/passwd | sort 反转排序： cat /etc/passwd | sort -r 按特定字段排序： cat /etc/passwd | sort -t&apos;:&apos; -k 3 上面的-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数： cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n uniq去重复命令uniq命令可以用于过滤或者输出重复行。 过滤行 使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令： history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq 然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序： history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq # 或者 history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u 这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。 输出重复行 # 输出重复过的行（重复的只输出一个）及重复次数 $ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc # 输出所有重复的行 $ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux任务计划crontab]]></title>
    <url>%2F2018%2F08%2F27%2FLinux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab%2F</url>
    <content type="text"><![CDATA[时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本文将带你很好的利用 Linux 系统的计划工具 crontab 命令常见于 Unix 和类 Unix 的操作系统之中（Linux 就属于类 Unix 操作系统），用于设置周期性被执行的指令。 Crontab简介Crontab命令从输入设备读取指令，并将其存于crontab文件中，以供之后读取和执行。crontab存储的指令在守护进程激活，crond为其守护进程，每一分钟会检查一次是否预定的作业需要执行。 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。 # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed crontab使用运行如下命令，添加一个集合任务： crontab -e 详细的格式可以使用man命令查看： man crontab 给出一个例子来完成一个任务的添加，该任务是每分钟在/home/zxp目录下创建一个以当前年月日时分秒为名字的空文件： */1 * * * * touch /home/zxp/$(date + /%H/%m/%d/%H/%M/%S) 注意 “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。 查看添加的任务： crontab -l 默认cron是自动启动的，可以通过如下命令查看是否启动: ps aux | grep cron pgrep cron 启动crontab: sudo cron -f &amp; 当不再需要这个任务时，可以使用如下命令： crontab -r crontab深入每个用户使用 crontab -e 添加计划任务，都会在 /var/spool/cron[/crontabs] 中添加一个该用户自己的任务文档，这样目的是为了隔离。 如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 /etc/crontab 文件就可以。 cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。 在/etc下，cron相关的文件和目录有： 每个目录的作用： /etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行； /etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行； /etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行； /etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；系统默认执行时间可以根据需求进行修改。 转自：实验楼]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的帮助命令]]></title>
    <url>%2F2018%2F08%2F25%2FLinux%E4%B8%AD%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[转自：实验楼 实验知识点 内建命令与外部命令之分 help , man , info命令的使用以及区别 内建命令与外部命令 内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。 外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。 简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用 type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的。 #得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中xxx is a shell builtin #得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中xxx is /usr/bin/xxx #若是得到alias的结果，说明该指令为命令别名所设定的名称；xxx is an alias for xx –xxx 帮助命令helpzsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令,首先进入bash: bash 尝试如下命令： help ls 这是因为help命令用户显示shell内建命令的简要帮助信息。帮助信息中显示该命令的简要说明以及一些参数的使用和说明。 外部命令帮助查看： ls --help 其实外部命令都具有一个参数--help。 manman命令得到的内容比help命令更详细，而且man命令没有内建和外部命令区分，因为man工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，包括一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。 man ls man ls (章节数) 在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节 章节数 说明 1 Standard commands （标准命令） 2 System calls （系统调用） 3 Library functions （库函数） 4 Special devices （设备说明） 5 File formats （文件格式） 6 Games and toys （游戏和娱乐） 7 Miscellaneous （杂项） 8 Administrative Commands （管理员命令） 9 其他（Linux特定的）， 用来存放内核例行程序的文档。 打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面 info该命令一般bash中自带 info ls 得到的信息是不是比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多 man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的 GNU 工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。 注释：Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell 。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。bash是大多数Linux系统以及Mac OS X默认的shell，它能运行于大多数类Unix风格的操作系统之上。详细见：Linux之bash介绍]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大数据结构]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[算法+数据结构=编程 转自：大数据文摘公众号 数组（列表） 栈 队列 链表 树 图 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表） 字典 元组 数组数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。 每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。 以下是数组的两种类型： 一维数组（如上所示） 多维数组（数组的数组） 数组的基本操作 Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量 面试中关于数组的常见问题 寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值 栈著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。 可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。 下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除： 栈的基本操作 Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它 面试中关于栈的常见问题 使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡 队列与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。 一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。 下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除： 移除先入队的元素、插入新元素 队列的基本操作 Enqueue() —— 在队列尾部插入元素 Dequeue() ——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top() ——返回队列的第一个元素 面试中关于队列的常见问题 使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数 链表链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。 链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。 链表一般用于实现文件系统、哈希表和邻接表。 这是链表内部结构的展示： 链表包括以下类型： 单链表（单向）双向链表（双向） 链表的基本操作： InsertAtEnd 在链表的末尾插入指定元素 InsertAtHead 在链接列表的开头/头部插入指定元素 Delete 从链接列表中删除指定元素 DeleteAtHead 删除链接列表的第一个元素 Search 从链表中返回指定元素 isEmpty 如果链表为空，则返回true 面试中关于链表的常见问题 反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项 图图是一组以网络形式相互连接的节点。节点也称为顶点。 一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。 图的类型 无向图 有向图 在程序语言中，图可以用两种形式表示： 邻接矩阵 邻接表 常见图遍历算法 广度优先搜索 深度优先搜索 面试中关于图的常见问题 实现广度和深度优先搜索 检查图是否为树 计算图的边数 找到两个顶点之间的最短路径 树树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。 树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。 这是一个简单树的示意图，以及树数据结构中使用的基本术语： Root 根节点 Parent 父节点 Child 子节点 Leaf 叶子节点 Sibling 兄弟节点 以下是树形结构的主要类型： N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树 其中，二叉树和二叉搜索树是最常用的树。 面试中关于树结构的常见问题： 求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点 字典树（Trie）字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。 以下是在字典树中存储三个单词“top”，“so”和“their”的例子： 这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。 面试中关于字典树的常见问题 计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ） 哈希表哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。 哈希表通常使用数组实现。 散列数据结构的性能取决于以下三个因素： 哈希函数 哈希表的大小 碰撞处理方法 下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。 面试中关于哈希结构的常见问题： 在数组中查找对称键值对 追踪遍历的完整路径 查找数组是否是另一个数组的子集 检查给定的数组是否不相交 字典元组]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式匹配的KMP算法]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单模式匹配算法的效率不高，原因在于匹配过程中的回溯。KMP匹配算法的时间复杂度是O(m+n)，优于简单算法，原因在于KMP算法到达失配点，串S不需要回溯，串P也不一定要回溯到第1个字符的位置。 模式匹配：设有两个串S和P,称在串中S中找串P的过程为模式匹配。S为主串，P为字串。 KMP算法的关键是$j$回溯到什么位置，实现KMP算法的关键是求出模式串$P$的每个字符的最大$k$值，$k$是失配时$j$需要向前回溯的最少位置。下一趟比较就可以从$S[i]$和$P[k]$开始。设主串为$S=”s_0s_1{\cdots}s_{n-1}”$，模式串为$P=”p_0p_1{\cdots}p_{m-1}”$，并设在$s_i \neq p_j$处失配。考察P串，如果发现： $$p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\tag{1-1} $$ 是失配点前的串$p_0p_1{\cdots}p_{j-1}$中“最长的相同的前缀子串和后缀子串”，其中，$p_0p_1{\cdots}p_{k-1}$是$p_0p_1{\cdots}p_{j-1}$的前缀子串，$p_{j-k}p_{j-k+1}{\cdots}p_{j-1}$是$p_0p_1{\cdots}p_{j-1}$的后缀子串。那么，由于匹配在$s_i \neq p_j$处失败，所以必有： $$p_{j-k}{\cdots}p_{j-2}p_{j-1} = s_{i-k}{\cdots}p_{i-2}p_{i-1}\tag{1-2} $$ 综合式（1-1）和式（1-2）,可得式（1-3）： $$p_0{\cdots}p_{k-2}p_{k-1} = s_{i-k}{\cdots}s_{i-2}s_{i-1}\tag{1-3} $$ 式（1-3）说明，下一趟匹配过程从$s_i$和$p_k$开始，即将模式串中$k$位置的字符和主串中$i$位置的字符对齐后开始下一趟比较。 1.失败函数f设长度为$m$的模式串$P=“p_0p_1{\cdots}p_{m-1}”$，$k$为相同的前、后缀子串长，失败函数定义为： $$f(j) =\begin{cases}-1 &amp; j=0\ |\max \left (k | 0&lt;k&lt;j 且 p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\right )\ |0 &amp; other\\end{cases}\tag{1-4}$$ 从式（1-4）可以看出，失败函数$f(j)$被定义为相同的前、后缀子串长的最大值，其含义为：当匹配在$s_i \neq p_j$处失败，$j$应该回溯的的位置$f(j)$。$f(j) \geq or \ge 0$表示下趟匹配过程从$s_i$和$p_{f(j)}$开始；$f(j)=-1$表示从下趟匹配过程从$s_{i+1}$和$p_0$开始。 j 0 1 2 3 4 5 6 7 8 9 10 P a b c a b c a b b a c $f(j)$ -1 0 0 0 1 2 3 4 5 0 1 $f(j)$的取决于模式串$P$自身的特性。一种特殊的情况，$P$中没有相同的字符出现，或头尾相同，其余不同，则除了$f(0)=-1$外，其他得$f(j)$均为0。也就是说，当到达失配点，$P$均回到第1个字符a_0开始下一趟匹配。 2. KMP算法的C++程序设串P的f值已求得 int FindKMP(int i, String &amp;P) { if (i&lt;0 || i&gt;n-1){ cout &lt;&lt; &quot;Out of bounds!&quot; &lt;&lt;endl; return -1; } int j=0, m=P.n; while(i&lt;n &amp;&amp; j&lt;m) { if( j==-1 || str[i] == P.str[j]) { i++; j++; } else j=P.f[j]; return ( (j==m)?i-m:-1) } }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2.x和Python3.x的版本区别]]></title>
    <url>%2F2018%2F08%2F22%2Fpython2.x%E5%92%8Cpython3.x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Python 3.0在设计的时候没有考虑向下相容。许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 pyython3.x和python2.x的版本区别 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。 printpython 3.0 中使用print()函数来输出，而不再使用print语句。 print(&quot;zxp&quot;) #python3.0 print &quot;zxp&quot; #python3.0不再支持 在python2.6和python2.7中，三种形式等价： print(&quot;zxp&quot;)# print不能带任何参数 print (&quot;zxp&quot;) #print后有空格 print &quot;zxp&quot; python2.6实际已经支持print()语法： seq = &apos;hello&apos; print(&apos;zxp&apos;,&apos;panda&apos;,seq) Unicodepython2中有ASCII str()类型，unicode()是单独的，不是byte类型。python3中有Unicode(utf-8)字符串，以及一个字节类：byte和bytearrays。 python3.x源码文件默认使用utf-8: &gt;&gt;&gt;中国 = “china” &gt;&gt;&gt;print(中国) china 而在python2.x中是语法错误 python2.x &gt;&gt;&gt; 中国 = &quot;china&quot; SyntaxError: invalid syntax &gt;&gt;&gt; str = &quot;我是霸王&quot; &gt;&gt;&gt; str &apos;\xce\xd2\xca\xc7\xb0\xd4\xcd\xf5&apos; &gt;&gt;&gt; print str 我是霸王 &gt;&gt;&gt; str = u&apos;我是霸王&apos; &gt;&gt;&gt; str u&apos;\u6211\u662f\u9738\u738b&apos; python3.x &gt;&gt;&gt; str = &quot;我是霸王&quot; &gt;&gt;&gt; str &apos;我是霸王&apos; &gt;&gt;&gt; print(str) 我是霸王 除法运算python中除法包括两个运算符，/和// python2.x中的/除法，跟java、c相同，整数相除结果是一个整数，把小数忽略掉。浮点数的除法会保留小数部分，得到一个浮点数结果。 python3.x中/除法对于整数之间相除，结果也会是浮点数 python2.x &gt;&gt;&gt; 3/2 1 python3.x &gt;&gt;&gt; 3/2 1.5 而对于//除法，被称为floor除法(python3.x中的floor)，会对除法的结果自动进行一个floor操作，在python2.x和python3.x中是一致的 &gt;&gt;&gt; 5//3 1 python3.x中floor操作：向下取整，小数不存在 &gt;&gt;&gt; import math &gt;&gt;&gt; math.floor(2.2) 2 python2.x中floor操作：向下取整，小数存在，仍然是浮点数 &gt;&gt;&gt; math.floor(3.2) 3.0 如果需要取整，需要trunc函数 &gt;&gt;&gt; import math &gt;&gt;&gt; math.trunc(5/3) 1 异常在 Python 3 中我们现在使用 as 作为关键词。捕获异常的语法由 except exc, var 改为 except exc as var。 使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。 1在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代，只有继承自BaseException的对象才可以被抛出。 2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩的写法，直接调用构造函数抛出对象即可。 创建迭代对象在Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。这个表现十分像生成器（比如。”惰性求值”）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。 在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。 python2.x中使用xrange()和range() &gt;&gt;&gt; range(1,10,2) [1, 3, 5, 7, 9] &gt;&gt;&gt; xrange(1,10,2) xrange(1, 11, 2) &gt;&gt;&gt; list(xrange(1,10,2)) [1, 3, 5, 7, 9] python3.x中使用range(),内容包含了xrange() &gt;&gt;&gt; xrange(10) Traceback (most recent call last): File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt; xrange(10) NameError: name &apos;xrange&apos; is not defined &gt;&gt;&gt; range(10) range(0, 10) &gt;&gt;&gt; list(range(1,10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] 八进制字面量表示八进制数必须写成0o777，原来的形式0777不能用了；二进制必须写成0b111。 新增了一个bin()函数用于将一个整数转换成二进制字串。 Python 2.6已经支持这两种语法。 在Python 3.x中，表示八进制字面量的方式只有一种，就是0o1000。 &gt;&gt;&gt; 0777 SyntaxError: invalid token &gt;&gt;&gt; 0o777 511 python2.x &gt;&gt;&gt; 0777 511 &gt;&gt;&gt; 0o777 511 不等于运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt; Python 3.x中去掉了&lt;&gt;, 只有!=一种写法，还好，我从来没有使用&lt;&gt;的习惯 数据类型python3.x中不再有long类型，只有一种整性int,当它的行为跟python2.x的long相同 python3.x中，字符串和bytes类型彻底分开了。字符串是以字符为单位进行处理的，bytes类型是以字节为单位处理的。 bytesbytes数据类型在所有的操作和使用甚至内置方法上和字符串数据类型基本一样，也是不可变的序列对象。 bytes对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等。可以通过调用bytes()生成bytes实例，其值形式为 b’xxxxx’，其中 ‘xxxxx’ 为一至多个转义的十六进制字符串（单个 x 的形式为：\x12，其中\x为小写的十六进制转义字符，12为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围0-255），对于同一个字符串如果采用不同的编码方式生成bytes对象，就会形成不同的值. b = b&apos;&apos; # 创建一个空的bytes b = byte() # 创建一个空的bytes b = b&apos;hello&apos; # 直接指定这个hello是bytes类型 b = bytes(&apos;string&apos;,encoding=&apos;编码类型&apos;) #利用内置bytes方法，将字符串转换为指定编码的bytes b = str.encode(&apos;编码类型&apos;) # 利用字符串的encode方法编码成bytes，默认为utf-8类型 bytes.decode(&apos;编码类型&apos;)：将bytes对象解码成字符串，默认使用utf-8进行解码。 对于bytes，我们只要知道在Python3中某些场合下强制使用，以及它和字符串类型之间的互相转换，其它的基本照抄字符串。 简单的省事模式： string = b&#39;xxxxxx&#39;.decode() 直接以默认的utf-8编码解码bytes成string b = string.encode() 直接以默认的utf-8编码string为bytes 转自：http://www.runoob.com/python/python-2x-3x.htmlhttps://www.cnblogs.com/R-bear/p/7744454.html]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现：8种排序算法]]></title>
    <url>%2F2018%2F08%2F22%2FPython%E5%AE%9E%E7%8E%B08%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍8中排序算法，包括算法的基本思路和算法的python实现。 选择排序-简单选择排序 选择排序-堆排序 插入排序-直接插入排序 插入排序-希尔排序 交换排序-快速排序 交换排序-冒泡排序 归并排序 桶排序/基数排序 经典文章：好文 选择排序简单选择排序每一趟从待排序的数据元素中选出最小（最大）的元素，顺序放在待排序的数列最前，直到全部待排序的数据元素全部排完。 例子：[4, 2, 3] 找出最小的：2,与第一个元素交换[2, 4, 3] 找出最小的：3，与第二个元素交换[2, 3, 4] 百度百科： 简单选择排序 算法实现 def j_sort(a): l = len(a) temp = 0 for j in range(0,l-1): count = j #记录最小元素下标 #每次找出最小元素 for i in range(j,l-1): if a[count] &gt; a[i+1]: count = i+1 #交换最小元素和待排序元素中最前一个 &apos;&apos;&apos;if count != j: temp = a[j] a[j] = a[count] a[count] = temp &apos;&apos;&apos; a[j], a[count] = a[count], a[j] #实现跟上述代码一样 for i in range(0,l): print(a[i]) if __name__ == &quot;__main__&quot;: a = [10, 2, 5, 1, 3, 7, 3] j_sort(a) 堆排序堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。 堆堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图： 转自：https://www.cnblogs.com/chengxiao/p/6129630.html 百度百科： 堆排序 算法实现 def d_sort(arr): l = len(arr) for i in range(int(l/2-1), -1, -1): adjustHead(arr,i,l) # 交换堆顶和最后一个元素，并调整堆结构 for j in range(l-1, 0, -1): arr[0], arr[j] = arr[j], arr[0] #将堆顶元素和末尾元素进行交换 adjustHead(arr, 0, j) #重新对对进行调整 for k in range(0,l): print(arr[k]) #构造大顶堆 def adjustHead(a, i, l): temp = a[i] #取出当前元素 k = 2*i + 1 #从左子节点开始，即2*i+1 while k &lt; l: if k+1 &lt; l &amp; a[k] &lt; a[k+1]: #若果左子节点小于右子节点，k指向右子节点 k=k+1 if a[k] &gt; temp: #如果子节点大于父节点，将子节点赋值给父节点，并将子节点下标记录下来，后面将父节点值赋值给该子节点 a[i] = a[k] i = k else: break k = 2*k + 1 #把该节点当作父节点，继续操作 a[i] = temp #将父节点值赋值给该子节点 if __name__ == &quot;__main__&quot;: a = [10,2,4,5] d_sort(a) 插入排序插入排序思想：每一趟将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素的适当位置上，直到所有待排序元素元素全部插入为止 直接插入排序直接插入排序是假定前i个构成的子序列是处于已排序的情况下进行排序的，然后将第i个元素与前i个构成的子序列逆序进行比较，如果是要升序排序，则比较第i个元素是否比j=i-1(i-1需要&gt;=0)的元素大，如果是则第i个元素的位置（即j+1的位置上）保持不动，反之则将j=i-1的元素放置到i的位置，再进行第i个元素与j=i-2(i-2需要&gt;=0)的,依次进行，如果第i个元素刚好比j=i-3大，则将第i个元素插入到j=i-2（即j+1的位置）上！ 百度百科： 直接插入排序 算法实现 def zc_sort(a): l = len(a) j=0 for i in range(1,l): temp = a[i] for j in range(i-1, -1, -1): if temp &lt; a[j]: #如果第i个元素大于前i个元素中的第j个 a[j+1] = a[j] #则第j个元素先后移1位 else: #如果第i个元素小于等于前i个元素中的第j个则结束循环 break a[j+1] = temp #将i个元素赋值给空着的位置 for i in range(0,l): print(a[i]) if __name__ == &quot;__main__&quot;: a = [1, 10, 5, 2, 6, 7, 2] zc_sort(a) 希尔排序转自：https://www.cnblogs.com/chengxiao/p/6104371.html 百度百科： 希尔排序 算法实现 def shell_sort(a): l = int(len(a)/2) #生成增量列表 gap_list = [] while l &gt; 0: gap_list.append(l) l = int(l/2) print(gap_list) for gap in gap_list:#增量gap，并逐步缩小增量 #print(gap) for i in range(gap, len(a)):#从第gap个元素，逐个对其所在组进行直接插入排序操作 j = i while j -gap &gt;= 0 and a[j-gap] &gt; a[j]: swap(a, j, j-gap) #交换两个元素 j = j - gap for i in range(0,len(a)): print(a[i]) def swap(arr, a, b): arr[a] = arr[a] + arr[b] arr[b] = arr[a] - arr[b] arr[a] = arr[a] - arr[b] if __name__== &quot;__main__&quot;: a = [1,0,4,-1,2,7,9,8,10, 3,6,5,18] shell_sort(a) 交换排序快速排序任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0];3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 注意：快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 百度百科： 快速排序 算法实现递归 def quick_sort(arr, low, high): #temp = a[0] i = low j = high if i &gt;= j: return arr temp = arr[i] while i &lt; j: while i &lt; j and arr[j] &gt;= temp: j = j-1 arr[i] = arr[j] while i &lt; j and arr[i] &lt;= temp: i = i + 1 arr[j] = arr[i] arr[i] = temp quick_sort(arr, low, i-1) quick_sort(arr, j+1, high) return arr if __name__ == &quot;__main__&quot;: a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8] quick_sort(a, 0, len(a)-1) print(a) 冒泡排序冒泡排序算法的原理如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 百度百科： 冒泡排序 def bubble_sort(arr): length = len(arr) while length &gt; 0: for i in range(length-1): if arr[i] &gt; a[i+1]: arr[i] = arr[i] + arr[i+1] arr[i+1] = arr[i] - arr[i+1] arr[i] = arr[i] - arr[i+1] length -= 1 if __name__ == &quot;__main__&quot;: a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8] bubble_sort(a) print(a) 归并排序（递归）本文中的快速排序就是一种递归排序先递归，在排序首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。 解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？ 可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。 转自：https://www.cnblogs.com/lulushow/p/6820727.html 百度百科： 归并排序 算法实现 def Merge_Sort(lists): if len(lists) &lt;= 1: return lists num = int(len(lists)/2) left = Merge_Sort(lists[:num]) #将列表从中间分为两部分 right = Merge_Sort(lists[num:]) return Merge(left, right) #合并两个列表 def Merge(left,right): r, l=0, 0 result=[] while l&lt;len(left) and r&lt;len(right): if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return result if __name__ == &quot;__main__&quot;: a = [10, 7, 4, 2, 8, 5, 1, 3] a = Merge_Sort(a) print(a) 基数排序基数排序又称为“桶子法”，从低位开始将待排序的数按照这一位的值放到相应的编号为0~9的桶中。等到低位排完得到一个子序列，再将这个序列按照次低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。 转：https://blog.csdn.net/double_happiness/article/details/72452243 百度百科： 基数排序 算法实现 import math def radix_sort(arr): radix = 10 #基数 k = int(math.ceil(math.log(max(arr),radix)))#k可以表示任意整数 #math.log对arr中最大的数取对数，log(max(arr),10),并对其取整得到最大值的位数 bucket =[[] for i in range(radix)] for i in range(1, k+1): for value in arr: bucket[int(value%(radix**i)/(radix**(i-1)))].append(value) #析取整数第k位数字（从低到高）10**2位10的二次方 del arr[:] for each in bucket: arr.extend(each) #桶合并 bucket = [[]for i in range(radix)] if __name__ == &quot;__main__&quot;: a = [10, 2, 13, 44, 22, 33, 100, 612, 333, 262] radix_sort(a) print(a)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题目]]></title>
    <url>%2F2018%2F08%2F22%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[leetcode是个题库，里面有很编程多面试的题目，可以在线编译运行。难度比较高。如果自己能都做出来，对面大公司很有帮助。 两数之和给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路： 利用python实现，先将列表转化为字典dict1，字典的键为列表元素，字典的值为对应元素的下标。 对于每个元素nums[i]，对于给定的target数，检查字典中是否有键（target-nums[i]）,如果存在则说明，该键对应的值和nums[i]的下标为对应的输出结果。注意该键对应的值不能是i! 代码： class Solution: def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict1 = {} l = len(nums) for i in range(0,l): dict1[nums[i]] = i for i in range(0,l): temp = target - nums[i] if (temp in dict1.keys()) and dict1.get(temp) != i: return [i,dict1.get(temp)] 算法分析: 时间复杂度：O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。 两数相加给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 思路： 考虑到两个链表长度不一，短的列表后面补零。 最开始的创建一个链表（ll），并赋值一个另一个值(lp)（后面链表的指针需要移动，不指向起始），并创建一个变量来存储进位的值（temp）。 首先判读两个链表是否都已到达末尾，如果没有，将两个链表的值分别赋值给两个变量（val1和val2）,如果其中一个到达末尾，则val1或val2赋值为0。然后，对两个数进行相加求余数，利用余数创建链表节点(lq)，并接在最先创建的链表(ll)后面，将节点ll先后指向下一个节点，同时计算val1+val2+temp的进位值。如果两个节点都已达到末尾，而此时还需进位值不为零（可以最后两个相加大于9），还需要创建一个节点来存储进位的值，并接在节点ll后面。 代码： # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; ll = ListNode(0) lp = ll temp = 0 while l1 or l2: if l1 == None: val1 = 0 else: val1 = l1.val l1 = l1.next if l2 == None: val2 = 0 else: val2 = l2.val l2 = l2.next lq = ListNode((val1 + val2 + temp) % 10) ll.next = lq ll = ll.next temp = (val1 + val2 + temp) //10 if l1 == None and l2 == None and temp != 0: lq = ListNode(temp) ll.next = lq return lp.next 算法分析： 时间复杂度：O(n)， 我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。 无重复字符的最长子串给定一个字符串，找出不含有重复字符的最长子串的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 无重复字符的最长子串是 “abc”，其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 无重复字符的最长子串是 “b”，其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 无重复字符的最长子串是 “wke”，其长度为 3。 请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。 方法一：暴力法思路 逐个检查所有的子字符串，看它是否不含有重复的字符。 算法 假设我们有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回true，否则会返回false。 我们可以遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为true，那么我们将会更新无重复字符子串的最大长度的答案。 现在让我们填补缺少的部分： 为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为i和j。那么我们有 0≤i&lt;j≤n （这里的结束索引 j 是按惯例排除的）。因此，使用 i 从0到 n−1 以及 jj 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。 要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。 代码： class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; def allUnique(s, start, end): st = set() for i in range(start,end): if s[i] in st: return 0 st.add(s[i]) return 1 l = len(s) ans = 0 for i in range(0, l): for j in range(i+1, l+1): if(allUnique(s,i,j)): ans = max(ans, j-i) return ans 方法二：滑动窗口代码： class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) ans = i = j = 0 st = set() while i &lt; n and j &lt; n: if s[j] in st: st.remove(s[i]) i = i+1 else: st.add(s[j]) j = j + 1 ans = max(ans, j-i) return ans 方法三：优化的滑动窗口代码： class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) ans = i = j = 0 d = {} #将存放 st = set() while j &lt; n: if s[j] in d.keys(): i = max(i, d.get(s[j])) ans = max(ans, j-i+1) d[s[j]] = j + 1 j = j + 1 return ans 两个排序数组的中位数链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/ 二、数组1.三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 方法一：该方案时间复杂度比方案二高 class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() l = len(nums) a = [] dict1 = {} for i in range(0,l): dict1[nums[i]] = i for i in range(0,l): for j in range(i+1,l): temp = -(nums[i] + nums[j]) if temp in dict1.keys() and dict1[temp] &gt; i and dict1[temp] &gt; j: b = [nums[i], nums[j], temp] if b not in a: a.append(b) return a 方法二：该方案时间复杂度为O(n^2) class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() l = len(nums) a = [] for i in range(0,l-2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l += 1 elif s &gt; 0: r -= 1 else: a.append([nums[i], nums[l], nums[r]]) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 return a 2.最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 代码 class Solution: def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; ll = len(nums) nums.sort() result = nums[0] + nums[1] + nums[2] for i in range(ll-2): l, r = i + 1,ll-1 while l &lt; r: sum1 = nums[i] + nums[l] + nums[r] if sum1 == target: return sum1 if abs(sum1 - target) &lt; abs(result - target): result = sum1 if target &lt; sum1: r -= 1 elif target &gt; sum1: l += 1 return result 3.四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 代码 def fourSum(self, nums, target): def findNsum(nums, target, N, result, results): ll = len(nums) if ll &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: return if N == 2: l,r = 0,ll-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 elif s &lt; target: l += 1 else: r -= 1 else: for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) results = [] nums.sort() findNsum(nums, target, 4, [], results) return results 4.删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 双指针法数组完成排序后，我们可以放置两个指针i和j ，其中i是慢指针，而j是快指针。只要nums[i]=nums[j]，我们就增加j 以跳过重复项。 当我们遇到 nums[j] \n eq nums[i]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到nums[i+1]。然后递增i，接着我们将再次重复相同的过程，直到j 到达数组的末尾为止。 代码： class Solution: def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; i = 0 if len(nums) == 0: return 0 for j in range(1, len(nums)): if nums[i] != nums[j]: i += 1 nums[i] = nums[j] return i + 1 5.移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 双指针法当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 代码： class Solution: def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; n = len(nums) i = 0 while i &lt; n: if nums[i] == val: nums[i] = nums[n-1] n -= 1 else: i += 1 return n 6.下一排序实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 字典排序： 对于数字1、2、3……n的排列，不同排列的先后关系是从左到右逐个比较对应的数字的先后来决定的。例如对于5个数字的排列 12354和12345，排列12345在前，排列12354在后。按照这样的规定，5个数字的所有的排列中最前面的是12345，最后面的是 54321。 一遍扫描 代码： class Solution: def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; i = len(nums) - 2 w hile (i &gt;= 0) and nums[i] &gt;= nums[i+1]: i -= 1 if i &gt;= 0: j = len(nums) - 1 while (j &gt;= 0) and nums[j] &lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] k = len(nums) - 1 i = i + 1 while (i &lt; k): nums[i], nums[k] = nums[k], nums[i] i += 1 k -= 1 7.搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 代码 class Solution: def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; k = range(len(nums)) d = dict(zip(nums,k)) if target in d.keys(): return d.get(target) else: return -1 8.插入搜索位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 代码 class Solution: def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if nums[len(nums)-1] &lt; target: return len(nums) for i in range(len(nums)): if nums[i] == target: return i if target &lt; nums[i]: return i 9.组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 代码 class Solution: def combinationSum(self, candidates, target): “”” :type candidates: List[int] :type target: int :rtype: List[List[int]] “”” if(target &lt; 0): return [] if(target == 0): return [[]] return [[candidates[i]] + left for i in range(len(candidates)) for left in self.combinationSum(candidates[i:], target - candidates[i])] 10. 缺失的第一个正数给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 代码 class Solution: def firstMissingPositive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 0: return 1 dict1 = dict(zip(nums, range(len(nums)))) for i in range(1,max(nums)+1): if i in dict1.keys(): continue return i return max(nums)+1 11. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 代码 class Solution: def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; l = len(height) if l == 0: return 0 total = 0 left_max = [0]*l right_max = [0]*l left_max[0] = height[0] for i in range(1, l): left_max[i] = max(height[i], left_max[i-1]) right_max[l-1] = height[l-1] for i in range(l-2, -1, -1): right_max[i] = max(height[i], right_max[i+1]) for i in range(0,l-1): total += min(left_max[i],right_max[i]) - height[i] return total 12. 跳跃游戏Ⅱ给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明: 假设你总是可以到达数组的最后一个位置。 代码 class Solution: def jump(self, nums): &quot;&quot;&quot; Greedy implementation maximizing the length of each jump. :type nums: List[int] :rtype: int &quot;&quot;&quot; current_index = 0 target_index = len(nums) - 1 total_jumps = 0 while current_index &lt; target_index: total_jumps += 1 jump_range = range(current_index, current_index + nums[current_index] + 1) if target_index in jump_range: break next_index = current_index for next_index_candidate in jump_range: candidate_jump_destination = next_index_candidate + nums[next_index_candidate] next_jump_destination = next_index + nums[next_index] if next_jump_destination &lt; candidate_jump_destination : next_index = next_index_candidate current_index = next_index return total_jumps 13. 图像旋转给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 代码 class Solution: def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix)-1 #交换第i行和第n-i行 for i in range(len(matrix)//2): matrix[i][:], matrix[n-i][:] = matrix[n-i][:], matrix[i][:] #将矩阵进行装置 for i in range(len(matrix)): for j in range(i+1, len(matrix)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 14. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 C++实现 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int *dp = new int[n]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; n; i++) { dp[i] = nums[i] + (dp[i-1] &gt; 0 ? dp[i-1] : 0); max = max &gt; dp[i] ? max : dp[i]; } return max; } }; 15 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 思路 一层一层输出，先输出第一行，最后一列，最后一行，第一列。然后进入第二层，采用通过的顺序输出。 C++实现 class Solution { public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) return {}; int j = 0; int r1 = 0; int r2 = matrix.size()-1; int c1 = 0; int c2 = matrix[0].size()-1; int totalnums = (r2+1) * (c2+1); vector&lt;int&gt; p(totalnums); int k = 0; while (r1 &lt;= r2 and c1 &lt;= c2) { for (int i = c1; i &lt;= c2; i++) p[k++] = matrix[r1][i]; for (int j = r1 + 1; j &lt;= r2; j++) p[k++] = matrix[j][c2]; if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) { cout &lt;&lt; &apos;1&apos; &lt;&lt; endl; for (int i = c2 - 1; i &gt; c1; i--) p[k++] = matrix[r2][i]; for (int j = r2; j &gt; r1; j--) p[k++] = matrix[j][c1]; } r1++; r2--; c1++; c2--; } return p; } }; 16 跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。]]></content>
      <tags>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制介绍以及相互转换]]></title>
    <url>%2F2018%2F08%2F22%2F%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[进制也就是进位计数制，是人为定义的带进位的计数方法 对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。 进制 十进制 二进制 四进制 七进制 八进制 十六进制 十进制十进制编码几乎就是数值本身。 二进制它由两个数码0，1组成，二进制数运算规律是逢二进一。 二进制乘法和加法基本运算法则： 0+0=0，0+1=1，1+0=1，1+1=10 0×0=0，0×1=0，1×0=0，1×1=1 四进制四进制是以4为基数的进位制，以 0、1、2 和 3 四个数字表示任何实数。 十进制0-12之间的相互转换： 七进制七进制是以7为基数的计数系统。使用数码0-6。 八进制由于二进制数据的基数R较小，所以二进制数据的书写和阅读不方便，为此，在小型机中引入了八进制。八进制的基数R=8=2^3，有数码0、1、2、3、4、5、6、7，并且每个数码正好对应三位二进制数，所以八进制能很好地反映二进制。八进制用下标8或数据后面加O表示 例如：二进制数据 （ 11 101 010 . 010 110 100 ）2 对应八进制数据 (352.264)8或352.264O。 十六进制由于二进制数在使用中位数太长，不容易记忆，所以又提出了十六进制数。 十六进制数有两个基本特点：它由十六个数码：数字0～9加上字母A-F组成（它们分别表示十进制数10～15），十六进制数运算规律是逢十六进一，即基数R=16=2^4，通常在表示时用尾部标志H或下标16以示区别，在c语言中用添加前缀0x以表示十六进制数。 例如：十六进制数4AC8可写成（4AC8）16，或写成4AC8H。 进制转换对于任何一个数，我们可以用不同的进位制来表示。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，也可以用八进制表示为71(8)、用十六进制表示为39(16)，它们所代表的数值都是一样的。 二进制数、十六进制数转换为十进制数（按权求和）二进制数、十六进制数转换为十进制数的规律是相同的。把二进制数（或十六进制数）按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”. 例如：把（1001.01)2 二进制计算。 解：（1001.01）2&lt;/br&gt; =8*1+4*0+2*0+1*1+0*(1/2)+1*(1/4)&lt;/br&gt; =8+0+0+1+0+0.25&lt;/br&gt; =9.25 把（38A.11)16转换为十进制数解：（38A.11)16=3×16的2次方+8×16的1次方+10×16的0次方+1×16的-1次方+1×16的-2次方=768+128+10+0.0625+0.0039=906.0664 十进制数转换为二进制数，十六进制数（除2/16取余法）整数转换.一个十进制整数转换为二进制整数通常采用除二取余法，即用2连续除十进制数，直到商为0，逆序排列余数即可得到――简称除二取余法． 例：将25转换为二进制数解：25÷2=12 余数112÷2=6 余数06÷2=3 余数03÷2=1 余数11÷2=0 余数1所以25=(11001)2 同理，把十进制数转换为十六进制数时，将基数2转换成16就可以了. 例：将25转换为十六进制数解：25÷16=1 余数91÷16=0 余数1所以25=(19)16 二进制数与十六进制数之间的转换由于4位二进制数恰好有16个组合状态，即1位十六进制数与4位二进制数是一一对应的.所以，十六进制数与二进制数的转换是十分简单的. (1）十六进制数转换成二进制数，只要将每一位十六进制数用对应的4位二进制数替代即可――简称位分四位.例：将（4AF8B)16转换为二进制数.解： 4 A F 8 B0100 1010 1111 1000 1011所以（4AF8B)16=(1001010111110001011)2 (2）二进制数转换为十六进制数，分别向左，向右每四位一组，依次写出每组4位二进制数所对应的十六进制数――简称四位合一位.例：将二进制数（000111010110)2转换为十六进制数.解： 0001 1101 01101 D 6所以（111010110)2=（1D6）16转换时注意最后一组不足4位时必须加0补齐4位 数制转换的一般化1）R进制转换成十进制 任意R进制数据按权展开、相加即可得十进制数据。例如：N = 1101.0101B = 1*2^3+1*2^2+0*2^1+1*2^0+0*2^-1+1*2^-2+0*2^-3+1*2^-4 = 8+4+0+1+0+0.25+0+0.0625 = 13.3125&lt;/br&gt; N = 5A.8H = 5*16^1+A*16^0+8*16^-1 = 80+10+0.5 = 90.5 2）十进制转换R 进制 十进制数转换成R 进制数，须将整数部分和小数部分分别转换. 1.整数转换———除R 取余法 规则：（1）用R 去除给出的十进制数的整数部分，取其余数作为转换后的R 进制数据的整数部分最低位数字； （2）再用R去除所得的商，取其余数作为转换后的R 进制数据的高一位数字； （3）重复执行（2）操作，一直到商为0结束。 2．小数转换—————乘R 取整法 规则：（1）用R 去乘给出的十进制数的小数部分，取乘积的整数部分作为转换后R 进制小数点后第一位数字； （2）再用R 去乘上一步乘积的小数部分，然后取新乘积的整数部分作为转换后R 进制小数的低一位数字； （3）重复（2）操作，一直到乘积为0，或已得到要求精度数位为止。 3.小数转换——整数退位法：举例：0.321d转成二进制，由于321不是5的倍数，用取余法、取整法可能要算很久，这时候我们可以采用整数退位法。原理如下： n为转成的二进制数的小数位数&lt;/br&gt; (x)10=(y)2&lt;/br&gt; (x)10*2^n=(y)2*2^n&lt;/br&gt; D=(x)10*2^n：计算10进制数，取整&lt;/br&gt; D→T转成2进制数&lt;/br&gt; (y)2=T/2^n=T*2^(-n)，T退位，位数不足前端补零&lt;/br&gt; 举例:&lt;/br&gt; 0.321转成二进制数，保留7位&lt;/br&gt; 0.321*2^7=41.088,取整数41&lt;/br&gt; 41=32+8+1即100000+1000+1=101001&lt;/br&gt; 退位，因只有6位而要求保留7位，所以是0.0101001 提炼至：百度百科]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2.7和Python3.6安装以及文件解决]]></title>
    <url>%2F2018%2F08%2F22%2Fpython2.7%E5%92%8Cpython3.6%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[在实际中，可以需要同时安装python2.7和python3.6版本，在此过程中可以遇到一些问题，在此将一一陈述。 Python2.7和Python3.6并存在环境变量中添加Python两个版本的值即可，具体如下： 右键我的电脑，按下图操作： 添加值： 在环境变量中添加： C:\Python27 C:\Python27\Scripts C:\Python36 C:\Python36\Scripts 打开CMD,切换Python2.7和Python3.6 py -2 切换至python2.7 py -3 Ctrl+C或 输入exit()退出Python环境 在具体py文件中，使用 #! python2 # coding: utf-8 可以指定解释器版本，这时只需py test.py，无需带-2或-3这种参数 IDLE打开方式可以尝试在搜索栏中输入IDLE，然后双击，如果找不到，尝试如下方法：找到C:\Python27\Lib\idlelib下的idle.bat文件，双击即可打开IDLE Python2.7的IDLE无法打开问题解决打开运行，输入如下代码： %USERPROFILE%\.idlerc 会自动大量如下文件夹： 删除文件夹中的三个文件 pip安装第三方库pip2.7 install numpy #仅为python2.7安装numpy库 pip3.6 install numpy #仅为python3.6安装numpy库 第三方库安装目录：C:\Python27\Lib\site-packages]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件系统概念]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[文件系统和硬盘分区基本概念介绍文件系统：是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。 硬盘分区：实质上是对硬盘的一种格式化。当我们创建分区时，就已经设置好了硬盘的各项物理参数，指定了硬盘主引导记录(即Master Boot Record，一般简称为MBR)和引导记录备份的存放位置。而对于文件系统以及其他操作系统管理硬盘所需要的信息则是通过之后的高级格式化，即Format命令来实现。 簇：是指可分配的用来保存文件的最小磁盘空间，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。所以,簇越小，保存信息的效率就越高。 主引导记录：（MBR，Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。 硬盘大小： 实际中，给硬盘分区时，按照1G=1024M来设置，但是显示的结果都不是整数。比如：将分区设置为10G,显示的确实9.XXG。原因是：正确计算公式 (N-1)*4+1024*N 式中N为想要的大小，单位为GB。最终计算出来的结果为MB. 例如：想要设置分区为2G,则（2-1）4+10242=2052M设置分区时应该为2052M 分区状态三种：主分区、扩展分区和逻辑分区 主分区：是一个比较单纯的分区，通常位于硬盘的最前面一块区域中，构成逻辑C磁盘。其中的主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区，负责把引导权移交给活动分区的DOS或其他操作系统。此段程序损坏将无法从硬盘引导，但从软驱或光驱引导之后可对硬盘进行读写。 扩展分区：仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区(实际上也就是下一个逻辑磁盘)的起始位置，以此起始位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘。 三者解释：主分区能够激活，通常用来引导系统。扩展分区本身并不能直接用来存放数据，逻辑分区是扩展分区进一步分割出来的区块，通常用来存储数据。如果将逻辑分区比作房间，那么扩展分区就好比客房区(包括若干个房间) 主分区和活动分区：主分区也被称为主磁盘分区，是磁盘分区的一中类型，其主要作用是用来安装操作系统。一个硬盘最多可创建4个主分区。活动分区是基于主分区的，磁盘分区中的任意主分区都可以设置为活动分区。如果电脑上4个主分区都安装了不同的系统，那被标记为活动分区的主分区将用于初始引导，即启动活动分区内安装的系统。 逻辑分区和扩展分区：因为主分区最多可以创建4个，我们需要使用扩展分区打破4的限制。在磁盘上可以创建多个逻辑分区而创建的这些逻辑分区都被称为扩展分区，您可以用主分区和逻辑分区中储存数据，但是不能用扩展分区储存，因为扩展分区是我们对逻辑分区的总称，只是一中称呼。 例子：通常我们会先在硬盘上划分一个主分区，就是我们常说的C分区，用于安装操作系统，然后将其他的空间全部作为扩展分区，并根据需要，将扩展分区分成几个逻辑分区，即D、E等分区。 分区格式windows:FAT16、FAT32、NTFS、exFATLinux: ext2、ext3、Linux swap、VFAT、ext4、 FAT和NNTFS区别FAT32：随着大容量硬盘的出现，从Windows 98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。其实白话说就是FAT格式的分区单个文件夹文件不支持大于4G的文件，NTFS可以支持无限大的，不过相对FAT格式不稳定是真的，xp一般系统是FAT格式的，现在的分区一般都选测NTFS格式的了，文件存储大了 分区表类型GPT分区: GUID磁盘分区表（GUIDPartition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。至少可以划分128个主分区。gtp不在有分区的概念。 MBR分区：只能划分四个分区，最多支持2T的磁盘 两者区别： 内存支持：mbr最多支持2T，而gpt理论上是无限制的。 在MBR硬盘中，分区信息直接存储于主引导记录（MBR）中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。 分区：mbr最多支持四个主分区，gpt没有限制。如果你想跑多系统，mbr最多4个而gpt没有限制。 系统：win7只能用mbr分区（也可以但是很麻烦，不建议），从Win8开始微软建议你使用gpt。 其它：gpt是由uefi启动的，而uefi是后来才提出的概念，兼容性和稳定性不如bios+mbr。 对于总容量大于2TB的硬盘，必须选择GPT分区表，才能识别所有的硬盘容量。MBR分区表由于自身设计的局限性，最大只能支持2TB的地址空间。对于超过2TB的大硬盘，如果使用MBR分区表，将无法识别和使用2TB后的空间。 BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。用于加载电脑最基本的程序代码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。只支持MBR分区。 UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS（基本输入/输出系统），UEFI旨在提高软件互操作性和解决BIOS的局限性。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而达到开机程序化繁为简节省时间的目的。只支持GPT分区。]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>硬盘分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock模拟数据生成接口]]></title>
    <url>%2F2018%2F08%2F17%2FMock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Easy Mock是一个可视化，并且能快速生成模拟数据的服务。 Mock解决的问题开发时，后端还没完成数据输出，前端只好写静态模拟数据。数据太长了，将数据写在js文件里，完成后挨个改url。某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。特殊的格式，例如IP,随机数，图片，地址，需要去收集。 教程官方地址：https://easy-mock.com/login 直接输入账号，密码，如果未注册，会直接注册。进入如下页面，按图操作 文档中给出了基本教程]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>Mock数据模拟</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境变量与文件查找]]></title>
    <url>%2F2018%2F08%2F16%2F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[介绍环境变量的作用与用法，及几种搜索文件的方法。学会这些技巧可以高效地使用 Linux 。 环境变量变量要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。 shell创建变量 declare tmp shell变量复制 temp=zxp 输出变量 echo $temp 注意：并不是任何形式的变量名都是可用的，变量名只能是英文字母、数字或者下划线，且不能以数字作为开头 环境变量环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。 通常我们会涉及到的变量类型有三种： 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表： 命 令 说 明 set 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 环境变量永久生效按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。查看每个用户的永久生效的环境变量： cd /home/用户名 ls -a 命令查找路径与顺序Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。 查看PATH环境变量路径： echo $PATH 其中给出的路径存放可执行文件，当在shell中执行命令时，系统就会安装PATH中设定的路径依次到目录中查找，如果找到同名文件，则执行先找到的文件。 创建Shell脚本创建脚本文件，并打开 gedit hello_world.sh 在打开的文本中输入： #！ /bin/bash //该行不是注释，不能少 for((i=0; i&lt;10; i++));do echo &quot;hello world&quot; done exit 0 为文件添加可执行权限 chmod 755 hello_shell.sh 执行脚本 ./hello_shell.sh 创建C语言程序创建并打开一个文件 gidit hello_world.c 在文本中输入 #include &lt;stdio.h&gt; int main(void) { printf(&quot;hello world&quot;); return 0; } 保存后，使用gcc生成可执行文件： gcc -o hello_world hello_world.c gcc生成二进制文件默认具有可执行文件，不需修改 在/当前目录修创建一个目录mybin,并将上述文件移动到其中 mkdir mybin mv hello_shell.sh hello_world mybin/ 并进入mybin目录，运行上述两个程序： cd mybin ./hello_shell.sh ./hello_world 回到上一级目录，再运行程序，则发现提示命令找不到，除非加上命令的完整路径，但比较麻烦，可以进该路径添加到PATH环境变量。 添加自定义路径到“PATH”环境变量PATH=$PATH:/home/shiyanlou/mybin =之前之后不能添加空格，否则会提示变量不存在注意：路径必须是绝对路径 这样在任意目录中，都可以执行上述两个文件，直接输入文件名即可执行。到此，如果退出终端，再打开则会发现失效，可以添加一种自动执行的方式：在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 .zshrc，相应 Bash 的配置文件为.bashrc。它们在 etc 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。 echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc 上述命令中 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 &gt; 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。 变量修改和删除变量的修改有以下几种方式： 变量设置方式 说明 ${变量名#匹配字串} 从头向后开始匹配，删除符合匹配字串的最短数据 ${变量名##匹配字串} 从头向后开始匹配，删除符合匹配字串的最长数据 ${变量名%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最短数据 ${变量名%%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最长数据 ${变量名/旧的字串/新的字串} 将符合旧字串的第一个字串替换为新的字串 ${变量名//旧的字串/新的字串} 将符合旧字串的全部字串替换为新的字串 变量删除unset temp 环境变量立即 生效在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如： source .zshrcc source命令还有一个别名就是 .，注意与表示当前路径的那个点区分开，虽然形式不一样，但作用和使用方式一样，上面的命令如果替换成.的方式就该是: . ./.zshrc 注意第一个点之后必须有个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 搜索文件与搜索相关的命令常用的有 whereis，which，find 和 locate 。 whereis简单快捷whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。 locate快而全通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。 locate 文件名 安装软件包：yum install mlocate which小而精which本身是 Shell 内建的一个命令，通常使用 which来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令： which man find精而细find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。 find / -name 文件名 //w文件名查找 find /etc/ -name interfaces //表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path] [option] [action] 。 与时间相关的命令参数： 参数 说明 -atime 最后访问时间 -ctime 最后修改文件内容的时间 -mtime 最后修改文件属性的时间 下面以 -mtime 参数举例： -mtime n：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件 -mtime +n：列出在 n 天之前（不包含 n 天本身）被修改过的文件 -mtime -n：列出在 n 天之内（包含 n 天本身）被修改过的文件 -newer file：file 为一个已存在的文件，列出比 file 还要新的文件名 find ~ -mtime 0 //查找当天(24小时之内)右改动的文件 find ~ -newer /home/shiyanlou/Code //列出目录下比 Code 文件夹新的文件 以上内容来自:实验楼]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现：用位运算符实现加法，不允许使用 “+”]]></title>
    <url>%2F2018%2F08%2F16%2FPython%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20%E2%80%9C%2B%E2%80%9D%2F</url>
    <content type="text"><![CDATA[计算两个整数a、b的和，但是不能使用“+”操作符。即：给定a=1,b=2，返回结果3 位运算基础1、位运算符利用位运算实现加法，即计算机利用二进制进行运算，当然离不开位运算 2、异或运算相同为0，不同为1 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 1 = 1 0 ^ 0 = 0 要实现加法，先考虑1位数的加法，不考虑进位，如下： 1 + 1 = 0 1 + 0 = 1 0 + 1 = 1 0 + 0 = 0可知，上面的表达式可以用位运算符”^”代替，接下来考虑进位 3、与运算都为1,则为1 上面的加法可以表示为： 0 &amp; 0 = 不进位 1 &amp; 0 = 不进位 0 &amp; 1 = 不进位 1 &amp; 1 = 进位 从上推到，可得： 位运算中，用“&lt;&lt;”表示向左移动一位，即“进位”，我么可以用以下表达式实现进位： （x&amp;y&lt;&lt;1 于是可以得到如下两个表达式： x^y //执行加法 （x&amp;y&lt;&lt;1 //进位操作 两位数的加法： 11+01=100 //实际的二进制算法 //推算表达式 11^01=10 11&amp;01&lt;&lt;1 = 10 由于不能使用加法，接着按上述算法计算： 10^10 =00 (10&amp;10)&lt;&lt;1=100 到此，就可以得出结论，总结如下定理： 定理一：设a，b位两个二进制数，则a+b=a^b+(a&amp;b)&lt;&lt;1 证明： a^b是不考虑进位的加法结果，当二进制位同时为1时，才有进位，因此(a&amp;b)&lt;&lt;1 是进位产生的值，称为进位补偿，将两者相加便是完整加法结果。定理二：利用定理一可以实现只用位运算进行加法运算。证明： 利用定理一中的等式不停对自身进行迭代，每迭代一次，进位补仓右边就多一位0，因此最多需要加数二进制位数长度次迭代，进为补偿就变为0，这时运算结束。 4、Python实现#不使用“+”来求两个数的和 def newadd(a, b): ta = a&amp;b tb = a^b while(ta): t_a = tb t_b = ta&lt;&lt;1 ta = t_a &amp; t_b tb = t_a ^ t_b print(&apos;a+b=&apos;, tb) if __name__ == &quot;__main__&quot;: newadd(4,5) &apos;&apos;&apos; 计算过程： a = 100 //4 b = 101 //5 ta = 100 //4 tb = 001 //1 进入循环循环 t_a = 001 t_b = 1000 //8 ta = 0000 //0 tb = 1001 //9 退出循环&apos;&apos;&apos; 转自：http://t.pae.baidu.com/s?s=bai-paallr]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开发工具调试]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[小程序开发过程中，调试是让程序跑起来的关键。第一步：点击调试器 第二步：点击sources 第三步：在目录中找到需要调试的js文件，打开图中文件，注意不是后缀为js的文件，而是js？[sm]的文件 第四步： 在文件中设置断点将鼠标移到文件最左侧，点击即可设置断点 快捷键ctrl+b进入调试第五步：点击红色箭头按钮，继续执行到下一个断点点击蓝色按钮，继续执行&lt;/r.点击黄色按钮，单步调试 第六步：查看变量值方法一： 鼠标放在变量上，即可显示变量值 方法二：在调试器窗口，点开Scope标签，然后再点开相应变量 方法三：使用console.log(options);打印出来，在console窗口可以查看]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django简介（一）]]></title>
    <url>%2F2018%2F08%2F16%2FDjango%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django是使用Python开发的开源Web开发框架。使用Django，你能以最小的代价构建和维护高质量的Web应用。 使用Django的原因： Django诞生于新闻网站的环境中，它所提供的特性非常适合开发内容类的网站（例如：博客，交流社区，图片分享站等等……）。因为Django是在快节奏的新闻编辑环境中开发的，它的设计目的是使常见的Web开发任务变得快速而简单。 Django是开源的，不是商业项目或者科研项目，它集中力量解决Web开发中所遇到的一系列问题。因此，Django每天都在现有的基础上进步，以适应不断更迭的开发需求。这样即节省了开发时间，也提高了后期维护的效率。 Django概览在Django建立网站的过程中，我分为3个Python文件（models.py, urls.py, views.py） 和HTML模板文件（template.html）来讲解。 设计模型ModelDjango无需数据库就可以使用，通过对象关系映射器（Object-relational mapping）,仅使用python代码就可以描述数据结构。 from django import models class book(models.Model): name = models.CharField(max_length=100) pud_date = models.DateField() models.py 文件主要用一个Python类来描述数据表。称为模型（model）。运用这个类，你可以通过简单的Python代码来创建、检索、更新、删除数据库中的记录而无需写一条由一条的SQL语句。在这里我们创建了一个book模型，并定义了name和pub_date属性。 设计视图views在模型定义之后，我们便可以在视图中引用模型，通常，根据视图参数检索数据，加载一个模板，并使用检索到的数据呈现模板。 form django.shortcuts import render from .models import Person def book_archive(request, year): book_list = Person.objects.filter(birth_year = year) content = {% raw %}{'year': year, 'book_list': book_list}{% endraw %} return render(request, &apos;books/year_archive.html&apos;, context) views.py文件包含了页面的业务逻辑。 book_archive()函数叫做视图。 这里还用到了year_archive.html模板。 设计链接URLs优雅简洁的Url解析式是衡量高品质网站的重要标准。Django鼓励使用漂亮的URL设计。使用这些优美的URL,只需要建立URL和Python回调函数简单的映射关系。 from django.urls import path from . import views ulrpatterns = [ path(&apos;book/&lt;int:year&gt;&apos;, views.year_archive) ] urls.py指出了什么样的 URL 调用什么视图。 在这个例子中books/xxxxx将会调用 year_archive()这个函数。也就是说，在进入这个链接时，会返回视图函数的结果。 设计模板Django拥有强大的模板功能，使用该模板能设计处强大的web页面 {% raw %} {%block title%}Books for {{year}}{%endblock%} {{%block content}} Articles for {{years}} {% for book in book_list %} {{book.name}} Published{{book.put_date | date: "F j, Y"}} {% endfor %} {% end block %} {% endraw %} year_archive.html是 html 模板。 使用带基本逻辑声明的模板语言，如{% for book in book_list %}，它试图将函数返回的结果显示在网页上。 Django的这种结构我们称之为MTV模式：M代表模型(Model)，T代表模板(Template)，V代表视图(View)。这三个分别代表了三种不同功能的Web应用，各司其职，又彼此合作。 转自：https://www.shiyanlou.com/courses/1127]]></content>
      <categories>
        <category>Python之Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git + TortoiseGit安装教程和环境部署]]></title>
    <url>%2F2018%2F08%2F15%2FGit%20%2B%20TortoiseGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对于程序员而言，版本管理是不可缺少的一部分，利用Gitlab或Github对代码进行管理大大提高的效率，本文介绍如何搭建环境。 工作模式： 生成公私钥对，将公钥部署到github上，然后利用保存在本地的私钥去连接github 第一步: 下载Git: https://git-scm.com/downloads 第二步： 下载TortoiseGit: https://tortoisegit.org/download/ 第三步： 安装以上两个软件，如果英语不ok的，可以安装tortoisegit语言包（简体中文语言包） 在安装TortoiseGit后，第一次配置时，选择语言 或者在TortoiseGit的设置进行设置，如下：首先鼠标右键，移到TortoiseGit上，点击Setting,进入如下页面，即可进行设置 第三步： 密钥生成及部署 在电脑搜索栏输入PuTTygen，打开软件 点击Generate 在红色方框内不停移动鼠标，10秒左右，进入如下页面： 点击Save private key,将私钥保存到本地： 点击是，并输入私钥文件名 接着将公钥填到Github或Gitlab中，这里以github为例，gitLab相同： 首页点击右上角的头像，并选择点击setting 然后点击 SSH Keys 接着点击创建一个ssh Key, 并将复制的公钥填入Key一栏中： 第四步： 利用本地的私钥去连接Github，并克隆（clone）代码包到本地 在需要存放代码的目录下，点击右键，并点击 git clone（git 克隆），进入如下页面： 根据图中指示填好，然后点击ok，即可将代码克隆到本地 其中的URL在Github上保存的代码包顶部地址 提交代码第一步： 右键点击 git commit 第二步： 右键点击 TortoiseGit,并点击push（推送）： 点击ok即可]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发前言]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[在这里，将介绍开发小程序的前期准备，和开发框架的了解 第一步 注册微信小程序账号：https://mp.weixin.qq.com/wxopen/waregister?action=step1 第二步 开发环境安装： https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18081317 第三步 小程序开发架构的了解，将是本文的重点 目录结构进入开发工具，可见如下图的目文件： utils中的文件处理全局配置pages下还有文件夹，每个文件夹对应一个页面，每个文件加下的文件管理对应的页面 app.json: 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等 project.config.json: 在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发 者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。 page.json: 可以独立定义每个页面的一些属性，例如顶部颜色、是否允许下拉刷新等等 wxml：相当于web开发中的html文件，用来描叙页面的结构 wxss: 相当于web开发中的css文件,兼容大部分css的特性 Js: 负责用户交互,响应用户的点击、获取用户的位置等等 分层 逻辑层：逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。 开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。视图层：框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示；将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN安装后无法连接到互联网]]></title>
    <url>%2F2018%2F08%2F13%2FVPN%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[VPN安装后无法连接到互联网问题解决方案赛风（psiphon）下载地址https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct 使用vpn时，出现浏览器无法连接到互联网问题解决： 原因是浏览器开启了局域网代理：]]></content>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN资源]]></title>
    <url>%2F2018%2F08%2F13%2FVPN%E8%B5%84%E6%BA%90md%2F</url>
    <content type="text"><![CDATA[VPN资源：赛风和兰灯 赛风：https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct 兰灯：http://pan.bcoderss.com/?dir=lan (包括安卓、windows、mac和linux端资源)]]></content>
      <tags>
        <tag>VPN</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机抓包软件：charles安装及教程]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%EF%BC%9Acharles%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[手机app或微信小程序开发过程中，解决数据传输过程中的问题，抓包软件必不可少 0、准备：电脑关闭防火墙、其他代理或者翻墙软件 1、安装最新版地址：charles 本教程使用v4.2.6 安装一路next即可 2、配置第一步： 查看本机IP 方法一：运行-&gt;输入cmd-&gt;在命令行中输入：ipconfig 方法二：在charles中点击Help-&gt;Local IP Adress 第一行为本地IP,后面两行为虚拟IP 第二步： 查看端口 第三步：手机上设置代理 安装证书 复制http://charlesproxy.com/getssl或http://www.charlesproxy.com/ssl.zip 到手机浏览器打开，点击 here 下载，安装，信任； 手机和电脑连接到同一局域网，在wifi中设置代理，ios如下： 电脑端弹出connction from “IP”,点击allow 第四步： 电脑端安装证书 点击help-&gt;SSL Proxying-&gt; install Charles root certificate 一路next即可安装 第五步：设置SSL代理 点击proxying-&gt;ssl proxying settings 点击Add 在host中填入：*通配符在port中填入：443 字段说明 Structure：树状结构显示，将网络请求按访问的域名分类； Sequence：水平结构显示，将网络请求按访问的时间排序 垃圾桶图标 ： 功能是clear，清理掉所有请求显示信息 Filter ： 过滤，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求 Overview ： 查看这次请求的详细内容，例如耗时详细列车了请求开始时间、结束时间，响应开始时间、结束时间，总耗时、DNS耗时、网络延时等。 对于Size也详细列出了请求头大小、响应头大小、压缩比例等内容。 URL：进行网络请求的链接； Status：当前状态，complete表示请求完成； Responce Code：返回码。不同的接口，不同的请求结果，返回码都不同； Protocol：使用的协议； Method：请求方式，如GET请求，POST请求等； Kept Alive：判断当前是否正在链接（活跃）； Content-Type:发送的内容类型，如这里用的是XML文本，以UTF8的方式发送； Client Address：客户端的IP地址； Remote Address：远程服务器的IP； Timing: Request Start Time：请求开始的时间； Request End Time：请求结束的时间； Response Start Time：返回开始的时间； Response End Time : 返回结束的时间； Duration : 总时间； Size: Request Header ：请求的头部大小； Response Header：返回的头部大小； Request : 请求发送的大小； Response：返回数据的大小； Total：所有数据大小； Request Compression : 请求压缩； Response Compression : 返回压缩； Request ： 查看请求内容（底下的Headers，Query String， Cookies，Raw。） Headers：发送请求的头部信息； Query String : 发送参数列表； Cookies： 浏览器缓存； Raw：发送的原生数据，包括了头部和参数； Reponse : 查看响应内容 Headers：是返回的头部信息； Text：返回信息（除去头部）后的文本； Hex：返回信息的16进制表示； XML：我返回的数据是XML。如果你返回的是JSON，这里就会显示JSON； XML Text：如果你返回JSON，这里会显示JSON Text； Raw：返回的所有原生数据，包括头部； Summary: 查看发送数据的一些简要信息（主机，状态码，数据的类型，header和body大下，加载时间，总时间） Chart: Summary中简要信息以图表形式展示 Notes: 其他信息 问题解决问题一You may need to configure your browser or application to trust the Charles Root Certificate由于手机虽然安装了证书，但是未信任 解决方案：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 转自：更多详细内容见此]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>手机抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim教程]]></title>
    <url>%2F2018%2F08%2F13%2FVim%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文介绍linux中的编辑器vim操作,以及基本命令操作 Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式： 普通模式(Normal mode) 在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。 Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。 插入模式(Insert mode) 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。 在插入模式中，可以按ESC键回到普通模式。 可视模式(Visual mode)这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。 选择模式(Select mode)这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。 命令行模式(Command line mode)在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 Ex模式(Ex mode)这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。 这其中我们常用到就是普通模式、插入模式和命令 vim 文件名 //如果文件名不存在，会自动创建文件并打开 vim nginx.conf //进入普通模式 a 或 i //进入插入模式 Esc //退出插入模式，进入普通模式 ： //退出普通模式，进入命令行模式 命令行模式下： wq保存退出 游标移动按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右（小写L） j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 从普通模式进入插入模式按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右（小写L） j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 保存文件:w 文件名 //可以将文档另存为其他文件名或存到其它路径下 :w //保存文件 :w test //另存为test文件 退出vim命令行模式下退出vim从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑 以下为其它几种退出方式： 命令 说明 :q! 强制退出，不保存 :q 退出 :wq! 强制保存并退出 :w &lt;文件路径&gt; 另存为 :saveas 文件路径 另存为 :x 保存并退出 :wq 保存并退出 普通模式下退出vim普通模式下输入Shift+zz即可保存退出vim 普通模式下删除vim文本信息进入普通模式，使用下列命令可以进行文本快速删除： 命令 说明 x 删除游标所在的字符 X 删除游标所在前一个字符 Delete 同x dd 删除整行 dw 删除一个单词（不适用中文） d$或D 删除至行尾 d^ 删除至行首 dG 删除到文档结尾处 d1G 删至文档首部 vim重复命令（普通模式下）. 表示重复执行上次命令 //向输入x删除第一个字符，再输入.接着删除一个字符 10x 表示删除10连续个字符 3dd 表示删除3行文本 dw或daw 删除一个单词 dNw 删除N个单词 #游标快速跳转 行间跳转. 命令 说明 nG(n Shift+g) 游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号) gg 游标移动到到第一行 G(Shift+g) 到最后一行 行内跳转 命令 说明 w 到下一个单词的开头 e 到当前单词的结尾 b 到前一个单词的开头 ge 到前一个单词的结尾 0或^ 到行头 $ 到行尾 f&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用) F&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配的位置 t&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用) T&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用) 复制粘贴和剪切复制及粘贴普通模式中使用y复制 普通模式中，yy复制游标所在的整行（3yy表示复制3行） 普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。 普通模式中，y$ 复制至行尾。含光标所在处字符。 普通模式中，yw 复制一个单词。 普通模式中，y2w 复制两个单词。 普通模式中，yG 复制至文本末。 普通模式中，y1G 复制至文本开头。 普通模式中使用 p 粘贴 普通模式中，p(小写)代表粘贴至光标后（下）普通模式中，P(大写)代表粘贴至光标前（上） 剪切及粘贴dd删除命令其实是剪切，每次dd删除文档内容后，使用p来粘贴，这样可以实现—-交换上下行 查找替换字符的替换及撤销操作 命令 说明 r+&lt;待替换字母&gt; 将游标所在字母替换为指定字母 R 连续替换，直到按下Esc cc 替换整行，即删除游标所在行，并进入插入模式 cw 替换一个单词，即删除一个单词，并进入插入模式 C(大写) 替换游标以后至行末 ~ 反转游标所在字母大小写 u{n} 撤销一次或n次操作 U(大写) 撤销当前行的所有修改 Ctrl+r redo，即撤销undo的操作 快速缩进普通模式下操作 &gt;&gt; 整行向右缩进 &lt;&lt; 整行向左回退 普通模式下，对shftwidth值进行设置，可以控制缩进和回退e字符数 :set shiftwidth? //查看当前缩进字符数 :set shiftwidth=10 //设置缩进字符数为10 shiftwidthn可以简写为sw 调整文本位置命令行模式下，操作光标所在的行 :ce //本行内容剧中 :ri //本行内容靠右 :le //本行内容靠左 查找普通模式下，输入 /, 然后输入需要查找的字符串，按回车即可进行查找。 ? 功能与 / 功能相同，只不过 ?向下查找。进入查找之后，在字符串之后输入n和N 可以继续查找，n表示继续查找，N表示方向查找 高级查找普通模式下输入*寻找游标所在处的单词普通模式下输入#同上，但 # 是向前（上）找，*则是向后（下）找普通模式下输入g*同* ，但部分符合该单词即可普通模式下输入g#同# ，但部分符合该单词即可 高级功能多文件编辑vim编辑多个文件vim 1.txt 2.txt 默认进入1.txt文件的编辑界面 命令行模式下输入 :n 编辑 2.txt 文件，可以加 ! 即 :n! 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件 命令行模式下输入 :N 编辑 1.txt 文件，可以加! 即 :N! 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件 进入vim后打开新文件 命令行模式下输入:e 3.txt 打开新文件3.txt 命令行模式下输入:e#回到前一个文件 命令行模式下输入:ls可以列出以前编辑过的文档 命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑 命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目 命令行模式下输入:e! 4.txt，新打开文件4.txt，放弃正在编辑的文件 命令行模式下输入:f 显示正在编辑的文件名 命令行模式下输入:f new.txt，改变正在编辑的文件名字为new.txt 恢复文件如果因为断电等原因造成文档没有保存，可以采用恢复方式，vim -r进入文档后，输入:ewcover 1.txt来恢复 vim -r 1.txt 可视模式可视模式命令简介 在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。 在普通模式下输入 Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取。 在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取。 在可视模式下输入 d 删除选取区域内容在可视模式下输入y复制选取区域内容可视模式命令练习 在普通模式下9G跳转到第9行,输入Shift+v（小写V），进入可视模式进行行选择，选中5行，按下&gt;&gt;缩进，将5行整体缩进一个shiftwidth 在普通模式下输入 Ctrl+v（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后x删除整列 视窗操作vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入 :new 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 Ctrl+w也可以），除了 :new 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗： 注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。 命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt 命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt 普通模式下Ctrl+w s 将当前窗口分割成两个水平的窗口 普通模式下Ctrl+w v 将当前窗口分割成两个垂直的窗口 普通模式下Ctrl+w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q! 普通模式下Ctrl+w o 打开一个视窗并且隐藏之前的所有视窗 普通模式下Ctrl+w j 移至下面视窗 普通模式下Ctrl+w k 移至上面视窗 普通模式下Ctrl+w h 移至左边视窗 普通模式下Ctrl+w l 移至右边视窗 普通模式下Ctrl+w J 将当前视窗移至下面 普通模式下Ctrl+w K 将当前视窗移至上面 普通模式下Ctrl+w H 将当前视窗移至左边 普通模式下Ctrl+w L 将当前视窗移至右边 普通模式下Ctrl+w 减小视窗的高度 普通模式下Ctrl+w + 增加视窗的高度 创建加密文档vim -x nginx.conf 根据提示输入密码，下次打开文件时，需要输入密码 vim执行外部命令在命令行模式中输入!可以执行外部的shell命令 :!ls 用于显示当前目录的内容 :!rm FILENAME用于删除名为 FILENAME 的文件 :w FILENAME可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件 vim中查看帮助 普通模式下按F1打开vim自己预设的帮助文档 命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件 命令行模式下输入:ver 显示版本及参数 功能设定vim的功能设定可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用 获取目前的设定 命令行模式下输入:set或者:se显示所有修改过的配置 命令行模式下输入:set all 显示所有的设定值 命令行模式下输入:set option? 显示option的设定值 命令行模式下输入:set nooption 取消当前设定值set功能的说明 命令行模式下输入:set autoindent(ai) 设置自动缩进 命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开 命令行模式下输入:set background=dark或light，设置背景风格 命令行模式下输入:set backup(bk) 设置自动备份，默认未打开 命令行模式下输入: set cindent(cin) 设置C语言风格缩进-以上内容来自https://www.shiyanlou.com/courses/2，为作者边学习，边摘抄和总计的内容]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown教程]]></title>
    <url>%2F2018%2F08%2F12%2FMarkdown%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Markdown安装，升级，以及语法介绍 升级Pro版本邮箱地址：Soar360@live.com 授权秘钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVp bP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vV y4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/ QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnx t1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 作者：hecatonchires链接：https://www.jianshu.com/p/8a1bd4892291來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 来自：https://www.jianshu.com/p/8a1bd4892291 语法常用语法开启数学公式： mathjax: true 在文章中显示$\ast$: $\ast$ 前提在开启数学公式。 本文居中&lt;center&gt;成员名和参数名&lt;/center&gt; 文本加粗__加粗__ 或者 **加粗** 第二种加粗方式可能不起作用，所以建议使用第一种。 标题支持六级标题 # 一级标题 ## 二级标题 ### 三级标题 注意：#之后必须加一个空格，当然有些编辑器不用，但最后还是添加 字体设置&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;内容填写在这里&lt;/font&gt; 效果：内容填写在这里 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考[Github][2]. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 &gt; 代码块代码块语法遵循标准markdown代码，例如： 12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见[math.stackexchange.com][1]. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 [这儿][3]. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 [这儿][4], 关于 流程图 语法，参考 [这儿][5]. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入 数学公式语法转：https://www.jianshu.com/p/a0aa94ef8ab2 https://blog.csdn.net/yzr1183739890/article/details/64130912:花括号 https://blog.csdn.net/smstong/article/details/44340637#3-csdn-markdown%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%BE%93%E5%85%A5%E6%95%99%E7%A8%8B https://blog.csdn.net/huanhuan_Coder/article/details/79325071 其他语法转自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件系统操作与磁盘管理]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[df,du,mount命令的使用，以及磁盘相关知识学习。 查看磁盘和目录的容量df dev/sda1：是对应这主力硬盘的分区，后面的数字表示分区号，数字前面的字母a表示第几块硬盘（也可能是可移动磁盘）。如果主机上有多快磁盘，可能会出现/dev/sdb,/dev/sdc，这些磁盘设备都会放在/dev目录下以文件的存在形式。 1k.块：表示磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用容量和可用容量。 接下来的命令，显示结果一目了然： df -h du查看目录容量du //默认以块的大小展示 du -h //以更易读的方式展示 -d参数指定查看目录的深度 du -h -d 0 ~ //只查看1级目录的深度 du -h -d 1 ~ //查看2级 常用参数： du -h //以k,M,G为单位，提高信息的可读性 du -a //同-aall,显示目录中所有文件的大小 du s //同–summarize 仅仅显示终极，只列出最后加总的值 下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作 创建虚拟磁盘dd命令简介 dd命令用于转换和复制文件，不过它的复制不同于cp。Linux中，一切即文件，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，主持在各自的驱动程序中实现了对应的功能，dd也可以读取文件或写入这些文件。于是dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在ASCII与EBCDIC编码间互换。 dd命令行语句与其他的Linux程序不同，因为它的命令选项格式为选项=值，而不是标准的--选项 值或-选项=值。dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file输入文件）和of(output file输出文件)改变。 //输出到文件 dd of=test bs=10 count=1 dd if=/dev/stdin of=test bs=10 count=1 //输出到标准输出 dd if=/dev/stdin of=/dev/stdout bs=10 count=1 //在打完这个命令后，继续在终端打字，作为你的输入 上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。 dd在拷贝的同时可以实现数据转换，例子：将输出的英文字符转换为大写在输入文件： dd if=/dev/stdin of=test bs=10 count=1 conv=ucase dd命令创建虚拟镜像文件 dd完成创建虚拟磁盘的步骤第一步:从/dev/zero设置创建一个容量为265M的空文件 dd if=/dev/zero of=virtual.img bs=1M count=256 du -h virtual.img 第二步：将上述创建文件格式化（写入文件系统） 使用mkfs命令格式化磁盘 可以在命令行输入sudo mkfs 然后按下tab键，可以看到多个以mkfs为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。 sudo mkfs.ext4 virtual.img ext4：EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。 第三步： 使用count命令挂载磁盘到目录树 用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。 Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。 查看主机已经挂载的文件系统： sudo mount 输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。 挂在磁盘到目录树,mount命令的一般格式为: mount 【optons】 [source] [directory] 以下常用操作： mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro[文件系统源]]] [挂载点] 将创建的磁盘镜像挂载到/mnt目录： mount -o loop -t ext4 virtual.img /mnt //也可以省略挂载类型，很多时候 mount 会自动识别 /以只读方式挂载 mount -o loop --ro virtual.img /mnt //或者mount -o loop,ro virtual.img /mnt 使用umount命令卸载已挂载磁盘 命令格式 sudo umount 已挂载设备名或者挂载点，如： sudo umount /mnt fdisk为磁盘分区 查看磁盘分区表信息 sudo fdisk -l sudo fdisk virtual.img m：为帮助手册 n: 创建新分区，接着输入分区号，分区起始和结尾，两个相减为分区大小 w: 写入新建分区 p: 查看现有分区]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux介绍]]></title>
    <url>%2F2018%2F08%2F11%2FLinux%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Liunx支持多用户登陆，共享一些主机的资源,但他们也分别有自己的用户空间,用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但是由于 Linux 的 用户管理 和 权限机制，不同用户不可以轻易地查看、修改彼此的文件。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用的压缩/解压工具：zip和tar]]></title>
    <url>%2F2018%2F08%2F11%2FLinux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7zip%E5%92%8Ctar%2F</url>
    <content type="text"><![CDATA[知识点：zip命令、tar命令、压缩与解压常用组合 常用压缩包格式 文件后缀名 说明 *.zip zip 程序打包压缩的文件 *.rar rar 程序压缩的文件 *.7z 7zip 程序压缩的文件 *.tar tar 程序打包，未压缩的文件 *.gz gzip 程序（GNU zip）压缩的文件 *.xz xz 程序压缩的文件 *.bz2 bzip2 程序压缩的文件 *.tar.gz tar 打包，gzip 程序压缩的文件 *.tar.xz tar 打包，xz 程序压缩的文件 *tar.bz2 tar 打包，bzip2 程序压缩的文件 *.tar.7z tar 打包，7z 程序压缩的文件 zip压缩zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop 将Desktop目录下的子文件打包成shiyanlou.zip压缩文件，-r表示递归打包包含子目录的全部内容，-q表示安静模式，不向屏幕显示内容，-o表示输出文件，须在其后紧跟打包输出文件名（shiyanlou.zip）。 du -h shiyanlou.zip du命令查看打包文件的大小。-h表示文件大小可读，-d表示查看所查文件的深度，打印在屏幕上。 加密创建zip包：使用-e参数 zip -r -e -o shiyanlou_e.zip /home/shiyanlou/Desktop 跟着屏幕提示输入密码 注意：： 关于zip命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改： zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop unzip解压zip文件unzip shiyanlou.zip u使用安静模式,将文件解压到指定目录： unzip -q shiyanlou.zip -d ziptest 上述目录不存在，将会自动创建，如果不想解压只想查看压缩包的内容，可以使用-l参数： unzip -l shiyanlou.zip 注意：中文的兼容性问题，windows系统创建的压缩文件，如果有中文文档或文件名为中文，默认采用GBK或其他编码，而Linux上默认使用的是UTF-8编码。 使用-o参数指定编码类型： unzip -o GBK 中文压缩文件.zip tar打包工具tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。 创建一个tar包： tar -cf shiyanlou.tar home/shiyanlou/Desktop 不能使用相对路径，不然会提示图中问题 上面命令中，-c表示创建一个tar包文件，-f用户指定创建的文件，注意文件名必须紧跟在-f参数之后，比如不能写出tar -fc shiiyanlou.tar,可以写成tar -f shiyanlou.tar -c。-v参数以可视的方式输出打包的文件， 解压一个tar包：解压参数：-x指定已存在的目录： -C tar -xf shiyanlou.tar -C tardir 只查看不解包文件：参数： -t tar -tf shiyanlou.tar 保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（-p 参数）和备份链接指向的源文件而不是链接本身（-h 参数）： tar -cphf etc.tar /etc 使用gzip来压缩文件 添加-z参数 tar -czf shiyanlou.tar.gz home/shiyanlou/Desktop 解压*.tar.gz文件 tar -xzf shiyanlou.tar.gz 要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可： 压缩文件格式 参数 *.tar.gz -z *.tar.xz -J *tar.bz2 -j tar 命令的参数很多，不过常用的就是上述这些，需要了解更多你可以查看 man 手册获取帮助。 总结常用命令： zip： 打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数 tar： 打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数]]></content>
      <categories>
        <category>实验楼学习笔记之Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建属于自己的博客]]></title>
    <url>%2F2018%2F08%2F11%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文将介绍利用Hexo搭建博客的教程，包括其中遇到问题的解决方案，包括：添加域名等等内容，本人亲自实践过，希望对您有所帮助，如果遇到其他问题，可联系本人。 准备：Git：https://git-scm.com/downloads Nodejs:https://nodejs.org/en/ Github账号，并创建新仓库 新建仓库如下： 安装Nodejs：一路next即可 安装git安装一路next，重点在配置 首先将安装目录添加进环境变量 然后设置用户名和邮箱 $ git config --global user.name &quot;John Doe&quot; $ git config --global user.email johndoe@example.com 安装hexo在所要存放博客文件的文件夹下右键，点击git bash 输入如下命令： npm install -g hexo-cli 创建hexo文件夹hexo init 安装依赖依赖包npm install 站点配置在博客目录下找到_config.yml,修改如下内容在修改配置文件时，建议使用Notepad++进行编辑，原因是缩进和空格会影响代码能否成功提交 # Site title: 平步青云win subtitle: description: 建站 Linux Python C++ 编程语言 keywords: 建站 Linux Python C++ 编程语言 author: zxp language: zh-Hans timezone: deploy: type: git repository: https://github.com/zxpgo/blog.git# 博客仓库地址 #repository: https://github.com/xxx/xxx.github.io.git 博客仓库地址见本文开头第二张图片内的地址 注意：：之后必须添加一个空格再添加内容 否则会有如下错误： 发布博客hexo new &quot;文章名字&quot; 本地站点生成生成文件hexo g 显示如下信息，表示成功 启动服务hexo s 显示如下信息，表示成功： 到此本地的配置结束 打开浏览器，输入localhost:4000查看 部署Githubhexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。（个人习惯，非必需） hexo g #生成静态文件，每次改动之后都需要执行以下这个命令。 hexo d #这个才是真正的部署命令，这里用的都是简写形式 问题一运行时出错，由于还没有添加sshkey，具体教程如下：打开Git Bash 设置Git的user name和email：（前面以及设置） git config --global user.name &quot;aqiongbei&quot; #改成你的注册Github的用户名 git config --global user.email &quot;aqiongbei@gmail.com&quot; #改成你的注册Github的邮箱 生成SSH密钥：生存密钥： ssh-keygen -t rsa -C &quot;aqiongbei@gmail.com&quot; #改成你注册Github的邮箱 返回提示如下： 然后会提示，不用理，直接按回车，一共三次。在C:\Users\Neckpain.ssh得到 id_rsa 和 id_rsa.pub 文件，说明生成成功 添加密钥到 Github打开 Github，登录自己的账号后点击自己的头像-&gt;settings-&gt;SSH Keys-&gt;Add SSH key将本地 id_rsa.pub 中的内容粘贴到 Key 文本框中，随意输入一个 title，点击 Add Key 即可。 测试Git里面继续输入 ssh -T git@github.com 返回 则说明验证成功。 问题一ERROR Deployer not found: git 解决方案如下： npm install --save hexo-deployer-git 添加域名首先购买域名，博主在阿里云购买，记得实名认证 首先在域名控制台添加记录， 记录一般添加两条，具体如下: 其中的ip通过ping命令获取github服务器ip,其中仓库的URL为： github&apos;用户名&apos;.github.io 具体可见下图： 然后在github的博客代码处添加一个CNMAE文件，不要后缀，或者在本地的source文件（所有提交的文件都放在该目录下）中添加该文件，并提交， 内容为申请的域名 www.zxpblog.cn zxpblog.cn 最后还得在setting中的Custom domain处添加域名，必须加www, 如下 主题修改在本地博客目录下打开git bash git clone https://github.com/iissnan/hexo-theme-next themes/next 在_config.yml中找到theme修改为下载的主题名 重新部署到github即可 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 底部添加访问量统计部分主题自带访问量统计，不用配置打开\themes\主题名字\layout_partials\footer.swig文件,不同具体footer文件的后缀可能不同，在顶部添加如下代码： &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 接着在合适的地方添加需要显示的统计数字代码（同上文件）： &lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; 两种统计方式： 同一用户连续点击n篇文章，记录n次访问量 本站总访问量次 同一用户连续点击n篇文章，记录1次访问量 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次 添加RSS首先安装 hexo-generator-feed包 npm install hexo-generator-feed 在配置文件中添加如下代码： #RSS配置 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: content_limit_delim: &apos; &apos; 主题不同，添加方式可能不同，NEXT主题 _CONFIG.YML文件中有个 RSS的配置，直接设置为 TRUE就可以了 Yelee主题http://moxfive.coding.me/yelee/ Hexo中的Yelee主题，首页不显示文章摘要转自：https://blog.csdn.net/youshaoduo/article/details/78709160 首页显示文章摘要方法一：在需要显示的摘要之后添加如下代码： &lt;!--more--&gt; 方法二： 自动截取方法转自：https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/ 添加文章访问量统计themes\yelee\layout_partial\footer.ejs中添加如下代码： &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 在article.ejs中&lt;%- partial(‘post/tag’) %&gt;后添加如下代码： &lt;span id=&quot;busuanzi_container_page_pv&quot; style =&quot;display:block&quot;&gt; |阅读量(&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;) &lt;/span&gt; 在theme/source/css/style.styl文件中设置格式 #busuanzi_container_page_pv {display:block !important; padding-top:4px; color: #bebebe; //margin-left:200px; } 问题系列：出现Template render error：（unknown path）问题描述在使用hexo g生成文章的时候，报错如下: ATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) unexpected end of file 问题原因当文章中有}}时,且这两个括号未被代码块包含，解析会出问题 解决方法{% raw %} 含有双大括号的内容 {% endraw %} 转自：https://www.jianshu.com/p/738ebe02029b]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
