<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python2.7和Python3.6安装以及文件解决</title>
      <link href="/2019/08/22/python2.7%E5%92%8Cpython3.6%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/22/python2.7%E5%92%8Cpython3.6%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<h2 id="Python2-7和Python3-6并存"><a href="#Python2-7和Python3-6并存" class="headerlink" title="Python2.7和Python3.6并存"></a>Python2.7和Python3.6并存</h2><p>在环境变量中添加Python两个版本的值即可，具体如下：</p><p>右键我的电脑，按下图操作：<br><img src="https://i.imgur.com/XR3VI7D.png" alt=""></p><p>添加值：</p><p><img src="https://i.imgur.com/85ex4wA.png" alt=""></p><p>在环境变量中添加：</p><pre><code>C:\Python27C:\Python27\Scripts    C:\Python36C:\Python36\Scripts</code></pre><p>打开CMD,切换Python2.7和Python3.6</p><pre><code>py -2 切换至python2.7py -3 </code></pre><p><img src="https://i.imgur.com/LtX3Wxy.png" alt=""></p><p>Ctrl+C或 输入<code>exit()</code>退出Python环境</p><p>在具体py文件中，使用</p><pre><code>#! python2# coding: utf-8</code></pre><p>可以指定解释器版本，这时只需py test.py，无需带-2或-3这种参数</p><h2 id="IDLE打开方式"><a href="#IDLE打开方式" class="headerlink" title="IDLE打开方式"></a>IDLE打开方式</h2><p>可以尝试在搜索栏中输入IDLE，然后双击，如果找不到，尝试如下方法：<br>找到<code>C:\Python27\Lib\idlelib</code>下的<code>idle.bat</code>文件，双击即可打开IDLE</p><h2 id="Python2-7的IDLE无法打开问题解决"><a href="#Python2-7的IDLE无法打开问题解决" class="headerlink" title="Python2.7的IDLE无法打开问题解决"></a>Python2.7的IDLE无法打开问题解决</h2><p>打开运行，输入如下代码：</p><pre><code>%USERPROFILE%\.idlerc</code></pre><p>会自动大量如下文件夹：</p><p><img src="https://i.imgur.com/9YIypTY.png" alt=""></p><p>删除文件夹中的三个文件</p><h2 id="pip安装第三方库"><a href="#pip安装第三方库" class="headerlink" title="pip安装第三方库"></a>pip安装第三方库</h2><pre><code>pip2.7 install numpy#仅为python2.7安装numpy库pip3.6 install numpy#仅为python3.6安装numpy库</code></pre><p><img src="https://i.imgur.com/I9XDzyO.png" alt=""></p><p>第三方库安装目录：<code>C:\Python27\Lib\site-packages</code></p>]]></content>
      
      
        <tags>
            
            <tag> -Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python实现：8种排序算法</title>
      <link href="/2019/08/22/Python%E5%AE%9E%E7%8E%B08%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/22/Python%E5%AE%9E%E7%8E%B08%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>介绍8中排序算法，包括算法的基本思路和算法的python实现。<a id="more"></a></p><ul><li>选择排序-简单选择排序</li><li>选择排序-堆排序</li><li>插入排序-直接插入排序</li><li>插入排序-希尔排序</li><li>交换排序-快速排序</li><li>交换排序-冒泡排序</li><li>归并排序</li><li>桶排序/基数排序</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>每一趟从待排序的数据元素中选出最小（最大）的元素，顺序放在待排序的数列最前，直到全部待排序的数据元素全部排完。</p><p>例子：<br><br>[4, 2, 3] 找出最小的：2,与第一个元素交换<br><br>[2, 4, 3] 找出最小的：3，与第二个元素交换<br><br>[2, 3, 4] <br></p><p>百度百科： <a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">简单选择排序</a></p><p><strong>算法实现</strong></p><pre><code>def j_sort(a):      l = len(a)      temp = 0      for j in range(0,l-1):            count = j  #记录最小元素下标            #每次找出最小元素            for i in range(j,l-1):                  if a[count] &gt; a[i+1]:                        count = i+1            #交换最小元素和待排序元素中最前一个            &apos;&apos;&apos;if count != j:                  temp = a[j]                  a[j] = a[count]                  a[count] = temp &apos;&apos;&apos;            a[j], a[count] = a[count], a[j] #实现跟上述代码一样      for i in range(0,l):            print(a[i])if __name__ == &quot;__main__&quot;:      a = [10, 2, 5, 1, 3, 7, 3]      j_sort(a)</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong><br><br>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p><p><img src="https://i.imgur.com/JpLbFCa.png" alt=""></p><p>转自：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">堆排序</a></p><p><strong>算法实现</strong></p><pre><code>def d_sort(arr):      l = len(arr)      for i in range(int(l/2-1), -1, -1):            adjustHead(arr,i,l)      # 交换堆顶和最后一个元素，并调整堆结构      for j in range(l-1, 0, -1):            arr[0], arr[j] = arr[j], arr[0] #将堆顶元素和末尾元素进行交换            adjustHead(arr, 0, j) #重新对对进行调整      for k in range(0,l):            print(arr[k])#构造大顶堆            def adjustHead(a, i, l):      temp = a[i] #取出当前元素      k = 2*i + 1 #从左子节点开始，即2*i+1      while k &lt; l:            if k+1 &lt; l &amp; a[k] &lt; a[k+1]: #若果左子节点小于右子节点，k指向右子节点                  k=k+1            if a[k] &gt; temp: #如果子节点大于父节点，将子节点赋值给父节点，并将子节点下标记录下来，后面将父节点值赋值给该子节点                  a[i] = a[k]                  i = k            else:                  break            k = 2*k + 1 #把该节点当作父节点，继续操作      a[i] = temp #将父节点值赋值给该子节点if __name__ == &quot;__main__&quot;:      a = [10,2,4,5]      d_sort(a)</code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序思想：每一趟将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素的适当位置上，直到所有待排序元素元素全部插入为止</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序是假定前i个构成的子序列是处于已排序的情况下进行排序的，然后将第i个元素与前i个构成的子序列逆序进行比较，如果是要升序排序，则比较第i个元素是否比j=i-1(i-1需要&gt;=0)的元素大，如果是则第i个元素的位置（即j+1的位置上）保持不动，反之则将j=i-1的元素放置到i的位置，再进行第i个元素与j=i-2(i-2需要&gt;=0)的,依次进行，如果第i个元素刚好比j=i-3大，则将第i个元素插入到j=i-2（即j+1的位置）上！</p><p>百度百科： <a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">直接插入排序</a></p><p><strong>算法实现</strong></p><pre><code>def zc_sort(a):      l = len(a)      j=0      for i in range(1,l):            temp = a[i]            for j in range(i-1, -1, -1):                  if  temp &lt; a[j]:  #如果第i个元素大于前i个元素中的第j个                        a[j+1] = a[j] #则第j个元素先后移1位                  else:   #如果第i个元素小于等于前i个元素中的第j个则结束循环                        break            a[j+1] = temp #将i个元素赋值给空着的位置      for i in range(0,l):            print(a[i])if __name__ == &quot;__main__&quot;:      a = [1, 10, 5, 2, 6, 7, 2]      zc_sort(a)</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>转自：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">希尔排序</a></p><p><strong>算法实现</strong></p><pre><code>def shell_sort(a):     l = int(len(a)/2)     #生成增量列表     gap_list = []     while l &gt; 0:          gap_list.append(l)          l = int(l/2)     print(gap_list)     for gap in gap_list:#增量gap，并逐步缩小增量           #print(gap)          for i in range(gap, len(a)):#从第gap个元素，逐个对其所在组进行直接插入排序操作               j = i               while j -gap &gt;= 0 and a[j-gap] &gt; a[j]:                    swap(a, j, j-gap)  #交换两个元素                    j = j - gap     for i in range(0,len(a)):          print(a[i])def swap(arr, a, b):     arr[a] = arr[a] + arr[b]     arr[b] = arr[a] - arr[b]     arr[a] = arr[a] - arr[b]if __name__== &quot;__main__&quot;:      a = [1,0,4,-1,2,7,9,8,10, 3,6,5,18]      shell_sort(a)</code></pre><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br><br>一趟快速排序的算法是：<br><br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br><br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0];<br><br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br><br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br><br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><p><strong>注意：快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</strong></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;fromid=2084344" target="_blank" rel="noopener">快速排序</a></p><p><strong>算法实现</strong><br>递归</p><pre><code>def quick_sort(arr, low, high):     #temp = a[0]     i = low     j = high     if i &gt;= j:          return arr     temp = arr[i]     while i &lt; j:          while i &lt; j and arr[j] &gt;= temp:               j = j-1          arr[i] = arr[j]          while i &lt; j and arr[i] &lt;= temp:               i = i + 1          arr[j] = arr[i]     arr[i] = temp     quick_sort(arr, low, i-1)     quick_sort(arr, j+1, high)     return arrif __name__ == &quot;__main__&quot;:     a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8]     quick_sort(a, 0, len(a)-1)     print(a)</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序算法的原理如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ul><p>百度百科： <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">冒泡排序</a></p><pre><code>def bubble_sort(arr):     length = len(arr)     while length &gt; 0:             for i in range(length-1):               if arr[i] &gt; a[i+1]:                    arr[i] = arr[i] + arr[i+1]                    arr[i+1] = arr[i] - arr[i+1]                    arr[i] = arr[i] - arr[i+1]          length -= 1if __name__ == &quot;__main__&quot;:     a = [10, 3, -3, 6, 0, 1, 4, 5, 11, 8]     bubble_sort(a)     print(a)</code></pre><h1 id="归并排序（递归）"><a href="#归并排序（递归）" class="headerlink" title="归并排序（递归）"></a>归并排序（递归）</h1><p>本文中的<strong>快速排序</strong>就是一种递归排序<br><br>先递归，在排序<br>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p><p>解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？</p><p>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><p>转自：<a href="https://www.cnblogs.com/lulushow/p/6820727.html" target="_blank" rel="noopener">https://www.cnblogs.com/lulushow/p/6820727.html</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015" target="_blank" rel="noopener">归并排序</a></p><p><strong>算法实现</strong></p><pre><code>def Merge_Sort(lists):    if len(lists) &lt;= 1:        return lists    num = int(len(lists)/2)    left = Merge_Sort(lists[:num]) #将列表从中间分为两部分    right = Merge_Sort(lists[num:])    return Merge(left, right) #合并两个列表def Merge(left,right):    r, l=0, 0    result=[]    while l&lt;len(left) and r&lt;len(right):        if left[l] &lt; right[r]:            result.append(left[l])            l += 1        else:            result.append(right[r])            r += 1    result += left[l:]    result += right[r:]    return resultif __name__ == &quot;__main__&quot;:     a = [10, 7, 4, 2, 8, 5, 1, 3]     a = Merge_Sort(a)     print(a)</code></pre><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序又称为“桶子法”，从低位开始将待排序的数按照这一位的值放到相应的编号为0~9的桶中。等到低位排完得到一个子序列，再将这个序列按照次低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。</p><p><img src="https://i.imgur.com/XVIjAFa.jpg" alt=""></p><p>转：<a href="https://blog.csdn.net/double_happiness/article/details/72452243" target="_blank" rel="noopener">https://blog.csdn.net/double_happiness/article/details/72452243</a></p><p>百度百科： <a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin" target="_blank" rel="noopener">基数排序</a></p><p><strong>算法实现</strong></p><pre><code>import mathdef radix_sort(arr):     radix = 10 #基数     k = int(math.ceil(math.log(max(arr),radix)))#k可以表示任意整数     #math.log对arr中最大的数取对数，log(max(arr),10),并对其取整得到最大值的位数     bucket =[[] for i in range(radix)]      for i in range(1, k+1):           for  value in arr:               bucket[int(value%(radix**i)/(radix**(i-1)))].append(value) #析取整数第k位数字（从低到高）10**2位10的二次方          del arr[:]          for each in bucket:               arr.extend(each) #桶合并          bucket = [[]for i in range(radix)]if __name__ == &quot;__main__&quot;:     a = [10, 2, 13, 44, 22, 33, 100, 612, 333, 262]     radix_sort(a)     print(a)</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python2.x和Python3.x的版本区别</title>
      <link href="/2019/08/22/python2.x%E5%92%8Cpython3.x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/22/python2.x%E5%92%8Cpython3.x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>Python 3.0在设计的时候没有考虑向下相容。许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。&lt;！–more–&gt;</p><p>为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。</p><p>目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。</p><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>python 3.0 中使用print()函数来输出，而不再使用print语句。</p><pre><code>print(&quot;zxp&quot;) #python3.0print &quot;zxp&quot; #python3.0不再支持</code></pre><p>在python2.6和python2.7中，三种形式等价：</p><pre><code>print(&quot;zxp&quot;)# print不能带任何参数print (&quot;zxp&quot;) #print后有空格print &quot;zxp&quot;</code></pre><p>python2.6实际已经支持print()语法：</p><pre><code>seq = &apos;hello&apos;print(&apos;zxp&apos;,&apos;panda&apos;,seq)</code></pre><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>python2中有ASCII str()类型，unicode()是单独的，不是byte类型。<a id="more"></a><br>python3中有Unicode(utf-8)字符串，以及一个字节类：byte和bytearrays。</p><p>python3.x源码文件默认使用utf-8:</p><pre><code>&gt;&gt;&gt;中国 = “china”&gt;&gt;&gt;print(中国)china</code></pre><p>而在python2.x中是语法错误<br></p><p>python2.x</p><pre><code>&gt;&gt;&gt; 中国 = &quot;china&quot;SyntaxError: invalid syntax&gt;&gt;&gt; str = &quot;我是霸王&quot;&gt;&gt;&gt; str&apos;\xce\xd2\xca\xc7\xb0\xd4\xcd\xf5&apos;&gt;&gt;&gt; print str我是霸王&gt;&gt;&gt; str = u&apos;我是霸王&apos;&gt;&gt;&gt; stru&apos;\u6211\u662f\u9738\u738b&apos;</code></pre><p>python3.x</p><pre><code>&gt;&gt;&gt; str = &quot;我是霸王&quot;&gt;&gt;&gt; str&apos;我是霸王&apos;&gt;&gt;&gt; print(str)我是霸王</code></pre><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><p>python中除法包括两个运算符，<code>/</code>和<code>//</code></p><p>python2.x中的<code>/</code>除法，跟java、c相同，整数相除结果是一个整数，把小数忽略掉。浮点数的除法会保留小数部分，得到一个浮点数结果。</p><p>python3.x中<code>/</code>除法对于整数之间相除，结果也会是浮点数</p><p>python2.x</p><pre><code>&gt;&gt;&gt; 3/21</code></pre><p>python3.x</p><pre><code>&gt;&gt;&gt; 3/21.5</code></pre><p>而对于<code>//</code>除法，被称为floor除法(python3.x中的floor)，会对除法的结果自动进行一个floor操作，在python2.x和python3.x中是一致的</p><pre><code>&gt;&gt;&gt; 5//31</code></pre><p>python3.x中floor操作：向下取整，小数不存在</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; math.floor(2.2)2</code></pre><p>python2.x中floor操作：向下取整，小数存在，仍然是浮点数</p><pre><code>&gt;&gt;&gt; math.floor(3.2)3.0</code></pre><p>如果需要取整，需要<code>trunc</code>函数</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; math.trunc(5/3)1</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 Python 3 中我们现在使用 as 作为关键词。捕获异常的语法由 except exc, var 改为 except exc as var。</p><p>使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。</p><p>转自：<a href="http://www.runoob.com/python/python-2x-3x.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-2x-3x.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux中的帮助命令</title>
      <link href="/2018/08/25/Linux%E4%B8%AD%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/25/Linux%E4%B8%AD%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>转自：<a href="https://www.shiyanlou.com" target="_blank" rel="noopener">实验楼</a></p><p><strong>实验知识点</strong></p><ul><li>内建命令与外部命令之分</li><li>help , man , info命令的使用以及区别<a id="more"></a></li></ul><h1 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h1><blockquote><p><strong>内建命令</strong>实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</p></blockquote><blockquote><p><strong>外部命令</strong>是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。</p></blockquote><p>简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用　type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的。</p><p><img src="https://i.imgur.com/ZLCpZe6.png" alt=""></p><p>#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中<br>xxx is a shell builtin</p><p>#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中<br>xxx is /usr/bin/xxx</p><p>#若是得到alias的结果，说明该指令为命令别名所设定的名称；<br>xxx is an alias for xx –xxx</p><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>zsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令,首先进入bash:</p><pre><code>bash</code></pre><p>尝试如下命令：</p><pre><code>help ls</code></pre><p><img src="https://i.imgur.com/TUrUXwO.png" alt=""></p><p>这是因为<strong>help命令用户显示shell内建命令</strong>的简要帮助信息。帮助信息中显示该命令的简要说明以及一些参数的使用和说明。</p><p>外部命令帮助查看：</p><pre><code>ls --help</code></pre><p>其实外部命令都具有一个参数<code>--help</code>。</p><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p><code>man</code>命令得到的内容比<code>help</code>命令更详细，而且<code>man</code>命令没有内建和外部命令区分，因为<code>man</code>工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，包括一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。</p><pre><code>man lsman ls (章节数)</code></pre><p>在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节</p><table><thead><tr><th>章节数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Standard commands （标准命令）</td></tr><tr><td>2</td><td>System calls （系统调用）</td></tr><tr><td>3</td><td>Library functions （库函数）</td></tr><tr><td>4</td><td>Special devices （设备说明）</td></tr><tr><td>5</td><td>File formats （文件格式）</td></tr><tr><td>6</td><td>Games and toys （游戏和娱乐）</td></tr><tr><td>7</td><td>Miscellaneous （杂项）</td></tr><tr><td>8</td><td>Administrative Commands （管理员命令）</td></tr><tr><td>9</td><td>其他（Linux特定的）， 用来存放内核例行程序的文档。</td></tr></tbody></table><p> 打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面</p><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>该命令一般bash中自带</p><pre><code>info ls</code></pre><p>得到的信息是不是比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多</p><p>man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的　GNU　工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。</p><p><strong>注释：</strong><br>Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell 。事实上，还有许多传统UNIX上用的Shell，例如tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。bash是大多数Linux系统以及Mac OS X默认的shell，它能运行于大多数类Unix风格的操作系统之上。<br><br>详细见：<a href="https://blog.csdn.net/sujz12345/article/details/54565056" target="_blank" rel="noopener">Linux之bash介绍</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十大数据结构</title>
      <link href="/2018/08/24/%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/08/24/%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>算法+数据结构=编程<a id="more"></a></p><p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MTQzNzU2NA==&amp;mid=2651662400&amp;idx=1&amp;sn=01bc405903147ee4b21134f59dff9b06&amp;chksm=bd4c0fd38a3b86c5f82d32adf653e799a1cee631cb6821b857d6771687d93831271fde52a700&amp;mpshare=1&amp;scene=23&amp;srcid=0819ZBXPPG2xl22aKHLdKwb4#rd" target="_blank" rel="noopener">大数据文摘公众号</a></p><ul><li>数组（列表）</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树（这是一种高效的树形结构，但值得单独说明）</li><li>散列表（哈希表）</li><li>字典</li><li>元组</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。</p><p><img src="https://i.imgur.com/hUYJfsC.jpg" alt=""></p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><p>以下是数组的两种类型：</p><ul><li>一维数组（如上所示）</li><li>多维数组（数组的数组）</li></ul><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><ul><li>Insert——在指定索引位置插入一个元素</li><li>Get——返回指定索引位置的元素</li><li>Delete——删除指定索引位置的元素</li><li>Size——得到数组所有元素的数量</li></ul><h2 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h2><ul><li>寻找数组中第二小的元素</li><li>找到数组中第一个不重复出现的整数</li><li>合并两个有序数组</li><li>重新排列数组中的正值和负值</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。</p><p>可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除：</p><p><img src="https://i.imgur.com/bWUcIYF.jpg" alt=""></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><ul><li>Push——在顶部插入一个元素</li><li>Pop——返回并移除栈顶元素</li><li>isEmpty——如果栈为空，则返回true</li><li>Top——返回顶部元素，但并不移除它</li></ul><h2 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h2><ul><li>使用栈计算后缀表达式</li><li>对栈的元素进行排序</li><li>判断表达式是否括号平衡</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。</p><p>一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。</p><p>下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除：</p><p><img src="https://i.imgur.com/Zr2ydAS.jpg" div="" align="center"></p><p>移除先入队的元素、插入新元素</p><h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><ul><li>Enqueue() —— 在队列尾部插入元素</li><li>Dequeue() ——移除队列头部的元素</li><li>isEmpty()——如果队列为空，则返回true</li><li>Top() ——返回队列的第一个元素</li></ul><h2 id="面试中关于队列的常见问题"><a href="#面试中关于队列的常见问题" class="headerlink" title="面试中关于队列的常见问题"></a>面试中关于队列的常见问题</h2><ul><li>使用队列表示栈</li><li>对队列的前k个元素倒序</li><li>使用队列生成从1到n的二进制数</li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p>链表包括以下类型：</p><p>单链表（单向）<br>双向链表（双向）</p><h2 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h2><ul><li>InsertAtEnd 在链表的末尾插入指定元素</li><li>InsertAtHead 在链接列表的开头/头部插入指定元素</li><li>Delete  从链接列表中删除指定元素</li><li>DeleteAtHead 删除链接列表的第一个元素</li><li>Search  从链表中返回指定元素</li><li>isEmpty 如果链表为空，则返回true</li></ul><h2 id="面试中关于链表的常见问题"><a href="#面试中关于链表的常见问题" class="headerlink" title="面试中关于链表的常见问题"></a>面试中关于链表的常见问题</h2><ul><li>反转链表</li><li>检测链表中的循环</li><li>返回链表倒数第N个节点</li><li>删除链表中的重复项</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一组以网络形式相互连接的节点。节点也称为顶点。 一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。</p><p><img src="https://i.imgur.com/qcRYa9G.jpg" alt=""></p><h2 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a>图的类型</h2><ul><li>无向图</li><li>有向图</li></ul><h2 id="在程序语言中，图可以用两种形式表示："><a href="#在程序语言中，图可以用两种形式表示：" class="headerlink" title="在程序语言中，图可以用两种形式表示："></a>在程序语言中，图可以用两种形式表示：</h2><ul><li>邻接矩阵</li><li>邻接表</li></ul><h2 id="常见图遍历算法"><a href="#常见图遍历算法" class="headerlink" title="常见图遍历算法"></a>常见图遍历算法</h2><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><h2 id="面试中关于图的常见问题"><a href="#面试中关于图的常见问题" class="headerlink" title="面试中关于图的常见问题"></a>面试中关于图的常见问题</h2><ul><li>实现广度和深度优先搜索</li><li>检查图是否为树</li><li>计算图的边数</li><li>找到两个顶点之间的最短路径</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。</p><p>树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：<br><img src="https://i.imgur.com/wAMjjBW.jpg" alt=""></p><ul><li>Root 根节点</li><li>Parent 父节点</li><li>Child 子节点</li><li>Leaf 叶子节点</li><li>Sibling 兄弟节点</li></ul><h2 id="以下是树形结构的主要类型："><a href="#以下是树形结构的主要类型：" class="headerlink" title="以下是树形结构的主要类型："></a>以下是树形结构的主要类型：</h2><ul><li>N元树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>AVL树</li><li>红黑树</li><li>2-3树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><h2 id="面试中关于树结构的常见问题："><a href="#面试中关于树结构的常见问题：" class="headerlink" title="面试中关于树结构的常见问题："></a>面试中关于树结构的常见问题：</h2><ul><li>求二叉树的高度</li><li>在二叉搜索树中查找第k个最大值</li><li>查找与根节点距离k的节点</li><li>在二叉树中查找给定节点的祖先节点</li></ul><h1 id="字典树（Trie）"><a href="#字典树（Trie）" class="headerlink" title="字典树（Trie）"></a>字典树（Trie）</h1><p>字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。</p><p>以下是在字典树中存储三个单词“top”，“so”和“their”的例子：</p><p><img src="https://i.imgur.com/gNIj2Md.jpg" alt=""></p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。</p><h2 id="面试中关于字典树的常见问题"><a href="#面试中关于字典树的常见问题" class="headerlink" title="面试中关于字典树的常见问题"></a>面试中关于字典树的常见问题</h2><ul><li>计算字典树中的总单词数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建T9字典（字典树+ DFS ）</li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p><h2 id="散列数据结构的性能取决于以下三个因素："><a href="#散列数据结构的性能取决于以下三个因素：" class="headerlink" title="散列数据结构的性能取决于以下三个因素："></a>散列数据结构的性能取决于以下三个因素：</h2><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。</p><p><img src="https://i.imgur.com/xlEJuB7.jpg" alt=""></p><h2 id="面试中关于哈希结构的常见问题："><a href="#面试中关于哈希结构的常见问题：" class="headerlink" title="面试中关于哈希结构的常见问题："></a>面试中关于哈希结构的常见问题：</h2><ul><li>在数组中查找对称键值对</li><li>追踪遍历的完整路径</li><li>查找数组是否是另一个数组的子集</li><li>检查给定的数组是否不相交</li></ul><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件系统概念</title>
      <link href="/2018/08/19/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/08/19/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>文件系统和硬盘分区基本概念介绍<a id="more"></a><br><strong>文件系统</strong>：是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。<br>从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p><p><strong>硬盘分区</strong>：实质上是对硬盘的一种格式化。当我们创建分区时，就已经设置好了硬盘的各项物理参数，指定了硬盘主引导记录(即Master Boot Record，一般简称为MBR)和引导记录备份的存放位置。而对于文件系统以及其他操作系统管理硬盘所需要的信息则是通过之后的高级格式化，即Format命令来实现。</p><p><strong>簇</strong>：是指可分配的用来保存文件的最小磁盘空间，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。所以,簇越小，保存信息的效率就越高。</p><p><strong>主引导记录</strong>：（MBR，Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。</p><p><strong>硬盘大小</strong>： 实际中，给硬盘分区时，按照1G=1024M来设置，但是显示的结果都不是整数。比如：将分区设置为10G,显示的确实9.XXG。原因是：<br><br>正确计算公式</p><pre><code>(N-1)*4+1024*N式中N为想要的大小，单位为GB。最终计算出来的结果为MB.</code></pre><p>例如：想要设置分区为2G,则<br>（2-1）<em>4+1024</em>2=2052M<br>设置分区时应该为2052M</p><h1 id="分区状态"><a href="#分区状态" class="headerlink" title="分区状态"></a>分区状态</h1><p>三种：主分区、扩展分区和逻辑分区</p><p>主分区：是一个比较单纯的分区，通常位于硬盘的最前面一块区域中，构成逻辑C磁盘。其中的主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区，负责把引导权移交给活动分区的DOS或其他操作系统。此段程序损坏将无法从硬盘引导，但从软驱或光驱引导之后可对硬盘进行读写。</p><p>扩展分区：仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区(实际上也就是下一个逻辑磁盘)的起始位置，以此起始位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘。</p><p><strong>三者解释：</strong><br><br>主分区能够激活，通常用来引导系统。扩展分区本身并不能直接用来存放数据，逻辑分区是扩展分区进一步分割出来的区块，通常用来存储数据。如果将逻辑分区比作房间，那么扩展分区就好比客房区(包括若干个房间)</p><p><strong>主分区和活动分区：</strong><br><br>主分区也被称为主磁盘分区，是磁盘分区的一中类型，其主要作用是用来安装操作系统。一个硬盘最多可创建4个主分区。活动分区是基于主分区的，磁盘分区中的任意主分区都可以设置为活动分区。如果电脑上4个主分区都安装了不同的系统，那被标记为活动分区的主分区将用于初始引导，即启动活动分区内安装的系统。</p><p><strong>逻辑分区和扩展分区：</strong><br><br>因为主分区最多可以创建4个，我们需要使用扩展分区打破4的限制。在磁盘上可以创建多个逻辑分区而创建的这些逻辑分区都被称为扩展分区，您可以用主分区和逻辑分区中储存数据，但是不能用扩展分区储存，因为扩展分区是我们对逻辑分区的总称，只是一中称呼。</p><p><strong>例子</strong>：通常我们会先在硬盘上划分一个主分区，就是我们常说的C分区，用于安装操作系统，然后将其他的空间全部作为扩展分区，并根据需要，将扩展分区分成几个逻辑分区，即D、E等分区。</p><h1 id="分区格式"><a href="#分区格式" class="headerlink" title="分区格式"></a>分区格式</h1><p>windows:FAT16、FAT32、NTFS、exFAT<br>Linux: ext2、ext3、Linux swap、VFAT、ext4、</p><p><strong>FAT和NNTFS区别</strong><br><br>FAT32：随着大容量硬盘的出现，从Windows 98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。<br><br>NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。<br><br>其实白话说就是FAT格式的分区单个文件夹文件不支持大于4G的文件，NTFS可以支持无限大的，不过相对FAT格式不稳定是真的，xp一般系统是FAT格式的，现在的分区一般都选测NTFS格式的了，文件存储大了</p><h1 id="分区表类型"><a href="#分区表类型" class="headerlink" title="分区表类型"></a>分区表类型</h1><p><strong>GPT分区</strong>: GUID磁盘分区表（GUIDPartition Table，缩写：GPT）是一个实体硬盘的分区表的结构布局的标准。至少可以划分128个主分区。gtp不在有分区的概念。</p><p><strong>MBR分区</strong>：只能划分四个分区，最多支持2T的磁盘</p><p><strong>两者区别</strong>：</p><ul><li><p>内存支持：mbr最多支持2T，而gpt理论上是无限制的。</p></li><li><p>在MBR硬盘中，分区信息直接存储于主引导记录（MBR）中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。</p></li><li><p>分区：mbr最多支持四个主分区，gpt没有限制。如果你想跑多系统，mbr最多4个而gpt没有限制。</p></li><li><p>系统：win7只能用mbr分区（也可以但是很麻烦，不建议），从Win8开始微软建议你使用gpt。</p></li><li><p>其它：gpt是由uefi启动的，而uefi是后来才提出的概念，兼容性和稳定性不如bios+mbr。</p></li><li>对于总容量大于2TB的硬盘，必须选择GPT分区表，才能识别所有的硬盘容量。MBR分区表由于自身设计的局限性，最大只能支持2TB的地址空间。对于超过2TB的大硬盘，如果使用MBR分区表，将无法识别和使用2TB后的空间。</li></ul><p>BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。用于加载电脑最基本的程序代码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。只支持MBR分区。</p><p>UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS（基本输入/输出系统），UEFI旨在提高软件互操作性和解决BIOS的局限性。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而达到开机程序化繁为简节省时间的目的。只支持GPT分区。</p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 硬盘分区 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mock模拟数据生成接口</title>
      <link href="/2018/08/17/Mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/08/17/Mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>Easy Mock是一个可视化，并且能快速生成模拟数据的服务。<a id="more"></a></p><h1 id="Mock解决的问题"><a href="#Mock解决的问题" class="headerlink" title="Mock解决的问题"></a>Mock解决的问题</h1><p><br><br>开发时，后端还没完成数据输出，前端只好写静态模拟数据。<br><br>数据太长了，将数据写在js文件里，完成后挨个改url。<br><br>某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。<br><br>想要尽可能还原真实的数据，要么编写更多代码，要么手动修改模拟数据。<br><br>特殊的格式，例如IP,随机数，图片，地址，需要去收集。<br></p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>官方地址：<a href="https://easy-mock.com/login" title="Easy Mock" target="_blank" rel="noopener">https://easy-mock.com/login</a></p><p>直接输入账号，密码，如果未注册，会直接注册。<br>进入如下页面，按图操作<br><img src="https://i.imgur.com/T7ZlKQu.png" alt=""></p><p><br><br>文档中给出了基本教程<br><br><img src="https://i.imgur.com/EFCIDDm.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Mock数据模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>环境变量与文件查找</title>
      <link href="/2018/08/16/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
      <url>/2018/08/16/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>介绍环境变量的作用与用法，及几种搜索文件的方法。学会这些技巧可以高效地使用 Linux 。<a id="more"></a></p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。<br><code>变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。</code></p><p>shell创建变量</p><pre><code>declare tmp</code></pre><p>shell变量复制</p><pre><code>temp=zxp</code></pre><p>输出变量</p><pre><code>echo $temp</code></pre><p><strong>注意</strong>：并不是任何形式的变量名都是可用的，变量名只能是英文字母、数字或者下划线，且<strong>不能以数字</strong>作为开头</p><h2 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。</p><p>通常我们会涉及到的变量类型有三种：</p><ul><li>当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。</li><li>Shell 本身内建的变量。</li><li>从自定义变量导出的环境变量。<br>也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：</li></ul><table><thead><tr><th>命 令</th><th>说 明</th></tr></thead><tbody><tr><td>set</td><td>显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。</td></tr><tr><td>env</td><td>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td></tr><tr><td>export</td><td>显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</td></tr></tbody></table><h3 id="环境变量永久生效"><a href="#环境变量永久生效" class="headerlink" title="环境变量永久生效"></a>环境变量永久生效</h3><p>按变量的生存周期来划分，Linux 变量可分为两类：</p><ul><li><p>永久的：需要修改配置文件，变量永久生效；</p></li><li><p>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。</p></li></ul><p>介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。<br>查看每个用户的永久生效的环境变量：</p><pre><code>cd /home/用户名ls -a</code></pre><h2 id="命令查找路径与顺序"><a href="#命令查找路径与顺序" class="headerlink" title="命令查找路径与顺序"></a>命令查找路径与顺序</h2><p>Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。</p><p>查看PATH环境变量路径：</p><pre><code>echo $PATH</code></pre><p>其中给出的路径存放可执行文件，当在shell中执行命令时，系统就会安装PATH中设定的路径依次到目录中查找，如果找到同名文件，则执行先找到的文件。</p><h3 id="创建Shell脚本"><a href="#创建Shell脚本" class="headerlink" title="创建Shell脚本"></a>创建Shell脚本</h3><p>创建脚本文件，并打开<br>    gedit hello_world.sh</p><p>在打开的文本中输入：</p><pre><code>#！ /bin/bash   //该行不是注释，不能少for((i=0; i&lt;10; i++));do    echo &quot;hello world&quot;doneexit 0</code></pre><p>为文件添加可执行权限</p><pre><code>chmod 755 hello_shell.sh</code></pre><p>执行脚本</p><pre><code>./hello_shell.sh</code></pre><h2 id="创建C语言程序"><a href="#创建C语言程序" class="headerlink" title="创建C语言程序"></a>创建C语言程序</h2><p>创建并打开一个文件</p><pre><code>gidit hello_world.c</code></pre><p>在文本中输入</p><pre><code>#include &lt;stdio.h&gt;int main(void){     printf(&quot;hello world&quot;);    return 0;}</code></pre><p>保存后，使用gcc生成可执行文件：</p><pre><code>gcc -o hello_world hello_world.c</code></pre><p><em>gcc生成二进制文件默认具有可执行文件，不需修改</em></p><p>在/当前目录修创建一个目录<code>mybin</code>,并将上述文件移动到其中<br>    mkdir mybin<br>    mv hello_shell.sh hello_world mybin/</p><p>并进入<code>mybin</code>目录，运行上述两个程序：</p><pre><code>cd mybin./hello_shell.sh./hello_world</code></pre><p>回到上一级目录，再运行程序，则发现提示命令找不到，除非加上命令的完整路径，但比较麻烦，可以进该路径添加到PATH环境变量。</p><h2 id="添加自定义路径到“PATH”环境变量"><a href="#添加自定义路径到“PATH”环境变量" class="headerlink" title="添加自定义路径到“PATH”环境变量"></a>添加自定义路径到“PATH”环境变量</h2><pre><code>PATH=$PATH:/home/shiyanlou/mybin</code></pre><p><strong><code>=</code>之前之后不能添加空格，否则会提示变量不存在</strong><br><br>注意：路径必须是绝对路径</p><p>这样在任意目录中，都可以执行上述两个文件，直接输入文件名即可执行。<br>到此，如果退出终端，再打开则会发现失效，可以添加一种自动执行的方式：<br>在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 <code>.zshrc</code>，相应 Bash 的配置文件为<code>.bashrc</code>。它们在 <code>etc</code> 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。</p><pre><code>echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</code></pre><p>上述命令中 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 &gt; 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。</p><h2 id="变量修改和删除"><a href="#变量修改和删除" class="headerlink" title="变量修改和删除"></a>变量修改和删除</h2><p>变量的修改有以下几种方式：</p><table><thead><tr><th>变量设置方式</th><th>说明</th></tr></thead><tbody><tr><td>${变量名#匹配字串}</td><td>从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td>${变量名##匹配字串}</td><td>从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td>${变量名%匹配字串}</td><td>从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td>${变量名%%匹配字串}</td><td>从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td>${变量名/旧的字串/新的字串}</td><td>将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td>${变量名//旧的字串/新的字串}</td><td>将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><h2 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h2><pre><code>unset temp</code></pre><h2 id="环境变量立即-生效"><a href="#环境变量立即-生效" class="headerlink" title="环境变量立即 生效"></a>环境变量立即 生效</h2><p>在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如：</p><pre><code>source .zshrcc</code></pre><p><code>source</code>命令还有一个别名就是 <code>.</code>，注意与表示当前路径的那个点区分开，虽然形式不一样，但作用和使用方式一样，上面的命令如果替换成<code>.</code>的方式就该是:</p><pre><code>. ./.zshrc</code></pre><p>注意第一个点之后必须有个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。</p><h1 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h1><p>与搜索相关的命令常用的有 whereis，which，find 和 locate 。</p><h2 id="whereis简单快捷"><a href="#whereis简单快捷" class="headerlink" title="whereis简单快捷"></a>whereis简单快捷<br></h2><pre><code>whereis find</code></pre><p><img src="https://i.imgur.com/QHit5bQ.png" alt=""></p><p>找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。</p><h2 id="locate快而全"><a href="#locate快而全" class="headerlink" title="locate快而全"></a>locate快而全</h2><p>通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。</p><pre><code>locate 文件名</code></pre><p>安装软件包：<code>yum install mlocate</code></p><h2 id="which小而精"><a href="#which小而精" class="headerlink" title="which小而精"></a>which小而精</h2><p><code>which</code>本身是 <code>Shell</code> 内建的一个命令，通常使用 <code>which</code>来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令：</p><pre><code>which man</code></pre><h2 id="find精而细"><a href="#find精而细" class="headerlink" title="find精而细"></a>find精而细<br></h2><p>find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p><pre><code>find / -name 文件名  //w文件名查找find /etc/ -name interfaces  //表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。</code></pre><p><strong><br>注意</strong> find 命令的路径是作为第一个参数的， 基本命令格式为 <code>find [path] [option] [action]</code> 。</p><p>与时间相关的命令参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-atime</td><td>最后访问时间</td></tr><tr><td>-ctime</td><td>最后修改文件内容的时间</td></tr><tr><td>-mtime</td><td>最后修改文件属性的时间</td></tr></tbody></table><p>下面以 -mtime 参数举例：</p><ul><li><code>-mtime n：n</code> 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li><li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li><li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li><li><p><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名<br></p><p>  find ~ -mtime 0 //查找当天(24小时之内)右改动的文件<br>  find ~ -newer /home/shiyanlou/Code  //列出目录下比 Code 文件夹新的文件</p></li></ul><p>以上内容来自:<a href="https://www.shiyanlou.com" target="_blank" rel="noopener">实验楼</a></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python实现：用位运算符实现加法，不允许使用 “+”</title>
      <link href="/2018/08/16/Python%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20%E2%80%9C+%E2%80%9D/"/>
      <url>/2018/08/16/Python%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20%E2%80%9C+%E2%80%9D/</url>
      <content type="html"><![CDATA[<p>计算两个整数a、b的和，但是不能使用“+”操作符。<a id="more"></a><br>即：给定a=1,b=2，返回结果3</p><h1 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h1><h2 id="1、位运算符"><a href="#1、位运算符" class="headerlink" title="1、位运算符"></a>1、位运算符</h2><p>利用位运算实现加法，即计算机利用二进制进行运算，当然离不开位运算</p><p><img src="https://i.imgur.com/V2JKW9z.jpg" alt=""></p><h2 id="2、异或运算"><a href="#2、异或运算" class="headerlink" title="2、异或运算"></a>2、异或运算</h2><p>相同为0，不同为1</p><pre><code>1 ^ 1 = 01 ^ 0 = 10 ^ 1 = 10 ^ 0 = 0</code></pre><p>要实现加法，先考虑1位数的加法，不考虑进位，如下：<br>    1 + 1 = 0<br>    1 + 0 = 1<br>    0 + 1 = 1<br>    0 + 0 = 0<br>可知，上面的表达式可以用位运算符”^”代替，接下来考虑进位</p><h2 id="3、与运算"><a href="#3、与运算" class="headerlink" title="3、与运算"></a>3、与运算</h2><p>都为1,则为1</p><p>上面的加法可以表示为：<br>    0 &amp; 0 = 不进位<br>    1 &amp; 0 = 不进位<br>    0 &amp; 1 = 不进位<br>    1 &amp; 1 = 进位   </p><p>从上推到，可得：</p><p>位运算中，用“&lt;&lt;”表示向左移动一位，即“进位”，我么可以用以下表达式实现进位：</p><pre><code>（x&amp;y&lt;&lt;1</code></pre><p>于是可以得到如下两个表达式：</p><pre><code>x^y //执行加法（x&amp;y&lt;&lt;1 //进位操作</code></pre><p>两位数的加法：</p><pre><code>11+01=100 //实际的二进制算法//推算表达式11^01=1011&amp;01&lt;&lt;1 = 10</code></pre><p>由于不能使用加法，接着按上述算法计算：</p><pre><code>10^10 =00(10&amp;10)&lt;&lt;1=100</code></pre><p>到此，就可以得出结论，总结如下定理：</p><p><strong>定理一</strong>：设a，b位两个二进制数，则a+b=a^b+(a&amp;b)&lt;&lt;1 <br><br>证明： a^b是不考虑进位的加法结果，当二进制位同时为1时，才有进位，因此(a&amp;b)&lt;&lt;1 是进位产生的值，称为进位补偿，将两者相加便是完整加法结果。<br><br><strong>定理二</strong>：利用定理一可以实现只用位运算进行加法运算。<br><br>证明： 利用定理一中的等式不停对自身进行迭代，每迭代一次，进位补仓右边就多一位0，因此最多需要加数二进制位数长度次迭代，进为补偿就变为0，这时运算结束。</p><h2 id="4、Python实现"><a href="#4、Python实现" class="headerlink" title="4、Python实现"></a>4、Python实现</h2><pre><code>#不使用“+”来求两个数的和def newadd(a, b):      ta = a&amp;b        tb = a^b      while(ta):            t_a = tb            t_b = ta&lt;&lt;1            ta = t_a &amp; t_b            tb = t_a ^ t_b      print(&apos;a+b=&apos;, tb)if __name__ == &quot;__main__&quot;:      newadd(4,5)&apos;&apos;&apos;计算过程：a = 100  //4b = 101  //5ta = 100  //4tb = 001  //1进入循环循环t_a = 001 t_b = 1000 //8ta = 0000 //0tb = 1001 //9退出循环&apos;&apos;&apos;</code></pre><p>转自：<a href="http://t.pae.baidu.com/s?s=bai-paallr" target="_blank" rel="noopener">http://t.pae.baidu.com/s?s=bai-paallr</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
            <tag> 面试题目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序开发工具调试</title>
      <link href="/2018/08/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95/"/>
      <url>/2018/08/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>小程序开发过程中，调试是让程序跑起来的关键。<a id="more"></a><br>第一步：点击调试器</p><p><img src="https://i.imgur.com/ACdgBOh.png" alt=""></p><p>第二步：点击sources</p><p><img src="https://i.imgur.com/D59w6ea.png" alt=""></p><p>第三步：在目录中找到需要调试的js文件，打开图中文件，注意不是后缀为js的文件，而是js？[sm]的文件</p><p><img src="https://i.imgur.com/tZKGrVq.png" alt=""></p><p>第四步： 在文件中设置断点<br><br>将鼠标移到文件最左侧，点击即可设置断点</p><p><img src="https://i.imgur.com/Mv5G61K.png" alt=""><br><strong>快捷键ctrl+b进入调试</strong><br><br>第五步：点击红色箭头按钮，继续执行到下一个断点<br><br>点击蓝色按钮，继续执行&lt;/r.<br>点击黄色按钮，单步调试<br><img src="https://i.imgur.com/fIZSVCX.png" alt=""></p><p>第六步：查看变量值<br><br>方法一： 鼠标放在变量上，即可显示变量值<br><img src="https://i.imgur.com/bFqe8vy.png" alt=""></p><p>方法二：在调试器窗口，点开Scope标签，然后再点开相应变量</p><p><img src="https://i.imgur.com/Row1z1q.png" alt=""></p><p>方法三：使用console.log(options);打印出来，在console窗口可以查看</p>]]></content>
      
      <categories>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git + TortoiseGit安装教程和环境部署</title>
      <link href="/2018/08/15/Git%20+%20TortoiseGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/15/Git%20+%20TortoiseGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>对于程序员而言，版本管理是不可缺少的一部分，利用Gitlab或Github对代码进行管理大大提高的效率，本文介绍如何搭建环境。<a id="more"></a></p><p>工作模式： 生成公私钥对，将公钥部署到github上，然后利用保存在本地的私钥去连接github</p><p>第一步: 下载Git: <a href="https://git-scm.com/downloads" title="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>第二步： 下载TortoiseGit: <a href="https://tortoisegit.org/download/" target="_blank" rel="noopener">https://tortoisegit.org/download/</a></p><p>第三步： 安装以上两个软件，如果英语不ok的，可以安装tortoisegit语言包（<a href="https://download.tortoisegit.org/tgit/2.6.0.0/TortoiseGit-LanguagePack-2.6.0.0-64bit-zh_CN.msi" target="_blank" rel="noopener">简体中文语言包</a>）</p><p>在安装TortoiseGit后，第一次配置时，选择语言</p><p><img src="https://i.imgur.com/9eXOV7H.png" alt=""></p><p>或者在TortoiseGit的设置进行设置，如下：<br><br>首先鼠标右键，移到TortoiseGit上，点击Setting,进入如下页面，即可进行设置</p><p><img src="https://i.imgur.com/x8bqPCu.png" alt=""></p><p>第三步： 密钥生成及部署</p><p>在电脑搜索栏输入PuTTygen，打开软件</p><p><img src="https://i.imgur.com/bpnbfmw.png" alt=""></p><p>点击Generate</p><p><img src="https://i.imgur.com/DuP2F0a.png" alt=""></p><p>在红色方框内不停移动鼠标，10秒左右，进入如下页面：</p><p><img src="https://i.imgur.com/DXOtW6Q.png" alt=""></p><p>点击Save private key,将私钥保存到本地：</p><p><img src="https://i.imgur.com/hFAjehH.png" alt=""></p><p>点击是，并输入私钥文件名</p><p>接着将公钥填到Github或Gitlab中，这里以github为例，gitLab相同：<br> 首页点击右上角的头像，并选择点击setting</p><p><img src="https://i.imgur.com/NIuRTsI.png" alt=""></p><p>然后点击 SSH Keys</p><p><img src="https://i.imgur.com/FcQBKu3.png" alt=""></p><p>接着点击创建一个ssh Key, 并将复制的公钥填入Key一栏中：</p><p><img src="https://i.imgur.com/Hef7aPM.png" alt=""></p><p>第四步： 利用本地的私钥去连接Github，并克隆（clone）代码包到本地</p><p>在需要存放代码的目录下，点击右键，并点击 git clone（git 克隆），进入如下页面：</p><p><img src="https://i.imgur.com/2LnKwQI.png" alt=""></p><p>根据图中指示填好，然后点击ok，即可将代码克隆到本地</p><p>其中的URL在Github上保存的代码包顶部右地址：</p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序开发前言</title>
      <link href="/2018/08/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%89%8D%E8%A8%80/"/>
      <url>/2018/08/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>在这里，将介绍开发小程序的前期准备，和开发框架的了解<a id="more"></a></p><p>第一步 注册微信小程序账号：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" title="链接送上" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a></p><p>第二步 开发环境安装： <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18081317" title="链接送上" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18081317</a></p><p>第三步 小程序开发架构的了解，将是本文的重点</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>进入开发工具，可见如下图的目文件：</p><p><img src="https://i.imgur.com/xPSgVkj.png" alt=""></p><p>utils中的文件处理全局配置<br><br>pages下还有文件夹，每个文件夹对应一个页面，每个文件加下的文件管理对应的页面</p><ul><li>app.json: 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等<br></li><li>project.config.json: 在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发   者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。<br></li><li>page.json: 可以独立定义每个页面的一些属性，例如顶部颜色、是否允许下拉刷新等等</li><li>wxml：相当于web开发中的html文件，用来描叙页面的结构<br></li><li>wxss: 相当于web开发中的css文件,兼容大部分css的特性<br></li><li>Js: 负责用户交互,响应用户的点击、获取用户的位置等等<br></li></ul><h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><ul><li>逻辑层：逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。</li><li>开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。<br>视图层：框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示；将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。</li></ul>]]></content>
      
      <categories>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPN安装后无法连接到互联网</title>
      <link href="/2018/08/13/VPN%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91/"/>
      <url>/2018/08/13/VPN%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91/</url>
      <content type="html"><![CDATA[<p> VPN安装后无法连接到互联网问题解决方案<a id="more"></a><br>赛风（psiphon）下载地址<a href="https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct" target="_blank" rel="noopener">https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct</a></p><p>使用vpn时，出现浏览器无法连接到互联网问题解决：</p><p><img src="https://i.imgur.com/J1OUsRC.png" alt=""></p><p>原因是浏览器开启了局域网代理：</p><p><img src="https://i.imgur.com/73gPHHW.png" alt=""></p><p><img src="https://i.imgur.com/wKG7Mte.png" alt=""></p><p><img src="https://i.imgur.com/Q1iTRqq.png" alt=""></p><p><img src="https://i.imgur.com/D5vuZFK.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPN资源</title>
      <link href="/2018/08/13/VPN%E8%B5%84%E6%BA%90md/"/>
      <url>/2018/08/13/VPN%E8%B5%84%E6%BA%90md/</url>
      <content type="html"><![CDATA[<p>VPN资源：赛风和兰灯<a id="more"></a></p><p>赛风：<a href="https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct" title="https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct" target="_blank" rel="noopener">https://s3.amazonaws.com/psiphon/web/4vul-knjv-amkn/zh/download.html#direct</a></p><p>兰灯：<a href="http://pan.bcoderss.com/?dir=lan" title="http://pan.bcoderss.com/?dir=lan" target="_blank" rel="noopener">http://pan.bcoderss.com/?dir=lan</a>  (包括安卓、windows、mac和linux端资源)</p>]]></content>
      
      
        <tags>
            
            <tag> VPN </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手机抓包软件：charles安装及教程</title>
      <link href="/2018/08/13/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%EF%BC%9Acharles%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/13/%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%EF%BC%9Acharles%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>手机app或微信小程序开发过程中，解决数据传输过程中的问题，抓包软件必不可少<a id="more"></a></p><h1 id="0、准备："><a href="#0、准备：" class="headerlink" title="0、准备："></a>0、准备：</h1><p>电脑关闭防火墙、其他代理或者翻墙软件</p><h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h1><p>最新版地址：<a href="https://www.charlesproxy.com/latest-release/download.do#" target="_blank" rel="noopener">charles</a></p><p>本教程使用v4.2.6</p><p>安装一路next即可</p><h1 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h1><p><strong>第一步</strong>： 查看本机IP</p><p>  方法一：运行-&gt;输入cmd-&gt;在命令行中输入：ipconfig<br><br>  方法二：在charles中点击Help-&gt;Local IP Adress</p><p><img src="https://i.imgur.com/8cxacvx.png" alt=""><br><br>第一行为本地IP,后面两行为虚拟IP</p><p><strong>第二步</strong>： 查看端口</p><p><img src="https://i.imgur.com/vZ8LWDH.png" alt=""></p><p><strong>第三步</strong>：手机上设置代理</p><p>安装证书</p><p> 复制<a href="http://charlesproxy.com/getssl或http://www.charlesproxy.com/ssl.zip" target="_blank" rel="noopener">http://charlesproxy.com/getssl或http://www.charlesproxy.com/ssl.zip</a> 到手机浏览器打开，点击 here 下载，安装，信任；</p><p>手机和电脑连接到同一局域网，在wifi中设置代理，ios如下：</p><p><img src="https://i.imgur.com/FVD46mi.png" alt="">  <img src="https://i.imgur.com/YS5YY45.png" alt=""></p><p>电脑端弹出connction from “IP”,点击allow</p><p><strong>第四步</strong>： 电脑端安装证书</p><p>点击help-&gt;SSL Proxying-&gt; install Charles root certificate</p><p><img src="https://i.imgur.com/A1lKaZK.png" alt=""></p><p>一路next即可安装</p><p>第五步：设置SSL代理</p><p>点击proxying-&gt;ssl proxying settings</p><p><img src="https://i.imgur.com/Y2fKZVp.png" alt=""></p><p>点击Add</p><p> <img src="https://i.imgur.com/2TIvQNX.png" alt=""></p><p>在host中填入：*通配符<br>在port中填入：443</p><h1 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h1><ul><li>Structure：树状结构显示，将网络请求按访问的域名分类；</li><li>Sequence：水平结构显示，将网络请求按访问的时间排序</li><li>垃圾桶图标 ： 功能是clear，清理掉所有请求显示信息</li><li>Filter ： 过滤，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求</li><li>Overview ： 查看这次请求的详细内容，例如耗时详细列车了请求开始时间、结束时间，响应开始时间、结束时间，总耗时、DNS耗时、网络延时等。 </li><li><p>对于Size也详细列出了请求头大小、响应头大小、压缩比例等内容。 </p></li><li><p>URL：进行网络请求的链接；</p></li><li>Status：当前状态，complete表示请求完成；</li><li>Responce Code：返回码。不同的接口，不同的请求结果，返回码都不同；</li><li>Protocol：使用的协议；</li><li>Method：请求方式，如GET请求，POST请求等；</li><li>Kept Alive：判断当前是否正在链接（活跃）；</li><li>Content-Type:发送的内容类型，如这里用的是XML文本，以UTF8的方式发送；</li><li>Client Address：客户端的IP地址；</li><li>Remote Address：远程服务器的IP；</li><li>Timing: <ul><li>Request Start Time：请求开始的时间；</li><li>Request End Time：请求结束的时间；</li><li>Response Start Time：返回开始的时间；</li><li>Response End Time : 返回结束的时间；</li><li>Duration : 总时间；</li></ul></li><li>Size: <ul><li>Request Header ：请求的头部大小；</li><li>Response Header：返回的头部大小；</li><li>Request : 请求发送的大小；</li><li>Response：返回数据的大小；</li><li>Total：所有数据大小；</li><li>Request Compression : 请求压缩；</li><li>Response Compression : 返回压缩；</li></ul></li><li>Request ： 查看请求内容（底下的Headers，Query String， Cookies，Raw。） <ul><li>Headers：发送请求的头部信息； </li><li>Query String : 发送参数列表；</li><li>Cookies： 浏览器缓存；</li><li>Raw：发送的原生数据，包括了头部和参数；</li></ul></li><li>Reponse : 查看响应内容 <ul><li>Headers：是返回的头部信息；</li><li>Text：返回信息（除去头部）后的文本； </li><li>Hex：返回信息的16进制表示；</li><li>XML：我返回的数据是XML。如果你返回的是JSON，这里就会显示JSON；</li><li>XML Text：如果你返回JSON，这里会显示JSON Text；</li><li>Raw：返回的所有原生数据，包括头部；</li></ul></li><li>Summary: 查看发送数据的一些简要信息（主机，状态码，数据的类型，header和body大下，加载时间，总时间）</li><li>Chart: Summary中简要信息以图表形式展示</li><li>Notes: 其他信息</li></ul><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>You may need to configure your browser or application to trust the Charles Root Certificate<br><br>由于手机虽然安装了证书，但是未信任</p><p>解决方案：<br><br>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可.</p><p>转自：<a href="https://blog.csdn.net/zhangxiang_1102/article/details/77855548" target="_blank" rel="noopener">更多详细内容见此</a></p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 手机抓包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim教程</title>
      <link href="/2018/08/13/Vim%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/13/Vim%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>本文介绍linux中的编辑器vim操作,以及基本命令操作<a id="more"></a></p><h1 id="Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式："><a href="#Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：" class="headerlink" title="Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式："></a>Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：</h1><ul><li>普通模式(Normal mode)</li></ul><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p><p>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</p><p>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</p><ul><li>插入模式(Insert mode)</li></ul><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p><p>在插入模式中，可以按ESC键回到普通模式。</p><p>可视模式(Visual mode)<br>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p><ul><li>选择模式(Select mode)<br>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</li></ul><ul><li>命令行模式(Command line mode)<br>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</li></ul><ul><li>Ex模式(Ex mode)<br>这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。</li></ul><p>这其中我们常用到就是普通模式、插入模式和命令</p><pre><code>vim  文件名 //如果文件名不存在，会自动创建文件并打开vim nginx.conf //进入普通模式a 或 i  //进入插入模式Esc  //退出插入模式，进入普通模式： //退出普通模式，进入命令行模式命令行模式下： wq保存退出</code></pre><h1 id="游标移动"><a href="#游标移动" class="headerlink" title="游标移动"></a>游标移动</h1><p>按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右（小写L）</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>w</td><td>移动到下一个单词</td></tr><tr><td>b</td><td>移动到上一个单词</td></tr></tbody></table><h1 id="从普通模式进入插入模式"><a href="#从普通模式进入插入模式" class="headerlink" title="从普通模式进入插入模式"></a>从普通模式进入插入模式</h1><p>按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右（小写L）</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>w</td><td>移动到下一个单词</td></tr><tr><td>b</td><td>移动到上一个单词</td></tr></tbody></table><h1 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h1><pre><code>:w 文件名 //可以将文档另存为其他文件名或存到其它路径下:w //保存文件:w test //另存为test文件</code></pre><h1 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h1><p>命令行模式下退出vim<br>从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑</p><p>以下为其它几种退出方式：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:q!</td><td>强制退出，不保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq!</td><td>强制保存并退出</td></tr><tr><td>:w &lt;文件路径&gt;</td><td>另存为</td></tr><tr><td>:saveas 文件路径</td><td>另存为</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr></tbody></table><p>普通模式下退出vim<br>普通模式下输入Shift+zz即可保存退出vim</p><h1 id="普通模式下删除vim文本信息"><a href="#普通模式下删除vim文本信息" class="headerlink" title="普通模式下删除vim文本信息"></a>普通模式下删除vim文本信息</h1><p>进入普通模式，使用下列命令可以进行文本快速删除：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除游标所在的字符</td></tr><tr><td>X</td><td>删除游标所在前一个字符</td></tr><tr><td>Delete</td><td>同x</td></tr><tr><td>dd</td><td>删除整行</td></tr><tr><td>dw</td><td>删除一个单词（不适用中文）</td></tr><tr><td>d$或D</td><td>删除至行尾</td></tr><tr><td>d^</td><td>删除至行首</td></tr><tr><td>dG</td><td>删除到文档结尾处</td></tr><tr><td>d1G</td><td>删至文档首部</td></tr></tbody></table><h1 id="vim重复命令（普通模式下）"><a href="#vim重复命令（普通模式下）" class="headerlink" title="vim重复命令（普通模式下）"></a>vim重复命令（普通模式下）</h1><pre><code>. 表示重复执行上次命令  //向输入x删除第一个字符，再输入.接着删除一个字符10x 表示删除10连续个字符3dd 表示删除3行文本dw或daw 删除一个单词dNw 删除N个单词</code></pre><p>#游标快速跳转</p><h2 id="行间跳转"><a href="#行间跳转" class="headerlink" title="行间跳转."></a>行间跳转.</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nG(n Shift+g)</td><td>游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号)</td></tr><tr><td>gg</td><td>游标移动到到第一行</td></tr><tr><td>G(Shift+g)</td><td>到最后一行</td></tr></tbody></table><h2 id="行内跳转"><a href="#行内跳转" class="headerlink" title="行内跳转"></a>行内跳转</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>到下一个单词的开头</td></tr><tr><td>e</td><td>到当前单词的结尾</td></tr><tr><td>b</td><td>到前一个单词的开头</td></tr><tr><td>ge</td><td>到前一个单词的结尾</td></tr><tr><td>0或^</td><td>到行头</td></tr><tr><td>$</td><td>到行尾</td></tr><tr><td>f&lt;字母&gt;</td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td></tr><tr><td>F&lt;字母&gt;</td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td></tr><tr><td>t&lt;字母&gt;</td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td></tr><tr><td>T&lt;字母&gt;</td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td></tr></tbody></table><h1 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h1><h2 id="复制及粘贴"><a href="#复制及粘贴" class="headerlink" title="复制及粘贴"></a>复制及粘贴</h2><p>普通模式中使用y复制</p><p>普通模式中，yy复制游标所在的整行（3yy表示复制3行）</p><p>普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。</p><p>普通模式中，y$ 复制至行尾。含光标所在处字符。</p><p>普通模式中，yw 复制一个单词。</p><p>普通模式中，y2w 复制两个单词。</p><p>普通模式中，yG 复制至文本末。</p><p>普通模式中，y1G 复制至文本开头。</p><p>普通模式中使用 p 粘贴</p><p>普通模式中，p(小写)代表粘贴至光标后（下）<br>普通模式中，P(大写)代表粘贴至光标前（上）</p><h2 id="剪切及粘贴"><a href="#剪切及粘贴" class="headerlink" title="剪切及粘贴"></a>剪切及粘贴</h2><p>dd删除命令其实是剪切，每次dd删除文档内容后，使用p来粘贴，这样可以实现—-交换上下行</p><h1 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h1><h2 id="字符的替换及撤销操作"><a href="#字符的替换及撤销操作" class="headerlink" title="字符的替换及撤销操作"></a>字符的替换及撤销操作</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>r+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td>R</td><td>连续替换，直到按下Esc</td></tr><tr><td>cc</td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td>cw</td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td>C(大写)</td><td>替换游标以后至行末</td></tr><tr><td>~</td><td>反转游标所在字母大小写</td></tr><tr><td>u{n}</td><td>撤销一次或n次操作</td></tr><tr><td>U(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td>Ctrl+r</td><td>redo，即撤销undo的操作</td></tr></tbody></table><h2 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h2><p>普通模式下操作 </p><pre><code>&gt;&gt; 整行向右缩进&lt;&lt; 整行向左回退</code></pre><p>普通模式下，对shftwidth值进行设置，可以控制缩进和回退e字符数</p><pre><code>:set shiftwidth? //查看当前缩进字符数:set shiftwidth=10 //设置缩进字符数为10</code></pre><p>shiftwidthn可以简写为sw</p><h2 id="调整文本位置"><a href="#调整文本位置" class="headerlink" title="调整文本位置"></a>调整文本位置</h2><p>命令行模式下，操作光标所在的行</p><pre><code>:ce //本行内容剧中:ri //本行内容靠右:le //本行内容靠左</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>普通模式下，输入 <em>/</em>, 然后输入需要查找的字符串，按回车即可进行查找。 <em>? </em>功能与 <em>/</em> 功能相同，只不过 <em>?</em>向下查找。进入查找之后，在字符串之后输入<em>n</em>和<em>N</em> 可以继续查找，<em>n</em>表示继续查找，<em>N</em>表示方向查找</p><h2 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h2><p>普通模式下输入*寻找游标所在处的单词<br><br>普通模式下输入#同上，但 # 是向前（上）找，*则是向后（下）找<br><br>普通模式下输入g*同* ，但部分符合该单词即可<br><br>普通模式下输入g#同# ，但部分符合该单词即可<br></p><h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><h3 id="vim编辑多个文件"><a href="#vim编辑多个文件" class="headerlink" title="vim编辑多个文件"></a>vim编辑多个文件</h3><pre><code>vim 1.txt 2.txt</code></pre><p>默认进入<em>1.txt</em>文件的编辑界面<br></p><ul><li>命令行模式下输入<em> :n </em>编辑 <em>2.txt </em>文件，可以加<em> ! </em>即<em> :n! </em>强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件<br></li></ul><ul><li>命令行模式下输入<em> :N </em>编辑 <em>1.txt </em>文件，可以加<br><em>! </em>即 <em>:N!</em> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li></ul><h3 id="进入vim后打开新文件"><a href="#进入vim后打开新文件" class="headerlink" title="进入vim后打开新文件"></a>进入vim后打开新文件</h3><ul><li>命令行模式下输入<code>:e 3.txt</code> 打开新文件<code>3.txt</code></li><li>命令行模式下输入<code>:e#</code>回到前一个文件</li><li>命令行模式下输入<code>:ls</code>可以列出以前编辑过的文档</li><li>命令行模式下输入<code>:b 2.txt</code>（或者编号）可以直接进入文件2.txt编辑</li><li>命令行模式下输入<code>:bd 2.txt</code>（或者编号）可以删除以前编辑过的列表中的文件项目</li><li>命令行模式下输入<code>:e! 4.txt</code>，新打开文件<code>4.txt</code>，放弃正在编辑的文件</li><li>命令行模式下输入<code>:f</code> 显示正在编辑的文件名</li><li>命令行模式下输入<code>:f new.txt</code>，改变正在编辑的文件名字为<code>new.txt</code></li></ul><h3 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a>恢复文件</h3><p>如果因为断电等原因造成文档没有保存，可以采用恢复方式，<code>vim -r</code>进入文档后，输入<code>:ewcover 1.txt</code>来恢复</p><pre><code>vim -r 1.txt</code></pre><h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><h3 id="可视模式命令简介"><a href="#可视模式命令简介" class="headerlink" title="可视模式命令简介"></a>可视模式命令简介</h3><ul><li>在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。</li><li>在普通模式下输入 Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取。</li><li>在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取。</li><li>在可视模式下输入 d 删除选取区域内容<br>在可视模式下输入y复制选取区域内容<h3 id="可视模式命令练习"><a href="#可视模式命令练习" class="headerlink" title="可视模式命令练习"></a>可视模式命令练习</h3></li><li>在普通模式下9G跳转到第9行,输入Shift+v（小写V），进入可视模式进行行选择，选中5行，按下&gt;&gt;缩进，将5行整体缩进一个shiftwidth</li><li>在普通模式下输入 Ctrl+v（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后x删除整列</li></ul><h2 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h2><p>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入 :new 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 Ctrl+w也可以），除了 :new 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：</p><p><strong>注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。</strong></p><ul><li>命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt</li><li>命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt</li><li>普通模式下Ctrl+w s 将当前窗口分割成两个水平的窗口</li><li>普通模式下Ctrl+w v 将当前窗口分割成两个垂直的窗口</li><li>普通模式下Ctrl+w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</li><li>普通模式下Ctrl+w o 打开一个视窗并且隐藏之前的所有视窗</li><li>普通模式下Ctrl+w j 移至下面视窗</li><li>普通模式下Ctrl+w k 移至上面视窗</li><li>普通模式下Ctrl+w h 移至左边视窗</li><li>普通模式下Ctrl+w l 移至右边视窗</li><li>普通模式下Ctrl+w J 将当前视窗移至下面</li><li>普通模式下Ctrl+w K 将当前视窗移至上面</li><li>普通模式下Ctrl+w H 将当前视窗移至左边</li><li>普通模式下Ctrl+w L 将当前视窗移至右边</li><li>普通模式下Ctrl+w 减小视窗的高度</li><li>普通模式下Ctrl+w + 增加视窗的高度</li></ul><h2 id="创建加密文档"><a href="#创建加密文档" class="headerlink" title="创建加密文档"></a>创建加密文档</h2><pre><code>vim -x nginx.conf</code></pre><p>根据提示输入密码，下次打开文件时，需要输入密码</p><h2 id="vim执行外部命令"><a href="#vim执行外部命令" class="headerlink" title="vim执行外部命令"></a>vim执行外部命令</h2><p>在命令行模式中输入!可以执行外部的shell命令</p><ul><li><code>:!ls</code> 用于显示当前目录的内容</li><li><code>:!rm FILENAME</code>用于删除名为 FILENAME 的文件</li><li><code>:w FILENAME</code>可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li></ul><h2 id="vim中查看帮助"><a href="#vim中查看帮助" class="headerlink" title="vim中查看帮助"></a>vim中查看帮助</h2><ul><li>普通模式下按F1打开vim自己预设的帮助文档</li><li>命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件</li><li>命令行模式下输入:ver 显示版本及参数</li></ul><h2 id="功能设定"><a href="#功能设定" class="headerlink" title="功能设定"></a>功能设定</h2><h3 id="vim的功能设定"><a href="#vim的功能设定" class="headerlink" title="vim的功能设定"></a>vim的功能设定</h3><p>可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用</p><h3 id="获取目前的设定"><a href="#获取目前的设定" class="headerlink" title="获取目前的设定"></a>获取目前的设定</h3><ul><li>命令行模式下输入:set或者:se显示所有修改过的配置</li><li>命令行模式下输入:set all 显示所有的设定值</li><li>命令行模式下输入:set option? 显示option的设定值</li><li>命令行模式下输入:set nooption 取消当前设定值<h3 id="set功能的说明"><a href="#set功能的说明" class="headerlink" title="set功能的说明"></a>set功能的说明</h3></li><li>命令行模式下输入:set autoindent(ai) 设置自动缩进</li><li>命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开</li><li>命令行模式下输入:set background=dark或light，设置背景风格</li><li>命令行模式下输入:set backup(bk) 设置自动备份，默认未打开</li><li>命令行模式下输入: set cindent(cin) 设置C语言风格缩进<br>-<br>以上内容来自<a href="https://www.shiyanlou.com/courses/2" title="实验楼" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/2</a>，为作者边学习，边摘抄和总计的内容</li></ul>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown教程</title>
      <link href="/2018/08/12/Markdown%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/12/Markdown%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Markdown安装，升级，以及语法介绍<a id="more"></a></p><h1 id="升级Pro版本"><a href="#升级Pro版本" class="headerlink" title="升级Pro版本"></a>升级Pro版本</h1><h2 id="邮箱地址："><a href="#邮箱地址：" class="headerlink" title="邮箱地址："></a>邮箱地址：</h2><pre><code>Soar360@live.com</code></pre><h2 id="授权秘钥："><a href="#授权秘钥：" class="headerlink" title="授权秘钥："></a>授权秘钥：</h2><pre><code>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</code></pre><p>来自：<a href="https://www.jianshu.com/p/8a1bd4892291" target="_blank" rel="noopener">https://www.jianshu.com/p/8a1bd4892291</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>支持六级标题</p><pre><code># 一级标题## 二级标题### 三级标题</code></pre><p>注意：#之后必须加一个空格，当然有些编辑器不用，但最后还是添加</p><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><pre><code>&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;内容填写在这里&lt;/font&gt;</code></pre><p>效果：<font color="#0099ff" size="5" face="黑体">内容填写在这里</font></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code> </li><li>斜体    <code>Ctrl + I</code> </li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等，详细语法参考帮助？。</p><p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考[Github][2].  </p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>Markdown　Extra</strong>　表格语法：</p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>. </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见[math.stackexchange.com][1].</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>更多LaTex语法请参考 [这儿][3].</p><h2 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h2><p>可以渲染序列图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 [这儿][4],</li><li>关于 <strong>流程图</strong> 语法，参考 [这儿][5].</li></ul><h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="noopener">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p><p>博客发表后，本地缓存将被删除。　</p><p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p></blockquote><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ol><li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li><li>IE９以下不支持</li><li>IE９，１０，１１存在以下问题<ol><li>不支持离线功能</li><li>IE9不支持文件导入导出</li><li>IE10不支持拖拽文件导入</li></ol></li></ol><h1 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h1><p>转自：<a href="https://www.jianshu.com/p/191d1e21f7ed" title="其他语法" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></p>]]></content>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo搭建属于自己的博客</title>
      <link href="/2018/08/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/08/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本文将介绍利用Hexo搭建博客的教程，包括其中遇到问题的解决方案，包括：添加域名等等内容，本人亲自实践过，希望对您有所帮助，如果遇到其他问题，可联系本人。<a id="more"></a></p><h1 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h1><p>Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>Nodejs:<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>Github账号，并创建新仓库</p><p>新建仓库如下：<br><img src="https://i.imgur.com/Qt2pUjV.png" alt=""><br><img src="https://i.imgur.com/FSsJniC.png" alt=""></p><h1 id="安装Nodejs："><a href="#安装Nodejs：" class="headerlink" title="安装Nodejs："></a>安装Nodejs：</h1><p>一路next即可</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>安装一路next，重点在配置</p><p>首先将安装目录添加进环境变量</p><p>然后设置用户名和邮箱</p><pre><code>$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com</code></pre><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>在所要存放博客文件的文件夹下右键，点击git bash</p><p>输入如下命令：</p><pre><code>npm install -g hexo-cli</code></pre><h1 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h1><pre><code>hexo init </code></pre><h1 id="安装依赖依赖包"><a href="#安装依赖依赖包" class="headerlink" title="安装依赖依赖包"></a>安装依赖依赖包</h1><pre><code>npm install</code></pre><h1 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h1><p>在博客目录下找到_config.yml,修改如下内容</p><pre><code># Sitetitle: 平步青云winsubtitle:description: 建站 Linux Python C++ 编程语言keywords: 建站 Linux Python C++ 编程语言author: zxplanguage: zh-Hanstimezone:deploy:  type: git  repository: https://github.com/zxpgo/blog.git# 博客仓库地址 #repository: https://github.com/xxx/xxx.github.io.git </code></pre><p>博客仓库地址见本文开头第二张图片内的地址</p><p>注意：<strong>：之后必须添加一个空格再添加内容</strong></p><p>否则会有如下错误：<br><img src="https://i.imgur.com/Z9xaVfN.png" alt=""></p><h1 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h1><pre><code>hexo new &quot;文章名字&quot;</code></pre><h1 id="本地站点生成"><a href="#本地站点生成" class="headerlink" title="本地站点生成"></a>本地站点生成</h1><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><pre><code>hexo g</code></pre><p>显示如下信息，表示成功</p><p><img src="https://i.imgur.com/UpMYKme.png" alt=""></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><pre><code>hexo s</code></pre><p>显示如下信息，表示成功：</p><p><img src="https://i.imgur.com/ENe7sIs.png" alt=""></p><p>到此本地的配置结束</p><p>打开浏览器，输入localhost:4000查看</p><h1 id="部署Github"><a href="#部署Github" class="headerlink" title="部署Github"></a>部署Github</h1><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo dhexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。（个人习惯，非必需）hexo g #生成静态文件，每次改动之后都需要执行以下这个命令。hexo d #这个才是真正的部署命令，这里用的都是简写形式</code></pre><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a><font color="#f00">问题一</font></h2><p>运行时出错，由于还没有添加sshkey，具体教程如下：<br>打开Git Bash</p><p>设置Git的user name和email：（前面以及设置）<br>    git config –global user.name “aqiongbei” #改成你的注册Github的用户名<br>    git config –global user.email “<a href="mailto:aqiongbei@gmail.com" target="_blank" rel="noopener">aqiongbei@gmail.com</a>“ #改成你的注册Github的邮箱</p><h2 id="生成SSH密钥："><a href="#生成SSH密钥：" class="headerlink" title="生成SSH密钥："></a>生成SSH密钥：</h2><p>生存密钥：</p><pre><code>ssh-keygen -t rsa -C &quot;aqiongbei@gmail.com&quot; #改成你注册Github的邮箱</code></pre><p>返回提示如下：</p><p><img src="https://i.imgur.com/ONTwjSc.png" alt=""></p><p>然后会提示，不用理，直接按回车，一共三次。<br>在C:\Users\Neckpain.ssh得到 id_rsa 和 id_rsa.pub 文件，说明生成成功</p><h2 id="添加密钥到-Github"><a href="#添加密钥到-Github" class="headerlink" title="添加密钥到 Github"></a>添加密钥到 Github</h2><p>打开 Github，登录自己的账号后<br>点击自己的头像-&gt;settings-&gt;SSH Keys-&gt;Add SSH key<br>将本地 id_rsa.pub 中的内容粘贴到 Key 文本框中，随意输入一个 title，点击 Add Key 即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Git里面继续输入</p><pre><code>ssh -T git@github.com</code></pre><p>返回</p><p><img src="https://i.imgur.com/ztaoOqM.png" alt=""></p><p>则说明验证成功。</p><h2 id="问题一-1"><a href="#问题一-1" class="headerlink" title="问题一"></a><font color="#f00">问题一</font></h2><p>ERROR Deployer not found: git</p><p><img src="https://i.imgur.com/g0NwgIs.png" alt=""></p><p>解决方案如下：</p><pre><code>npm install --save hexo-deployer-git</code></pre><h2 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h2><p>首先购买域名，博主在阿里云购买，记得实名认证</p><p>首先在域名控制台添加记录，</p><p><img src="https://i.imgur.com/KvOvo9Q.png" alt=""></p><p>记录一般添加两条，具体如下:</p><p><img src="https://i.imgur.com/m3HfCIE.png" alt=""></p><p>其中的ip通过ping命令获取github服务器ip,参考：<br><a href="https://blog.csdn.net/dongdong9223/article/details/52634354" target="_blank" rel="noopener">https://blog.csdn.net/dongdong9223/article/details/52634354</a></p><p>然后在github的博客代码处添加一个CNMAE文件，不要后缀，或者在本地的source文件（所有提交的文件都放在该目录下）中添加该文件，并提交，</p><p>内容为申请的域名</p><pre><code>www.zxpblog.cnzxpblog.cn</code></pre><p>最后还得在setting中的Custom domain处添加域名，必须加www, 如下<br><img src="https://i.imgur.com/ZbIj49r.png" alt=""></p><p><img src="https://i.imgur.com/RPLwY5K.png" alt=""></p><h1 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h1><p>在本地博客目录下打开git bash</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>在_config.yml中找到theme修改为下载的主题名</p><p><img src="https://i.imgur.com/RPI4qld.png" alt=""></p><p>重新部署到github即可</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><h1 id="底部添加访问量统计"><a href="#底部添加访问量统计" class="headerlink" title="底部添加访问量统计"></a>底部添加访问量统计</h1><p>部分主题自带访问量统计，不用配置<br>打开\themes\主题名字\layout_partials\footer.swig文件,不同具体footer文件的后缀可能不同，在顶部添加如下代码：</p><pre><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>接着在合适的地方添加需要显示的统计数字代码（同上文件）：</p><pre><code>&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;  本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><p>两种统计方式：</p><ul><li>同一用户连续点击n篇文章，记录n次访问量</li><li>  <span id="busuanzi_container_site_pv"><br>  本站总访问量<span id="busuanzi_value_site_pv"></span>次<br>  </span></li></ul><ul><li>同一用户连续点击n篇文章，记录1次访问量</li><li>  <span id="busuanzi_container_site_uv"><pre><code>本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次</code></pre>  </span></li></ul><h1 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h1><p>首先安装 hexo-generator-feed包</p><pre><code>npm install hexo-generator-feed</code></pre><p>在配置文件中添加如下代码：</p><pre><code>#RSS配置feed:    type: atom    path: atom.xml    limit: 20    hub:    content:    content_limit:       content_limit_delim: &apos; &apos;</code></pre><p>主题不同，添加方式可能不同，NEXT主题 _CONFIG.YML文件中有个 RSS的配置，直接设置为 TRUE就可以了 </p><h1 id="Yelee主题"><a href="#Yelee主题" class="headerlink" title="Yelee主题"></a>Yelee主题</h1><p><a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">http://moxfive.coding.me/yelee/</a></p><h1 id="Hexo中的Yelee主题，首页不显示文章摘要"><a href="#Hexo中的Yelee主题，首页不显示文章摘要" class="headerlink" title="Hexo中的Yelee主题，首页不显示文章摘要"></a>Hexo中的Yelee主题，首页不显示文章摘要</h1><p>转自：<a href="https://blog.csdn.net/youshaoduo/article/details/78709160" target="_blank" rel="noopener">https://blog.csdn.net/youshaoduo/article/details/78709160</a></p><h1 id="首页显示文章摘要"><a href="#首页显示文章摘要" class="headerlink" title="首页显示文章摘要"></a>首页显示文章摘要</h1><p>方法一：在需要显示的摘要之后添加如下代码：</p><pre><code>&lt;!--more--&gt;</code></pre><p>方法二： 自动截取方法<br>转自：<a href="https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/" target="_blank" rel="noopener">https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/</a></p><h1 id="添加文章访问量统计"><a href="#添加文章访问量统计" class="headerlink" title="添加文章访问量统计"></a>添加文章访问量统计</h1><p>themes\yelee\layout_partial\footer.ejs中添加如下代码：</p><pre><code>&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>在article.ejs中&lt;%- partial(‘post/tag’) %&gt;后添加如下代码：</p><pre><code>&lt;span id=&quot;busuanzi_container_page_pv&quot; style =&quot;display:block&quot;&gt;     |阅读量(&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;)&lt;/span&gt;</code></pre><p>在theme/source/css/style.styl文件中设置格式</p><pre><code>#busuanzi_container_page_pv{display:block  !important;padding-top:4px;color: #bebebe;//margin-left:200px;}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件系统操作与磁盘管理</title>
      <link href="/2018/08/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2018/08/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p><code>df</code>,<code>du</code>,<code>mount</code>命令的使用，以及磁盘相关知识学习。<a id="more"></a></p><h1 id="查看磁盘和目录的容量"><a href="#查看磁盘和目录的容量" class="headerlink" title="查看磁盘和目录的容量"></a>查看磁盘和目录的容量</h1><pre><code>df</code></pre><p><img src="https://i.imgur.com/aDgUG9N.png" alt=""></p><p>dev/sda1：是对应这主力硬盘的分区，后面的数字表示分区号，数字前面的字母a表示第几块硬盘（也可能是可移动磁盘）。如果主机上有多快磁盘，可能会出现/dev/sdb,/dev/sdc，这些磁盘设备都会放在/dev目录下以文件的存在形式。</p><p>1k.块：表示磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用容量和可用容量。</p><p>接下来的命令，显示结果一目了然：</p><pre><code>df -h</code></pre><p><img src="https://i.imgur.com/81DFdeQ.png" alt=""></p><h1 id="du查看目录容量"><a href="#du查看目录容量" class="headerlink" title="du查看目录容量"></a>du查看目录容量</h1><pre><code>du  //默认以块的大小展示du -h  //以更易读的方式展示</code></pre><p><code>-d</code>参数指定查看目录的深度</p><pre><code>du -h -d 0 ~ //只查看1级目录的深度du -h -d 1 ~ //查看2级</code></pre><p>常用参数：<br>    du -h //以k,M,G为单位，提高信息的可读性<br>    du -a //同-aall,显示目录中所有文件的大小<br>    du s  //同–summarize 仅仅显示终极，只列出最后加总的值</p><font color="red" size="5" face="黑体">下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作</font><h1 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h1><p><code>dd</code>命令简介</p><p><code>dd</code>命令用于转换和复制文件，不过它的复制不同于<code>cp</code>。Linux中，<strong>一切即文件</strong>，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，主持在各自的驱动程序中实现了对应的功能，<code>dd</code>也可以读取文件或写入这些文件。于是<code>dd</code>也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。<code>dd</code>程序也可以在复制时处理数据，例如转换字节序、或在ASCII与EBCDIC编码间互换。</p><p><code>dd</code>命令行语句与其他的Linux程序不同，因为它的命令选项格式为<code>选项=值</code>，而不是标准的<code>--选项 值</code>或<code>-选项=值</code>。<code>dd</code>默认从标准输入中读取，并写入到标准输出中，但可以用选项<code>if</code>（input file输入文件）和<code>of</code>(output file输出文件)改变。</p><pre><code>//输出到文件dd of=test bs=10 count=1    dd if=/dev/stdin of=test bs=10 count=1//输出到标准输出dd if=/dev/stdin of=/dev/stdout bs=10 count=1//在打完这个命令后，继续在终端打字，作为你的输入</code></pre><p>上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。</p><p><code>dd</code>在拷贝的同时可以实现数据转换，例子：将输出的英文字符转换为大写在输入文件：</p><pre><code>dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</code></pre><p><img src="https://i.imgur.com/ACPF222.png" alt=""></p><p><code>dd</code>命令创建虚拟镜像文件</p><p><code>dd</code>完成创建虚拟磁盘的步骤<br>第一步:从/dev/zero设置创建一个容量为265M的空文件</p><pre><code>dd if=/dev/zero of=virtual.img bs=1M count=256du -h virtual.img</code></pre><p><img src="https://i.imgur.com/G0psdj4.png" alt=""></p><p>第二步：将上述创建文件格式化（写入文件系统）</p><p><strong>使用mkfs命令格式化磁盘</strong></p><p>可以在命令行输入<code>sudo mkfs</code> 然后按下<code>tab</code>键，可以看到多个以mkfs为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。</p><pre><code>sudo mkfs.ext4 virtual.img</code></pre><p><img src="https://i.imgur.com/ziq3dEE.png" alt=""></p><p><strong>ext4</strong>：EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。<br><br>可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。</p><p>第三步： 使用<code>count</code>命令挂载磁盘到目录树</p><p>用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。</p><p>Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。</p><p>查看主机已经挂载的文件系统：</p><pre><code>sudo mount</code></pre><p><img src="https://i.imgur.com/QsmEmnJ.png" alt=""></p><p>输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。</p><p>挂在磁盘到目录树,<code>mount</code>命令的一般格式为:</p><pre><code>mount 【optons】 [source] [directory]</code></pre><p>以下常用操作：</p><pre><code>mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro[文件系统源]]] [挂载点]</code></pre><p>将创建的磁盘镜像挂载到/mnt目录：</p><pre><code>mount -o loop -t ext4 virtual.img /mnt //也可以省略挂载类型，很多时候 mount 会自动识别/以只读方式挂载mount -o loop --ro virtual.img /mnt//或者mount -o loop,ro virtual.img /mnt</code></pre><p><img src="https://i.imgur.com/0VTliSx.png" alt=""></p><p>使用umount命令卸载已挂载磁盘</p><pre><code>命令格式 sudo umount 已挂载设备名或者挂载点，如：sudo umount /mnt</code></pre><p><strong><code>fdisk</code>为磁盘分区</strong></p><p>查看磁盘分区表信息</p><pre><code>sudo fdisk -l</code></pre><p><img src="https://i.imgur.com/w7hlBSI.png" alt=""></p><pre><code>sudo fdisk virtual.imgm：为帮助手册n: 创建新分区，接着输入分区号，分区起始和结尾，两个相减为分区大小w: 写入新建分区p: 查看现有分区</code></pre><p><img src="https://i.imgur.com/m8upwZ1.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用的压缩/解压工具：zip和tar</title>
      <link href="/2018/08/11/Linux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7zip%E5%92%8Ctar/"/>
      <url>/2018/08/11/Linux%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7zip%E5%92%8Ctar/</url>
      <content type="html"><![CDATA[<p>知识点：zip命令、tar命令、压缩与解压常用组合<a id="more"></a></p><h1 id="常用压缩包格式"><a href="#常用压缩包格式" class="headerlink" title="常用压缩包格式"></a>常用压缩包格式</h1><table><thead><tr><th>文件后缀名</th><th>说明</th></tr></thead><tbody><tr><td>*.zip</td><td>zip 程序打包压缩的文件</td></tr><tr><td>*.rar</td><td>rar 程序压缩的文件</td></tr><tr><td>*.7z</td><td>7zip 程序压缩的文件</td></tr><tr><td>*.tar</td><td>tar 程序打包，未压缩的文件</td></tr><tr><td>*.gz</td><td>gzip 程序（GNU zip）压缩的文件</td></tr><tr><td>*.xz</td><td>xz 程序压缩的文件</td></tr><tr><td>*.bz2</td><td>bzip2 程序压缩的文件</td></tr><tr><td>*.tar.gz</td><td>tar 打包，gzip 程序压缩的文件</td></tr><tr><td>*.tar.xz</td><td>tar 打包，xz 程序压缩的文件</td></tr><tr><td>*tar.bz2</td><td>tar 打包，bzip2 程序压缩的文件</td></tr><tr><td>*.tar.7z</td><td>tar 打包，7z 程序压缩的文件</td></tr></tbody></table><h1 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h1><pre><code>zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop</code></pre><p>将Desktop目录下的子文件打包成shiyanlou.zip压缩文件，<code>-r</code>表示递归打包包含子目录的全部内容，<code>-q</code>表示安静模式，不向屏幕显示内容，<code>-o</code>表示输出文件，须在其后紧跟打包输出文件名（shiyanlou.zip）。</p><pre><code>du -h shiyanlou.zip </code></pre><p><code>du</code>命令查看打包文件的大小。<code>-h</code>表示文件大小可读，<code>-d</code>表示查看所查文件的深度，打印在屏幕上。</p><p>加密创建zip包：<br><br>使用<code>-e</code>参数</p><pre><code>zip -r -e -o shiyanlou_e.zip /home/shiyanlou/Desktop</code></pre><p>跟着屏幕提示输入密码</p><p><strong>注意</strong>：： 关于<code>zip</code>命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：</p><pre><code>zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop</code></pre><h1 id="unzip解压zip文件"><a href="#unzip解压zip文件" class="headerlink" title="unzip解压zip文件"></a>unzip解压zip文件</h1><pre><code>unzip shiyanlou.zip</code></pre><p>u使用安静模式,将文件解压到指定目录：</p><pre><code>unzip -q shiyanlou.zip -d ziptest</code></pre><p>上述目录不存在，将会自动创建，如果不想解压只想查看压缩包的内容，可以使用<code>-l</code>参数：</p><pre><code>unzip -l shiyanlou.zip</code></pre><p><strong>注意</strong>：中文的兼容性问题，windows系统创建的压缩文件，如果有中文文档或文件名为中文，默认采用GBK或其他编码，而Linux上默认使用的是UTF-8编码。</p><p>使用<code>-o</code>参数指定编码类型：</p><pre><code>unzip -o GBK 中文压缩文件.zip</code></pre><h1 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h1><p>tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。</p><p><strong>创建一个tar包：</strong></p><pre><code>tar -cf shiyanlou.tar home/shiyanlou/Desktop</code></pre><p><img src="https://i.imgur.com/t43P6f3.png" alt=""><br>不能使用相对路径，不然会提示图中问题</p><p>上面命令中，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用户指定创建的文件，注意文件名必须紧跟在<code>-f</code>参数之后，比如不能写出<code>tar -fc shiiyanlou.tar</code>,可以写成<code>tar -f shiyanlou.tar -c</code>。<br><br><code>-v</code>参数以可视的方式输出打包的文件，</p><p><strong>解压一个tar包：</strong><br><br>解压参数：<code>-x</code><br><br>指定已存在的目录： <code>-C</code><br></p><pre><code>tar -xf shiyanlou.tar -C tardir</code></pre><p><strong>只查看不解包文件：</strong><br><br>参数： -t</p><pre><code>tar -tf shiyanlou.tar</code></pre><p>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）：<br>    tar -cphf etc.tar /etc</p><p><strong>使用gzip来压缩文件</strong></p><p>添加<code>-z</code>参数</p><pre><code>tar -czf shiyanlou.tar.gz home/shiyanlou/Desktop</code></pre><p><strong>解压<code>*.tar.gz</code>文件</strong></p><pre><code>tar -xzf shiyanlou.tar.gz</code></pre><p>要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：</p><table><thead><tr><th>压缩文件格式</th><th>参数</th></tr></thead><tbody><tr><td>*.tar.gz</td><td>-z</td></tr><tr><td>*.tar.xz</td><td>-J</td></tr><tr><td>*tar.bz2</td><td>-j</td></tr></tbody></table><p>tar 命令的参数很多，不过常用的就是上述这些，需要了解更多你可以查看 man 手册获取帮助。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>常用命令：</p><ul><li>zip：<ul><li>打包 ：zip something.zip something （目录请加 -r 参数）</li><li>解包：unzip something.zip</li><li>指定路径：-d 参数</li></ul></li><li>tar：<ul><li>打包：tar -cf something.tar something</li><li>解包：tar -xf something.tar</li><li>指定路径：-C 参数</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 实验楼学习笔记之Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux介绍</title>
      <link href="/2018/08/11/Linux%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/08/11/Linux%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>Liunx支持多用户登陆，共享一些主机的资源,但他们也分别有自己的用户空间,用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，<a id="more"></a>但是由于 Linux 的 用户管理 和 权限机制，不同用户不可以轻易地查看、修改彼此的文件。</p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
